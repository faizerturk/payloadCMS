"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/slate";
exports.ids = ["vendor-chunks/slate"];
exports.modules = {

/***/ "(rsc)/./node_modules/slate/dist/index.js":
/*!******************************************!*\
  !*** ./node_modules/slate/dist/index.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nvar isPlainObject = __webpack_require__(/*! is-plain-object */ \"(rsc)/./node_modules/is-plain-object/dist/is-plain-object.js\");\nvar immer = __webpack_require__(/*! immer */ \"(rsc)/./node_modules/immer/dist/index.js\");\nfunction unwrapExports(x) {\n    return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, \"default\") ? x[\"default\"] : x;\n}\nfunction createCommonjsModule(fn, module) {\n    return module = {\n        exports: {}\n    }, fn(module, module.exports), module.exports;\n}\nvar arrayLikeToArray = createCommonjsModule(function(module) {\n    function _arrayLikeToArray(arr, len) {\n        if (len == null || len > arr.length) len = arr.length;\n        for(var i = 0, arr2 = new Array(len); i < len; i++){\n            arr2[i] = arr[i];\n        }\n        return arr2;\n    }\n    module.exports = _arrayLikeToArray;\n    module.exports[\"default\"] = module.exports, module.exports.__esModule = true;\n});\nunwrapExports(arrayLikeToArray);\nvar arrayWithoutHoles = createCommonjsModule(function(module) {\n    function _arrayWithoutHoles(arr) {\n        if (Array.isArray(arr)) return arrayLikeToArray(arr);\n    }\n    module.exports = _arrayWithoutHoles;\n    module.exports[\"default\"] = module.exports, module.exports.__esModule = true;\n});\nunwrapExports(arrayWithoutHoles);\nvar iterableToArray = createCommonjsModule(function(module) {\n    function _iterableToArray(iter) {\n        if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n    }\n    module.exports = _iterableToArray;\n    module.exports[\"default\"] = module.exports, module.exports.__esModule = true;\n});\nunwrapExports(iterableToArray);\nvar unsupportedIterableToArray = createCommonjsModule(function(module) {\n    function _unsupportedIterableToArray(o, minLen) {\n        if (!o) return;\n        if (typeof o === \"string\") return arrayLikeToArray(o, minLen);\n        var n = Object.prototype.toString.call(o).slice(8, -1);\n        if (n === \"Object\" && o.constructor) n = o.constructor.name;\n        if (n === \"Map\" || n === \"Set\") return Array.from(o);\n        if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);\n    }\n    module.exports = _unsupportedIterableToArray;\n    module.exports[\"default\"] = module.exports, module.exports.__esModule = true;\n});\nunwrapExports(unsupportedIterableToArray);\nvar nonIterableSpread = createCommonjsModule(function(module) {\n    function _nonIterableSpread() {\n        throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n    }\n    module.exports = _nonIterableSpread;\n    module.exports[\"default\"] = module.exports, module.exports.__esModule = true;\n});\nunwrapExports(nonIterableSpread);\nvar toConsumableArray = createCommonjsModule(function(module) {\n    function _toConsumableArray(arr) {\n        return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();\n    }\n    module.exports = _toConsumableArray;\n    module.exports[\"default\"] = module.exports, module.exports.__esModule = true;\n});\nvar _toConsumableArray = unwrapExports(toConsumableArray);\nvar defineProperty = createCommonjsModule(function(module) {\n    function _defineProperty(obj, key, value) {\n        if (key in obj) {\n            Object.defineProperty(obj, key, {\n                value: value,\n                enumerable: true,\n                configurable: true,\n                writable: true\n            });\n        } else {\n            obj[key] = value;\n        }\n        return obj;\n    }\n    module.exports = _defineProperty;\n    module.exports[\"default\"] = module.exports, module.exports.__esModule = true;\n});\nvar _defineProperty = unwrapExports(defineProperty);\nvar arrayWithHoles = createCommonjsModule(function(module) {\n    function _arrayWithHoles(arr) {\n        if (Array.isArray(arr)) return arr;\n    }\n    module.exports = _arrayWithHoles;\n    module.exports[\"default\"] = module.exports, module.exports.__esModule = true;\n});\nunwrapExports(arrayWithHoles);\nvar iterableToArrayLimit = createCommonjsModule(function(module) {\n    function _iterableToArrayLimit(arr, i) {\n        var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"];\n        if (_i == null) return;\n        var _arr = [];\n        var _n = true;\n        var _d = false;\n        var _s, _e;\n        try {\n            for(_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true){\n                _arr.push(_s.value);\n                if (i && _arr.length === i) break;\n            }\n        } catch (err) {\n            _d = true;\n            _e = err;\n        } finally{\n            try {\n                if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n            } finally{\n                if (_d) throw _e;\n            }\n        }\n        return _arr;\n    }\n    module.exports = _iterableToArrayLimit;\n    module.exports[\"default\"] = module.exports, module.exports.__esModule = true;\n});\nunwrapExports(iterableToArrayLimit);\nvar nonIterableRest = createCommonjsModule(function(module) {\n    function _nonIterableRest() {\n        throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n    }\n    module.exports = _nonIterableRest;\n    module.exports[\"default\"] = module.exports, module.exports.__esModule = true;\n});\nunwrapExports(nonIterableRest);\nvar slicedToArray = createCommonjsModule(function(module) {\n    function _slicedToArray(arr, i) {\n        return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray(arr, i) || nonIterableRest();\n    }\n    module.exports = _slicedToArray;\n    module.exports[\"default\"] = module.exports, module.exports.__esModule = true;\n});\nvar _slicedToArray = unwrapExports(slicedToArray);\nvar DIRTY_PATHS = new WeakMap();\nvar DIRTY_PATH_KEYS = new WeakMap();\nvar FLUSHING = new WeakMap();\nvar NORMALIZING = new WeakMap();\nvar PATH_REFS = new WeakMap();\nvar POINT_REFS = new WeakMap();\nvar RANGE_REFS = new WeakMap();\nfunction ownKeys$9(object, enumerableOnly) {\n    var keys = Object.keys(object);\n    if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        if (enumerableOnly) {\n            symbols = symbols.filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n            });\n        }\n        keys.push.apply(keys, symbols);\n    }\n    return keys;\n}\nfunction _objectSpread$9(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = arguments[i] != null ? arguments[i] : {};\n        if (i % 2) {\n            ownKeys$9(Object(source), true).forEach(function(key) {\n                _defineProperty(target, key, source[key]);\n            });\n        } else if (Object.getOwnPropertyDescriptors) {\n            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n        } else {\n            ownKeys$9(Object(source)).forEach(function(key) {\n                Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n            });\n        }\n    }\n    return target;\n}\nfunction _createForOfIteratorHelper$7(o, allowArrayLike) {\n    var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n    if (!it) {\n        if (Array.isArray(o) || (it = _unsupportedIterableToArray$7(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n            if (it) o = it;\n            var i = 0;\n            var F = function F() {};\n            return {\n                s: F,\n                n: function n() {\n                    if (i >= o.length) return {\n                        done: true\n                    };\n                    return {\n                        done: false,\n                        value: o[i++]\n                    };\n                },\n                e: function e(_e) {\n                    throw _e;\n                },\n                f: F\n            };\n        }\n        throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n    }\n    var normalCompletion = true, didErr = false, err;\n    return {\n        s: function s() {\n            it = it.call(o);\n        },\n        n: function n() {\n            var step = it.next();\n            normalCompletion = step.done;\n            return step;\n        },\n        e: function e(_e2) {\n            didErr = true;\n            err = _e2;\n        },\n        f: function f() {\n            try {\n                if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n            } finally{\n                if (didErr) throw err;\n            }\n        }\n    };\n}\nfunction _unsupportedIterableToArray$7(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray$7(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(o);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$7(o, minLen);\n}\nfunction _arrayLikeToArray$7(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++){\n        arr2[i] = arr[i];\n    }\n    return arr2;\n}\n/**\r\n * Create a new Slate `Editor` object.\r\n */ var createEditor = function createEditor() {\n    var editor = {\n        children: [],\n        operations: [],\n        selection: null,\n        marks: null,\n        isInline: function isInline() {\n            return false;\n        },\n        isVoid: function isVoid() {\n            return false;\n        },\n        markableVoid: function markableVoid() {\n            return false;\n        },\n        onChange: function onChange() {},\n        apply: function apply(op) {\n            var _iterator = _createForOfIteratorHelper$7(Editor.pathRefs(editor)), _step;\n            try {\n                for(_iterator.s(); !(_step = _iterator.n()).done;){\n                    var ref = _step.value;\n                    PathRef.transform(ref, op);\n                }\n            } catch (err) {\n                _iterator.e(err);\n            } finally{\n                _iterator.f();\n            }\n            var _iterator2 = _createForOfIteratorHelper$7(Editor.pointRefs(editor)), _step2;\n            try {\n                for(_iterator2.s(); !(_step2 = _iterator2.n()).done;){\n                    var _ref = _step2.value;\n                    PointRef.transform(_ref, op);\n                }\n            } catch (err) {\n                _iterator2.e(err);\n            } finally{\n                _iterator2.f();\n            }\n            var _iterator3 = _createForOfIteratorHelper$7(Editor.rangeRefs(editor)), _step3;\n            try {\n                for(_iterator3.s(); !(_step3 = _iterator3.n()).done;){\n                    var _ref2 = _step3.value;\n                    RangeRef.transform(_ref2, op);\n                }\n            } catch (err) {\n                _iterator3.e(err);\n            } finally{\n                _iterator3.f();\n            }\n            var oldDirtyPaths = DIRTY_PATHS.get(editor) || [];\n            var oldDirtyPathKeys = DIRTY_PATH_KEYS.get(editor) || new Set();\n            var dirtyPaths;\n            var dirtyPathKeys;\n            var add = function add(path) {\n                if (path) {\n                    var key = path.join(\",\");\n                    if (!dirtyPathKeys.has(key)) {\n                        dirtyPathKeys.add(key);\n                        dirtyPaths.push(path);\n                    }\n                }\n            };\n            if (Path.operationCanTransformPath(op)) {\n                dirtyPaths = [];\n                dirtyPathKeys = new Set();\n                var _iterator4 = _createForOfIteratorHelper$7(oldDirtyPaths), _step4;\n                try {\n                    for(_iterator4.s(); !(_step4 = _iterator4.n()).done;){\n                        var path = _step4.value;\n                        var newPath = Path.transform(path, op);\n                        add(newPath);\n                    }\n                } catch (err) {\n                    _iterator4.e(err);\n                } finally{\n                    _iterator4.f();\n                }\n            } else {\n                dirtyPaths = oldDirtyPaths;\n                dirtyPathKeys = oldDirtyPathKeys;\n            }\n            var newDirtyPaths = editor.getDirtyPaths(op);\n            var _iterator5 = _createForOfIteratorHelper$7(newDirtyPaths), _step5;\n            try {\n                for(_iterator5.s(); !(_step5 = _iterator5.n()).done;){\n                    var _path = _step5.value;\n                    add(_path);\n                }\n            } catch (err) {\n                _iterator5.e(err);\n            } finally{\n                _iterator5.f();\n            }\n            DIRTY_PATHS.set(editor, dirtyPaths);\n            DIRTY_PATH_KEYS.set(editor, dirtyPathKeys);\n            Transforms.transform(editor, op);\n            editor.operations.push(op);\n            Editor.normalize(editor, {\n                operation: op\n            }); // Clear any formats applied to the cursor if the selection changes.\n            if (op.type === \"set_selection\") {\n                editor.marks = null;\n            }\n            if (!FLUSHING.get(editor)) {\n                FLUSHING.set(editor, true);\n                Promise.resolve().then(function() {\n                    FLUSHING.set(editor, false);\n                    editor.onChange({\n                        operation: op\n                    });\n                    editor.operations = [];\n                });\n            }\n        },\n        addMark: function addMark(key, value) {\n            var selection = editor.selection;\n            editor.markableVoid;\n            if (selection) {\n                var match = function match(node, path) {\n                    if (!Text.isText(node)) {\n                        return false; // marks can only be applied to text\n                    }\n                    var _Editor$parent = Editor.parent(editor, path), _Editor$parent2 = _slicedToArray(_Editor$parent, 2), parentNode = _Editor$parent2[0];\n                    _Editor$parent2[1];\n                    return !editor.isVoid(parentNode) || editor.markableVoid(parentNode);\n                };\n                var expandedSelection = Range.isExpanded(selection);\n                var markAcceptingVoidSelected = false;\n                if (!expandedSelection) {\n                    var _Editor$node = Editor.node(editor, selection), _Editor$node2 = _slicedToArray(_Editor$node, 2), selectedNode = _Editor$node2[0], selectedPath = _Editor$node2[1];\n                    if (selectedNode && match(selectedNode, selectedPath)) {\n                        var _Editor$parent3 = Editor.parent(editor, selectedPath), _Editor$parent4 = _slicedToArray(_Editor$parent3, 1), parentNode = _Editor$parent4[0];\n                        markAcceptingVoidSelected = parentNode && editor.markableVoid(parentNode);\n                    }\n                }\n                if (expandedSelection || markAcceptingVoidSelected) {\n                    Transforms.setNodes(editor, _defineProperty({}, key, value), {\n                        match: match,\n                        split: true,\n                        voids: true\n                    });\n                } else {\n                    var marks = _objectSpread$9(_objectSpread$9({}, Editor.marks(editor) || {}), {}, _defineProperty({}, key, value));\n                    editor.marks = marks;\n                    if (!FLUSHING.get(editor)) {\n                        editor.onChange();\n                    }\n                }\n            }\n        },\n        deleteBackward: function deleteBackward(unit) {\n            var selection = editor.selection;\n            if (selection && Range.isCollapsed(selection)) {\n                Transforms[\"delete\"](editor, {\n                    unit: unit,\n                    reverse: true\n                });\n            }\n        },\n        deleteForward: function deleteForward(unit) {\n            var selection = editor.selection;\n            if (selection && Range.isCollapsed(selection)) {\n                Transforms[\"delete\"](editor, {\n                    unit: unit\n                });\n            }\n        },\n        deleteFragment: function deleteFragment(direction) {\n            var selection = editor.selection;\n            if (selection && Range.isExpanded(selection)) {\n                Transforms[\"delete\"](editor, {\n                    reverse: direction === \"backward\"\n                });\n            }\n        },\n        getFragment: function getFragment() {\n            var selection = editor.selection;\n            if (selection) {\n                return Node.fragment(editor, selection);\n            }\n            return [];\n        },\n        insertBreak: function insertBreak() {\n            Transforms.splitNodes(editor, {\n                always: true\n            });\n        },\n        insertSoftBreak: function insertSoftBreak() {\n            Transforms.splitNodes(editor, {\n                always: true\n            });\n        },\n        insertFragment: function insertFragment(fragment) {\n            Transforms.insertFragment(editor, fragment);\n        },\n        insertNode: function insertNode(node) {\n            Transforms.insertNodes(editor, node);\n        },\n        insertText: function insertText(text) {\n            var selection = editor.selection, marks = editor.marks;\n            if (selection) {\n                if (marks) {\n                    var node = _objectSpread$9({\n                        text: text\n                    }, marks);\n                    Transforms.insertNodes(editor, node);\n                } else {\n                    Transforms.insertText(editor, text);\n                }\n                editor.marks = null;\n            }\n        },\n        normalizeNode: function normalizeNode(entry) {\n            var _entry = _slicedToArray(entry, 2), node = _entry[0], path = _entry[1]; // There are no core normalizations for text nodes.\n            if (Text.isText(node)) {\n                return;\n            } // Ensure that block and inline nodes have at least one text child.\n            if (Element.isElement(node) && node.children.length === 0) {\n                var child = {\n                    text: \"\"\n                };\n                Transforms.insertNodes(editor, child, {\n                    at: path.concat(0),\n                    voids: true\n                });\n                return;\n            } // Determine whether the node should have block or inline children.\n            var shouldHaveInlines = Editor.isEditor(node) ? false : Element.isElement(node) && (editor.isInline(node) || node.children.length === 0 || Text.isText(node.children[0]) || editor.isInline(node.children[0])); // Since we'll be applying operations while iterating, keep track of an\n            // index that accounts for any added/removed nodes.\n            var n = 0;\n            for(var i = 0; i < node.children.length; i++, n++){\n                var currentNode = Node.get(editor, path);\n                if (Text.isText(currentNode)) continue;\n                var _child = node.children[i];\n                var prev = currentNode.children[n - 1];\n                var isLast = i === node.children.length - 1;\n                var isInlineOrText = Text.isText(_child) || Element.isElement(_child) && editor.isInline(_child); // Only allow block nodes in the top-level children and parent blocks\n                // that only contain block nodes. Similarly, only allow inline nodes in\n                // other inline nodes, or parent blocks that only contain inlines and\n                // text.\n                if (isInlineOrText !== shouldHaveInlines) {\n                    Transforms.removeNodes(editor, {\n                        at: path.concat(n),\n                        voids: true\n                    });\n                    n--;\n                } else if (Element.isElement(_child)) {\n                    // Ensure that inline nodes are surrounded by text nodes.\n                    if (editor.isInline(_child)) {\n                        if (prev == null || !Text.isText(prev)) {\n                            var newChild = {\n                                text: \"\"\n                            };\n                            Transforms.insertNodes(editor, newChild, {\n                                at: path.concat(n),\n                                voids: true\n                            });\n                            n++;\n                        } else if (isLast) {\n                            var _newChild = {\n                                text: \"\"\n                            };\n                            Transforms.insertNodes(editor, _newChild, {\n                                at: path.concat(n + 1),\n                                voids: true\n                            });\n                            n++;\n                        }\n                    }\n                } else {\n                    // Merge adjacent text nodes that are empty or match.\n                    if (prev != null && Text.isText(prev)) {\n                        if (Text.equals(_child, prev, {\n                            loose: true\n                        })) {\n                            Transforms.mergeNodes(editor, {\n                                at: path.concat(n),\n                                voids: true\n                            });\n                            n--;\n                        } else if (prev.text === \"\") {\n                            Transforms.removeNodes(editor, {\n                                at: path.concat(n - 1),\n                                voids: true\n                            });\n                            n--;\n                        } else if (_child.text === \"\") {\n                            Transforms.removeNodes(editor, {\n                                at: path.concat(n),\n                                voids: true\n                            });\n                            n--;\n                        }\n                    }\n                }\n            }\n        },\n        removeMark: function removeMark(key) {\n            var selection = editor.selection;\n            if (selection) {\n                var match = function match(node, path) {\n                    if (!Text.isText(node)) {\n                        return false; // marks can only be applied to text\n                    }\n                    var _Editor$parent5 = Editor.parent(editor, path), _Editor$parent6 = _slicedToArray(_Editor$parent5, 2), parentNode = _Editor$parent6[0];\n                    _Editor$parent6[1];\n                    return !editor.isVoid(parentNode) || editor.markableVoid(parentNode);\n                };\n                var expandedSelection = Range.isExpanded(selection);\n                var markAcceptingVoidSelected = false;\n                if (!expandedSelection) {\n                    var _Editor$node3 = Editor.node(editor, selection), _Editor$node4 = _slicedToArray(_Editor$node3, 2), selectedNode = _Editor$node4[0], selectedPath = _Editor$node4[1];\n                    if (selectedNode && match(selectedNode, selectedPath)) {\n                        var _Editor$parent7 = Editor.parent(editor, selectedPath), _Editor$parent8 = _slicedToArray(_Editor$parent7, 1), parentNode = _Editor$parent8[0];\n                        markAcceptingVoidSelected = parentNode && editor.markableVoid(parentNode);\n                    }\n                }\n                if (expandedSelection || markAcceptingVoidSelected) {\n                    Transforms.unsetNodes(editor, key, {\n                        match: match,\n                        split: true,\n                        voids: true\n                    });\n                } else {\n                    var marks = _objectSpread$9({}, Editor.marks(editor) || {});\n                    delete marks[key];\n                    editor.marks = marks;\n                    if (!FLUSHING.get(editor)) {\n                        editor.onChange();\n                    }\n                }\n            }\n        },\n        /**\r\n     * Get the \"dirty\" paths generated from an operation.\r\n     */ getDirtyPaths: function getDirtyPaths(op) {\n            switch(op.type){\n                case \"insert_text\":\n                case \"remove_text\":\n                case \"set_node\":\n                    {\n                        var path = op.path;\n                        return Path.levels(path);\n                    }\n                case \"insert_node\":\n                    {\n                        var node = op.node, _path2 = op.path;\n                        var levels = Path.levels(_path2);\n                        var descendants = Text.isText(node) ? [] : Array.from(Node.nodes(node), function(_ref3) {\n                            var _ref4 = _slicedToArray(_ref3, 2), p = _ref4[1];\n                            return _path2.concat(p);\n                        });\n                        return [].concat(_toConsumableArray(levels), _toConsumableArray(descendants));\n                    }\n                case \"merge_node\":\n                    {\n                        var _path3 = op.path;\n                        var ancestors = Path.ancestors(_path3);\n                        var previousPath = Path.previous(_path3);\n                        return [].concat(_toConsumableArray(ancestors), [\n                            previousPath\n                        ]);\n                    }\n                case \"move_node\":\n                    {\n                        var _path4 = op.path, newPath = op.newPath;\n                        if (Path.equals(_path4, newPath)) {\n                            return [];\n                        }\n                        var oldAncestors = [];\n                        var newAncestors = [];\n                        var _iterator6 = _createForOfIteratorHelper$7(Path.ancestors(_path4)), _step6;\n                        try {\n                            for(_iterator6.s(); !(_step6 = _iterator6.n()).done;){\n                                var ancestor = _step6.value;\n                                var p = Path.transform(ancestor, op);\n                                oldAncestors.push(p);\n                            }\n                        } catch (err) {\n                            _iterator6.e(err);\n                        } finally{\n                            _iterator6.f();\n                        }\n                        var _iterator7 = _createForOfIteratorHelper$7(Path.ancestors(newPath)), _step7;\n                        try {\n                            for(_iterator7.s(); !(_step7 = _iterator7.n()).done;){\n                                var _ancestor = _step7.value;\n                                var _p = Path.transform(_ancestor, op);\n                                newAncestors.push(_p);\n                            }\n                        } catch (err) {\n                            _iterator7.e(err);\n                        } finally{\n                            _iterator7.f();\n                        }\n                        var newParent = newAncestors[newAncestors.length - 1];\n                        var newIndex = newPath[newPath.length - 1];\n                        var resultPath = newParent.concat(newIndex);\n                        return [].concat(oldAncestors, newAncestors, [\n                            resultPath\n                        ]);\n                    }\n                case \"remove_node\":\n                    {\n                        var _path5 = op.path;\n                        var _ancestors = Path.ancestors(_path5);\n                        return _toConsumableArray(_ancestors);\n                    }\n                case \"split_node\":\n                    {\n                        var _path6 = op.path;\n                        var _levels = Path.levels(_path6);\n                        var nextPath = Path.next(_path6);\n                        return [].concat(_toConsumableArray(_levels), [\n                            nextPath\n                        ]);\n                    }\n                default:\n                    {\n                        return [];\n                    }\n            }\n        },\n        shouldNormalize: function shouldNormalize(_ref5) {\n            var iteration = _ref5.iteration, initialDirtyPathsLength = _ref5.initialDirtyPathsLength;\n            var maxIterations = initialDirtyPathsLength * 42; // HACK: better way?\n            if (iteration > maxIterations) {\n                throw new Error(\"Could not completely normalize the editor after \".concat(maxIterations, \" iterations! This is usually due to incorrect normalization logic that leaves a node in an invalid state.\"));\n            }\n            return true;\n        }\n    };\n    return editor;\n};\nvar objectWithoutPropertiesLoose = createCommonjsModule(function(module) {\n    function _objectWithoutPropertiesLoose(source, excluded) {\n        if (source == null) return {};\n        var target = {};\n        var sourceKeys = Object.keys(source);\n        var key, i;\n        for(i = 0; i < sourceKeys.length; i++){\n            key = sourceKeys[i];\n            if (excluded.indexOf(key) >= 0) continue;\n            target[key] = source[key];\n        }\n        return target;\n    }\n    module.exports = _objectWithoutPropertiesLoose;\n    module.exports[\"default\"] = module.exports, module.exports.__esModule = true;\n});\nunwrapExports(objectWithoutPropertiesLoose);\nvar objectWithoutProperties = createCommonjsModule(function(module) {\n    function _objectWithoutProperties(source, excluded) {\n        if (source == null) return {};\n        var target = objectWithoutPropertiesLoose(source, excluded);\n        var key, i;\n        if (Object.getOwnPropertySymbols) {\n            var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n            for(i = 0; i < sourceSymbolKeys.length; i++){\n                key = sourceSymbolKeys[i];\n                if (excluded.indexOf(key) >= 0) continue;\n                if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n                target[key] = source[key];\n            }\n        }\n        return target;\n    }\n    module.exports = _objectWithoutProperties;\n    module.exports[\"default\"] = module.exports, module.exports.__esModule = true;\n});\nvar _objectWithoutProperties = unwrapExports(objectWithoutProperties);\nfunction _createForOfIteratorHelper$6(o, allowArrayLike) {\n    var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n    if (!it) {\n        if (Array.isArray(o) || (it = _unsupportedIterableToArray$6(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n            if (it) o = it;\n            var i = 0;\n            var F = function F() {};\n            return {\n                s: F,\n                n: function n() {\n                    if (i >= o.length) return {\n                        done: true\n                    };\n                    return {\n                        done: false,\n                        value: o[i++]\n                    };\n                },\n                e: function e(_e) {\n                    throw _e;\n                },\n                f: F\n            };\n        }\n        throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n    }\n    var normalCompletion = true, didErr = false, err;\n    return {\n        s: function s() {\n            it = it.call(o);\n        },\n        n: function n() {\n            var step = it.next();\n            normalCompletion = step.done;\n            return step;\n        },\n        e: function e(_e2) {\n            didErr = true;\n            err = _e2;\n        },\n        f: function f() {\n            try {\n                if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n            } finally{\n                if (didErr) throw err;\n            }\n        }\n    };\n}\nfunction _unsupportedIterableToArray$6(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray$6(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(o);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$6(o, minLen);\n}\nfunction _arrayLikeToArray$6(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++){\n        arr2[i] = arr[i];\n    }\n    return arr2;\n}\n// Character (grapheme cluster) boundaries are determined according to\n// the default grapheme cluster boundary specification, extended grapheme clusters variant[1].\n//\n// References:\n//\n// [1] https://www.unicode.org/reports/tr29/#Default_Grapheme_Cluster_Table\n// [2] https://www.unicode.org/Public/UCD/latest/ucd/auxiliary/GraphemeBreakProperty.txt\n// [3] https://www.unicode.org/Public/UCD/latest/ucd/auxiliary/GraphemeBreakTest.html\n// [4] https://www.unicode.org/Public/UCD/latest/ucd/auxiliary/GraphemeBreakTest.txt\n/**\r\n * Get the distance to the end of the first character in a string of text.\r\n */ var getCharacterDistance = function getCharacterDistance(str) {\n    var isRTL = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    var isLTR = !isRTL;\n    var codepoints = isRTL ? codepointsIteratorRTL(str) : str;\n    var left = CodepointType.None;\n    var right = CodepointType.None;\n    var distance = 0; // Evaluation of these conditions are deferred.\n    var gb11 = null; // Is GB11 applicable?\n    var gb12Or13 = null; // Is GB12 or GB13 applicable?\n    var _iterator = _createForOfIteratorHelper$6(codepoints), _step;\n    try {\n        for(_iterator.s(); !(_step = _iterator.n()).done;){\n            var _char = _step.value;\n            var code = _char.codePointAt(0);\n            if (!code) break;\n            var type = getCodepointType(_char, code);\n            var _ref = isLTR ? [\n                right,\n                type\n            ] : [\n                type,\n                left\n            ];\n            var _ref2 = _slicedToArray(_ref, 2);\n            left = _ref2[0];\n            right = _ref2[1];\n            if (intersects(left, CodepointType.ZWJ) && intersects(right, CodepointType.ExtPict)) {\n                if (isLTR) {\n                    gb11 = endsWithEmojiZWJ(str.substring(0, distance));\n                } else {\n                    gb11 = endsWithEmojiZWJ(str.substring(0, str.length - distance));\n                }\n                if (!gb11) break;\n            }\n            if (intersects(left, CodepointType.RI) && intersects(right, CodepointType.RI)) {\n                if (gb12Or13 !== null) {\n                    gb12Or13 = !gb12Or13;\n                } else {\n                    if (isLTR) {\n                        gb12Or13 = true;\n                    } else {\n                        gb12Or13 = endsWithOddNumberOfRIs(str.substring(0, str.length - distance));\n                    }\n                }\n                if (!gb12Or13) break;\n            }\n            if (left !== CodepointType.None && right !== CodepointType.None && isBoundaryPair(left, right)) {\n                break;\n            }\n            distance += _char.length;\n        }\n    } catch (err) {\n        _iterator.e(err);\n    } finally{\n        _iterator.f();\n    }\n    return distance || 1;\n};\nvar SPACE = /\\s/;\nvar PUNCTUATION = /[\\u0021-\\u0023\\u0025-\\u002A\\u002C-\\u002F\\u003A\\u003B\\u003F\\u0040\\u005B-\\u005D\\u005F\\u007B\\u007D\\u00A1\\u00A7\\u00AB\\u00B6\\u00B7\\u00BB\\u00BF\\u037E\\u0387\\u055A-\\u055F\\u0589\\u058A\\u05BE\\u05C0\\u05C3\\u05C6\\u05F3\\u05F4\\u0609\\u060A\\u060C\\u060D\\u061B\\u061E\\u061F\\u066A-\\u066D\\u06D4\\u0700-\\u070D\\u07F7-\\u07F9\\u0830-\\u083E\\u085E\\u0964\\u0965\\u0970\\u0AF0\\u0DF4\\u0E4F\\u0E5A\\u0E5B\\u0F04-\\u0F12\\u0F14\\u0F3A-\\u0F3D\\u0F85\\u0FD0-\\u0FD4\\u0FD9\\u0FDA\\u104A-\\u104F\\u10FB\\u1360-\\u1368\\u1400\\u166D\\u166E\\u169B\\u169C\\u16EB-\\u16ED\\u1735\\u1736\\u17D4-\\u17D6\\u17D8-\\u17DA\\u1800-\\u180A\\u1944\\u1945\\u1A1E\\u1A1F\\u1AA0-\\u1AA6\\u1AA8-\\u1AAD\\u1B5A-\\u1B60\\u1BFC-\\u1BFF\\u1C3B-\\u1C3F\\u1C7E\\u1C7F\\u1CC0-\\u1CC7\\u1CD3\\u2010-\\u2027\\u2030-\\u2043\\u2045-\\u2051\\u2053-\\u205E\\u207D\\u207E\\u208D\\u208E\\u2329\\u232A\\u2768-\\u2775\\u27C5\\u27C6\\u27E6-\\u27EF\\u2983-\\u2998\\u29D8-\\u29DB\\u29FC\\u29FD\\u2CF9-\\u2CFC\\u2CFE\\u2CFF\\u2D70\\u2E00-\\u2E2E\\u2E30-\\u2E3B\\u3001-\\u3003\\u3008-\\u3011\\u3014-\\u301F\\u3030\\u303D\\u30A0\\u30FB\\uA4FE\\uA4FF\\uA60D-\\uA60F\\uA673\\uA67E\\uA6F2-\\uA6F7\\uA874-\\uA877\\uA8CE\\uA8CF\\uA8F8-\\uA8FA\\uA92E\\uA92F\\uA95F\\uA9C1-\\uA9CD\\uA9DE\\uA9DF\\uAA5C-\\uAA5F\\uAADE\\uAADF\\uAAF0\\uAAF1\\uABEB\\uFD3E\\uFD3F\\uFE10-\\uFE19\\uFE30-\\uFE52\\uFE54-\\uFE61\\uFE63\\uFE68\\uFE6A\\uFE6B\\uFF01-\\uFF03\\uFF05-\\uFF0A\\uFF0C-\\uFF0F\\uFF1A\\uFF1B\\uFF1F\\uFF20\\uFF3B-\\uFF3D\\uFF3F\\uFF5B\\uFF5D\\uFF5F-\\uFF65]/;\nvar CHAMELEON = /['\\u2018\\u2019]/;\n/**\r\n * Get the distance to the end of the first word in a string of text.\r\n */ var getWordDistance = function getWordDistance(text) {\n    var isRTL = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    var dist = 0;\n    var started = false;\n    while(text.length > 0){\n        var charDist = getCharacterDistance(text, isRTL);\n        var _splitByCharacterDist = splitByCharacterDistance(text, charDist, isRTL), _splitByCharacterDist2 = _slicedToArray(_splitByCharacterDist, 2), _char2 = _splitByCharacterDist2[0], remaining = _splitByCharacterDist2[1];\n        if (isWordCharacter(_char2, remaining, isRTL)) {\n            started = true;\n            dist += charDist;\n        } else if (!started) {\n            dist += charDist;\n        } else {\n            break;\n        }\n        text = remaining;\n    }\n    return dist;\n};\n/**\r\n * Split a string in two parts at a given distance starting from the end when\r\n * `isRTL` is set to `true`.\r\n */ var splitByCharacterDistance = function splitByCharacterDistance(str, dist, isRTL) {\n    if (isRTL) {\n        var at = str.length - dist;\n        return [\n            str.slice(at, str.length),\n            str.slice(0, at)\n        ];\n    }\n    return [\n        str.slice(0, dist),\n        str.slice(dist)\n    ];\n};\n/**\r\n * Check if a character is a word character. The `remaining` argument is used\r\n * because sometimes you must read subsequent characters to truly determine it.\r\n */ var isWordCharacter = function isWordCharacter(_char3, remaining) {\n    var isRTL = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    if (SPACE.test(_char3)) {\n        return false;\n    } // Chameleons count as word characters as long as they're in a word, so\n    // recurse to see if the next one is a word character or not.\n    if (CHAMELEON.test(_char3)) {\n        var charDist = getCharacterDistance(remaining, isRTL);\n        var _splitByCharacterDist3 = splitByCharacterDistance(remaining, charDist, isRTL), _splitByCharacterDist4 = _slicedToArray(_splitByCharacterDist3, 2), nextChar = _splitByCharacterDist4[0], nextRemaining = _splitByCharacterDist4[1];\n        if (isWordCharacter(nextChar, nextRemaining, isRTL)) {\n            return true;\n        }\n    }\n    if (PUNCTUATION.test(_char3)) {\n        return false;\n    }\n    return true;\n};\n/**\r\n * Iterate on codepoints from right to left.\r\n */ var codepointsIteratorRTL = function* codepointsIteratorRTL(str) {\n    var end = str.length - 1;\n    for(var i = 0; i < str.length; i++){\n        var char1 = str.charAt(end - i);\n        if (isLowSurrogate(char1.charCodeAt(0))) {\n            var char2 = str.charAt(end - i - 1);\n            if (isHighSurrogate(char2.charCodeAt(0))) {\n                yield char2 + char1;\n                i++;\n                continue;\n            }\n        }\n        yield char1;\n    }\n};\n/**\r\n * Is `charCode` a high surrogate.\r\n *\r\n * https://en.wikipedia.org/wiki/Universal_Character_Set_characters#Surrogates\r\n */ var isHighSurrogate = function isHighSurrogate(charCode) {\n    return charCode >= 0xd800 && charCode <= 0xdbff;\n};\n/**\r\n * Is `charCode` a low surrogate.\r\n *\r\n * https://en.wikipedia.org/wiki/Universal_Character_Set_characters#Surrogates\r\n */ var isLowSurrogate = function isLowSurrogate(charCode) {\n    return charCode >= 0xdc00 && charCode <= 0xdfff;\n};\nvar CodepointType;\n(function(CodepointType) {\n    CodepointType[CodepointType[\"None\"] = 0] = \"None\";\n    CodepointType[CodepointType[\"Extend\"] = 1] = \"Extend\";\n    CodepointType[CodepointType[\"ZWJ\"] = 2] = \"ZWJ\";\n    CodepointType[CodepointType[\"RI\"] = 4] = \"RI\";\n    CodepointType[CodepointType[\"Prepend\"] = 8] = \"Prepend\";\n    CodepointType[CodepointType[\"SpacingMark\"] = 16] = \"SpacingMark\";\n    CodepointType[CodepointType[\"L\"] = 32] = \"L\";\n    CodepointType[CodepointType[\"V\"] = 64] = \"V\";\n    CodepointType[CodepointType[\"T\"] = 128] = \"T\";\n    CodepointType[CodepointType[\"LV\"] = 256] = \"LV\";\n    CodepointType[CodepointType[\"LVT\"] = 512] = \"LVT\";\n    CodepointType[CodepointType[\"ExtPict\"] = 1024] = \"ExtPict\";\n    CodepointType[CodepointType[\"Any\"] = 2048] = \"Any\";\n})(CodepointType || (CodepointType = {}));\nvar reExtend = /^(?:[\\u0300-\\u036F\\u0483-\\u0489\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u0610-\\u061A\\u064B-\\u065F\\u0670\\u06D6-\\u06DC\\u06DF-\\u06E4\\u06E7\\u06E8\\u06EA-\\u06ED\\u0711\\u0730-\\u074A\\u07A6-\\u07B0\\u07EB-\\u07F3\\u07FD\\u0816-\\u0819\\u081B-\\u0823\\u0825-\\u0827\\u0829-\\u082D\\u0859-\\u085B\\u08D3-\\u08E1\\u08E3-\\u0902\\u093A\\u093C\\u0941-\\u0948\\u094D\\u0951-\\u0957\\u0962\\u0963\\u0981\\u09BC\\u09BE\\u09C1-\\u09C4\\u09CD\\u09D7\\u09E2\\u09E3\\u09FE\\u0A01\\u0A02\\u0A3C\\u0A41\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A70\\u0A71\\u0A75\\u0A81\\u0A82\\u0ABC\\u0AC1-\\u0AC5\\u0AC7\\u0AC8\\u0ACD\\u0AE2\\u0AE3\\u0AFA-\\u0AFF\\u0B01\\u0B3C\\u0B3E\\u0B3F\\u0B41-\\u0B44\\u0B4D\\u0B55-\\u0B57\\u0B62\\u0B63\\u0B82\\u0BBE\\u0BC0\\u0BCD\\u0BD7\\u0C00\\u0C04\\u0C3E-\\u0C40\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C62\\u0C63\\u0C81\\u0CBC\\u0CBF\\u0CC2\\u0CC6\\u0CCC\\u0CCD\\u0CD5\\u0CD6\\u0CE2\\u0CE3\\u0D00\\u0D01\\u0D3B\\u0D3C\\u0D3E\\u0D41-\\u0D44\\u0D4D\\u0D57\\u0D62\\u0D63\\u0D81\\u0DCA\\u0DCF\\u0DD2-\\u0DD4\\u0DD6\\u0DDF\\u0E31\\u0E34-\\u0E3A\\u0E47-\\u0E4E\\u0EB1\\u0EB4-\\u0EBC\\u0EC8-\\u0ECD\\u0F18\\u0F19\\u0F35\\u0F37\\u0F39\\u0F71-\\u0F7E\\u0F80-\\u0F84\\u0F86\\u0F87\\u0F8D-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u102D-\\u1030\\u1032-\\u1037\\u1039\\u103A\\u103D\\u103E\\u1058\\u1059\\u105E-\\u1060\\u1071-\\u1074\\u1082\\u1085\\u1086\\u108D\\u109D\\u135D-\\u135F\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17B4\\u17B5\\u17B7-\\u17BD\\u17C6\\u17C9-\\u17D3\\u17DD\\u180B-\\u180D\\u1885\\u1886\\u18A9\\u1920-\\u1922\\u1927\\u1928\\u1932\\u1939-\\u193B\\u1A17\\u1A18\\u1A1B\\u1A56\\u1A58-\\u1A5E\\u1A60\\u1A62\\u1A65-\\u1A6C\\u1A73-\\u1A7C\\u1A7F\\u1AB0-\\u1AC0\\u1B00-\\u1B03\\u1B34-\\u1B3A\\u1B3C\\u1B42\\u1B6B-\\u1B73\\u1B80\\u1B81\\u1BA2-\\u1BA5\\u1BA8\\u1BA9\\u1BAB-\\u1BAD\\u1BE6\\u1BE8\\u1BE9\\u1BED\\u1BEF-\\u1BF1\\u1C2C-\\u1C33\\u1C36\\u1C37\\u1CD0-\\u1CD2\\u1CD4-\\u1CE0\\u1CE2-\\u1CE8\\u1CED\\u1CF4\\u1CF8\\u1CF9\\u1DC0-\\u1DF9\\u1DFB-\\u1DFF\\u200C\\u20D0-\\u20F0\\u2CEF-\\u2CF1\\u2D7F\\u2DE0-\\u2DFF\\u302A-\\u302F\\u3099\\u309A\\uA66F-\\uA672\\uA674-\\uA67D\\uA69E\\uA69F\\uA6F0\\uA6F1\\uA802\\uA806\\uA80B\\uA825\\uA826\\uA82C\\uA8C4\\uA8C5\\uA8E0-\\uA8F1\\uA8FF\\uA926-\\uA92D\\uA947-\\uA951\\uA980-\\uA982\\uA9B3\\uA9B6-\\uA9B9\\uA9BC\\uA9BD\\uA9E5\\uAA29-\\uAA2E\\uAA31\\uAA32\\uAA35\\uAA36\\uAA43\\uAA4C\\uAA7C\\uAAB0\\uAAB2-\\uAAB4\\uAAB7\\uAAB8\\uAABE\\uAABF\\uAAC1\\uAAEC\\uAAED\\uAAF6\\uABE5\\uABE8\\uABED\\uFB1E\\uFE00-\\uFE0F\\uFE20-\\uFE2F\\uFF9E\\uFF9F]|\\uD800[\\uDDFD\\uDEE0\\uDF76-\\uDF7A]|\\uD802[\\uDE01-\\uDE03\\uDE05\\uDE06\\uDE0C-\\uDE0F\\uDE38-\\uDE3A\\uDE3F\\uDEE5\\uDEE6]|\\uD803[\\uDD24-\\uDD27\\uDEAB\\uDEAC\\uDF46-\\uDF50]|\\uD804[\\uDC01\\uDC38-\\uDC46\\uDC7F-\\uDC81\\uDCB3-\\uDCB6\\uDCB9\\uDCBA\\uDD00-\\uDD02\\uDD27-\\uDD2B\\uDD2D-\\uDD34\\uDD73\\uDD80\\uDD81\\uDDB6-\\uDDBE\\uDDC9-\\uDDCC\\uDDCF\\uDE2F-\\uDE31\\uDE34\\uDE36\\uDE37\\uDE3E\\uDEDF\\uDEE3-\\uDEEA\\uDF00\\uDF01\\uDF3B\\uDF3C\\uDF3E\\uDF40\\uDF57\\uDF66-\\uDF6C\\uDF70-\\uDF74]|\\uD805[\\uDC38-\\uDC3F\\uDC42-\\uDC44\\uDC46\\uDC5E\\uDCB0\\uDCB3-\\uDCB8\\uDCBA\\uDCBD\\uDCBF\\uDCC0\\uDCC2\\uDCC3\\uDDAF\\uDDB2-\\uDDB5\\uDDBC\\uDDBD\\uDDBF\\uDDC0\\uDDDC\\uDDDD\\uDE33-\\uDE3A\\uDE3D\\uDE3F\\uDE40\\uDEAB\\uDEAD\\uDEB0-\\uDEB5\\uDEB7\\uDF1D-\\uDF1F\\uDF22-\\uDF25\\uDF27-\\uDF2B]|\\uD806[\\uDC2F-\\uDC37\\uDC39\\uDC3A\\uDD30\\uDD3B\\uDD3C\\uDD3E\\uDD43\\uDDD4-\\uDDD7\\uDDDA\\uDDDB\\uDDE0\\uDE01-\\uDE0A\\uDE33-\\uDE38\\uDE3B-\\uDE3E\\uDE47\\uDE51-\\uDE56\\uDE59-\\uDE5B\\uDE8A-\\uDE96\\uDE98\\uDE99]|\\uD807[\\uDC30-\\uDC36\\uDC38-\\uDC3D\\uDC3F\\uDC92-\\uDCA7\\uDCAA-\\uDCB0\\uDCB2\\uDCB3\\uDCB5\\uDCB6\\uDD31-\\uDD36\\uDD3A\\uDD3C\\uDD3D\\uDD3F-\\uDD45\\uDD47\\uDD90\\uDD91\\uDD95\\uDD97\\uDEF3\\uDEF4]|\\uD81A[\\uDEF0-\\uDEF4\\uDF30-\\uDF36]|\\uD81B[\\uDF4F\\uDF8F-\\uDF92\\uDFE4]|\\uD82F[\\uDC9D\\uDC9E]|\\uD834[\\uDD65\\uDD67-\\uDD69\\uDD6E-\\uDD72\\uDD7B-\\uDD82\\uDD85-\\uDD8B\\uDDAA-\\uDDAD\\uDE42-\\uDE44]|\\uD836[\\uDE00-\\uDE36\\uDE3B-\\uDE6C\\uDE75\\uDE84\\uDE9B-\\uDE9F\\uDEA1-\\uDEAF]|\\uD838[\\uDC00-\\uDC06\\uDC08-\\uDC18\\uDC1B-\\uDC21\\uDC23\\uDC24\\uDC26-\\uDC2A\\uDD30-\\uDD36\\uDEEC-\\uDEEF]|\\uD83A[\\uDCD0-\\uDCD6\\uDD44-\\uDD4A]|\\uD83C[\\uDFFB-\\uDFFF]|\\uDB40[\\uDC20-\\uDC7F\\uDD00-\\uDDEF])$/;\nvar rePrepend = /^(?:[\\u0600-\\u0605\\u06DD\\u070F\\u0890\\u0891\\u08E2\\u0D4E]|\\uD804[\\uDCBD\\uDCCD\\uDDC2\\uDDC3]|\\uD806[\\uDD3F\\uDD41\\uDE3A\\uDE84-\\uDE89]|\\uD807\\uDD46)$/;\nvar reSpacingMark = /^(?:[\\u0903\\u093B\\u093E-\\u0940\\u0949-\\u094C\\u094E\\u094F\\u0982\\u0983\\u09BF\\u09C0\\u09C7\\u09C8\\u09CB\\u09CC\\u0A03\\u0A3E-\\u0A40\\u0A83\\u0ABE-\\u0AC0\\u0AC9\\u0ACB\\u0ACC\\u0B02\\u0B03\\u0B40\\u0B47\\u0B48\\u0B4B\\u0B4C\\u0BBF\\u0BC1\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCC\\u0C01-\\u0C03\\u0C41-\\u0C44\\u0C82\\u0C83\\u0CBE\\u0CC0\\u0CC1\\u0CC3\\u0CC4\\u0CC7\\u0CC8\\u0CCA\\u0CCB\\u0D02\\u0D03\\u0D3F\\u0D40\\u0D46-\\u0D48\\u0D4A-\\u0D4C\\u0D82\\u0D83\\u0DD0\\u0DD1\\u0DD8-\\u0DDE\\u0DF2\\u0DF3\\u0E33\\u0EB3\\u0F3E\\u0F3F\\u0F7F\\u1031\\u103B\\u103C\\u1056\\u1057\\u1084\\u1715\\u1734\\u17B6\\u17BE-\\u17C5\\u17C7\\u17C8\\u1923-\\u1926\\u1929-\\u192B\\u1930\\u1931\\u1933-\\u1938\\u1A19\\u1A1A\\u1A55\\u1A57\\u1A6D-\\u1A72\\u1B04\\u1B3B\\u1B3D-\\u1B41\\u1B43\\u1B44\\u1B82\\u1BA1\\u1BA6\\u1BA7\\u1BAA\\u1BE7\\u1BEA-\\u1BEC\\u1BEE\\u1BF2\\u1BF3\\u1C24-\\u1C2B\\u1C34\\u1C35\\u1CE1\\u1CF7\\uA823\\uA824\\uA827\\uA880\\uA881\\uA8B4-\\uA8C3\\uA952\\uA953\\uA983\\uA9B4\\uA9B5\\uA9BA\\uA9BB\\uA9BE-\\uA9C0\\uAA2F\\uAA30\\uAA33\\uAA34\\uAA4D\\uAAEB\\uAAEE\\uAAEF\\uAAF5\\uABE3\\uABE4\\uABE6\\uABE7\\uABE9\\uABEA\\uABEC]|\\uD804[\\uDC00\\uDC02\\uDC82\\uDCB0-\\uDCB2\\uDCB7\\uDCB8\\uDD2C\\uDD45\\uDD46\\uDD82\\uDDB3-\\uDDB5\\uDDBF\\uDDC0\\uDDCE\\uDE2C-\\uDE2E\\uDE32\\uDE33\\uDE35\\uDEE0-\\uDEE2\\uDF02\\uDF03\\uDF3F\\uDF41-\\uDF44\\uDF47\\uDF48\\uDF4B-\\uDF4D\\uDF62\\uDF63]|\\uD805[\\uDC35-\\uDC37\\uDC40\\uDC41\\uDC45\\uDCB1\\uDCB2\\uDCB9\\uDCBB\\uDCBC\\uDCBE\\uDCC1\\uDDB0\\uDDB1\\uDDB8-\\uDDBB\\uDDBE\\uDE30-\\uDE32\\uDE3B\\uDE3C\\uDE3E\\uDEAC\\uDEAE\\uDEAF\\uDEB6\\uDF26]|\\uD806[\\uDC2C-\\uDC2E\\uDC38\\uDD31-\\uDD35\\uDD37\\uDD38\\uDD3D\\uDD40\\uDD42\\uDDD1-\\uDDD3\\uDDDC-\\uDDDF\\uDDE4\\uDE39\\uDE57\\uDE58\\uDE97]|\\uD807[\\uDC2F\\uDC3E\\uDCA9\\uDCB1\\uDCB4\\uDD8A-\\uDD8E\\uDD93\\uDD94\\uDD96\\uDEF5\\uDEF6]|\\uD81B[\\uDF51-\\uDF87\\uDFF0\\uDFF1]|\\uD834[\\uDD66\\uDD6D])$/;\nvar reL = /^[\\u1100-\\u115F\\uA960-\\uA97C]$/;\nvar reV = /^[\\u1160-\\u11A7\\uD7B0-\\uD7C6]$/;\nvar reT = /^[\\u11A8-\\u11FF\\uD7CB-\\uD7FB]$/;\nvar reLV = /^[\\uAC00\\uAC1C\\uAC38\\uAC54\\uAC70\\uAC8C\\uACA8\\uACC4\\uACE0\\uACFC\\uAD18\\uAD34\\uAD50\\uAD6C\\uAD88\\uADA4\\uADC0\\uADDC\\uADF8\\uAE14\\uAE30\\uAE4C\\uAE68\\uAE84\\uAEA0\\uAEBC\\uAED8\\uAEF4\\uAF10\\uAF2C\\uAF48\\uAF64\\uAF80\\uAF9C\\uAFB8\\uAFD4\\uAFF0\\uB00C\\uB028\\uB044\\uB060\\uB07C\\uB098\\uB0B4\\uB0D0\\uB0EC\\uB108\\uB124\\uB140\\uB15C\\uB178\\uB194\\uB1B0\\uB1CC\\uB1E8\\uB204\\uB220\\uB23C\\uB258\\uB274\\uB290\\uB2AC\\uB2C8\\uB2E4\\uB300\\uB31C\\uB338\\uB354\\uB370\\uB38C\\uB3A8\\uB3C4\\uB3E0\\uB3FC\\uB418\\uB434\\uB450\\uB46C\\uB488\\uB4A4\\uB4C0\\uB4DC\\uB4F8\\uB514\\uB530\\uB54C\\uB568\\uB584\\uB5A0\\uB5BC\\uB5D8\\uB5F4\\uB610\\uB62C\\uB648\\uB664\\uB680\\uB69C\\uB6B8\\uB6D4\\uB6F0\\uB70C\\uB728\\uB744\\uB760\\uB77C\\uB798\\uB7B4\\uB7D0\\uB7EC\\uB808\\uB824\\uB840\\uB85C\\uB878\\uB894\\uB8B0\\uB8CC\\uB8E8\\uB904\\uB920\\uB93C\\uB958\\uB974\\uB990\\uB9AC\\uB9C8\\uB9E4\\uBA00\\uBA1C\\uBA38\\uBA54\\uBA70\\uBA8C\\uBAA8\\uBAC4\\uBAE0\\uBAFC\\uBB18\\uBB34\\uBB50\\uBB6C\\uBB88\\uBBA4\\uBBC0\\uBBDC\\uBBF8\\uBC14\\uBC30\\uBC4C\\uBC68\\uBC84\\uBCA0\\uBCBC\\uBCD8\\uBCF4\\uBD10\\uBD2C\\uBD48\\uBD64\\uBD80\\uBD9C\\uBDB8\\uBDD4\\uBDF0\\uBE0C\\uBE28\\uBE44\\uBE60\\uBE7C\\uBE98\\uBEB4\\uBED0\\uBEEC\\uBF08\\uBF24\\uBF40\\uBF5C\\uBF78\\uBF94\\uBFB0\\uBFCC\\uBFE8\\uC004\\uC020\\uC03C\\uC058\\uC074\\uC090\\uC0AC\\uC0C8\\uC0E4\\uC100\\uC11C\\uC138\\uC154\\uC170\\uC18C\\uC1A8\\uC1C4\\uC1E0\\uC1FC\\uC218\\uC234\\uC250\\uC26C\\uC288\\uC2A4\\uC2C0\\uC2DC\\uC2F8\\uC314\\uC330\\uC34C\\uC368\\uC384\\uC3A0\\uC3BC\\uC3D8\\uC3F4\\uC410\\uC42C\\uC448\\uC464\\uC480\\uC49C\\uC4B8\\uC4D4\\uC4F0\\uC50C\\uC528\\uC544\\uC560\\uC57C\\uC598\\uC5B4\\uC5D0\\uC5EC\\uC608\\uC624\\uC640\\uC65C\\uC678\\uC694\\uC6B0\\uC6CC\\uC6E8\\uC704\\uC720\\uC73C\\uC758\\uC774\\uC790\\uC7AC\\uC7C8\\uC7E4\\uC800\\uC81C\\uC838\\uC854\\uC870\\uC88C\\uC8A8\\uC8C4\\uC8E0\\uC8FC\\uC918\\uC934\\uC950\\uC96C\\uC988\\uC9A4\\uC9C0\\uC9DC\\uC9F8\\uCA14\\uCA30\\uCA4C\\uCA68\\uCA84\\uCAA0\\uCABC\\uCAD8\\uCAF4\\uCB10\\uCB2C\\uCB48\\uCB64\\uCB80\\uCB9C\\uCBB8\\uCBD4\\uCBF0\\uCC0C\\uCC28\\uCC44\\uCC60\\uCC7C\\uCC98\\uCCB4\\uCCD0\\uCCEC\\uCD08\\uCD24\\uCD40\\uCD5C\\uCD78\\uCD94\\uCDB0\\uCDCC\\uCDE8\\uCE04\\uCE20\\uCE3C\\uCE58\\uCE74\\uCE90\\uCEAC\\uCEC8\\uCEE4\\uCF00\\uCF1C\\uCF38\\uCF54\\uCF70\\uCF8C\\uCFA8\\uCFC4\\uCFE0\\uCFFC\\uD018\\uD034\\uD050\\uD06C\\uD088\\uD0A4\\uD0C0\\uD0DC\\uD0F8\\uD114\\uD130\\uD14C\\uD168\\uD184\\uD1A0\\uD1BC\\uD1D8\\uD1F4\\uD210\\uD22C\\uD248\\uD264\\uD280\\uD29C\\uD2B8\\uD2D4\\uD2F0\\uD30C\\uD328\\uD344\\uD360\\uD37C\\uD398\\uD3B4\\uD3D0\\uD3EC\\uD408\\uD424\\uD440\\uD45C\\uD478\\uD494\\uD4B0\\uD4CC\\uD4E8\\uD504\\uD520\\uD53C\\uD558\\uD574\\uD590\\uD5AC\\uD5C8\\uD5E4\\uD600\\uD61C\\uD638\\uD654\\uD670\\uD68C\\uD6A8\\uD6C4\\uD6E0\\uD6FC\\uD718\\uD734\\uD750\\uD76C\\uD788]$/;\nvar reLVT = /^[\\uAC01-\\uAC1B\\uAC1D-\\uAC37\\uAC39-\\uAC53\\uAC55-\\uAC6F\\uAC71-\\uAC8B\\uAC8D-\\uACA7\\uACA9-\\uACC3\\uACC5-\\uACDF\\uACE1-\\uACFB\\uACFD-\\uAD17\\uAD19-\\uAD33\\uAD35-\\uAD4F\\uAD51-\\uAD6B\\uAD6D-\\uAD87\\uAD89-\\uADA3\\uADA5-\\uADBF\\uADC1-\\uADDB\\uADDD-\\uADF7\\uADF9-\\uAE13\\uAE15-\\uAE2F\\uAE31-\\uAE4B\\uAE4D-\\uAE67\\uAE69-\\uAE83\\uAE85-\\uAE9F\\uAEA1-\\uAEBB\\uAEBD-\\uAED7\\uAED9-\\uAEF3\\uAEF5-\\uAF0F\\uAF11-\\uAF2B\\uAF2D-\\uAF47\\uAF49-\\uAF63\\uAF65-\\uAF7F\\uAF81-\\uAF9B\\uAF9D-\\uAFB7\\uAFB9-\\uAFD3\\uAFD5-\\uAFEF\\uAFF1-\\uB00B\\uB00D-\\uB027\\uB029-\\uB043\\uB045-\\uB05F\\uB061-\\uB07B\\uB07D-\\uB097\\uB099-\\uB0B3\\uB0B5-\\uB0CF\\uB0D1-\\uB0EB\\uB0ED-\\uB107\\uB109-\\uB123\\uB125-\\uB13F\\uB141-\\uB15B\\uB15D-\\uB177\\uB179-\\uB193\\uB195-\\uB1AF\\uB1B1-\\uB1CB\\uB1CD-\\uB1E7\\uB1E9-\\uB203\\uB205-\\uB21F\\uB221-\\uB23B\\uB23D-\\uB257\\uB259-\\uB273\\uB275-\\uB28F\\uB291-\\uB2AB\\uB2AD-\\uB2C7\\uB2C9-\\uB2E3\\uB2E5-\\uB2FF\\uB301-\\uB31B\\uB31D-\\uB337\\uB339-\\uB353\\uB355-\\uB36F\\uB371-\\uB38B\\uB38D-\\uB3A7\\uB3A9-\\uB3C3\\uB3C5-\\uB3DF\\uB3E1-\\uB3FB\\uB3FD-\\uB417\\uB419-\\uB433\\uB435-\\uB44F\\uB451-\\uB46B\\uB46D-\\uB487\\uB489-\\uB4A3\\uB4A5-\\uB4BF\\uB4C1-\\uB4DB\\uB4DD-\\uB4F7\\uB4F9-\\uB513\\uB515-\\uB52F\\uB531-\\uB54B\\uB54D-\\uB567\\uB569-\\uB583\\uB585-\\uB59F\\uB5A1-\\uB5BB\\uB5BD-\\uB5D7\\uB5D9-\\uB5F3\\uB5F5-\\uB60F\\uB611-\\uB62B\\uB62D-\\uB647\\uB649-\\uB663\\uB665-\\uB67F\\uB681-\\uB69B\\uB69D-\\uB6B7\\uB6B9-\\uB6D3\\uB6D5-\\uB6EF\\uB6F1-\\uB70B\\uB70D-\\uB727\\uB729-\\uB743\\uB745-\\uB75F\\uB761-\\uB77B\\uB77D-\\uB797\\uB799-\\uB7B3\\uB7B5-\\uB7CF\\uB7D1-\\uB7EB\\uB7ED-\\uB807\\uB809-\\uB823\\uB825-\\uB83F\\uB841-\\uB85B\\uB85D-\\uB877\\uB879-\\uB893\\uB895-\\uB8AF\\uB8B1-\\uB8CB\\uB8CD-\\uB8E7\\uB8E9-\\uB903\\uB905-\\uB91F\\uB921-\\uB93B\\uB93D-\\uB957\\uB959-\\uB973\\uB975-\\uB98F\\uB991-\\uB9AB\\uB9AD-\\uB9C7\\uB9C9-\\uB9E3\\uB9E5-\\uB9FF\\uBA01-\\uBA1B\\uBA1D-\\uBA37\\uBA39-\\uBA53\\uBA55-\\uBA6F\\uBA71-\\uBA8B\\uBA8D-\\uBAA7\\uBAA9-\\uBAC3\\uBAC5-\\uBADF\\uBAE1-\\uBAFB\\uBAFD-\\uBB17\\uBB19-\\uBB33\\uBB35-\\uBB4F\\uBB51-\\uBB6B\\uBB6D-\\uBB87\\uBB89-\\uBBA3\\uBBA5-\\uBBBF\\uBBC1-\\uBBDB\\uBBDD-\\uBBF7\\uBBF9-\\uBC13\\uBC15-\\uBC2F\\uBC31-\\uBC4B\\uBC4D-\\uBC67\\uBC69-\\uBC83\\uBC85-\\uBC9F\\uBCA1-\\uBCBB\\uBCBD-\\uBCD7\\uBCD9-\\uBCF3\\uBCF5-\\uBD0F\\uBD11-\\uBD2B\\uBD2D-\\uBD47\\uBD49-\\uBD63\\uBD65-\\uBD7F\\uBD81-\\uBD9B\\uBD9D-\\uBDB7\\uBDB9-\\uBDD3\\uBDD5-\\uBDEF\\uBDF1-\\uBE0B\\uBE0D-\\uBE27\\uBE29-\\uBE43\\uBE45-\\uBE5F\\uBE61-\\uBE7B\\uBE7D-\\uBE97\\uBE99-\\uBEB3\\uBEB5-\\uBECF\\uBED1-\\uBEEB\\uBEED-\\uBF07\\uBF09-\\uBF23\\uBF25-\\uBF3F\\uBF41-\\uBF5B\\uBF5D-\\uBF77\\uBF79-\\uBF93\\uBF95-\\uBFAF\\uBFB1-\\uBFCB\\uBFCD-\\uBFE7\\uBFE9-\\uC003\\uC005-\\uC01F\\uC021-\\uC03B\\uC03D-\\uC057\\uC059-\\uC073\\uC075-\\uC08F\\uC091-\\uC0AB\\uC0AD-\\uC0C7\\uC0C9-\\uC0E3\\uC0E5-\\uC0FF\\uC101-\\uC11B\\uC11D-\\uC137\\uC139-\\uC153\\uC155-\\uC16F\\uC171-\\uC18B\\uC18D-\\uC1A7\\uC1A9-\\uC1C3\\uC1C5-\\uC1DF\\uC1E1-\\uC1FB\\uC1FD-\\uC217\\uC219-\\uC233\\uC235-\\uC24F\\uC251-\\uC26B\\uC26D-\\uC287\\uC289-\\uC2A3\\uC2A5-\\uC2BF\\uC2C1-\\uC2DB\\uC2DD-\\uC2F7\\uC2F9-\\uC313\\uC315-\\uC32F\\uC331-\\uC34B\\uC34D-\\uC367\\uC369-\\uC383\\uC385-\\uC39F\\uC3A1-\\uC3BB\\uC3BD-\\uC3D7\\uC3D9-\\uC3F3\\uC3F5-\\uC40F\\uC411-\\uC42B\\uC42D-\\uC447\\uC449-\\uC463\\uC465-\\uC47F\\uC481-\\uC49B\\uC49D-\\uC4B7\\uC4B9-\\uC4D3\\uC4D5-\\uC4EF\\uC4F1-\\uC50B\\uC50D-\\uC527\\uC529-\\uC543\\uC545-\\uC55F\\uC561-\\uC57B\\uC57D-\\uC597\\uC599-\\uC5B3\\uC5B5-\\uC5CF\\uC5D1-\\uC5EB\\uC5ED-\\uC607\\uC609-\\uC623\\uC625-\\uC63F\\uC641-\\uC65B\\uC65D-\\uC677\\uC679-\\uC693\\uC695-\\uC6AF\\uC6B1-\\uC6CB\\uC6CD-\\uC6E7\\uC6E9-\\uC703\\uC705-\\uC71F\\uC721-\\uC73B\\uC73D-\\uC757\\uC759-\\uC773\\uC775-\\uC78F\\uC791-\\uC7AB\\uC7AD-\\uC7C7\\uC7C9-\\uC7E3\\uC7E5-\\uC7FF\\uC801-\\uC81B\\uC81D-\\uC837\\uC839-\\uC853\\uC855-\\uC86F\\uC871-\\uC88B\\uC88D-\\uC8A7\\uC8A9-\\uC8C3\\uC8C5-\\uC8DF\\uC8E1-\\uC8FB\\uC8FD-\\uC917\\uC919-\\uC933\\uC935-\\uC94F\\uC951-\\uC96B\\uC96D-\\uC987\\uC989-\\uC9A3\\uC9A5-\\uC9BF\\uC9C1-\\uC9DB\\uC9DD-\\uC9F7\\uC9F9-\\uCA13\\uCA15-\\uCA2F\\uCA31-\\uCA4B\\uCA4D-\\uCA67\\uCA69-\\uCA83\\uCA85-\\uCA9F\\uCAA1-\\uCABB\\uCABD-\\uCAD7\\uCAD9-\\uCAF3\\uCAF5-\\uCB0F\\uCB11-\\uCB2B\\uCB2D-\\uCB47\\uCB49-\\uCB63\\uCB65-\\uCB7F\\uCB81-\\uCB9B\\uCB9D-\\uCBB7\\uCBB9-\\uCBD3\\uCBD5-\\uCBEF\\uCBF1-\\uCC0B\\uCC0D-\\uCC27\\uCC29-\\uCC43\\uCC45-\\uCC5F\\uCC61-\\uCC7B\\uCC7D-\\uCC97\\uCC99-\\uCCB3\\uCCB5-\\uCCCF\\uCCD1-\\uCCEB\\uCCED-\\uCD07\\uCD09-\\uCD23\\uCD25-\\uCD3F\\uCD41-\\uCD5B\\uCD5D-\\uCD77\\uCD79-\\uCD93\\uCD95-\\uCDAF\\uCDB1-\\uCDCB\\uCDCD-\\uCDE7\\uCDE9-\\uCE03\\uCE05-\\uCE1F\\uCE21-\\uCE3B\\uCE3D-\\uCE57\\uCE59-\\uCE73\\uCE75-\\uCE8F\\uCE91-\\uCEAB\\uCEAD-\\uCEC7\\uCEC9-\\uCEE3\\uCEE5-\\uCEFF\\uCF01-\\uCF1B\\uCF1D-\\uCF37\\uCF39-\\uCF53\\uCF55-\\uCF6F\\uCF71-\\uCF8B\\uCF8D-\\uCFA7\\uCFA9-\\uCFC3\\uCFC5-\\uCFDF\\uCFE1-\\uCFFB\\uCFFD-\\uD017\\uD019-\\uD033\\uD035-\\uD04F\\uD051-\\uD06B\\uD06D-\\uD087\\uD089-\\uD0A3\\uD0A5-\\uD0BF\\uD0C1-\\uD0DB\\uD0DD-\\uD0F7\\uD0F9-\\uD113\\uD115-\\uD12F\\uD131-\\uD14B\\uD14D-\\uD167\\uD169-\\uD183\\uD185-\\uD19F\\uD1A1-\\uD1BB\\uD1BD-\\uD1D7\\uD1D9-\\uD1F3\\uD1F5-\\uD20F\\uD211-\\uD22B\\uD22D-\\uD247\\uD249-\\uD263\\uD265-\\uD27F\\uD281-\\uD29B\\uD29D-\\uD2B7\\uD2B9-\\uD2D3\\uD2D5-\\uD2EF\\uD2F1-\\uD30B\\uD30D-\\uD327\\uD329-\\uD343\\uD345-\\uD35F\\uD361-\\uD37B\\uD37D-\\uD397\\uD399-\\uD3B3\\uD3B5-\\uD3CF\\uD3D1-\\uD3EB\\uD3ED-\\uD407\\uD409-\\uD423\\uD425-\\uD43F\\uD441-\\uD45B\\uD45D-\\uD477\\uD479-\\uD493\\uD495-\\uD4AF\\uD4B1-\\uD4CB\\uD4CD-\\uD4E7\\uD4E9-\\uD503\\uD505-\\uD51F\\uD521-\\uD53B\\uD53D-\\uD557\\uD559-\\uD573\\uD575-\\uD58F\\uD591-\\uD5AB\\uD5AD-\\uD5C7\\uD5C9-\\uD5E3\\uD5E5-\\uD5FF\\uD601-\\uD61B\\uD61D-\\uD637\\uD639-\\uD653\\uD655-\\uD66F\\uD671-\\uD68B\\uD68D-\\uD6A7\\uD6A9-\\uD6C3\\uD6C5-\\uD6DF\\uD6E1-\\uD6FB\\uD6FD-\\uD717\\uD719-\\uD733\\uD735-\\uD74F\\uD751-\\uD76B\\uD76D-\\uD787\\uD789-\\uD7A3]$/;\nvar reExtPict = /^(?:[\\xA9\\xAE\\u203C\\u2049\\u2122\\u2139\\u2194-\\u2199\\u21A9\\u21AA\\u231A\\u231B\\u2328\\u2388\\u23CF\\u23E9-\\u23F3\\u23F8-\\u23FA\\u24C2\\u25AA\\u25AB\\u25B6\\u25C0\\u25FB-\\u25FE\\u2600-\\u2605\\u2607-\\u2612\\u2614-\\u2685\\u2690-\\u2705\\u2708-\\u2712\\u2714\\u2716\\u271D\\u2721\\u2728\\u2733\\u2734\\u2744\\u2747\\u274C\\u274E\\u2753-\\u2755\\u2757\\u2763-\\u2767\\u2795-\\u2797\\u27A1\\u27B0\\u27BF\\u2934\\u2935\\u2B05-\\u2B07\\u2B1B\\u2B1C\\u2B50\\u2B55\\u3030\\u303D\\u3297\\u3299]|\\uD83C[\\uDC00-\\uDCFF\\uDD0D-\\uDD0F\\uDD2F\\uDD6C-\\uDD71\\uDD7E\\uDD7F\\uDD8E\\uDD91-\\uDD9A\\uDDAD-\\uDDE5\\uDE01-\\uDE0F\\uDE1A\\uDE2F\\uDE32-\\uDE3A\\uDE3C-\\uDE3F\\uDE49-\\uDFFA]|\\uD83D[\\uDC00-\\uDD3D\\uDD46-\\uDE4F\\uDE80-\\uDEFF\\uDF74-\\uDF7F\\uDFD5-\\uDFFF]|\\uD83E[\\uDC0C-\\uDC0F\\uDC48-\\uDC4F\\uDC5A-\\uDC5F\\uDC88-\\uDC8F\\uDCAE-\\uDCFF\\uDD0C-\\uDD3A\\uDD3C-\\uDD45\\uDD47-\\uDEFF]|\\uD83F[\\uDC00-\\uDFFD])$/;\nvar getCodepointType = function getCodepointType(_char4, code) {\n    var type = CodepointType.Any;\n    if (_char4.search(reExtend) !== -1) {\n        type |= CodepointType.Extend;\n    }\n    if (code === 0x200d) {\n        type |= CodepointType.ZWJ;\n    }\n    if (code >= 0x1f1e6 && code <= 0x1f1ff) {\n        type |= CodepointType.RI;\n    }\n    if (_char4.search(rePrepend) !== -1) {\n        type |= CodepointType.Prepend;\n    }\n    if (_char4.search(reSpacingMark) !== -1) {\n        type |= CodepointType.SpacingMark;\n    }\n    if (_char4.search(reL) !== -1) {\n        type |= CodepointType.L;\n    }\n    if (_char4.search(reV) !== -1) {\n        type |= CodepointType.V;\n    }\n    if (_char4.search(reT) !== -1) {\n        type |= CodepointType.T;\n    }\n    if (_char4.search(reLV) !== -1) {\n        type |= CodepointType.LV;\n    }\n    if (_char4.search(reLVT) !== -1) {\n        type |= CodepointType.LVT;\n    }\n    if (_char4.search(reExtPict) !== -1) {\n        type |= CodepointType.ExtPict;\n    }\n    return type;\n};\nfunction intersects(x, y) {\n    return (x & y) !== 0;\n}\nvar NonBoundaryPairs = [\n    [\n        CodepointType.L,\n        CodepointType.L | CodepointType.V | CodepointType.LV | CodepointType.LVT\n    ],\n    [\n        CodepointType.LV | CodepointType.V,\n        CodepointType.V | CodepointType.T\n    ],\n    [\n        CodepointType.LVT | CodepointType.T,\n        CodepointType.T\n    ],\n    [\n        CodepointType.Any,\n        CodepointType.Extend | CodepointType.ZWJ\n    ],\n    [\n        CodepointType.Any,\n        CodepointType.SpacingMark\n    ],\n    [\n        CodepointType.Prepend,\n        CodepointType.Any\n    ],\n    [\n        CodepointType.ZWJ,\n        CodepointType.ExtPict\n    ],\n    [\n        CodepointType.RI,\n        CodepointType.RI\n    ]\n];\nfunction isBoundaryPair(left, right) {\n    return NonBoundaryPairs.findIndex(function(r) {\n        return intersects(left, r[0]) && intersects(right, r[1]);\n    }) === -1;\n}\nvar endingEmojiZWJ = /(?:[\\xA9\\xAE\\u203C\\u2049\\u2122\\u2139\\u2194-\\u2199\\u21A9\\u21AA\\u231A\\u231B\\u2328\\u2388\\u23CF\\u23E9-\\u23F3\\u23F8-\\u23FA\\u24C2\\u25AA\\u25AB\\u25B6\\u25C0\\u25FB-\\u25FE\\u2600-\\u2605\\u2607-\\u2612\\u2614-\\u2685\\u2690-\\u2705\\u2708-\\u2712\\u2714\\u2716\\u271D\\u2721\\u2728\\u2733\\u2734\\u2744\\u2747\\u274C\\u274E\\u2753-\\u2755\\u2757\\u2763-\\u2767\\u2795-\\u2797\\u27A1\\u27B0\\u27BF\\u2934\\u2935\\u2B05-\\u2B07\\u2B1B\\u2B1C\\u2B50\\u2B55\\u3030\\u303D\\u3297\\u3299]|\\uD83C[\\uDC00-\\uDCFF\\uDD0D-\\uDD0F\\uDD2F\\uDD6C-\\uDD71\\uDD7E\\uDD7F\\uDD8E\\uDD91-\\uDD9A\\uDDAD-\\uDDE5\\uDE01-\\uDE0F\\uDE1A\\uDE2F\\uDE32-\\uDE3A\\uDE3C-\\uDE3F\\uDE49-\\uDFFA]|\\uD83D[\\uDC00-\\uDD3D\\uDD46-\\uDE4F\\uDE80-\\uDEFF\\uDF74-\\uDF7F\\uDFD5-\\uDFFF]|\\uD83E[\\uDC0C-\\uDC0F\\uDC48-\\uDC4F\\uDC5A-\\uDC5F\\uDC88-\\uDC8F\\uDCAE-\\uDCFF\\uDD0C-\\uDD3A\\uDD3C-\\uDD45\\uDD47-\\uDEFF]|\\uD83F[\\uDC00-\\uDFFD])(?:[\\u0300-\\u036F\\u0483-\\u0489\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u0610-\\u061A\\u064B-\\u065F\\u0670\\u06D6-\\u06DC\\u06DF-\\u06E4\\u06E7\\u06E8\\u06EA-\\u06ED\\u0711\\u0730-\\u074A\\u07A6-\\u07B0\\u07EB-\\u07F3\\u07FD\\u0816-\\u0819\\u081B-\\u0823\\u0825-\\u0827\\u0829-\\u082D\\u0859-\\u085B\\u08D3-\\u08E1\\u08E3-\\u0902\\u093A\\u093C\\u0941-\\u0948\\u094D\\u0951-\\u0957\\u0962\\u0963\\u0981\\u09BC\\u09BE\\u09C1-\\u09C4\\u09CD\\u09D7\\u09E2\\u09E3\\u09FE\\u0A01\\u0A02\\u0A3C\\u0A41\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A70\\u0A71\\u0A75\\u0A81\\u0A82\\u0ABC\\u0AC1-\\u0AC5\\u0AC7\\u0AC8\\u0ACD\\u0AE2\\u0AE3\\u0AFA-\\u0AFF\\u0B01\\u0B3C\\u0B3E\\u0B3F\\u0B41-\\u0B44\\u0B4D\\u0B55-\\u0B57\\u0B62\\u0B63\\u0B82\\u0BBE\\u0BC0\\u0BCD\\u0BD7\\u0C00\\u0C04\\u0C3E-\\u0C40\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C62\\u0C63\\u0C81\\u0CBC\\u0CBF\\u0CC2\\u0CC6\\u0CCC\\u0CCD\\u0CD5\\u0CD6\\u0CE2\\u0CE3\\u0D00\\u0D01\\u0D3B\\u0D3C\\u0D3E\\u0D41-\\u0D44\\u0D4D\\u0D57\\u0D62\\u0D63\\u0D81\\u0DCA\\u0DCF\\u0DD2-\\u0DD4\\u0DD6\\u0DDF\\u0E31\\u0E34-\\u0E3A\\u0E47-\\u0E4E\\u0EB1\\u0EB4-\\u0EBC\\u0EC8-\\u0ECD\\u0F18\\u0F19\\u0F35\\u0F37\\u0F39\\u0F71-\\u0F7E\\u0F80-\\u0F84\\u0F86\\u0F87\\u0F8D-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u102D-\\u1030\\u1032-\\u1037\\u1039\\u103A\\u103D\\u103E\\u1058\\u1059\\u105E-\\u1060\\u1071-\\u1074\\u1082\\u1085\\u1086\\u108D\\u109D\\u135D-\\u135F\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17B4\\u17B5\\u17B7-\\u17BD\\u17C6\\u17C9-\\u17D3\\u17DD\\u180B-\\u180D\\u1885\\u1886\\u18A9\\u1920-\\u1922\\u1927\\u1928\\u1932\\u1939-\\u193B\\u1A17\\u1A18\\u1A1B\\u1A56\\u1A58-\\u1A5E\\u1A60\\u1A62\\u1A65-\\u1A6C\\u1A73-\\u1A7C\\u1A7F\\u1AB0-\\u1AC0\\u1B00-\\u1B03\\u1B34-\\u1B3A\\u1B3C\\u1B42\\u1B6B-\\u1B73\\u1B80\\u1B81\\u1BA2-\\u1BA5\\u1BA8\\u1BA9\\u1BAB-\\u1BAD\\u1BE6\\u1BE8\\u1BE9\\u1BED\\u1BEF-\\u1BF1\\u1C2C-\\u1C33\\u1C36\\u1C37\\u1CD0-\\u1CD2\\u1CD4-\\u1CE0\\u1CE2-\\u1CE8\\u1CED\\u1CF4\\u1CF8\\u1CF9\\u1DC0-\\u1DF9\\u1DFB-\\u1DFF\\u200C\\u20D0-\\u20F0\\u2CEF-\\u2CF1\\u2D7F\\u2DE0-\\u2DFF\\u302A-\\u302F\\u3099\\u309A\\uA66F-\\uA672\\uA674-\\uA67D\\uA69E\\uA69F\\uA6F0\\uA6F1\\uA802\\uA806\\uA80B\\uA825\\uA826\\uA82C\\uA8C4\\uA8C5\\uA8E0-\\uA8F1\\uA8FF\\uA926-\\uA92D\\uA947-\\uA951\\uA980-\\uA982\\uA9B3\\uA9B6-\\uA9B9\\uA9BC\\uA9BD\\uA9E5\\uAA29-\\uAA2E\\uAA31\\uAA32\\uAA35\\uAA36\\uAA43\\uAA4C\\uAA7C\\uAAB0\\uAAB2-\\uAAB4\\uAAB7\\uAAB8\\uAABE\\uAABF\\uAAC1\\uAAEC\\uAAED\\uAAF6\\uABE5\\uABE8\\uABED\\uFB1E\\uFE00-\\uFE0F\\uFE20-\\uFE2F\\uFF9E\\uFF9F]|\\uD800[\\uDDFD\\uDEE0\\uDF76-\\uDF7A]|\\uD802[\\uDE01-\\uDE03\\uDE05\\uDE06\\uDE0C-\\uDE0F\\uDE38-\\uDE3A\\uDE3F\\uDEE5\\uDEE6]|\\uD803[\\uDD24-\\uDD27\\uDEAB\\uDEAC\\uDF46-\\uDF50]|\\uD804[\\uDC01\\uDC38-\\uDC46\\uDC7F-\\uDC81\\uDCB3-\\uDCB6\\uDCB9\\uDCBA\\uDD00-\\uDD02\\uDD27-\\uDD2B\\uDD2D-\\uDD34\\uDD73\\uDD80\\uDD81\\uDDB6-\\uDDBE\\uDDC9-\\uDDCC\\uDDCF\\uDE2F-\\uDE31\\uDE34\\uDE36\\uDE37\\uDE3E\\uDEDF\\uDEE3-\\uDEEA\\uDF00\\uDF01\\uDF3B\\uDF3C\\uDF3E\\uDF40\\uDF57\\uDF66-\\uDF6C\\uDF70-\\uDF74]|\\uD805[\\uDC38-\\uDC3F\\uDC42-\\uDC44\\uDC46\\uDC5E\\uDCB0\\uDCB3-\\uDCB8\\uDCBA\\uDCBD\\uDCBF\\uDCC0\\uDCC2\\uDCC3\\uDDAF\\uDDB2-\\uDDB5\\uDDBC\\uDDBD\\uDDBF\\uDDC0\\uDDDC\\uDDDD\\uDE33-\\uDE3A\\uDE3D\\uDE3F\\uDE40\\uDEAB\\uDEAD\\uDEB0-\\uDEB5\\uDEB7\\uDF1D-\\uDF1F\\uDF22-\\uDF25\\uDF27-\\uDF2B]|\\uD806[\\uDC2F-\\uDC37\\uDC39\\uDC3A\\uDD30\\uDD3B\\uDD3C\\uDD3E\\uDD43\\uDDD4-\\uDDD7\\uDDDA\\uDDDB\\uDDE0\\uDE01-\\uDE0A\\uDE33-\\uDE38\\uDE3B-\\uDE3E\\uDE47\\uDE51-\\uDE56\\uDE59-\\uDE5B\\uDE8A-\\uDE96\\uDE98\\uDE99]|\\uD807[\\uDC30-\\uDC36\\uDC38-\\uDC3D\\uDC3F\\uDC92-\\uDCA7\\uDCAA-\\uDCB0\\uDCB2\\uDCB3\\uDCB5\\uDCB6\\uDD31-\\uDD36\\uDD3A\\uDD3C\\uDD3D\\uDD3F-\\uDD45\\uDD47\\uDD90\\uDD91\\uDD95\\uDD97\\uDEF3\\uDEF4]|\\uD81A[\\uDEF0-\\uDEF4\\uDF30-\\uDF36]|\\uD81B[\\uDF4F\\uDF8F-\\uDF92\\uDFE4]|\\uD82F[\\uDC9D\\uDC9E]|\\uD834[\\uDD65\\uDD67-\\uDD69\\uDD6E-\\uDD72\\uDD7B-\\uDD82\\uDD85-\\uDD8B\\uDDAA-\\uDDAD\\uDE42-\\uDE44]|\\uD836[\\uDE00-\\uDE36\\uDE3B-\\uDE6C\\uDE75\\uDE84\\uDE9B-\\uDE9F\\uDEA1-\\uDEAF]|\\uD838[\\uDC00-\\uDC06\\uDC08-\\uDC18\\uDC1B-\\uDC21\\uDC23\\uDC24\\uDC26-\\uDC2A\\uDD30-\\uDD36\\uDEEC-\\uDEEF]|\\uD83A[\\uDCD0-\\uDCD6\\uDD44-\\uDD4A]|\\uD83C[\\uDFFB-\\uDFFF]|\\uDB40[\\uDC20-\\uDC7F\\uDD00-\\uDDEF])*\\u200D$/;\nvar endsWithEmojiZWJ = function endsWithEmojiZWJ(str) {\n    return str.search(endingEmojiZWJ) !== -1;\n};\nvar endingRIs = /(?:\\uD83C[\\uDDE6-\\uDDFF])+$/g;\nvar endsWithOddNumberOfRIs = function endsWithOddNumberOfRIs(str) {\n    var match = str.match(endingRIs);\n    if (match === null) {\n        return false;\n    } else {\n        // A RI is represented by a surrogate pair.\n        var numRIs = match[0].length / 2;\n        return numRIs % 2 === 1;\n    }\n};\n/**\r\n * Shared the function with isElementType utility\r\n */ var isElement = function isElement(value) {\n    return isPlainObject.isPlainObject(value) && Node.isNodeList(value.children) && !Editor.isEditor(value);\n}; // eslint-disable-next-line no-redeclare\nvar Element = {\n    /**\r\n   * Check if a value implements the 'Ancestor' interface.\r\n   */ isAncestor: function isAncestor(value) {\n        return isPlainObject.isPlainObject(value) && Node.isNodeList(value.children);\n    },\n    /**\r\n   * Check if a value implements the `Element` interface.\r\n   */ isElement: isElement,\n    /**\r\n   * Check if a value is an array of `Element` objects.\r\n   */ isElementList: function isElementList(value) {\n        return Array.isArray(value) && value.every(function(val) {\n            return Element.isElement(val);\n        });\n    },\n    /**\r\n   * Check if a set of props is a partial of Element.\r\n   */ isElementProps: function isElementProps(props) {\n        return props.children !== undefined;\n    },\n    /**\r\n   * Check if a value implements the `Element` interface and has elementKey with selected value.\r\n   * Default it check to `type` key value\r\n   */ isElementType: function isElementType(value, elementVal) {\n        var elementKey = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"type\";\n        return isElement(value) && value[elementKey] === elementVal;\n    },\n    /**\r\n   * Check if an element matches set of properties.\r\n   *\r\n   * Note: this checks custom properties, and it does not ensure that any\r\n   * children are equivalent.\r\n   */ matches: function matches(element, props) {\n        for(var key in props){\n            if (key === \"children\") {\n                continue;\n            }\n            if (element[key] !== props[key]) {\n                return false;\n            }\n        }\n        return true;\n    }\n};\nvar _excluded$4 = [\n    \"text\"\n], _excluded2$3 = [\n    \"text\"\n];\nfunction ownKeys$8(object, enumerableOnly) {\n    var keys = Object.keys(object);\n    if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        if (enumerableOnly) {\n            symbols = symbols.filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n            });\n        }\n        keys.push.apply(keys, symbols);\n    }\n    return keys;\n}\nfunction _objectSpread$8(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = arguments[i] != null ? arguments[i] : {};\n        if (i % 2) {\n            ownKeys$8(Object(source), true).forEach(function(key) {\n                _defineProperty(target, key, source[key]);\n            });\n        } else if (Object.getOwnPropertyDescriptors) {\n            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n        } else {\n            ownKeys$8(Object(source)).forEach(function(key) {\n                Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n            });\n        }\n    }\n    return target;\n}\nfunction _createForOfIteratorHelper$5(o, allowArrayLike) {\n    var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n    if (!it) {\n        if (Array.isArray(o) || (it = _unsupportedIterableToArray$5(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n            if (it) o = it;\n            var i = 0;\n            var F = function F() {};\n            return {\n                s: F,\n                n: function n() {\n                    if (i >= o.length) return {\n                        done: true\n                    };\n                    return {\n                        done: false,\n                        value: o[i++]\n                    };\n                },\n                e: function e(_e) {\n                    throw _e;\n                },\n                f: F\n            };\n        }\n        throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n    }\n    var normalCompletion = true, didErr = false, err;\n    return {\n        s: function s() {\n            it = it.call(o);\n        },\n        n: function n() {\n            var step = it.next();\n            normalCompletion = step.done;\n            return step;\n        },\n        e: function e(_e2) {\n            didErr = true;\n            err = _e2;\n        },\n        f: function f() {\n            try {\n                if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n            } finally{\n                if (didErr) throw err;\n            }\n        }\n    };\n}\nfunction _unsupportedIterableToArray$5(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray$5(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(o);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$5(o, minLen);\n}\nfunction _arrayLikeToArray$5(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++){\n        arr2[i] = arr[i];\n    }\n    return arr2;\n}\nvar IS_EDITOR_CACHE = new WeakMap(); // eslint-disable-next-line no-redeclare\nvar Editor = {\n    /**\r\n   * Get the ancestor above a location in the document.\r\n   */ above: function above(editor) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        var _options$voids = options.voids, voids = _options$voids === void 0 ? false : _options$voids, _options$mode = options.mode, mode = _options$mode === void 0 ? \"lowest\" : _options$mode, _options$at = options.at, at = _options$at === void 0 ? editor.selection : _options$at, match = options.match;\n        if (!at) {\n            return;\n        }\n        var path = Editor.path(editor, at);\n        var reverse = mode === \"lowest\";\n        var _iterator = _createForOfIteratorHelper$5(Editor.levels(editor, {\n            at: path,\n            voids: voids,\n            match: match,\n            reverse: reverse\n        })), _step;\n        try {\n            for(_iterator.s(); !(_step = _iterator.n()).done;){\n                var _step$value = _slicedToArray(_step.value, 2), n = _step$value[0], p = _step$value[1];\n                if (Text.isText(n)) continue;\n                if (Range.isRange(at)) {\n                    if (Path.isAncestor(p, at.anchor.path) && Path.isAncestor(p, at.focus.path)) {\n                        return [\n                            n,\n                            p\n                        ];\n                    }\n                } else {\n                    if (!Path.equals(path, p)) {\n                        return [\n                            n,\n                            p\n                        ];\n                    }\n                }\n            }\n        } catch (err) {\n            _iterator.e(err);\n        } finally{\n            _iterator.f();\n        }\n    },\n    /**\r\n   * Add a custom property to the leaf text nodes in the current selection.\r\n   *\r\n   * If the selection is currently collapsed, the marks will be added to the\r\n   * `editor.marks` property instead, and applied when text is inserted next.\r\n   */ addMark: function addMark(editor, key, value) {\n        editor.addMark(key, value);\n    },\n    /**\r\n   * Get the point after a location.\r\n   */ after: function after(editor, at) {\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        var anchor = Editor.point(editor, at, {\n            edge: \"end\"\n        });\n        var focus = Editor.end(editor, []);\n        var range = {\n            anchor: anchor,\n            focus: focus\n        };\n        var _options$distance = options.distance, distance = _options$distance === void 0 ? 1 : _options$distance;\n        var d = 0;\n        var target;\n        var _iterator2 = _createForOfIteratorHelper$5(Editor.positions(editor, _objectSpread$8(_objectSpread$8({}, options), {}, {\n            at: range\n        }))), _step2;\n        try {\n            for(_iterator2.s(); !(_step2 = _iterator2.n()).done;){\n                var p = _step2.value;\n                if (d > distance) {\n                    break;\n                }\n                if (d !== 0) {\n                    target = p;\n                }\n                d++;\n            }\n        } catch (err) {\n            _iterator2.e(err);\n        } finally{\n            _iterator2.f();\n        }\n        return target;\n    },\n    /**\r\n   * Get the point before a location.\r\n   */ before: function before(editor, at) {\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        var anchor = Editor.start(editor, []);\n        var focus = Editor.point(editor, at, {\n            edge: \"start\"\n        });\n        var range = {\n            anchor: anchor,\n            focus: focus\n        };\n        var _options$distance2 = options.distance, distance = _options$distance2 === void 0 ? 1 : _options$distance2;\n        var d = 0;\n        var target;\n        var _iterator3 = _createForOfIteratorHelper$5(Editor.positions(editor, _objectSpread$8(_objectSpread$8({}, options), {}, {\n            at: range,\n            reverse: true\n        }))), _step3;\n        try {\n            for(_iterator3.s(); !(_step3 = _iterator3.n()).done;){\n                var p = _step3.value;\n                if (d > distance) {\n                    break;\n                }\n                if (d !== 0) {\n                    target = p;\n                }\n                d++;\n            }\n        } catch (err) {\n            _iterator3.e(err);\n        } finally{\n            _iterator3.f();\n        }\n        return target;\n    },\n    /**\r\n   * Delete content in the editor backward from the current selection.\r\n   */ deleteBackward: function deleteBackward(editor) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        var _options$unit = options.unit, unit = _options$unit === void 0 ? \"character\" : _options$unit;\n        editor.deleteBackward(unit);\n    },\n    /**\r\n   * Delete content in the editor forward from the current selection.\r\n   */ deleteForward: function deleteForward(editor) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        var _options$unit2 = options.unit, unit = _options$unit2 === void 0 ? \"character\" : _options$unit2;\n        editor.deleteForward(unit);\n    },\n    /**\r\n   * Delete the content in the current selection.\r\n   */ deleteFragment: function deleteFragment(editor) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        var _options$direction = options.direction, direction = _options$direction === void 0 ? \"forward\" : _options$direction;\n        editor.deleteFragment(direction);\n    },\n    /**\r\n   * Get the start and end points of a location.\r\n   */ edges: function edges(editor, at) {\n        return [\n            Editor.start(editor, at),\n            Editor.end(editor, at)\n        ];\n    },\n    /**\r\n   * Get the end point of a location.\r\n   */ end: function end(editor, at) {\n        return Editor.point(editor, at, {\n            edge: \"end\"\n        });\n    },\n    /**\r\n   * Get the first node at a location.\r\n   */ first: function first(editor, at) {\n        var path = Editor.path(editor, at, {\n            edge: \"start\"\n        });\n        return Editor.node(editor, path);\n    },\n    /**\r\n   * Get the fragment at a location.\r\n   */ fragment: function fragment(editor, at) {\n        var range = Editor.range(editor, at);\n        var fragment = Node.fragment(editor, range);\n        return fragment;\n    },\n    /**\r\n   * Check if a node has block children.\r\n   */ hasBlocks: function hasBlocks(editor, element) {\n        return element.children.some(function(n) {\n            return Element.isElement(n) && Editor.isBlock(editor, n);\n        });\n    },\n    /**\r\n   * Check if a node has inline and text children.\r\n   */ hasInlines: function hasInlines(editor, element) {\n        return element.children.some(function(n) {\n            return Text.isText(n) || Editor.isInline(editor, n);\n        });\n    },\n    /**\r\n   * Check if a node has text children.\r\n   */ hasTexts: function hasTexts(editor, element) {\n        return element.children.every(function(n) {\n            return Text.isText(n);\n        });\n    },\n    /**\r\n   * Insert a block break at the current selection.\r\n   *\r\n   * If the selection is currently expanded, it will be deleted first.\r\n   */ insertBreak: function insertBreak(editor) {\n        editor.insertBreak();\n    },\n    /**\r\n   * Insert a soft break at the current selection.\r\n   *\r\n   * If the selection is currently expanded, it will be deleted first.\r\n   */ insertSoftBreak: function insertSoftBreak(editor) {\n        editor.insertSoftBreak();\n    },\n    /**\r\n   * Insert a fragment at the current selection.\r\n   *\r\n   * If the selection is currently expanded, it will be deleted first.\r\n   */ insertFragment: function insertFragment(editor, fragment) {\n        editor.insertFragment(fragment);\n    },\n    /**\r\n   * Insert a node at the current selection.\r\n   *\r\n   * If the selection is currently expanded, it will be deleted first.\r\n   */ insertNode: function insertNode(editor, node) {\n        editor.insertNode(node);\n    },\n    /**\r\n   * Insert text at the current selection.\r\n   *\r\n   * If the selection is currently expanded, it will be deleted first.\r\n   */ insertText: function insertText(editor, text) {\n        editor.insertText(text);\n    },\n    /**\r\n   * Check if a value is a block `Element` object.\r\n   */ isBlock: function isBlock(editor, value) {\n        return !editor.isInline(value);\n    },\n    /**\r\n   * Check if a value is an `Editor` object.\r\n   */ isEditor: function isEditor(value) {\n        var cachedIsEditor = IS_EDITOR_CACHE.get(value);\n        if (cachedIsEditor !== undefined) {\n            return cachedIsEditor;\n        }\n        if (!isPlainObject.isPlainObject(value)) {\n            return false;\n        }\n        var isEditor = typeof value.addMark === \"function\" && typeof value.apply === \"function\" && typeof value.deleteBackward === \"function\" && typeof value.deleteForward === \"function\" && typeof value.deleteFragment === \"function\" && typeof value.insertBreak === \"function\" && typeof value.insertSoftBreak === \"function\" && typeof value.insertFragment === \"function\" && typeof value.insertNode === \"function\" && typeof value.insertText === \"function\" && typeof value.isInline === \"function\" && typeof value.isVoid === \"function\" && typeof value.normalizeNode === \"function\" && typeof value.onChange === \"function\" && typeof value.removeMark === \"function\" && typeof value.getDirtyPaths === \"function\" && (value.marks === null || isPlainObject.isPlainObject(value.marks)) && (value.selection === null || Range.isRange(value.selection)) && Node.isNodeList(value.children) && Operation.isOperationList(value.operations);\n        IS_EDITOR_CACHE.set(value, isEditor);\n        return isEditor;\n    },\n    /**\r\n   * Check if a point is the end point of a location.\r\n   */ isEnd: function isEnd(editor, point, at) {\n        var end = Editor.end(editor, at);\n        return Point.equals(point, end);\n    },\n    /**\r\n   * Check if a point is an edge of a location.\r\n   */ isEdge: function isEdge(editor, point, at) {\n        return Editor.isStart(editor, point, at) || Editor.isEnd(editor, point, at);\n    },\n    /**\r\n   * Check if an element is empty, accounting for void nodes.\r\n   */ isEmpty: function isEmpty(editor, element) {\n        var children = element.children;\n        var _children = _slicedToArray(children, 1), first = _children[0];\n        return children.length === 0 || children.length === 1 && Text.isText(first) && first.text === \"\" && !editor.isVoid(element);\n    },\n    /**\r\n   * Check if a value is an inline `Element` object.\r\n   */ isInline: function isInline(editor, value) {\n        return editor.isInline(value);\n    },\n    /**\r\n   * Check if the editor is currently normalizing after each operation.\r\n   */ isNormalizing: function isNormalizing(editor) {\n        var isNormalizing = NORMALIZING.get(editor);\n        return isNormalizing === undefined ? true : isNormalizing;\n    },\n    /**\r\n   * Check if a point is the start point of a location.\r\n   */ isStart: function isStart(editor, point, at) {\n        // PERF: If the offset isn't `0` we know it's not the start.\n        if (point.offset !== 0) {\n            return false;\n        }\n        var start = Editor.start(editor, at);\n        return Point.equals(point, start);\n    },\n    /**\r\n   * Check if a value is a void `Element` object.\r\n   */ isVoid: function isVoid(editor, value) {\n        return editor.isVoid(value);\n    },\n    /**\r\n   * Get the last node at a location.\r\n   */ last: function last(editor, at) {\n        var path = Editor.path(editor, at, {\n            edge: \"end\"\n        });\n        return Editor.node(editor, path);\n    },\n    /**\r\n   * Get the leaf text node at a location.\r\n   */ leaf: function leaf(editor, at) {\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        var path = Editor.path(editor, at, options);\n        var node = Node.leaf(editor, path);\n        return [\n            node,\n            path\n        ];\n    },\n    /**\r\n   * Iterate through all of the levels at a location.\r\n   */ levels: function* levels(editor) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        var _options$at2 = options.at, at = _options$at2 === void 0 ? editor.selection : _options$at2, _options$reverse = options.reverse, reverse = _options$reverse === void 0 ? false : _options$reverse, _options$voids2 = options.voids, voids = _options$voids2 === void 0 ? false : _options$voids2;\n        var match = options.match;\n        if (match == null) {\n            match = function match() {\n                return true;\n            };\n        }\n        if (!at) {\n            return;\n        }\n        var levels = [];\n        var path = Editor.path(editor, at);\n        var _iterator4 = _createForOfIteratorHelper$5(Node.levels(editor, path)), _step4;\n        try {\n            for(_iterator4.s(); !(_step4 = _iterator4.n()).done;){\n                var _step4$value = _slicedToArray(_step4.value, 2), n = _step4$value[0], p = _step4$value[1];\n                if (!match(n, p)) {\n                    continue;\n                }\n                levels.push([\n                    n,\n                    p\n                ]);\n                if (!voids && Element.isElement(n) && Editor.isVoid(editor, n)) {\n                    break;\n                }\n            }\n        } catch (err) {\n            _iterator4.e(err);\n        } finally{\n            _iterator4.f();\n        }\n        if (reverse) {\n            levels.reverse();\n        }\n        yield* levels;\n    },\n    /**\r\n   * Get the marks that would be added to text at the current selection.\r\n   */ marks: function marks(editor) {\n        var marks = editor.marks, selection = editor.selection;\n        if (!selection) {\n            return null;\n        }\n        if (marks) {\n            return marks;\n        }\n        if (Range.isExpanded(selection)) {\n            var _Editor$nodes = Editor.nodes(editor, {\n                match: Text.isText\n            }), _Editor$nodes2 = _slicedToArray(_Editor$nodes, 1), match = _Editor$nodes2[0];\n            if (match) {\n                var _match = _slicedToArray(match, 1), _node = _match[0];\n                _node.text;\n                var _rest = _objectWithoutProperties(_node, _excluded$4);\n                return _rest;\n            } else {\n                return {};\n            }\n        }\n        var anchor = selection.anchor;\n        var path = anchor.path;\n        var _Editor$leaf = Editor.leaf(editor, path), _Editor$leaf2 = _slicedToArray(_Editor$leaf, 1), node = _Editor$leaf2[0];\n        if (anchor.offset === 0) {\n            var prev = Editor.previous(editor, {\n                at: path,\n                match: Text.isText\n            });\n            var markedVoid = Editor.above(editor, {\n                match: function match(n) {\n                    return Element.isElement(n) && Editor.isVoid(editor, n) && editor.markableVoid(n);\n                }\n            });\n            if (!markedVoid) {\n                var block = Editor.above(editor, {\n                    match: function match(n) {\n                        return Element.isElement(n) && Editor.isBlock(editor, n);\n                    }\n                });\n                if (prev && block) {\n                    var _prev = _slicedToArray(prev, 2), prevNode = _prev[0], prevPath = _prev[1];\n                    var _block = _slicedToArray(block, 2), blockPath = _block[1];\n                    if (Path.isAncestor(blockPath, prevPath)) {\n                        node = prevNode;\n                    }\n                }\n            }\n        }\n        var _node2 = node;\n        _node2.text;\n        var rest = _objectWithoutProperties(_node2, _excluded2$3);\n        return rest;\n    },\n    /**\r\n   * Get the matching node in the branch of the document after a location.\r\n   */ next: function next(editor) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        var _options$mode2 = options.mode, mode = _options$mode2 === void 0 ? \"lowest\" : _options$mode2, _options$voids3 = options.voids, voids = _options$voids3 === void 0 ? false : _options$voids3;\n        var match = options.match, _options$at3 = options.at, at = _options$at3 === void 0 ? editor.selection : _options$at3;\n        if (!at) {\n            return;\n        }\n        var pointAfterLocation = Editor.after(editor, at, {\n            voids: voids\n        });\n        if (!pointAfterLocation) return;\n        var _Editor$last = Editor.last(editor, []), _Editor$last2 = _slicedToArray(_Editor$last, 2), to = _Editor$last2[1];\n        var span = [\n            pointAfterLocation.path,\n            to\n        ];\n        if (Path.isPath(at) && at.length === 0) {\n            throw new Error(\"Cannot get the next node from the root node!\");\n        }\n        if (match == null) {\n            if (Path.isPath(at)) {\n                var _Editor$parent = Editor.parent(editor, at), _Editor$parent2 = _slicedToArray(_Editor$parent, 1), parent = _Editor$parent2[0];\n                match = function match(n) {\n                    return parent.children.includes(n);\n                };\n            } else {\n                match = function match() {\n                    return true;\n                };\n            }\n        }\n        var _Editor$nodes3 = Editor.nodes(editor, {\n            at: span,\n            match: match,\n            mode: mode,\n            voids: voids\n        }), _Editor$nodes4 = _slicedToArray(_Editor$nodes3, 1), next = _Editor$nodes4[0];\n        return next;\n    },\n    /**\r\n   * Get the node at a location.\r\n   */ node: function node(editor, at) {\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        var path = Editor.path(editor, at, options);\n        var node = Node.get(editor, path);\n        return [\n            node,\n            path\n        ];\n    },\n    /**\r\n   * Iterate through all of the nodes in the Editor.\r\n   */ nodes: function* nodes(editor) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        var _options$at4 = options.at, at = _options$at4 === void 0 ? editor.selection : _options$at4, _options$mode3 = options.mode, mode = _options$mode3 === void 0 ? \"all\" : _options$mode3, _options$universal = options.universal, universal = _options$universal === void 0 ? false : _options$universal, _options$reverse2 = options.reverse, reverse = _options$reverse2 === void 0 ? false : _options$reverse2, _options$voids4 = options.voids, voids = _options$voids4 === void 0 ? false : _options$voids4;\n        var match = options.match;\n        if (!match) {\n            match = function match() {\n                return true;\n            };\n        }\n        if (!at) {\n            return;\n        }\n        var from;\n        var to;\n        if (Span.isSpan(at)) {\n            from = at[0];\n            to = at[1];\n        } else {\n            var first = Editor.path(editor, at, {\n                edge: \"start\"\n            });\n            var last = Editor.path(editor, at, {\n                edge: \"end\"\n            });\n            from = reverse ? last : first;\n            to = reverse ? first : last;\n        }\n        var nodeEntries = Node.nodes(editor, {\n            reverse: reverse,\n            from: from,\n            to: to,\n            pass: function pass(_ref) {\n                var _ref2 = _slicedToArray(_ref, 1), n = _ref2[0];\n                return voids ? false : Element.isElement(n) && Editor.isVoid(editor, n);\n            }\n        });\n        var matches = [];\n        var hit;\n        var _iterator5 = _createForOfIteratorHelper$5(nodeEntries), _step5;\n        try {\n            for(_iterator5.s(); !(_step5 = _iterator5.n()).done;){\n                var _step5$value = _slicedToArray(_step5.value, 2), node = _step5$value[0], path = _step5$value[1];\n                var isLower = hit && Path.compare(path, hit[1]) === 0; // In highest mode any node lower than the last hit is not a match.\n                if (mode === \"highest\" && isLower) {\n                    continue;\n                }\n                if (!match(node, path)) {\n                    // If we've arrived at a leaf text node that is not lower than the last\n                    // hit, then we've found a branch that doesn't include a match, which\n                    // means the match is not universal.\n                    if (universal && !isLower && Text.isText(node)) {\n                        return;\n                    } else {\n                        continue;\n                    }\n                } // If there's a match and it's lower than the last, update the hit.\n                if (mode === \"lowest\" && isLower) {\n                    hit = [\n                        node,\n                        path\n                    ];\n                    continue;\n                } // In lowest mode we emit the last hit, once it's guaranteed lowest.\n                var emit = mode === \"lowest\" ? hit : [\n                    node,\n                    path\n                ];\n                if (emit) {\n                    if (universal) {\n                        matches.push(emit);\n                    } else {\n                        yield emit;\n                    }\n                }\n                hit = [\n                    node,\n                    path\n                ];\n            } // Since lowest is always emitting one behind, catch up at the end.\n        } catch (err) {\n            _iterator5.e(err);\n        } finally{\n            _iterator5.f();\n        }\n        if (mode === \"lowest\" && hit) {\n            if (universal) {\n                matches.push(hit);\n            } else {\n                yield hit;\n            }\n        } // Universal defers to ensure that the match occurs in every branch, so we\n        // yield all of the matches after iterating.\n        if (universal) {\n            yield* matches;\n        }\n    },\n    /**\r\n   * Normalize any dirty objects in the editor.\r\n   */ normalize: function normalize(editor) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        var _options$force = options.force, force = _options$force === void 0 ? false : _options$force, operation = options.operation;\n        var getDirtyPaths = function getDirtyPaths(editor) {\n            return DIRTY_PATHS.get(editor) || [];\n        };\n        var getDirtyPathKeys = function getDirtyPathKeys(editor) {\n            return DIRTY_PATH_KEYS.get(editor) || new Set();\n        };\n        var popDirtyPath = function popDirtyPath(editor) {\n            var path = getDirtyPaths(editor).pop();\n            var key = path.join(\",\");\n            getDirtyPathKeys(editor)[\"delete\"](key);\n            return path;\n        };\n        if (!Editor.isNormalizing(editor)) {\n            return;\n        }\n        if (force) {\n            var allPaths = Array.from(Node.nodes(editor), function(_ref3) {\n                var _ref4 = _slicedToArray(_ref3, 2), p = _ref4[1];\n                return p;\n            });\n            var allPathKeys = new Set(allPaths.map(function(p) {\n                return p.join(\",\");\n            }));\n            DIRTY_PATHS.set(editor, allPaths);\n            DIRTY_PATH_KEYS.set(editor, allPathKeys);\n        }\n        if (getDirtyPaths(editor).length === 0) {\n            return;\n        }\n        Editor.withoutNormalizing(editor, function() {\n            /*\r\n        Fix dirty elements with no children.\r\n        editor.normalizeNode() does fix this, but some normalization fixes also require it to work.\r\n        Running an initial pass avoids the catch-22 race condition.\r\n      */ var _iterator6 = _createForOfIteratorHelper$5(getDirtyPaths(editor)), _step6;\n            try {\n                for(_iterator6.s(); !(_step6 = _iterator6.n()).done;){\n                    var _dirtyPath = _step6.value;\n                    if (Node.has(editor, _dirtyPath)) {\n                        var _entry = Editor.node(editor, _dirtyPath);\n                        var _entry2 = _slicedToArray(_entry, 2), node = _entry2[0], _ = _entry2[1];\n                        /*\r\n              The default normalizer inserts an empty text node in this scenario, but it can be customised.\r\n              So there is some risk here.\r\n                         As long as the normalizer only inserts child nodes for this case it is safe to do in any order;\r\n              by definition adding children to an empty node can't cause other paths to change.\r\n            */ if (Element.isElement(node) && node.children.length === 0) {\n                            editor.normalizeNode(_entry, {\n                                operation: operation\n                            });\n                        }\n                    }\n                }\n            } catch (err) {\n                _iterator6.e(err);\n            } finally{\n                _iterator6.f();\n            }\n            var dirtyPaths = getDirtyPaths(editor);\n            var initialDirtyPathsLength = dirtyPaths.length;\n            var iteration = 0;\n            while(dirtyPaths.length !== 0){\n                if (!editor.shouldNormalize({\n                    dirtyPaths: dirtyPaths,\n                    iteration: iteration,\n                    initialDirtyPathsLength: initialDirtyPathsLength,\n                    operation: operation\n                })) {\n                    return;\n                }\n                var dirtyPath = popDirtyPath(editor); // If the node doesn't exist in the tree, it does not need to be normalized.\n                if (Node.has(editor, dirtyPath)) {\n                    var entry = Editor.node(editor, dirtyPath);\n                    editor.normalizeNode(entry, {\n                        operation: operation\n                    });\n                }\n                iteration++;\n                dirtyPaths = getDirtyPaths(editor);\n            }\n        });\n    },\n    /**\r\n   * Get the parent node of a location.\r\n   */ parent: function parent(editor, at) {\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        var path = Editor.path(editor, at, options);\n        var parentPath = Path.parent(path);\n        var entry = Editor.node(editor, parentPath);\n        return entry;\n    },\n    /**\r\n   * Get the path of a location.\r\n   */ path: function path(editor, at) {\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        var depth = options.depth, edge = options.edge;\n        if (Path.isPath(at)) {\n            if (edge === \"start\") {\n                var _Node$first = Node.first(editor, at), _Node$first2 = _slicedToArray(_Node$first, 2), firstPath = _Node$first2[1];\n                at = firstPath;\n            } else if (edge === \"end\") {\n                var _Node$last = Node.last(editor, at), _Node$last2 = _slicedToArray(_Node$last, 2), lastPath = _Node$last2[1];\n                at = lastPath;\n            }\n        }\n        if (Range.isRange(at)) {\n            if (edge === \"start\") {\n                at = Range.start(at);\n            } else if (edge === \"end\") {\n                at = Range.end(at);\n            } else {\n                at = Path.common(at.anchor.path, at.focus.path);\n            }\n        }\n        if (Point.isPoint(at)) {\n            at = at.path;\n        }\n        if (depth != null) {\n            at = at.slice(0, depth);\n        }\n        return at;\n    },\n    hasPath: function hasPath(editor, path) {\n        return Node.has(editor, path);\n    },\n    /**\r\n   * Create a mutable ref for a `Path` object, which will stay in sync as new\r\n   * operations are applied to the editor.\r\n   */ pathRef: function pathRef(editor, path) {\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        var _options$affinity = options.affinity, affinity = _options$affinity === void 0 ? \"forward\" : _options$affinity;\n        var ref = {\n            current: path,\n            affinity: affinity,\n            unref: function unref() {\n                var current = ref.current;\n                var pathRefs = Editor.pathRefs(editor);\n                pathRefs[\"delete\"](ref);\n                ref.current = null;\n                return current;\n            }\n        };\n        var refs = Editor.pathRefs(editor);\n        refs.add(ref);\n        return ref;\n    },\n    /**\r\n   * Get the set of currently tracked path refs of the editor.\r\n   */ pathRefs: function pathRefs(editor) {\n        var refs = PATH_REFS.get(editor);\n        if (!refs) {\n            refs = new Set();\n            PATH_REFS.set(editor, refs);\n        }\n        return refs;\n    },\n    /**\r\n   * Get the start or end point of a location.\r\n   */ point: function point(editor, at) {\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        var _options$edge = options.edge, edge = _options$edge === void 0 ? \"start\" : _options$edge;\n        if (Path.isPath(at)) {\n            var path;\n            if (edge === \"end\") {\n                var _Node$last3 = Node.last(editor, at), _Node$last4 = _slicedToArray(_Node$last3, 2), lastPath = _Node$last4[1];\n                path = lastPath;\n            } else {\n                var _Node$first3 = Node.first(editor, at), _Node$first4 = _slicedToArray(_Node$first3, 2), firstPath = _Node$first4[1];\n                path = firstPath;\n            }\n            var node = Node.get(editor, path);\n            if (!Text.isText(node)) {\n                throw new Error(\"Cannot get the \".concat(edge, \" point in the node at path [\").concat(at, \"] because it has no \").concat(edge, \" text node.\"));\n            }\n            return {\n                path: path,\n                offset: edge === \"end\" ? node.text.length : 0\n            };\n        }\n        if (Range.isRange(at)) {\n            var _Range$edges = Range.edges(at), _Range$edges2 = _slicedToArray(_Range$edges, 2), start = _Range$edges2[0], end = _Range$edges2[1];\n            return edge === \"start\" ? start : end;\n        }\n        return at;\n    },\n    /**\r\n   * Create a mutable ref for a `Point` object, which will stay in sync as new\r\n   * operations are applied to the editor.\r\n   */ pointRef: function pointRef(editor, point) {\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        var _options$affinity2 = options.affinity, affinity = _options$affinity2 === void 0 ? \"forward\" : _options$affinity2;\n        var ref = {\n            current: point,\n            affinity: affinity,\n            unref: function unref() {\n                var current = ref.current;\n                var pointRefs = Editor.pointRefs(editor);\n                pointRefs[\"delete\"](ref);\n                ref.current = null;\n                return current;\n            }\n        };\n        var refs = Editor.pointRefs(editor);\n        refs.add(ref);\n        return ref;\n    },\n    /**\r\n   * Get the set of currently tracked point refs of the editor.\r\n   */ pointRefs: function pointRefs(editor) {\n        var refs = POINT_REFS.get(editor);\n        if (!refs) {\n            refs = new Set();\n            POINT_REFS.set(editor, refs);\n        }\n        return refs;\n    },\n    /**\r\n   * Return all the positions in `at` range where a `Point` can be placed.\r\n   *\r\n   * By default, moves forward by individual offsets at a time, but\r\n   * the `unit` option can be used to to move by character, word, line, or block.\r\n   *\r\n   * The `reverse` option can be used to change iteration direction.\r\n   *\r\n   * Note: By default void nodes are treated as a single point and iteration\r\n   * will not happen inside their content unless you pass in true for the\r\n   * `voids` option, then iteration will occur.\r\n   */ positions: function* positions(editor) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        var _options$at5 = options.at, at = _options$at5 === void 0 ? editor.selection : _options$at5, _options$unit3 = options.unit, unit = _options$unit3 === void 0 ? \"offset\" : _options$unit3, _options$reverse3 = options.reverse, reverse = _options$reverse3 === void 0 ? false : _options$reverse3, _options$voids5 = options.voids, voids = _options$voids5 === void 0 ? false : _options$voids5;\n        if (!at) {\n            return;\n        }\n        /**\r\n     * Algorithm notes:\r\n     *\r\n     * Each step `distance` is dynamic depending on the underlying text\r\n     * and the `unit` specified.  Each step, e.g., a line or word, may\r\n     * span multiple text nodes, so we iterate through the text both on\r\n     * two levels in step-sync:\r\n     *\r\n     * `leafText` stores the text on a text leaf level, and is advanced\r\n     * through using the counters `leafTextOffset` and `leafTextRemaining`.\r\n     *\r\n     * `blockText` stores the text on a block level, and is shortened\r\n     * by `distance` every time it is advanced.\r\n     *\r\n     * We only maintain a window of one blockText and one leafText because\r\n     * a block node always appears before all of its leaf nodes.\r\n     */ var range = Editor.range(editor, at);\n        var _Range$edges3 = Range.edges(range), _Range$edges4 = _slicedToArray(_Range$edges3, 2), start = _Range$edges4[0], end = _Range$edges4[1];\n        var first = reverse ? end : start;\n        var isNewBlock = false;\n        var blockText = \"\";\n        var distance = 0; // Distance for leafText to catch up to blockText.\n        var leafTextRemaining = 0;\n        var leafTextOffset = 0; // Iterate through all nodes in range, grabbing entire textual content\n        // of block nodes in blockText, and text nodes in leafText.\n        // Exploits the fact that nodes are sequenced in such a way that we first\n        // encounter the block node, then all of its text nodes, so when iterating\n        // through the blockText and leafText we just need to remember a window of\n        // one block node and leaf node, respectively.\n        var _iterator7 = _createForOfIteratorHelper$5(Editor.nodes(editor, {\n            at: at,\n            reverse: reverse,\n            voids: voids\n        })), _step7;\n        try {\n            for(_iterator7.s(); !(_step7 = _iterator7.n()).done;){\n                var _step7$value = _slicedToArray(_step7.value, 2), node = _step7$value[0], path = _step7$value[1];\n                /*\r\n         * ELEMENT NODE - Yield position(s) for voids, collect blockText for blocks\r\n         */ if (Element.isElement(node)) {\n                    // Void nodes are a special case, so by default we will always\n                    // yield their first point. If the `voids` option is set to true,\n                    // then we will iterate over their content.\n                    if (!voids && editor.isVoid(node)) {\n                        yield Editor.start(editor, path);\n                        continue;\n                    } // Inline element nodes are ignored as they don't themselves\n                    // contribute to `blockText` or `leafText` - their parent and\n                    // children do.\n                    if (editor.isInline(node)) continue; // Block element node - set `blockText` to its text content.\n                    if (Editor.hasInlines(editor, node)) {\n                        // We always exhaust block nodes before encountering a new one:\n                        //   console.assert(blockText === '',\n                        //     `blockText='${blockText}' - `+\n                        //     `not exhausted before new block node`, path)\n                        // Ensure range considered is capped to `range`, in the\n                        // start/end edge cases where block extends beyond range.\n                        // Equivalent to this, but presumably more performant:\n                        //   blockRange = Editor.range(editor, ...Editor.edges(editor, path))\n                        //   blockRange = Range.intersection(range, blockRange) // intersect\n                        //   blockText = Editor.string(editor, blockRange, { voids })\n                        var e = Path.isAncestor(path, end.path) ? end : Editor.end(editor, path);\n                        var s = Path.isAncestor(path, start.path) ? start : Editor.start(editor, path);\n                        blockText = Editor.string(editor, {\n                            anchor: s,\n                            focus: e\n                        }, {\n                            voids: voids\n                        });\n                        isNewBlock = true;\n                    }\n                }\n                /*\r\n         * TEXT LEAF NODE - Iterate through text content, yielding\r\n         * positions every `distance` offset according to `unit`.\r\n         */ if (Text.isText(node)) {\n                    var isFirst = Path.equals(path, first.path); // Proof that we always exhaust text nodes before encountering a new one:\n                    //   console.assert(leafTextRemaining <= 0,\n                    //     `leafTextRemaining=${leafTextRemaining} - `+\n                    //     `not exhausted before new leaf text node`, path)\n                    // Reset `leafText` counters for new text node.\n                    if (isFirst) {\n                        leafTextRemaining = reverse ? first.offset : node.text.length - first.offset;\n                        leafTextOffset = first.offset; // Works for reverse too.\n                    } else {\n                        leafTextRemaining = node.text.length;\n                        leafTextOffset = reverse ? leafTextRemaining : 0;\n                    } // Yield position at the start of node (potentially).\n                    if (isFirst || isNewBlock || unit === \"offset\") {\n                        yield {\n                            path: path,\n                            offset: leafTextOffset\n                        };\n                        isNewBlock = false;\n                    } // Yield positions every (dynamically calculated) `distance` offset.\n                    while(true){\n                        // If `leafText` has caught up with `blockText` (distance=0),\n                        // and if blockText is exhausted, break to get another block node,\n                        // otherwise advance blockText forward by the new `distance`.\n                        if (distance === 0) {\n                            if (blockText === \"\") break;\n                            distance = calcDistance(blockText, unit, reverse); // Split the string at the previously found distance and use the\n                            // remaining string for the next iteration.\n                            blockText = splitByCharacterDistance(blockText, distance, reverse)[1];\n                        } // Advance `leafText` by the current `distance`.\n                        leafTextOffset = reverse ? leafTextOffset - distance : leafTextOffset + distance;\n                        leafTextRemaining = leafTextRemaining - distance; // If `leafText` is exhausted, break to get a new leaf node\n                        // and set distance to the overflow amount, so we'll (maybe)\n                        // catch up to blockText in the next leaf text node.\n                        if (leafTextRemaining < 0) {\n                            distance = -leafTextRemaining;\n                            break;\n                        } // Successfully walked `distance` offsets through `leafText`\n                        // to catch up with `blockText`, so we can reset `distance`\n                        // and yield this position in this node.\n                        distance = 0;\n                        yield {\n                            path: path,\n                            offset: leafTextOffset\n                        };\n                    }\n                }\n            } // Proof that upon completion, we've exahusted both leaf and block text:\n        //   console.assert(leafTextRemaining <= 0, \"leafText wasn't exhausted\")\n        //   console.assert(blockText === '', \"blockText wasn't exhausted\")\n        // Helper:\n        // Return the distance in offsets for a step of size `unit` on given string.\n        } catch (err) {\n            _iterator7.e(err);\n        } finally{\n            _iterator7.f();\n        }\n        function calcDistance(text, unit, reverse) {\n            if (unit === \"character\") {\n                return getCharacterDistance(text, reverse);\n            } else if (unit === \"word\") {\n                return getWordDistance(text, reverse);\n            } else if (unit === \"line\" || unit === \"block\") {\n                return text.length;\n            }\n            return 1;\n        }\n    },\n    /**\r\n   * Get the matching node in the branch of the document before a location.\r\n   */ previous: function previous(editor) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        var _options$mode4 = options.mode, mode = _options$mode4 === void 0 ? \"lowest\" : _options$mode4, _options$voids6 = options.voids, voids = _options$voids6 === void 0 ? false : _options$voids6;\n        var match = options.match, _options$at6 = options.at, at = _options$at6 === void 0 ? editor.selection : _options$at6;\n        if (!at) {\n            return;\n        }\n        var pointBeforeLocation = Editor.before(editor, at, {\n            voids: voids\n        });\n        if (!pointBeforeLocation) {\n            return;\n        }\n        var _Editor$first = Editor.first(editor, []), _Editor$first2 = _slicedToArray(_Editor$first, 2), to = _Editor$first2[1]; // The search location is from the start of the document to the path of\n        // the point before the location passed in\n        var span = [\n            pointBeforeLocation.path,\n            to\n        ];\n        if (Path.isPath(at) && at.length === 0) {\n            throw new Error(\"Cannot get the previous node from the root node!\");\n        }\n        if (match == null) {\n            if (Path.isPath(at)) {\n                var _Editor$parent3 = Editor.parent(editor, at), _Editor$parent4 = _slicedToArray(_Editor$parent3, 1), parent = _Editor$parent4[0];\n                match = function match(n) {\n                    return parent.children.includes(n);\n                };\n            } else {\n                match = function match() {\n                    return true;\n                };\n            }\n        }\n        var _Editor$nodes5 = Editor.nodes(editor, {\n            reverse: true,\n            at: span,\n            match: match,\n            mode: mode,\n            voids: voids\n        }), _Editor$nodes6 = _slicedToArray(_Editor$nodes5, 1), previous = _Editor$nodes6[0];\n        return previous;\n    },\n    /**\r\n   * Get a range of a location.\r\n   */ range: function range(editor, at, to) {\n        if (Range.isRange(at) && !to) {\n            return at;\n        }\n        var start = Editor.start(editor, at);\n        var end = Editor.end(editor, to || at);\n        return {\n            anchor: start,\n            focus: end\n        };\n    },\n    /**\r\n   * Create a mutable ref for a `Range` object, which will stay in sync as new\r\n   * operations are applied to the editor.\r\n   */ rangeRef: function rangeRef(editor, range) {\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        var _options$affinity3 = options.affinity, affinity = _options$affinity3 === void 0 ? \"forward\" : _options$affinity3;\n        var ref = {\n            current: range,\n            affinity: affinity,\n            unref: function unref() {\n                var current = ref.current;\n                var rangeRefs = Editor.rangeRefs(editor);\n                rangeRefs[\"delete\"](ref);\n                ref.current = null;\n                return current;\n            }\n        };\n        var refs = Editor.rangeRefs(editor);\n        refs.add(ref);\n        return ref;\n    },\n    /**\r\n   * Get the set of currently tracked range refs of the editor.\r\n   */ rangeRefs: function rangeRefs(editor) {\n        var refs = RANGE_REFS.get(editor);\n        if (!refs) {\n            refs = new Set();\n            RANGE_REFS.set(editor, refs);\n        }\n        return refs;\n    },\n    /**\r\n   * Remove a custom property from all of the leaf text nodes in the current\r\n   * selection.\r\n   *\r\n   * If the selection is currently collapsed, the removal will be stored on\r\n   * `editor.marks` and applied to the text inserted next.\r\n   */ removeMark: function removeMark(editor, key) {\n        editor.removeMark(key);\n    },\n    /**\r\n   * Manually set if the editor should currently be normalizing.\r\n   *\r\n   * Note: Using this incorrectly can leave the editor in an invalid state.\r\n   *\r\n   */ setNormalizing: function setNormalizing(editor, isNormalizing) {\n        NORMALIZING.set(editor, isNormalizing);\n    },\n    /**\r\n   * Get the start point of a location.\r\n   */ start: function start(editor, at) {\n        return Editor.point(editor, at, {\n            edge: \"start\"\n        });\n    },\n    /**\r\n   * Get the text string content of a location.\r\n   *\r\n   * Note: by default the text of void nodes is considered to be an empty\r\n   * string, regardless of content, unless you pass in true for the voids option\r\n   */ string: function string(editor, at) {\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        var _options$voids7 = options.voids, voids = _options$voids7 === void 0 ? false : _options$voids7;\n        var range = Editor.range(editor, at);\n        var _Range$edges5 = Range.edges(range), _Range$edges6 = _slicedToArray(_Range$edges5, 2), start = _Range$edges6[0], end = _Range$edges6[1];\n        var text = \"\";\n        var _iterator8 = _createForOfIteratorHelper$5(Editor.nodes(editor, {\n            at: range,\n            match: Text.isText,\n            voids: voids\n        })), _step8;\n        try {\n            for(_iterator8.s(); !(_step8 = _iterator8.n()).done;){\n                var _step8$value = _slicedToArray(_step8.value, 2), node = _step8$value[0], path = _step8$value[1];\n                var t = node.text;\n                if (Path.equals(path, end.path)) {\n                    t = t.slice(0, end.offset);\n                }\n                if (Path.equals(path, start.path)) {\n                    t = t.slice(start.offset);\n                }\n                text += t;\n            }\n        } catch (err) {\n            _iterator8.e(err);\n        } finally{\n            _iterator8.f();\n        }\n        return text;\n    },\n    /**\r\n   * Convert a range into a non-hanging one.\r\n   */ unhangRange: function unhangRange(editor, range) {\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        var _options$voids8 = options.voids, voids = _options$voids8 === void 0 ? false : _options$voids8;\n        var _Range$edges7 = Range.edges(range), _Range$edges8 = _slicedToArray(_Range$edges7, 2), start = _Range$edges8[0], end = _Range$edges8[1]; // PERF: exit early if we can guarantee that the range isn't hanging.\n        if (start.offset !== 0 || end.offset !== 0 || Range.isCollapsed(range) || Path.hasPrevious(end.path)) {\n            return range;\n        }\n        var endBlock = Editor.above(editor, {\n            at: end,\n            match: function match(n) {\n                return Element.isElement(n) && Editor.isBlock(editor, n);\n            },\n            voids: voids\n        });\n        var blockPath = endBlock ? endBlock[1] : [];\n        var first = Editor.start(editor, start);\n        var before = {\n            anchor: first,\n            focus: end\n        };\n        var skip = true;\n        var _iterator9 = _createForOfIteratorHelper$5(Editor.nodes(editor, {\n            at: before,\n            match: Text.isText,\n            reverse: true,\n            voids: voids\n        })), _step9;\n        try {\n            for(_iterator9.s(); !(_step9 = _iterator9.n()).done;){\n                var _step9$value = _slicedToArray(_step9.value, 2), node = _step9$value[0], path = _step9$value[1];\n                if (skip) {\n                    skip = false;\n                    continue;\n                }\n                if (node.text !== \"\" || Path.isBefore(path, blockPath)) {\n                    end = {\n                        path: path,\n                        offset: node.text.length\n                    };\n                    break;\n                }\n            }\n        } catch (err) {\n            _iterator9.e(err);\n        } finally{\n            _iterator9.f();\n        }\n        return {\n            anchor: start,\n            focus: end\n        };\n    },\n    /**\r\n   * Match a void node in the current branch of the editor.\r\n   */ \"void\": function _void(editor) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        return Editor.above(editor, _objectSpread$8(_objectSpread$8({}, options), {}, {\n            match: function match(n) {\n                return Element.isElement(n) && Editor.isVoid(editor, n);\n            }\n        }));\n    },\n    /**\r\n   * Call a function, deferring normalization until after it completes.\r\n   */ withoutNormalizing: function withoutNormalizing(editor, fn) {\n        var value = Editor.isNormalizing(editor);\n        Editor.setNormalizing(editor, false);\n        try {\n            fn();\n        } finally{\n            Editor.setNormalizing(editor, value);\n        }\n        Editor.normalize(editor);\n    }\n};\nvar Location = {\n    /**\r\n   * Check if a value implements the `Location` interface.\r\n   */ isLocation: function isLocation(value) {\n        return Path.isPath(value) || Point.isPoint(value) || Range.isRange(value);\n    }\n}; // eslint-disable-next-line no-redeclare\nvar Span = {\n    /**\r\n   * Check if a value implements the `Span` interface.\r\n   */ isSpan: function isSpan(value) {\n        return Array.isArray(value) && value.length === 2 && value.every(Path.isPath);\n    }\n};\nvar _excluded$3 = [\n    \"children\"\n], _excluded2$2 = [\n    \"text\"\n];\nfunction _createForOfIteratorHelper$4(o, allowArrayLike) {\n    var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n    if (!it) {\n        if (Array.isArray(o) || (it = _unsupportedIterableToArray$4(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n            if (it) o = it;\n            var i = 0;\n            var F = function F() {};\n            return {\n                s: F,\n                n: function n() {\n                    if (i >= o.length) return {\n                        done: true\n                    };\n                    return {\n                        done: false,\n                        value: o[i++]\n                    };\n                },\n                e: function e(_e) {\n                    throw _e;\n                },\n                f: F\n            };\n        }\n        throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n    }\n    var normalCompletion = true, didErr = false, err;\n    return {\n        s: function s() {\n            it = it.call(o);\n        },\n        n: function n() {\n            var step = it.next();\n            normalCompletion = step.done;\n            return step;\n        },\n        e: function e(_e2) {\n            didErr = true;\n            err = _e2;\n        },\n        f: function f() {\n            try {\n                if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n            } finally{\n                if (didErr) throw err;\n            }\n        }\n    };\n}\nfunction _unsupportedIterableToArray$4(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray$4(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(o);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$4(o, minLen);\n}\nfunction _arrayLikeToArray$4(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++){\n        arr2[i] = arr[i];\n    }\n    return arr2;\n}\nvar IS_NODE_LIST_CACHE = new WeakMap(); // eslint-disable-next-line no-redeclare\nvar Node = {\n    /**\r\n   * Get the node at a specific path, asserting that it's an ancestor node.\r\n   */ ancestor: function ancestor(root, path) {\n        var node = Node.get(root, path);\n        if (Text.isText(node)) {\n            throw new Error(\"Cannot get the ancestor node at path [\".concat(path, \"] because it refers to a text node instead: \").concat(Scrubber.stringify(node)));\n        }\n        return node;\n    },\n    /**\r\n   * Return a generator of all the ancestor nodes above a specific path.\r\n   *\r\n   * By default the order is top-down, from highest to lowest ancestor in\r\n   * the tree, but you can pass the `reverse: true` option to go bottom-up.\r\n   */ ancestors: function* ancestors(root, path) {\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        var _iterator = _createForOfIteratorHelper$4(Path.ancestors(path, options)), _step;\n        try {\n            for(_iterator.s(); !(_step = _iterator.n()).done;){\n                var p = _step.value;\n                var n = Node.ancestor(root, p);\n                var entry = [\n                    n,\n                    p\n                ];\n                yield entry;\n            }\n        } catch (err) {\n            _iterator.e(err);\n        } finally{\n            _iterator.f();\n        }\n    },\n    /**\r\n   * Get the child of a node at a specific index.\r\n   */ child: function child(root, index) {\n        if (Text.isText(root)) {\n            throw new Error(\"Cannot get the child of a text node: \".concat(Scrubber.stringify(root)));\n        }\n        var c = root.children[index];\n        if (c == null) {\n            throw new Error(\"Cannot get child at index `\".concat(index, \"` in node: \").concat(Scrubber.stringify(root)));\n        }\n        return c;\n    },\n    /**\r\n   * Iterate over the children of a node at a specific path.\r\n   */ children: function* children(root, path) {\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        var _options$reverse = options.reverse, reverse = _options$reverse === void 0 ? false : _options$reverse;\n        var ancestor = Node.ancestor(root, path);\n        var children = ancestor.children;\n        var index = reverse ? children.length - 1 : 0;\n        while(reverse ? index >= 0 : index < children.length){\n            var child = Node.child(ancestor, index);\n            var childPath = path.concat(index);\n            yield [\n                child,\n                childPath\n            ];\n            index = reverse ? index - 1 : index + 1;\n        }\n    },\n    /**\r\n   * Get an entry for the common ancesetor node of two paths.\r\n   */ common: function common(root, path, another) {\n        var p = Path.common(path, another);\n        var n = Node.get(root, p);\n        return [\n            n,\n            p\n        ];\n    },\n    /**\r\n   * Get the node at a specific path, asserting that it's a descendant node.\r\n   */ descendant: function descendant(root, path) {\n        var node = Node.get(root, path);\n        if (Editor.isEditor(node)) {\n            throw new Error(\"Cannot get the descendant node at path [\".concat(path, \"] because it refers to the root editor node instead: \").concat(Scrubber.stringify(node)));\n        }\n        return node;\n    },\n    /**\r\n   * Return a generator of all the descendant node entries inside a root node.\r\n   */ descendants: function* descendants(root) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        var _iterator2 = _createForOfIteratorHelper$4(Node.nodes(root, options)), _step2;\n        try {\n            for(_iterator2.s(); !(_step2 = _iterator2.n()).done;){\n                var _step2$value = _slicedToArray(_step2.value, 2), node = _step2$value[0], path = _step2$value[1];\n                if (path.length !== 0) {\n                    // NOTE: we have to coerce here because checking the path's length does\n                    // guarantee that `node` is not a `Editor`, but TypeScript doesn't know.\n                    yield [\n                        node,\n                        path\n                    ];\n                }\n            }\n        } catch (err) {\n            _iterator2.e(err);\n        } finally{\n            _iterator2.f();\n        }\n    },\n    /**\r\n   * Return a generator of all the element nodes inside a root node. Each iteration\r\n   * will return an `ElementEntry` tuple consisting of `[Element, Path]`. If the\r\n   * root node is an element it will be included in the iteration as well.\r\n   */ elements: function* elements(root) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        var _iterator3 = _createForOfIteratorHelper$4(Node.nodes(root, options)), _step3;\n        try {\n            for(_iterator3.s(); !(_step3 = _iterator3.n()).done;){\n                var _step3$value = _slicedToArray(_step3.value, 2), node = _step3$value[0], path = _step3$value[1];\n                if (Element.isElement(node)) {\n                    yield [\n                        node,\n                        path\n                    ];\n                }\n            }\n        } catch (err) {\n            _iterator3.e(err);\n        } finally{\n            _iterator3.f();\n        }\n    },\n    /**\r\n   * Extract props from a Node.\r\n   */ extractProps: function extractProps(node) {\n        if (Element.isAncestor(node)) {\n            node.children;\n            var properties = _objectWithoutProperties(node, _excluded$3);\n            return properties;\n        } else {\n            node.text;\n            var _properties = _objectWithoutProperties(node, _excluded2$2);\n            return _properties;\n        }\n    },\n    /**\r\n   * Get the first node entry in a root node from a path.\r\n   */ first: function first(root, path) {\n        var p = path.slice();\n        var n = Node.get(root, p);\n        while(n){\n            if (Text.isText(n) || n.children.length === 0) {\n                break;\n            } else {\n                n = n.children[0];\n                p.push(0);\n            }\n        }\n        return [\n            n,\n            p\n        ];\n    },\n    /**\r\n   * Get the sliced fragment represented by a range inside a root node.\r\n   */ fragment: function fragment(root, range) {\n        if (Text.isText(root)) {\n            throw new Error(\"Cannot get a fragment starting from a root text node: \".concat(Scrubber.stringify(root)));\n        }\n        var newRoot = immer.produce({\n            children: root.children\n        }, function(r) {\n            var _Range$edges = Range.edges(range), _Range$edges2 = _slicedToArray(_Range$edges, 2), start = _Range$edges2[0], end = _Range$edges2[1];\n            var nodeEntries = Node.nodes(r, {\n                reverse: true,\n                pass: function pass(_ref) {\n                    var _ref2 = _slicedToArray(_ref, 2), path = _ref2[1];\n                    return !Range.includes(range, path);\n                }\n            });\n            var _iterator4 = _createForOfIteratorHelper$4(nodeEntries), _step4;\n            try {\n                for(_iterator4.s(); !(_step4 = _iterator4.n()).done;){\n                    var _step4$value = _slicedToArray(_step4.value, 2), path = _step4$value[1];\n                    if (!Range.includes(range, path)) {\n                        var parent = Node.parent(r, path);\n                        var index = path[path.length - 1];\n                        parent.children.splice(index, 1);\n                    }\n                    if (Path.equals(path, end.path)) {\n                        var leaf = Node.leaf(r, path);\n                        leaf.text = leaf.text.slice(0, end.offset);\n                    }\n                    if (Path.equals(path, start.path)) {\n                        var _leaf = Node.leaf(r, path);\n                        _leaf.text = _leaf.text.slice(start.offset);\n                    }\n                }\n            } catch (err) {\n                _iterator4.e(err);\n            } finally{\n                _iterator4.f();\n            }\n            if (Editor.isEditor(r)) {\n                r.selection = null;\n            }\n        });\n        return newRoot.children;\n    },\n    /**\r\n   * Get the descendant node referred to by a specific path. If the path is an\r\n   * empty array, it refers to the root node itself.\r\n   */ get: function get(root, path) {\n        var node = root;\n        for(var i = 0; i < path.length; i++){\n            var p = path[i];\n            if (Text.isText(node) || !node.children[p]) {\n                throw new Error(\"Cannot find a descendant at path [\".concat(path, \"] in node: \").concat(Scrubber.stringify(root)));\n            }\n            node = node.children[p];\n        }\n        return node;\n    },\n    /**\r\n   * Check if a descendant node exists at a specific path.\r\n   */ has: function has(root, path) {\n        var node = root;\n        for(var i = 0; i < path.length; i++){\n            var p = path[i];\n            if (Text.isText(node) || !node.children[p]) {\n                return false;\n            }\n            node = node.children[p];\n        }\n        return true;\n    },\n    /**\r\n   * Check if a value implements the `Node` interface.\r\n   */ isNode: function isNode(value) {\n        return Text.isText(value) || Element.isElement(value) || Editor.isEditor(value);\n    },\n    /**\r\n   * Check if a value is a list of `Node` objects.\r\n   */ isNodeList: function isNodeList(value) {\n        if (!Array.isArray(value)) {\n            return false;\n        }\n        var cachedResult = IS_NODE_LIST_CACHE.get(value);\n        if (cachedResult !== undefined) {\n            return cachedResult;\n        }\n        var isNodeList = value.every(function(val) {\n            return Node.isNode(val);\n        });\n        IS_NODE_LIST_CACHE.set(value, isNodeList);\n        return isNodeList;\n    },\n    /**\r\n   * Get the last node entry in a root node from a path.\r\n   */ last: function last(root, path) {\n        var p = path.slice();\n        var n = Node.get(root, p);\n        while(n){\n            if (Text.isText(n) || n.children.length === 0) {\n                break;\n            } else {\n                var i = n.children.length - 1;\n                n = n.children[i];\n                p.push(i);\n            }\n        }\n        return [\n            n,\n            p\n        ];\n    },\n    /**\r\n   * Get the node at a specific path, ensuring it's a leaf text node.\r\n   */ leaf: function leaf(root, path) {\n        var node = Node.get(root, path);\n        if (!Text.isText(node)) {\n            throw new Error(\"Cannot get the leaf node at path [\".concat(path, \"] because it refers to a non-leaf node: \").concat(Scrubber.stringify(node)));\n        }\n        return node;\n    },\n    /**\r\n   * Return a generator of the in a branch of the tree, from a specific path.\r\n   *\r\n   * By default the order is top-down, from highest to lowest node in the tree,\r\n   * but you can pass the `reverse: true` option to go bottom-up.\r\n   */ levels: function* levels(root, path) {\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        var _iterator5 = _createForOfIteratorHelper$4(Path.levels(path, options)), _step5;\n        try {\n            for(_iterator5.s(); !(_step5 = _iterator5.n()).done;){\n                var p = _step5.value;\n                var n = Node.get(root, p);\n                yield [\n                    n,\n                    p\n                ];\n            }\n        } catch (err) {\n            _iterator5.e(err);\n        } finally{\n            _iterator5.f();\n        }\n    },\n    /**\r\n   * Check if a node matches a set of props.\r\n   */ matches: function matches(node, props) {\n        return Element.isElement(node) && Element.isElementProps(props) && Element.matches(node, props) || Text.isText(node) && Text.isTextProps(props) && Text.matches(node, props);\n    },\n    /**\r\n   * Return a generator of all the node entries of a root node. Each entry is\r\n   * returned as a `[Node, Path]` tuple, with the path referring to the node's\r\n   * position inside the root node.\r\n   */ nodes: function* nodes(root) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        var pass = options.pass, _options$reverse2 = options.reverse, reverse = _options$reverse2 === void 0 ? false : _options$reverse2;\n        var _options$from = options.from, from = _options$from === void 0 ? [] : _options$from, to = options.to;\n        var visited = new Set();\n        var p = [];\n        var n = root;\n        while(true){\n            if (to && (reverse ? Path.isBefore(p, to) : Path.isAfter(p, to))) {\n                break;\n            }\n            if (!visited.has(n)) {\n                yield [\n                    n,\n                    p\n                ];\n            } // If we're allowed to go downward and we haven't descended yet, do.\n            if (!visited.has(n) && !Text.isText(n) && n.children.length !== 0 && (pass == null || pass([\n                n,\n                p\n            ]) === false)) {\n                visited.add(n);\n                var nextIndex = reverse ? n.children.length - 1 : 0;\n                if (Path.isAncestor(p, from)) {\n                    nextIndex = from[p.length];\n                }\n                p = p.concat(nextIndex);\n                n = Node.get(root, p);\n                continue;\n            } // If we're at the root and we can't go down, we're done.\n            if (p.length === 0) {\n                break;\n            } // If we're going forward...\n            if (!reverse) {\n                var newPath = Path.next(p);\n                if (Node.has(root, newPath)) {\n                    p = newPath;\n                    n = Node.get(root, p);\n                    continue;\n                }\n            } // If we're going backward...\n            if (reverse && p[p.length - 1] !== 0) {\n                var _newPath = Path.previous(p);\n                p = _newPath;\n                n = Node.get(root, p);\n                continue;\n            } // Otherwise we're going upward...\n            p = Path.parent(p);\n            n = Node.get(root, p);\n            visited.add(n);\n        }\n    },\n    /**\r\n   * Get the parent of a node at a specific path.\r\n   */ parent: function parent(root, path) {\n        var parentPath = Path.parent(path);\n        var p = Node.get(root, parentPath);\n        if (Text.isText(p)) {\n            throw new Error(\"Cannot get the parent of path [\".concat(path, \"] because it does not exist in the root.\"));\n        }\n        return p;\n    },\n    /**\r\n   * Get the concatenated text string of a node's content.\r\n   *\r\n   * Note that this will not include spaces or line breaks between block nodes.\r\n   * It is not a user-facing string, but a string for performing offset-related\r\n   * computations for a node.\r\n   */ string: function string(node) {\n        if (Text.isText(node)) {\n            return node.text;\n        } else {\n            return node.children.map(Node.string).join(\"\");\n        }\n    },\n    /**\r\n   * Return a generator of all leaf text nodes in a root node.\r\n   */ texts: function* texts(root) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        var _iterator6 = _createForOfIteratorHelper$4(Node.nodes(root, options)), _step6;\n        try {\n            for(_iterator6.s(); !(_step6 = _iterator6.n()).done;){\n                var _step6$value = _slicedToArray(_step6.value, 2), node = _step6$value[0], path = _step6$value[1];\n                if (Text.isText(node)) {\n                    yield [\n                        node,\n                        path\n                    ];\n                }\n            }\n        } catch (err) {\n            _iterator6.e(err);\n        } finally{\n            _iterator6.f();\n        }\n    }\n};\nfunction ownKeys$7(object, enumerableOnly) {\n    var keys = Object.keys(object);\n    if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        if (enumerableOnly) {\n            symbols = symbols.filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n            });\n        }\n        keys.push.apply(keys, symbols);\n    }\n    return keys;\n}\nfunction _objectSpread$7(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = arguments[i] != null ? arguments[i] : {};\n        if (i % 2) {\n            ownKeys$7(Object(source), true).forEach(function(key) {\n                _defineProperty(target, key, source[key]);\n            });\n        } else if (Object.getOwnPropertyDescriptors) {\n            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n        } else {\n            ownKeys$7(Object(source)).forEach(function(key) {\n                Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n            });\n        }\n    }\n    return target;\n}\nvar Operation = {\n    /**\r\n   * Check if a value is a `NodeOperation` object.\r\n   */ isNodeOperation: function isNodeOperation(value) {\n        return Operation.isOperation(value) && value.type.endsWith(\"_node\");\n    },\n    /**\r\n   * Check if a value is an `Operation` object.\r\n   */ isOperation: function isOperation(value) {\n        if (!isPlainObject.isPlainObject(value)) {\n            return false;\n        }\n        switch(value.type){\n            case \"insert_node\":\n                return Path.isPath(value.path) && Node.isNode(value.node);\n            case \"insert_text\":\n                return typeof value.offset === \"number\" && typeof value.text === \"string\" && Path.isPath(value.path);\n            case \"merge_node\":\n                return typeof value.position === \"number\" && Path.isPath(value.path) && isPlainObject.isPlainObject(value.properties);\n            case \"move_node\":\n                return Path.isPath(value.path) && Path.isPath(value.newPath);\n            case \"remove_node\":\n                return Path.isPath(value.path) && Node.isNode(value.node);\n            case \"remove_text\":\n                return typeof value.offset === \"number\" && typeof value.text === \"string\" && Path.isPath(value.path);\n            case \"set_node\":\n                return Path.isPath(value.path) && isPlainObject.isPlainObject(value.properties) && isPlainObject.isPlainObject(value.newProperties);\n            case \"set_selection\":\n                return value.properties === null && Range.isRange(value.newProperties) || value.newProperties === null && Range.isRange(value.properties) || isPlainObject.isPlainObject(value.properties) && isPlainObject.isPlainObject(value.newProperties);\n            case \"split_node\":\n                return Path.isPath(value.path) && typeof value.position === \"number\" && isPlainObject.isPlainObject(value.properties);\n            default:\n                return false;\n        }\n    },\n    /**\r\n   * Check if a value is a list of `Operation` objects.\r\n   */ isOperationList: function isOperationList(value) {\n        return Array.isArray(value) && value.every(function(val) {\n            return Operation.isOperation(val);\n        });\n    },\n    /**\r\n   * Check if a value is a `SelectionOperation` object.\r\n   */ isSelectionOperation: function isSelectionOperation(value) {\n        return Operation.isOperation(value) && value.type.endsWith(\"_selection\");\n    },\n    /**\r\n   * Check if a value is a `TextOperation` object.\r\n   */ isTextOperation: function isTextOperation(value) {\n        return Operation.isOperation(value) && value.type.endsWith(\"_text\");\n    },\n    /**\r\n   * Invert an operation, returning a new operation that will exactly undo the\r\n   * original when applied.\r\n   */ inverse: function inverse(op) {\n        switch(op.type){\n            case \"insert_node\":\n                {\n                    return _objectSpread$7(_objectSpread$7({}, op), {}, {\n                        type: \"remove_node\"\n                    });\n                }\n            case \"insert_text\":\n                {\n                    return _objectSpread$7(_objectSpread$7({}, op), {}, {\n                        type: \"remove_text\"\n                    });\n                }\n            case \"merge_node\":\n                {\n                    return _objectSpread$7(_objectSpread$7({}, op), {}, {\n                        type: \"split_node\",\n                        path: Path.previous(op.path)\n                    });\n                }\n            case \"move_node\":\n                {\n                    var newPath = op.newPath, path = op.path; // PERF: in this case the move operation is a no-op anyways.\n                    if (Path.equals(newPath, path)) {\n                        return op;\n                    } // If the move happens completely within a single parent the path and\n                    // newPath are stable with respect to each other.\n                    if (Path.isSibling(path, newPath)) {\n                        return _objectSpread$7(_objectSpread$7({}, op), {}, {\n                            path: newPath,\n                            newPath: path\n                        });\n                    } // If the move does not happen within a single parent it is possible\n                    // for the move to impact the true path to the location where the node\n                    // was removed from and where it was inserted. We have to adjust for this\n                    // and find the original path. We can accomplish this (only in non-sibling)\n                    // moves by looking at the impact of the move operation on the node\n                    // after the original move path.\n                    var inversePath = Path.transform(path, op);\n                    var inverseNewPath = Path.transform(Path.next(path), op);\n                    return _objectSpread$7(_objectSpread$7({}, op), {}, {\n                        path: inversePath,\n                        newPath: inverseNewPath\n                    });\n                }\n            case \"remove_node\":\n                {\n                    return _objectSpread$7(_objectSpread$7({}, op), {}, {\n                        type: \"insert_node\"\n                    });\n                }\n            case \"remove_text\":\n                {\n                    return _objectSpread$7(_objectSpread$7({}, op), {}, {\n                        type: \"insert_text\"\n                    });\n                }\n            case \"set_node\":\n                {\n                    var properties = op.properties, newProperties = op.newProperties;\n                    return _objectSpread$7(_objectSpread$7({}, op), {}, {\n                        properties: newProperties,\n                        newProperties: properties\n                    });\n                }\n            case \"set_selection\":\n                {\n                    var _properties = op.properties, _newProperties = op.newProperties;\n                    if (_properties == null) {\n                        return _objectSpread$7(_objectSpread$7({}, op), {}, {\n                            properties: _newProperties,\n                            newProperties: null\n                        });\n                    } else if (_newProperties == null) {\n                        return _objectSpread$7(_objectSpread$7({}, op), {}, {\n                            properties: null,\n                            newProperties: _properties\n                        });\n                    } else {\n                        return _objectSpread$7(_objectSpread$7({}, op), {}, {\n                            properties: _newProperties,\n                            newProperties: _properties\n                        });\n                    }\n                }\n            case \"split_node\":\n                {\n                    return _objectSpread$7(_objectSpread$7({}, op), {}, {\n                        type: \"merge_node\",\n                        path: Path.next(op.path)\n                    });\n                }\n        }\n    }\n};\n// eslint-disable-next-line no-redeclare\nvar Path = {\n    /**\r\n   * Get a list of ancestor paths for a given path.\r\n   *\r\n   * The paths are sorted from shallowest to deepest ancestor. However, if the\r\n   * `reverse: true` option is passed, they are reversed.\r\n   */ ancestors: function ancestors(path) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        var _options$reverse = options.reverse, reverse = _options$reverse === void 0 ? false : _options$reverse;\n        var paths = Path.levels(path, options);\n        if (reverse) {\n            paths = paths.slice(1);\n        } else {\n            paths = paths.slice(0, -1);\n        }\n        return paths;\n    },\n    /**\r\n   * Get the common ancestor path of two paths.\r\n   */ common: function common(path, another) {\n        var common = [];\n        for(var i = 0; i < path.length && i < another.length; i++){\n            var av = path[i];\n            var bv = another[i];\n            if (av !== bv) {\n                break;\n            }\n            common.push(av);\n        }\n        return common;\n    },\n    /**\r\n   * Compare a path to another, returning an integer indicating whether the path\r\n   * was before, at, or after the other.\r\n   *\r\n   * Note: Two paths of unequal length can still receive a `0` result if one is\r\n   * directly above or below the other. If you want exact matching, use\r\n   * [[Path.equals]] instead.\r\n   */ compare: function compare(path, another) {\n        var min = Math.min(path.length, another.length);\n        for(var i = 0; i < min; i++){\n            if (path[i] < another[i]) return -1;\n            if (path[i] > another[i]) return 1;\n        }\n        return 0;\n    },\n    /**\r\n   * Check if a path ends after one of the indexes in another.\r\n   */ endsAfter: function endsAfter(path, another) {\n        var i = path.length - 1;\n        var as = path.slice(0, i);\n        var bs = another.slice(0, i);\n        var av = path[i];\n        var bv = another[i];\n        return Path.equals(as, bs) && av > bv;\n    },\n    /**\r\n   * Check if a path ends at one of the indexes in another.\r\n   */ endsAt: function endsAt(path, another) {\n        var i = path.length;\n        var as = path.slice(0, i);\n        var bs = another.slice(0, i);\n        return Path.equals(as, bs);\n    },\n    /**\r\n   * Check if a path ends before one of the indexes in another.\r\n   */ endsBefore: function endsBefore(path, another) {\n        var i = path.length - 1;\n        var as = path.slice(0, i);\n        var bs = another.slice(0, i);\n        var av = path[i];\n        var bv = another[i];\n        return Path.equals(as, bs) && av < bv;\n    },\n    /**\r\n   * Check if a path is exactly equal to another.\r\n   */ equals: function equals(path, another) {\n        return path.length === another.length && path.every(function(n, i) {\n            return n === another[i];\n        });\n    },\n    /**\r\n   * Check if the path of previous sibling node exists\r\n   */ hasPrevious: function hasPrevious(path) {\n        return path[path.length - 1] > 0;\n    },\n    /**\r\n   * Check if a path is after another.\r\n   */ isAfter: function isAfter(path, another) {\n        return Path.compare(path, another) === 1;\n    },\n    /**\r\n   * Check if a path is an ancestor of another.\r\n   */ isAncestor: function isAncestor(path, another) {\n        return path.length < another.length && Path.compare(path, another) === 0;\n    },\n    /**\r\n   * Check if a path is before another.\r\n   */ isBefore: function isBefore(path, another) {\n        return Path.compare(path, another) === -1;\n    },\n    /**\r\n   * Check if a path is a child of another.\r\n   */ isChild: function isChild(path, another) {\n        return path.length === another.length + 1 && Path.compare(path, another) === 0;\n    },\n    /**\r\n   * Check if a path is equal to or an ancestor of another.\r\n   */ isCommon: function isCommon(path, another) {\n        return path.length <= another.length && Path.compare(path, another) === 0;\n    },\n    /**\r\n   * Check if a path is a descendant of another.\r\n   */ isDescendant: function isDescendant(path, another) {\n        return path.length > another.length && Path.compare(path, another) === 0;\n    },\n    /**\r\n   * Check if a path is the parent of another.\r\n   */ isParent: function isParent(path, another) {\n        return path.length + 1 === another.length && Path.compare(path, another) === 0;\n    },\n    /**\r\n   * Check is a value implements the `Path` interface.\r\n   */ isPath: function isPath(value) {\n        return Array.isArray(value) && (value.length === 0 || typeof value[0] === \"number\");\n    },\n    /**\r\n   * Check if a path is a sibling of another.\r\n   */ isSibling: function isSibling(path, another) {\n        if (path.length !== another.length) {\n            return false;\n        }\n        var as = path.slice(0, -1);\n        var bs = another.slice(0, -1);\n        var al = path[path.length - 1];\n        var bl = another[another.length - 1];\n        return al !== bl && Path.equals(as, bs);\n    },\n    /**\r\n   * Get a list of paths at every level down to a path. Note: this is the same\r\n   * as `Path.ancestors`, but including the path itself.\r\n   *\r\n   * The paths are sorted from shallowest to deepest. However, if the `reverse:\r\n   * true` option is passed, they are reversed.\r\n   */ levels: function levels(path) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        var _options$reverse2 = options.reverse, reverse = _options$reverse2 === void 0 ? false : _options$reverse2;\n        var list = [];\n        for(var i = 0; i <= path.length; i++){\n            list.push(path.slice(0, i));\n        }\n        if (reverse) {\n            list.reverse();\n        }\n        return list;\n    },\n    /**\r\n   * Given a path, get the path to the next sibling node.\r\n   */ next: function next(path) {\n        if (path.length === 0) {\n            throw new Error(\"Cannot get the next path of a root path [\".concat(path, \"], because it has no next index.\"));\n        }\n        var last = path[path.length - 1];\n        return path.slice(0, -1).concat(last + 1);\n    },\n    /**\r\n   * Returns whether this operation can affect paths or not. Used as an\r\n   * optimization when updating dirty paths during normalization\r\n   *\r\n   * NOTE: This *must* be kept in sync with the implementation of 'transform'\r\n   * below\r\n   */ operationCanTransformPath: function operationCanTransformPath(operation) {\n        switch(operation.type){\n            case \"insert_node\":\n            case \"remove_node\":\n            case \"merge_node\":\n            case \"split_node\":\n            case \"move_node\":\n                return true;\n            default:\n                return false;\n        }\n    },\n    /**\r\n   * Given a path, return a new path referring to the parent node above it.\r\n   */ parent: function parent(path) {\n        if (path.length === 0) {\n            throw new Error(\"Cannot get the parent path of the root path [\".concat(path, \"].\"));\n        }\n        return path.slice(0, -1);\n    },\n    /**\r\n   * Given a path, get the path to the previous sibling node.\r\n   */ previous: function previous(path) {\n        if (path.length === 0) {\n            throw new Error(\"Cannot get the previous path of a root path [\".concat(path, \"], because it has no previous index.\"));\n        }\n        var last = path[path.length - 1];\n        if (last <= 0) {\n            throw new Error(\"Cannot get the previous path of a first child path [\".concat(path, \"] because it would result in a negative index.\"));\n        }\n        return path.slice(0, -1).concat(last - 1);\n    },\n    /**\r\n   * Get a path relative to an ancestor.\r\n   */ relative: function relative(path, ancestor) {\n        if (!Path.isAncestor(ancestor, path) && !Path.equals(path, ancestor)) {\n            throw new Error(\"Cannot get the relative path of [\".concat(path, \"] inside ancestor [\").concat(ancestor, \"], because it is not above or equal to the path.\"));\n        }\n        return path.slice(ancestor.length);\n    },\n    /**\r\n   * Transform a path by an operation.\r\n   */ transform: function transform(path, operation) {\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        if (!path) return null; // PERF: use destructing instead of immer\n        var p = _toConsumableArray(path);\n        var _options$affinity = options.affinity, affinity = _options$affinity === void 0 ? \"forward\" : _options$affinity; // PERF: Exit early if the operation is guaranteed not to have an effect.\n        if (path.length === 0) {\n            return p;\n        }\n        switch(operation.type){\n            case \"insert_node\":\n                {\n                    var op = operation.path;\n                    if (Path.equals(op, p) || Path.endsBefore(op, p) || Path.isAncestor(op, p)) {\n                        p[op.length - 1] += 1;\n                    }\n                    break;\n                }\n            case \"remove_node\":\n                {\n                    var _op = operation.path;\n                    if (Path.equals(_op, p) || Path.isAncestor(_op, p)) {\n                        return null;\n                    } else if (Path.endsBefore(_op, p)) {\n                        p[_op.length - 1] -= 1;\n                    }\n                    break;\n                }\n            case \"merge_node\":\n                {\n                    var _op2 = operation.path, position = operation.position;\n                    if (Path.equals(_op2, p) || Path.endsBefore(_op2, p)) {\n                        p[_op2.length - 1] -= 1;\n                    } else if (Path.isAncestor(_op2, p)) {\n                        p[_op2.length - 1] -= 1;\n                        p[_op2.length] += position;\n                    }\n                    break;\n                }\n            case \"split_node\":\n                {\n                    var _op3 = operation.path, _position = operation.position;\n                    if (Path.equals(_op3, p)) {\n                        if (affinity === \"forward\") {\n                            p[p.length - 1] += 1;\n                        } else if (affinity === \"backward\") ;\n                        else {\n                            return null;\n                        }\n                    } else if (Path.endsBefore(_op3, p)) {\n                        p[_op3.length - 1] += 1;\n                    } else if (Path.isAncestor(_op3, p) && path[_op3.length] >= _position) {\n                        p[_op3.length - 1] += 1;\n                        p[_op3.length] -= _position;\n                    }\n                    break;\n                }\n            case \"move_node\":\n                {\n                    var _op4 = operation.path, onp = operation.newPath; // If the old and new path are the same, it's a no-op.\n                    if (Path.equals(_op4, onp)) {\n                        return p;\n                    }\n                    if (Path.isAncestor(_op4, p) || Path.equals(_op4, p)) {\n                        var copy = onp.slice();\n                        if (Path.endsBefore(_op4, onp) && _op4.length < onp.length) {\n                            copy[_op4.length - 1] -= 1;\n                        }\n                        return copy.concat(p.slice(_op4.length));\n                    } else if (Path.isSibling(_op4, onp) && (Path.isAncestor(onp, p) || Path.equals(onp, p))) {\n                        if (Path.endsBefore(_op4, p)) {\n                            p[_op4.length - 1] -= 1;\n                        } else {\n                            p[_op4.length - 1] += 1;\n                        }\n                    } else if (Path.endsBefore(onp, p) || Path.equals(onp, p) || Path.isAncestor(onp, p)) {\n                        if (Path.endsBefore(_op4, p)) {\n                            p[_op4.length - 1] -= 1;\n                        }\n                        p[onp.length - 1] += 1;\n                    } else if (Path.endsBefore(_op4, p)) {\n                        if (Path.equals(onp, p)) {\n                            p[onp.length - 1] += 1;\n                        }\n                        p[_op4.length - 1] -= 1;\n                    }\n                    break;\n                }\n        }\n        return p;\n    }\n};\nvar PathRef = {\n    /**\r\n   * Transform the path ref's current value by an operation.\r\n   */ transform: function transform(ref, op) {\n        var current = ref.current, affinity = ref.affinity;\n        if (current == null) {\n            return;\n        }\n        var path = Path.transform(current, op, {\n            affinity: affinity\n        });\n        ref.current = path;\n        if (path == null) {\n            ref.unref();\n        }\n    }\n};\nfunction ownKeys$6(object, enumerableOnly) {\n    var keys = Object.keys(object);\n    if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        if (enumerableOnly) {\n            symbols = symbols.filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n            });\n        }\n        keys.push.apply(keys, symbols);\n    }\n    return keys;\n}\nfunction _objectSpread$6(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = arguments[i] != null ? arguments[i] : {};\n        if (i % 2) {\n            ownKeys$6(Object(source), true).forEach(function(key) {\n                _defineProperty(target, key, source[key]);\n            });\n        } else if (Object.getOwnPropertyDescriptors) {\n            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n        } else {\n            ownKeys$6(Object(source)).forEach(function(key) {\n                Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n            });\n        }\n    }\n    return target;\n}\nvar Point = {\n    /**\r\n   * Compare a point to another, returning an integer indicating whether the\r\n   * point was before, at, or after the other.\r\n   */ compare: function compare(point, another) {\n        var result = Path.compare(point.path, another.path);\n        if (result === 0) {\n            if (point.offset < another.offset) return -1;\n            if (point.offset > another.offset) return 1;\n            return 0;\n        }\n        return result;\n    },\n    /**\r\n   * Check if a point is after another.\r\n   */ isAfter: function isAfter(point, another) {\n        return Point.compare(point, another) === 1;\n    },\n    /**\r\n   * Check if a point is before another.\r\n   */ isBefore: function isBefore(point, another) {\n        return Point.compare(point, another) === -1;\n    },\n    /**\r\n   * Check if a point is exactly equal to another.\r\n   */ equals: function equals(point, another) {\n        // PERF: ensure the offsets are equal first since they are cheaper to check.\n        return point.offset === another.offset && Path.equals(point.path, another.path);\n    },\n    /**\r\n   * Check if a value implements the `Point` interface.\r\n   */ isPoint: function isPoint(value) {\n        return isPlainObject.isPlainObject(value) && typeof value.offset === \"number\" && Path.isPath(value.path);\n    },\n    /**\r\n   * Transform a point by an operation.\r\n   */ transform: function transform(point, op) {\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        return immer.produce(point, function(p) {\n            if (p === null) {\n                return null;\n            }\n            var _options$affinity = options.affinity, affinity = _options$affinity === void 0 ? \"forward\" : _options$affinity;\n            var path = p.path, offset = p.offset;\n            switch(op.type){\n                case \"insert_node\":\n                case \"move_node\":\n                    {\n                        p.path = Path.transform(path, op, options);\n                        break;\n                    }\n                case \"insert_text\":\n                    {\n                        if (Path.equals(op.path, path) && (op.offset < offset || op.offset === offset && affinity === \"forward\")) {\n                            p.offset += op.text.length;\n                        }\n                        break;\n                    }\n                case \"merge_node\":\n                    {\n                        if (Path.equals(op.path, path)) {\n                            p.offset += op.position;\n                        }\n                        p.path = Path.transform(path, op, options);\n                        break;\n                    }\n                case \"remove_text\":\n                    {\n                        if (Path.equals(op.path, path) && op.offset <= offset) {\n                            p.offset -= Math.min(offset - op.offset, op.text.length);\n                        }\n                        break;\n                    }\n                case \"remove_node\":\n                    {\n                        if (Path.equals(op.path, path) || Path.isAncestor(op.path, path)) {\n                            return null;\n                        }\n                        p.path = Path.transform(path, op, options);\n                        break;\n                    }\n                case \"split_node\":\n                    {\n                        if (Path.equals(op.path, path)) {\n                            if (op.position === offset && affinity == null) {\n                                return null;\n                            } else if (op.position < offset || op.position === offset && affinity === \"forward\") {\n                                p.offset -= op.position;\n                                p.path = Path.transform(path, op, _objectSpread$6(_objectSpread$6({}, options), {}, {\n                                    affinity: \"forward\"\n                                }));\n                            }\n                        } else {\n                            p.path = Path.transform(path, op, options);\n                        }\n                        break;\n                    }\n            }\n        });\n    }\n};\nvar PointRef = {\n    /**\r\n   * Transform the point ref's current value by an operation.\r\n   */ transform: function transform(ref, op) {\n        var current = ref.current, affinity = ref.affinity;\n        if (current == null) {\n            return;\n        }\n        var point = Point.transform(current, op, {\n            affinity: affinity\n        });\n        ref.current = point;\n        if (point == null) {\n            ref.unref();\n        }\n    }\n};\nvar _excluded$2 = [\n    \"anchor\",\n    \"focus\"\n];\nfunction ownKeys$5(object, enumerableOnly) {\n    var keys = Object.keys(object);\n    if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        if (enumerableOnly) {\n            symbols = symbols.filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n            });\n        }\n        keys.push.apply(keys, symbols);\n    }\n    return keys;\n}\nfunction _objectSpread$5(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = arguments[i] != null ? arguments[i] : {};\n        if (i % 2) {\n            ownKeys$5(Object(source), true).forEach(function(key) {\n                _defineProperty(target, key, source[key]);\n            });\n        } else if (Object.getOwnPropertyDescriptors) {\n            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n        } else {\n            ownKeys$5(Object(source)).forEach(function(key) {\n                Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n            });\n        }\n    }\n    return target;\n}\nvar Range = {\n    /**\r\n   * Get the start and end points of a range, in the order in which they appear\r\n   * in the document.\r\n   */ edges: function edges(range) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        var _options$reverse = options.reverse, reverse = _options$reverse === void 0 ? false : _options$reverse;\n        var anchor = range.anchor, focus = range.focus;\n        return Range.isBackward(range) === reverse ? [\n            anchor,\n            focus\n        ] : [\n            focus,\n            anchor\n        ];\n    },\n    /**\r\n   * Get the end point of a range.\r\n   */ end: function end(range) {\n        var _Range$edges = Range.edges(range), _Range$edges2 = _slicedToArray(_Range$edges, 2), end = _Range$edges2[1];\n        return end;\n    },\n    /**\r\n   * Check if a range is exactly equal to another.\r\n   */ equals: function equals(range, another) {\n        return Point.equals(range.anchor, another.anchor) && Point.equals(range.focus, another.focus);\n    },\n    /**\r\n   * Check if a range includes a path, a point or part of another range.\r\n   */ includes: function includes(range, target) {\n        if (Range.isRange(target)) {\n            if (Range.includes(range, target.anchor) || Range.includes(range, target.focus)) {\n                return true;\n            }\n            var _Range$edges3 = Range.edges(range), _Range$edges4 = _slicedToArray(_Range$edges3, 2), rs = _Range$edges4[0], re = _Range$edges4[1];\n            var _Range$edges5 = Range.edges(target), _Range$edges6 = _slicedToArray(_Range$edges5, 2), ts = _Range$edges6[0], te = _Range$edges6[1];\n            return Point.isBefore(rs, ts) && Point.isAfter(re, te);\n        }\n        var _Range$edges7 = Range.edges(range), _Range$edges8 = _slicedToArray(_Range$edges7, 2), start = _Range$edges8[0], end = _Range$edges8[1];\n        var isAfterStart = false;\n        var isBeforeEnd = false;\n        if (Point.isPoint(target)) {\n            isAfterStart = Point.compare(target, start) >= 0;\n            isBeforeEnd = Point.compare(target, end) <= 0;\n        } else {\n            isAfterStart = Path.compare(target, start.path) >= 0;\n            isBeforeEnd = Path.compare(target, end.path) <= 0;\n        }\n        return isAfterStart && isBeforeEnd;\n    },\n    /**\r\n   * Get the intersection of a range with another.\r\n   */ intersection: function intersection(range, another) {\n        range.anchor;\n        range.focus;\n        var rest = _objectWithoutProperties(range, _excluded$2);\n        var _Range$edges9 = Range.edges(range), _Range$edges10 = _slicedToArray(_Range$edges9, 2), s1 = _Range$edges10[0], e1 = _Range$edges10[1];\n        var _Range$edges11 = Range.edges(another), _Range$edges12 = _slicedToArray(_Range$edges11, 2), s2 = _Range$edges12[0], e2 = _Range$edges12[1];\n        var start = Point.isBefore(s1, s2) ? s2 : s1;\n        var end = Point.isBefore(e1, e2) ? e1 : e2;\n        if (Point.isBefore(end, start)) {\n            return null;\n        } else {\n            return _objectSpread$5({\n                anchor: start,\n                focus: end\n            }, rest);\n        }\n    },\n    /**\r\n   * Check if a range is backward, meaning that its anchor point appears in the\r\n   * document _after_ its focus point.\r\n   */ isBackward: function isBackward(range) {\n        var anchor = range.anchor, focus = range.focus;\n        return Point.isAfter(anchor, focus);\n    },\n    /**\r\n   * Check if a range is collapsed, meaning that both its anchor and focus\r\n   * points refer to the exact same position in the document.\r\n   */ isCollapsed: function isCollapsed(range) {\n        var anchor = range.anchor, focus = range.focus;\n        return Point.equals(anchor, focus);\n    },\n    /**\r\n   * Check if a range is expanded.\r\n   *\r\n   * This is the opposite of [[Range.isCollapsed]] and is provided for legibility.\r\n   */ isExpanded: function isExpanded(range) {\n        return !Range.isCollapsed(range);\n    },\n    /**\r\n   * Check if a range is forward.\r\n   *\r\n   * This is the opposite of [[Range.isBackward]] and is provided for legibility.\r\n   */ isForward: function isForward(range) {\n        return !Range.isBackward(range);\n    },\n    /**\r\n   * Check if a value implements the [[Range]] interface.\r\n   */ isRange: function isRange(value) {\n        return isPlainObject.isPlainObject(value) && Point.isPoint(value.anchor) && Point.isPoint(value.focus);\n    },\n    /**\r\n   * Iterate through all of the point entries in a range.\r\n   */ points: function* points(range) {\n        yield [\n            range.anchor,\n            \"anchor\"\n        ];\n        yield [\n            range.focus,\n            \"focus\"\n        ];\n    },\n    /**\r\n   * Get the start point of a range.\r\n   */ start: function start(range) {\n        var _Range$edges13 = Range.edges(range), _Range$edges14 = _slicedToArray(_Range$edges13, 1), start = _Range$edges14[0];\n        return start;\n    },\n    /**\r\n   * Transform a range by an operation.\r\n   */ transform: function transform(range, op) {\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        return immer.produce(range, function(r) {\n            if (r === null) {\n                return null;\n            }\n            var _options$affinity = options.affinity, affinity = _options$affinity === void 0 ? \"inward\" : _options$affinity;\n            var affinityAnchor;\n            var affinityFocus;\n            if (affinity === \"inward\") {\n                // If the range is collapsed, make sure to use the same affinity to\n                // avoid the two points passing each other and expanding in the opposite\n                // direction\n                var isCollapsed = Range.isCollapsed(r);\n                if (Range.isForward(r)) {\n                    affinityAnchor = \"forward\";\n                    affinityFocus = isCollapsed ? affinityAnchor : \"backward\";\n                } else {\n                    affinityAnchor = \"backward\";\n                    affinityFocus = isCollapsed ? affinityAnchor : \"forward\";\n                }\n            } else if (affinity === \"outward\") {\n                if (Range.isForward(r)) {\n                    affinityAnchor = \"backward\";\n                    affinityFocus = \"forward\";\n                } else {\n                    affinityAnchor = \"forward\";\n                    affinityFocus = \"backward\";\n                }\n            } else {\n                affinityAnchor = affinity;\n                affinityFocus = affinity;\n            }\n            var anchor = Point.transform(r.anchor, op, {\n                affinity: affinityAnchor\n            });\n            var focus = Point.transform(r.focus, op, {\n                affinity: affinityFocus\n            });\n            if (!anchor || !focus) {\n                return null;\n            }\n            r.anchor = anchor;\n            r.focus = focus;\n        });\n    }\n};\nvar RangeRef = {\n    /**\r\n   * Transform the range ref's current value by an operation.\r\n   */ transform: function transform(ref, op) {\n        var current = ref.current, affinity = ref.affinity;\n        if (current == null) {\n            return;\n        }\n        var path = Range.transform(current, op, {\n            affinity: affinity\n        });\n        ref.current = path;\n        if (path == null) {\n            ref.unref();\n        }\n    }\n};\nvar _scrubber = undefined;\n/**\r\n * This interface implements a stringify() function, which is used by Slate\r\n * internally when generating exceptions containing end user data. Developers\r\n * using Slate may call Scrubber.setScrubber() to alter the behavior of this\r\n * stringify() function.\r\n *\r\n * For example, to prevent the cleartext logging of 'text' fields within Nodes:\r\n *\r\n *    import { Scrubber } from 'slate';\r\n *    Scrubber.setScrubber((key, val) => {\r\n *      if (key === 'text') return '...scrubbed...'\r\n *      return val\r\n *    });\r\n *\r\n */ // eslint-disable-next-line no-redeclare\nvar Scrubber = {\n    setScrubber: function setScrubber(scrubber) {\n        _scrubber = scrubber;\n    },\n    stringify: function stringify(value) {\n        return JSON.stringify(value, _scrubber);\n    }\n};\n/*\r\n  Custom deep equal comparison for Slate nodes.\r\n\n  We don't need general purpose deep equality;\r\n  Slate only supports plain values, Arrays, and nested objects.\r\n  Complex values nested inside Arrays are not supported.\r\n\n  Slate objects are designed to be serialised, so\r\n  missing keys are deliberately normalised to undefined.\r\n */ var isDeepEqual = function isDeepEqual(node, another) {\n    for(var key in node){\n        var a = node[key];\n        var b = another[key];\n        if (isPlainObject.isPlainObject(a) && isPlainObject.isPlainObject(b)) {\n            if (!isDeepEqual(a, b)) return false;\n        } else if (Array.isArray(a) && Array.isArray(b)) {\n            if (a.length !== b.length) return false;\n            for(var i = 0; i < a.length; i++){\n                if (a[i] !== b[i]) return false;\n            }\n        } else if (a !== b) {\n            return false;\n        }\n    }\n    /*\r\n    Deep object equality is only necessary in one direction; in the reverse direction\r\n    we are only looking for keys that are missing.\r\n    As above, undefined keys are normalised to missing.\r\n  */ for(var _key in another){\n        if (node[_key] === undefined && another[_key] !== undefined) {\n            return false;\n        }\n    }\n    return true;\n};\nvar _excluded$1 = [\n    \"text\"\n], _excluded2$1 = [\n    \"anchor\",\n    \"focus\"\n];\nfunction _createForOfIteratorHelper$3(o, allowArrayLike) {\n    var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n    if (!it) {\n        if (Array.isArray(o) || (it = _unsupportedIterableToArray$3(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n            if (it) o = it;\n            var i = 0;\n            var F = function F() {};\n            return {\n                s: F,\n                n: function n() {\n                    if (i >= o.length) return {\n                        done: true\n                    };\n                    return {\n                        done: false,\n                        value: o[i++]\n                    };\n                },\n                e: function e(_e) {\n                    throw _e;\n                },\n                f: F\n            };\n        }\n        throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n    }\n    var normalCompletion = true, didErr = false, err;\n    return {\n        s: function s() {\n            it = it.call(o);\n        },\n        n: function n() {\n            var step = it.next();\n            normalCompletion = step.done;\n            return step;\n        },\n        e: function e(_e2) {\n            didErr = true;\n            err = _e2;\n        },\n        f: function f() {\n            try {\n                if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n            } finally{\n                if (didErr) throw err;\n            }\n        }\n    };\n}\nfunction _unsupportedIterableToArray$3(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray$3(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(o);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$3(o, minLen);\n}\nfunction _arrayLikeToArray$3(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++){\n        arr2[i] = arr[i];\n    }\n    return arr2;\n}\nfunction ownKeys$4(object, enumerableOnly) {\n    var keys = Object.keys(object);\n    if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        if (enumerableOnly) {\n            symbols = symbols.filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n            });\n        }\n        keys.push.apply(keys, symbols);\n    }\n    return keys;\n}\nfunction _objectSpread$4(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = arguments[i] != null ? arguments[i] : {};\n        if (i % 2) {\n            ownKeys$4(Object(source), true).forEach(function(key) {\n                _defineProperty(target, key, source[key]);\n            });\n        } else if (Object.getOwnPropertyDescriptors) {\n            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n        } else {\n            ownKeys$4(Object(source)).forEach(function(key) {\n                Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n            });\n        }\n    }\n    return target;\n}\nvar Text = {\n    /**\r\n   * Check if two text nodes are equal.\r\n   *\r\n   * When loose is set, the text is not compared. This is\r\n   * used to check whether sibling text nodes can be merged.\r\n   */ equals: function equals(text, another) {\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        var _options$loose = options.loose, loose = _options$loose === void 0 ? false : _options$loose;\n        function omitText(obj) {\n            obj.text;\n            var rest = _objectWithoutProperties(obj, _excluded$1);\n            return rest;\n        }\n        return isDeepEqual(loose ? omitText(text) : text, loose ? omitText(another) : another);\n    },\n    /**\r\n   * Check if a value implements the `Text` interface.\r\n   */ isText: function isText(value) {\n        return isPlainObject.isPlainObject(value) && typeof value.text === \"string\";\n    },\n    /**\r\n   * Check if a value is a list of `Text` objects.\r\n   */ isTextList: function isTextList(value) {\n        return Array.isArray(value) && value.every(function(val) {\n            return Text.isText(val);\n        });\n    },\n    /**\r\n   * Check if some props are a partial of Text.\r\n   */ isTextProps: function isTextProps(props) {\n        return props.text !== undefined;\n    },\n    /**\r\n   * Check if an text matches set of properties.\r\n   *\r\n   * Note: this is for matching custom properties, and it does not ensure that\r\n   * the `text` property are two nodes equal.\r\n   */ matches: function matches(text, props) {\n        for(var key in props){\n            if (key === \"text\") {\n                continue;\n            }\n            if (!text.hasOwnProperty(key) || text[key] !== props[key]) {\n                return false;\n            }\n        }\n        return true;\n    },\n    /**\r\n   * Get the leaves for a text node given decorations.\r\n   */ decorations: function decorations(node, _decorations) {\n        var leaves = [\n            _objectSpread$4({}, node)\n        ];\n        var _iterator = _createForOfIteratorHelper$3(_decorations), _step;\n        try {\n            for(_iterator.s(); !(_step = _iterator.n()).done;){\n                var dec = _step.value;\n                var anchor = dec.anchor, focus = dec.focus, rest = _objectWithoutProperties(dec, _excluded2$1);\n                var _Range$edges = Range.edges(dec), _Range$edges2 = _slicedToArray(_Range$edges, 2), start = _Range$edges2[0], end = _Range$edges2[1];\n                var next = [];\n                var leafEnd = 0;\n                var decorationStart = start.offset;\n                var decorationEnd = end.offset;\n                var _iterator2 = _createForOfIteratorHelper$3(leaves), _step2;\n                try {\n                    for(_iterator2.s(); !(_step2 = _iterator2.n()).done;){\n                        var leaf = _step2.value;\n                        var length = leaf.text.length;\n                        var leafStart = leafEnd;\n                        leafEnd += length; // If the range encompasses the entire leaf, add the range.\n                        if (decorationStart <= leafStart && leafEnd <= decorationEnd) {\n                            Object.assign(leaf, rest);\n                            next.push(leaf);\n                            continue;\n                        } // If the range expanded and match the leaf, or starts after, or ends before it, continue.\n                        if (decorationStart !== decorationEnd && (decorationStart === leafEnd || decorationEnd === leafStart) || decorationStart > leafEnd || decorationEnd < leafStart || decorationEnd === leafStart && leafStart !== 0) {\n                            next.push(leaf);\n                            continue;\n                        } // Otherwise we need to split the leaf, at the start, end, or both,\n                        // and add the range to the middle intersecting section. Do the end\n                        // split first since we don't need to update the offset that way.\n                        var middle = leaf;\n                        var before = void 0;\n                        var after = void 0;\n                        if (decorationEnd < leafEnd) {\n                            var off = decorationEnd - leafStart;\n                            after = _objectSpread$4(_objectSpread$4({}, middle), {}, {\n                                text: middle.text.slice(off)\n                            });\n                            middle = _objectSpread$4(_objectSpread$4({}, middle), {}, {\n                                text: middle.text.slice(0, off)\n                            });\n                        }\n                        if (decorationStart > leafStart) {\n                            var _off = decorationStart - leafStart;\n                            before = _objectSpread$4(_objectSpread$4({}, middle), {}, {\n                                text: middle.text.slice(0, _off)\n                            });\n                            middle = _objectSpread$4(_objectSpread$4({}, middle), {}, {\n                                text: middle.text.slice(_off)\n                            });\n                        }\n                        Object.assign(middle, rest);\n                        if (before) {\n                            next.push(before);\n                        }\n                        next.push(middle);\n                        if (after) {\n                            next.push(after);\n                        }\n                    }\n                } catch (err) {\n                    _iterator2.e(err);\n                } finally{\n                    _iterator2.f();\n                }\n                leaves = next;\n            }\n        } catch (err) {\n            _iterator.e(err);\n        } finally{\n            _iterator.f();\n        }\n        return leaves;\n    }\n};\nfunction ownKeys$3(object, enumerableOnly) {\n    var keys = Object.keys(object);\n    if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        if (enumerableOnly) {\n            symbols = symbols.filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n            });\n        }\n        keys.push.apply(keys, symbols);\n    }\n    return keys;\n}\nfunction _objectSpread$3(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = arguments[i] != null ? arguments[i] : {};\n        if (i % 2) {\n            ownKeys$3(Object(source), true).forEach(function(key) {\n                _defineProperty(target, key, source[key]);\n            });\n        } else if (Object.getOwnPropertyDescriptors) {\n            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n        } else {\n            ownKeys$3(Object(source)).forEach(function(key) {\n                Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n            });\n        }\n    }\n    return target;\n}\nfunction _createForOfIteratorHelper$2(o, allowArrayLike) {\n    var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n    if (!it) {\n        if (Array.isArray(o) || (it = _unsupportedIterableToArray$2(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n            if (it) o = it;\n            var i = 0;\n            var F = function F() {};\n            return {\n                s: F,\n                n: function n() {\n                    if (i >= o.length) return {\n                        done: true\n                    };\n                    return {\n                        done: false,\n                        value: o[i++]\n                    };\n                },\n                e: function e(_e) {\n                    throw _e;\n                },\n                f: F\n            };\n        }\n        throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n    }\n    var normalCompletion = true, didErr = false, err;\n    return {\n        s: function s() {\n            it = it.call(o);\n        },\n        n: function n() {\n            var step = it.next();\n            normalCompletion = step.done;\n            return step;\n        },\n        e: function e(_e2) {\n            didErr = true;\n            err = _e2;\n        },\n        f: function f() {\n            try {\n                if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n            } finally{\n                if (didErr) throw err;\n            }\n        }\n    };\n}\nfunction _unsupportedIterableToArray$2(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray$2(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(o);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$2(o, minLen);\n}\nfunction _arrayLikeToArray$2(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++){\n        arr2[i] = arr[i];\n    }\n    return arr2;\n}\nvar applyToDraft = function applyToDraft(editor, selection, op) {\n    switch(op.type){\n        case \"insert_node\":\n            {\n                var path = op.path, node = op.node;\n                var parent = Node.parent(editor, path);\n                var index = path[path.length - 1];\n                if (index > parent.children.length) {\n                    throw new Error('Cannot apply an \"insert_node\" operation at path ['.concat(path, \"] because the destination is past the end of the node.\"));\n                }\n                parent.children.splice(index, 0, node);\n                if (selection) {\n                    var _iterator = _createForOfIteratorHelper$2(Range.points(selection)), _step;\n                    try {\n                        for(_iterator.s(); !(_step = _iterator.n()).done;){\n                            var _step$value = _slicedToArray(_step.value, 2), point = _step$value[0], key = _step$value[1];\n                            selection[key] = Point.transform(point, op);\n                        }\n                    } catch (err) {\n                        _iterator.e(err);\n                    } finally{\n                        _iterator.f();\n                    }\n                }\n                break;\n            }\n        case \"insert_text\":\n            {\n                var _path = op.path, offset = op.offset, text = op.text;\n                if (text.length === 0) break;\n                var _node = Node.leaf(editor, _path);\n                var before = _node.text.slice(0, offset);\n                var after = _node.text.slice(offset);\n                _node.text = before + text + after;\n                if (selection) {\n                    var _iterator2 = _createForOfIteratorHelper$2(Range.points(selection)), _step2;\n                    try {\n                        for(_iterator2.s(); !(_step2 = _iterator2.n()).done;){\n                            var _step2$value = _slicedToArray(_step2.value, 2), _point = _step2$value[0], _key = _step2$value[1];\n                            selection[_key] = Point.transform(_point, op);\n                        }\n                    } catch (err) {\n                        _iterator2.e(err);\n                    } finally{\n                        _iterator2.f();\n                    }\n                }\n                break;\n            }\n        case \"merge_node\":\n            {\n                var _path2 = op.path;\n                var _node2 = Node.get(editor, _path2);\n                var prevPath = Path.previous(_path2);\n                var prev = Node.get(editor, prevPath);\n                var _parent = Node.parent(editor, _path2);\n                var _index = _path2[_path2.length - 1];\n                if (Text.isText(_node2) && Text.isText(prev)) {\n                    prev.text += _node2.text;\n                } else if (!Text.isText(_node2) && !Text.isText(prev)) {\n                    var _prev$children;\n                    (_prev$children = prev.children).push.apply(_prev$children, _toConsumableArray(_node2.children));\n                } else {\n                    throw new Error('Cannot apply a \"merge_node\" operation at path ['.concat(_path2, \"] to nodes of different interfaces: \").concat(Scrubber.stringify(_node2), \" \").concat(Scrubber.stringify(prev)));\n                }\n                _parent.children.splice(_index, 1);\n                if (selection) {\n                    var _iterator3 = _createForOfIteratorHelper$2(Range.points(selection)), _step3;\n                    try {\n                        for(_iterator3.s(); !(_step3 = _iterator3.n()).done;){\n                            var _step3$value = _slicedToArray(_step3.value, 2), _point2 = _step3$value[0], _key2 = _step3$value[1];\n                            selection[_key2] = Point.transform(_point2, op);\n                        }\n                    } catch (err) {\n                        _iterator3.e(err);\n                    } finally{\n                        _iterator3.f();\n                    }\n                }\n                break;\n            }\n        case \"move_node\":\n            {\n                var _path3 = op.path, newPath = op.newPath;\n                if (Path.isAncestor(_path3, newPath)) {\n                    throw new Error(\"Cannot move a path [\".concat(_path3, \"] to new path [\").concat(newPath, \"] because the destination is inside itself.\"));\n                }\n                var _node3 = Node.get(editor, _path3);\n                var _parent2 = Node.parent(editor, _path3);\n                var _index2 = _path3[_path3.length - 1]; // This is tricky, but since the `path` and `newPath` both refer to\n                // the same snapshot in time, there's a mismatch. After either\n                // removing the original position, the second step's path can be out\n                // of date. So instead of using the `op.newPath` directly, we\n                // transform `op.path` to ascertain what the `newPath` would be after\n                // the operation was applied.\n                _parent2.children.splice(_index2, 1);\n                var truePath = Path.transform(_path3, op);\n                var newParent = Node.get(editor, Path.parent(truePath));\n                var newIndex = truePath[truePath.length - 1];\n                newParent.children.splice(newIndex, 0, _node3);\n                if (selection) {\n                    var _iterator4 = _createForOfIteratorHelper$2(Range.points(selection)), _step4;\n                    try {\n                        for(_iterator4.s(); !(_step4 = _iterator4.n()).done;){\n                            var _step4$value = _slicedToArray(_step4.value, 2), _point3 = _step4$value[0], _key3 = _step4$value[1];\n                            selection[_key3] = Point.transform(_point3, op);\n                        }\n                    } catch (err) {\n                        _iterator4.e(err);\n                    } finally{\n                        _iterator4.f();\n                    }\n                }\n                break;\n            }\n        case \"remove_node\":\n            {\n                var _path4 = op.path;\n                var _index3 = _path4[_path4.length - 1];\n                var _parent3 = Node.parent(editor, _path4);\n                _parent3.children.splice(_index3, 1); // Transform all of the points in the value, but if the point was in the\n                // node that was removed we need to update the range or remove it.\n                if (selection) {\n                    var _iterator5 = _createForOfIteratorHelper$2(Range.points(selection)), _step5;\n                    try {\n                        for(_iterator5.s(); !(_step5 = _iterator5.n()).done;){\n                            var _step5$value = _slicedToArray(_step5.value, 2), _point4 = _step5$value[0], _key4 = _step5$value[1];\n                            var result = Point.transform(_point4, op);\n                            if (selection != null && result != null) {\n                                selection[_key4] = result;\n                            } else {\n                                var _prev = void 0;\n                                var next = void 0;\n                                var _iterator6 = _createForOfIteratorHelper$2(Node.texts(editor)), _step6;\n                                try {\n                                    for(_iterator6.s(); !(_step6 = _iterator6.n()).done;){\n                                        var _step6$value = _slicedToArray(_step6.value, 2), n = _step6$value[0], p = _step6$value[1];\n                                        if (Path.compare(p, _path4) === -1) {\n                                            _prev = [\n                                                n,\n                                                p\n                                            ];\n                                        } else {\n                                            next = [\n                                                n,\n                                                p\n                                            ];\n                                            break;\n                                        }\n                                    }\n                                } catch (err) {\n                                    _iterator6.e(err);\n                                } finally{\n                                    _iterator6.f();\n                                }\n                                var preferNext = false;\n                                if (_prev && next) {\n                                    if (Path.equals(next[1], _path4)) {\n                                        preferNext = !Path.hasPrevious(next[1]);\n                                    } else {\n                                        preferNext = Path.common(_prev[1], _path4).length < Path.common(next[1], _path4).length;\n                                    }\n                                }\n                                if (_prev && !preferNext) {\n                                    _point4.path = _prev[1];\n                                    _point4.offset = _prev[0].text.length;\n                                } else if (next) {\n                                    _point4.path = next[1];\n                                    _point4.offset = 0;\n                                } else {\n                                    selection = null;\n                                }\n                            }\n                        }\n                    } catch (err) {\n                        _iterator5.e(err);\n                    } finally{\n                        _iterator5.f();\n                    }\n                }\n                break;\n            }\n        case \"remove_text\":\n            {\n                var _path5 = op.path, _offset = op.offset, _text = op.text;\n                if (_text.length === 0) break;\n                var _node4 = Node.leaf(editor, _path5);\n                var _before = _node4.text.slice(0, _offset);\n                var _after = _node4.text.slice(_offset + _text.length);\n                _node4.text = _before + _after;\n                if (selection) {\n                    var _iterator7 = _createForOfIteratorHelper$2(Range.points(selection)), _step7;\n                    try {\n                        for(_iterator7.s(); !(_step7 = _iterator7.n()).done;){\n                            var _step7$value = _slicedToArray(_step7.value, 2), _point5 = _step7$value[0], _key5 = _step7$value[1];\n                            selection[_key5] = Point.transform(_point5, op);\n                        }\n                    } catch (err) {\n                        _iterator7.e(err);\n                    } finally{\n                        _iterator7.f();\n                    }\n                }\n                break;\n            }\n        case \"set_node\":\n            {\n                var _path6 = op.path, properties = op.properties, newProperties = op.newProperties;\n                if (_path6.length === 0) {\n                    throw new Error(\"Cannot set properties on the root node!\");\n                }\n                var _node5 = Node.get(editor, _path6);\n                for(var _key6 in newProperties){\n                    if (_key6 === \"children\" || _key6 === \"text\") {\n                        throw new Error('Cannot set the \"'.concat(_key6, '\" property of nodes!'));\n                    }\n                    var value = newProperties[_key6];\n                    if (value == null) {\n                        delete _node5[_key6];\n                    } else {\n                        _node5[_key6] = value;\n                    }\n                } // properties that were previously defined, but are now missing, must be deleted\n                for(var _key7 in properties){\n                    if (!newProperties.hasOwnProperty(_key7)) {\n                        delete _node5[_key7];\n                    }\n                }\n                break;\n            }\n        case \"set_selection\":\n            {\n                var _newProperties = op.newProperties;\n                if (_newProperties == null) {\n                    selection = _newProperties;\n                } else {\n                    if (selection == null) {\n                        if (!Range.isRange(_newProperties)) {\n                            throw new Error('Cannot apply an incomplete \"set_selection\" operation properties '.concat(Scrubber.stringify(_newProperties), \" when there is no current selection.\"));\n                        }\n                        selection = _objectSpread$3({}, _newProperties);\n                    }\n                    for(var _key8 in _newProperties){\n                        var _value = _newProperties[_key8];\n                        if (_value == null) {\n                            if (_key8 === \"anchor\" || _key8 === \"focus\") {\n                                throw new Error('Cannot remove the \"'.concat(_key8, '\" selection property'));\n                            }\n                            delete selection[_key8];\n                        } else {\n                            selection[_key8] = _value;\n                        }\n                    }\n                }\n                break;\n            }\n        case \"split_node\":\n            {\n                var _path7 = op.path, position = op.position, _properties = op.properties;\n                if (_path7.length === 0) {\n                    throw new Error('Cannot apply a \"split_node\" operation at path ['.concat(_path7, \"] because the root node cannot be split.\"));\n                }\n                var _node6 = Node.get(editor, _path7);\n                var _parent4 = Node.parent(editor, _path7);\n                var _index4 = _path7[_path7.length - 1];\n                var newNode;\n                if (Text.isText(_node6)) {\n                    var _before2 = _node6.text.slice(0, position);\n                    var _after2 = _node6.text.slice(position);\n                    _node6.text = _before2;\n                    newNode = _objectSpread$3(_objectSpread$3({}, _properties), {}, {\n                        text: _after2\n                    });\n                } else {\n                    var _before3 = _node6.children.slice(0, position);\n                    var _after3 = _node6.children.slice(position);\n                    _node6.children = _before3;\n                    newNode = _objectSpread$3(_objectSpread$3({}, _properties), {}, {\n                        children: _after3\n                    });\n                }\n                _parent4.children.splice(_index4 + 1, 0, newNode);\n                if (selection) {\n                    var _iterator8 = _createForOfIteratorHelper$2(Range.points(selection)), _step8;\n                    try {\n                        for(_iterator8.s(); !(_step8 = _iterator8.n()).done;){\n                            var _step8$value = _slicedToArray(_step8.value, 2), _point6 = _step8$value[0], _key9 = _step8$value[1];\n                            selection[_key9] = Point.transform(_point6, op);\n                        }\n                    } catch (err) {\n                        _iterator8.e(err);\n                    } finally{\n                        _iterator8.f();\n                    }\n                }\n                break;\n            }\n    }\n    return selection;\n}; // eslint-disable-next-line no-redeclare\nvar GeneralTransforms = {\n    /**\r\n   * Transform the editor by an operation.\r\n   */ transform: function transform(editor, op) {\n        editor.children = immer.createDraft(editor.children);\n        var selection = editor.selection && immer.createDraft(editor.selection);\n        try {\n            selection = applyToDraft(editor, selection, op);\n        } finally{\n            editor.children = immer.finishDraft(editor.children);\n            if (selection) {\n                editor.selection = immer.isDraft(selection) ? immer.finishDraft(selection) : selection;\n            } else {\n                editor.selection = null;\n            }\n        }\n    }\n};\nvar _excluded = [\n    \"text\"\n], _excluded2 = [\n    \"children\"\n];\nfunction ownKeys$2(object, enumerableOnly) {\n    var keys = Object.keys(object);\n    if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        if (enumerableOnly) {\n            symbols = symbols.filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n            });\n        }\n        keys.push.apply(keys, symbols);\n    }\n    return keys;\n}\nfunction _objectSpread$2(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = arguments[i] != null ? arguments[i] : {};\n        if (i % 2) {\n            ownKeys$2(Object(source), true).forEach(function(key) {\n                _defineProperty(target, key, source[key]);\n            });\n        } else if (Object.getOwnPropertyDescriptors) {\n            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n        } else {\n            ownKeys$2(Object(source)).forEach(function(key) {\n                Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n            });\n        }\n    }\n    return target;\n}\nfunction _createForOfIteratorHelper$1(o, allowArrayLike) {\n    var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n    if (!it) {\n        if (Array.isArray(o) || (it = _unsupportedIterableToArray$1(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n            if (it) o = it;\n            var i = 0;\n            var F = function F() {};\n            return {\n                s: F,\n                n: function n() {\n                    if (i >= o.length) return {\n                        done: true\n                    };\n                    return {\n                        done: false,\n                        value: o[i++]\n                    };\n                },\n                e: function e(_e) {\n                    throw _e;\n                },\n                f: F\n            };\n        }\n        throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n    }\n    var normalCompletion = true, didErr = false, err;\n    return {\n        s: function s() {\n            it = it.call(o);\n        },\n        n: function n() {\n            var step = it.next();\n            normalCompletion = step.done;\n            return step;\n        },\n        e: function e(_e2) {\n            didErr = true;\n            err = _e2;\n        },\n        f: function f() {\n            try {\n                if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n            } finally{\n                if (didErr) throw err;\n            }\n        }\n    };\n}\nfunction _unsupportedIterableToArray$1(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray$1(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(o);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$1(o, minLen);\n}\nfunction _arrayLikeToArray$1(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++){\n        arr2[i] = arr[i];\n    }\n    return arr2;\n}\nvar NodeTransforms = {\n    /**\r\n   * Insert nodes at a specific location in the Editor.\r\n   */ insertNodes: function insertNodes(editor, nodes) {\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        Editor.withoutNormalizing(editor, function() {\n            var _options$hanging = options.hanging, hanging = _options$hanging === void 0 ? false : _options$hanging, _options$voids = options.voids, voids = _options$voids === void 0 ? false : _options$voids, _options$mode = options.mode, mode = _options$mode === void 0 ? \"lowest\" : _options$mode;\n            var at = options.at, match = options.match, select = options.select;\n            if (Node.isNode(nodes)) {\n                nodes = [\n                    nodes\n                ];\n            }\n            if (nodes.length === 0) {\n                return;\n            }\n            var _nodes = nodes, _nodes2 = _slicedToArray(_nodes, 1), node = _nodes2[0]; // By default, use the selection as the target location. But if there is\n            // no selection, insert at the end of the document since that is such a\n            // common use case when inserting from a non-selected state.\n            if (!at) {\n                if (editor.selection) {\n                    at = editor.selection;\n                } else if (editor.children.length > 0) {\n                    at = Editor.end(editor, []);\n                } else {\n                    at = [\n                        0\n                    ];\n                }\n                select = true;\n            }\n            if (select == null) {\n                select = false;\n            }\n            if (Range.isRange(at)) {\n                if (!hanging) {\n                    at = Editor.unhangRange(editor, at, {\n                        voids: voids\n                    });\n                }\n                if (Range.isCollapsed(at)) {\n                    at = at.anchor;\n                } else {\n                    var _Range$edges = Range.edges(at), _Range$edges2 = _slicedToArray(_Range$edges, 2), end = _Range$edges2[1];\n                    var pointRef = Editor.pointRef(editor, end);\n                    Transforms[\"delete\"](editor, {\n                        at: at\n                    });\n                    at = pointRef.unref();\n                }\n            }\n            if (Point.isPoint(at)) {\n                if (match == null) {\n                    if (Text.isText(node)) {\n                        match = function match(n) {\n                            return Text.isText(n);\n                        };\n                    } else if (editor.isInline(node)) {\n                        match = function match(n) {\n                            return Text.isText(n) || Editor.isInline(editor, n);\n                        };\n                    } else {\n                        match = function match(n) {\n                            return Element.isElement(n) && Editor.isBlock(editor, n);\n                        };\n                    }\n                }\n                var _Editor$nodes = Editor.nodes(editor, {\n                    at: at.path,\n                    match: match,\n                    mode: mode,\n                    voids: voids\n                }), _Editor$nodes2 = _slicedToArray(_Editor$nodes, 1), entry = _Editor$nodes2[0];\n                if (entry) {\n                    var _entry = _slicedToArray(entry, 2), _matchPath = _entry[1];\n                    var pathRef = Editor.pathRef(editor, _matchPath);\n                    var isAtEnd = Editor.isEnd(editor, at, _matchPath);\n                    Transforms.splitNodes(editor, {\n                        at: at,\n                        match: match,\n                        mode: mode,\n                        voids: voids\n                    });\n                    var path = pathRef.unref();\n                    at = isAtEnd ? Path.next(path) : path;\n                } else {\n                    return;\n                }\n            }\n            var parentPath = Path.parent(at);\n            var index = at[at.length - 1];\n            if (!voids && Editor[\"void\"](editor, {\n                at: parentPath\n            })) {\n                return;\n            }\n            var _iterator = _createForOfIteratorHelper$1(nodes), _step;\n            try {\n                for(_iterator.s(); !(_step = _iterator.n()).done;){\n                    var _node = _step.value;\n                    var _path = parentPath.concat(index);\n                    index++;\n                    editor.apply({\n                        type: \"insert_node\",\n                        path: _path,\n                        node: _node\n                    });\n                    at = Path.next(at);\n                }\n            } catch (err) {\n                _iterator.e(err);\n            } finally{\n                _iterator.f();\n            }\n            at = Path.previous(at);\n            if (select) {\n                var point = Editor.end(editor, at);\n                if (point) {\n                    Transforms.select(editor, point);\n                }\n            }\n        });\n    },\n    /**\r\n   * Lift nodes at a specific location upwards in the document tree, splitting\r\n   * their parent in two if necessary.\r\n   */ liftNodes: function liftNodes(editor) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        Editor.withoutNormalizing(editor, function() {\n            var _options$at = options.at, at = _options$at === void 0 ? editor.selection : _options$at, _options$mode2 = options.mode, mode = _options$mode2 === void 0 ? \"lowest\" : _options$mode2, _options$voids2 = options.voids, voids = _options$voids2 === void 0 ? false : _options$voids2;\n            var match = options.match;\n            if (match == null) {\n                match = Path.isPath(at) ? matchPath(editor, at) : function(n) {\n                    return Element.isElement(n) && Editor.isBlock(editor, n);\n                };\n            }\n            if (!at) {\n                return;\n            }\n            var matches = Editor.nodes(editor, {\n                at: at,\n                match: match,\n                mode: mode,\n                voids: voids\n            });\n            var pathRefs = Array.from(matches, function(_ref) {\n                var _ref2 = _slicedToArray(_ref, 2), p = _ref2[1];\n                return Editor.pathRef(editor, p);\n            });\n            for(var _i = 0, _pathRefs = pathRefs; _i < _pathRefs.length; _i++){\n                var pathRef = _pathRefs[_i];\n                var path = pathRef.unref();\n                if (path.length < 2) {\n                    throw new Error(\"Cannot lift node at a path [\".concat(path, \"] because it has a depth of less than `2`.\"));\n                }\n                var parentNodeEntry = Editor.node(editor, Path.parent(path));\n                var _parentNodeEntry = _slicedToArray(parentNodeEntry, 2), parent = _parentNodeEntry[0], parentPath = _parentNodeEntry[1];\n                var index = path[path.length - 1];\n                var length = parent.children.length;\n                if (length === 1) {\n                    var toPath = Path.next(parentPath);\n                    Transforms.moveNodes(editor, {\n                        at: path,\n                        to: toPath,\n                        voids: voids\n                    });\n                    Transforms.removeNodes(editor, {\n                        at: parentPath,\n                        voids: voids\n                    });\n                } else if (index === 0) {\n                    Transforms.moveNodes(editor, {\n                        at: path,\n                        to: parentPath,\n                        voids: voids\n                    });\n                } else if (index === length - 1) {\n                    var _toPath = Path.next(parentPath);\n                    Transforms.moveNodes(editor, {\n                        at: path,\n                        to: _toPath,\n                        voids: voids\n                    });\n                } else {\n                    var splitPath = Path.next(path);\n                    var _toPath2 = Path.next(parentPath);\n                    Transforms.splitNodes(editor, {\n                        at: splitPath,\n                        voids: voids\n                    });\n                    Transforms.moveNodes(editor, {\n                        at: path,\n                        to: _toPath2,\n                        voids: voids\n                    });\n                }\n            }\n        });\n    },\n    /**\r\n   * Merge a node at a location with the previous node of the same depth,\r\n   * removing any empty containing nodes after the merge if necessary.\r\n   */ mergeNodes: function mergeNodes(editor) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        Editor.withoutNormalizing(editor, function() {\n            var match = options.match, _options$at2 = options.at, at = _options$at2 === void 0 ? editor.selection : _options$at2;\n            var _options$hanging2 = options.hanging, hanging = _options$hanging2 === void 0 ? false : _options$hanging2, _options$voids3 = options.voids, voids = _options$voids3 === void 0 ? false : _options$voids3, _options$mode3 = options.mode, mode = _options$mode3 === void 0 ? \"lowest\" : _options$mode3;\n            if (!at) {\n                return;\n            }\n            if (match == null) {\n                if (Path.isPath(at)) {\n                    var _Editor$parent = Editor.parent(editor, at), _Editor$parent2 = _slicedToArray(_Editor$parent, 1), parent = _Editor$parent2[0];\n                    match = function match(n) {\n                        return parent.children.includes(n);\n                    };\n                } else {\n                    match = function match(n) {\n                        return Element.isElement(n) && Editor.isBlock(editor, n);\n                    };\n                }\n            }\n            if (!hanging && Range.isRange(at)) {\n                at = Editor.unhangRange(editor, at, {\n                    voids: voids\n                });\n            }\n            if (Range.isRange(at)) {\n                if (Range.isCollapsed(at)) {\n                    at = at.anchor;\n                } else {\n                    var _Range$edges3 = Range.edges(at), _Range$edges4 = _slicedToArray(_Range$edges3, 2), end = _Range$edges4[1];\n                    var pointRef = Editor.pointRef(editor, end);\n                    Transforms[\"delete\"](editor, {\n                        at: at\n                    });\n                    at = pointRef.unref();\n                    if (options.at == null) {\n                        Transforms.select(editor, at);\n                    }\n                }\n            }\n            var _Editor$nodes3 = Editor.nodes(editor, {\n                at: at,\n                match: match,\n                voids: voids,\n                mode: mode\n            }), _Editor$nodes4 = _slicedToArray(_Editor$nodes3, 1), current = _Editor$nodes4[0];\n            var prev = Editor.previous(editor, {\n                at: at,\n                match: match,\n                voids: voids,\n                mode: mode\n            });\n            if (!current || !prev) {\n                return;\n            }\n            var _current = _slicedToArray(current, 2), node = _current[0], path = _current[1];\n            var _prev = _slicedToArray(prev, 2), prevNode = _prev[0], prevPath = _prev[1];\n            if (path.length === 0 || prevPath.length === 0) {\n                return;\n            }\n            var newPath = Path.next(prevPath);\n            var commonPath = Path.common(path, prevPath);\n            var isPreviousSibling = Path.isSibling(path, prevPath);\n            var levels = Array.from(Editor.levels(editor, {\n                at: path\n            }), function(_ref3) {\n                var _ref4 = _slicedToArray(_ref3, 1), n = _ref4[0];\n                return n;\n            }).slice(commonPath.length).slice(0, -1); // Determine if the merge will leave an ancestor of the path empty as a\n            // result, in which case we'll want to remove it after merging.\n            var emptyAncestor = Editor.above(editor, {\n                at: path,\n                mode: \"highest\",\n                match: function match(n) {\n                    return levels.includes(n) && hasSingleChildNest(editor, n);\n                }\n            });\n            var emptyRef = emptyAncestor && Editor.pathRef(editor, emptyAncestor[1]);\n            var properties;\n            var position; // Ensure that the nodes are equivalent, and figure out what the position\n            // and extra properties of the merge will be.\n            if (Text.isText(node) && Text.isText(prevNode)) {\n                node.text;\n                var rest = _objectWithoutProperties(node, _excluded);\n                position = prevNode.text.length;\n                properties = rest;\n            } else if (Element.isElement(node) && Element.isElement(prevNode)) {\n                node.children;\n                var _rest = _objectWithoutProperties(node, _excluded2);\n                position = prevNode.children.length;\n                properties = _rest;\n            } else {\n                throw new Error(\"Cannot merge the node at path [\".concat(path, \"] with the previous sibling because it is not the same kind: \").concat(Scrubber.stringify(node), \" \").concat(Scrubber.stringify(prevNode)));\n            } // If the node isn't already the next sibling of the previous node, move\n            // it so that it is before merging.\n            if (!isPreviousSibling) {\n                Transforms.moveNodes(editor, {\n                    at: path,\n                    to: newPath,\n                    voids: voids\n                });\n            } // If there was going to be an empty ancestor of the node that was merged,\n            // we remove it from the tree.\n            if (emptyRef) {\n                Transforms.removeNodes(editor, {\n                    at: emptyRef.current,\n                    voids: voids\n                });\n            } // If the target node that we're merging with is empty, remove it instead\n            // of merging the two. This is a common rich text editor behavior to\n            // prevent losing formatting when deleting entire nodes when you have a\n            // hanging selection.\n            // if prevNode is first child in parent,don't remove it.\n            if (Element.isElement(prevNode) && Editor.isEmpty(editor, prevNode) || Text.isText(prevNode) && prevNode.text === \"\" && prevPath[prevPath.length - 1] !== 0) {\n                Transforms.removeNodes(editor, {\n                    at: prevPath,\n                    voids: voids\n                });\n            } else {\n                editor.apply({\n                    type: \"merge_node\",\n                    path: newPath,\n                    position: position,\n                    properties: properties\n                });\n            }\n            if (emptyRef) {\n                emptyRef.unref();\n            }\n        });\n    },\n    /**\r\n   * Move the nodes at a location to a new location.\r\n   */ moveNodes: function moveNodes(editor, options) {\n        Editor.withoutNormalizing(editor, function() {\n            var to = options.to, _options$at3 = options.at, at = _options$at3 === void 0 ? editor.selection : _options$at3, _options$mode4 = options.mode, mode = _options$mode4 === void 0 ? \"lowest\" : _options$mode4, _options$voids4 = options.voids, voids = _options$voids4 === void 0 ? false : _options$voids4;\n            var match = options.match;\n            if (!at) {\n                return;\n            }\n            if (match == null) {\n                match = Path.isPath(at) ? matchPath(editor, at) : function(n) {\n                    return Element.isElement(n) && Editor.isBlock(editor, n);\n                };\n            }\n            var toRef = Editor.pathRef(editor, to);\n            var targets = Editor.nodes(editor, {\n                at: at,\n                match: match,\n                mode: mode,\n                voids: voids\n            });\n            var pathRefs = Array.from(targets, function(_ref5) {\n                var _ref6 = _slicedToArray(_ref5, 2), p = _ref6[1];\n                return Editor.pathRef(editor, p);\n            });\n            for(var _i2 = 0, _pathRefs2 = pathRefs; _i2 < _pathRefs2.length; _i2++){\n                var pathRef = _pathRefs2[_i2];\n                var path = pathRef.unref();\n                var newPath = toRef.current;\n                if (path.length !== 0) {\n                    editor.apply({\n                        type: \"move_node\",\n                        path: path,\n                        newPath: newPath\n                    });\n                }\n                if (toRef.current && Path.isSibling(newPath, path) && Path.isAfter(newPath, path)) {\n                    // When performing a sibling move to a later index, the path at the destination is shifted\n                    // to before the insertion point instead of after. To ensure our group of nodes are inserted\n                    // in the correct order we increment toRef to account for that\n                    toRef.current = Path.next(toRef.current);\n                }\n            }\n            toRef.unref();\n        });\n    },\n    /**\r\n   * Remove the nodes at a specific location in the document.\r\n   */ removeNodes: function removeNodes(editor) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        Editor.withoutNormalizing(editor, function() {\n            var _options$hanging3 = options.hanging, hanging = _options$hanging3 === void 0 ? false : _options$hanging3, _options$voids5 = options.voids, voids = _options$voids5 === void 0 ? false : _options$voids5, _options$mode5 = options.mode, mode = _options$mode5 === void 0 ? \"lowest\" : _options$mode5;\n            var _options$at4 = options.at, at = _options$at4 === void 0 ? editor.selection : _options$at4, match = options.match;\n            if (!at) {\n                return;\n            }\n            if (match == null) {\n                match = Path.isPath(at) ? matchPath(editor, at) : function(n) {\n                    return Element.isElement(n) && Editor.isBlock(editor, n);\n                };\n            }\n            if (!hanging && Range.isRange(at)) {\n                at = Editor.unhangRange(editor, at, {\n                    voids: voids\n                });\n            }\n            var depths = Editor.nodes(editor, {\n                at: at,\n                match: match,\n                mode: mode,\n                voids: voids\n            });\n            var pathRefs = Array.from(depths, function(_ref7) {\n                var _ref8 = _slicedToArray(_ref7, 2), p = _ref8[1];\n                return Editor.pathRef(editor, p);\n            });\n            for(var _i3 = 0, _pathRefs3 = pathRefs; _i3 < _pathRefs3.length; _i3++){\n                var pathRef = _pathRefs3[_i3];\n                var path = pathRef.unref();\n                if (path) {\n                    var _Editor$node = Editor.node(editor, path), _Editor$node2 = _slicedToArray(_Editor$node, 1), node = _Editor$node2[0];\n                    editor.apply({\n                        type: \"remove_node\",\n                        path: path,\n                        node: node\n                    });\n                }\n            }\n        });\n    },\n    /**\r\n   * Set new properties on the nodes at a location.\r\n   */ setNodes: function setNodes(editor, props) {\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        Editor.withoutNormalizing(editor, function() {\n            var match = options.match, _options$at5 = options.at, at = _options$at5 === void 0 ? editor.selection : _options$at5, compare = options.compare, merge = options.merge;\n            var _options$hanging4 = options.hanging, hanging = _options$hanging4 === void 0 ? false : _options$hanging4, _options$mode6 = options.mode, mode = _options$mode6 === void 0 ? \"lowest\" : _options$mode6, _options$split = options.split, split = _options$split === void 0 ? false : _options$split, _options$voids6 = options.voids, voids = _options$voids6 === void 0 ? false : _options$voids6;\n            if (!at) {\n                return;\n            }\n            if (match == null) {\n                match = Path.isPath(at) ? matchPath(editor, at) : function(n) {\n                    return Element.isElement(n) && Editor.isBlock(editor, n);\n                };\n            }\n            if (!hanging && Range.isRange(at)) {\n                at = Editor.unhangRange(editor, at, {\n                    voids: voids\n                });\n            }\n            if (split && Range.isRange(at)) {\n                if (Range.isCollapsed(at) && Editor.leaf(editor, at.anchor)[0].text.length > 0) {\n                    // If the range is collapsed in a non-empty node and 'split' is true, there's nothing to\n                    // set that won't get normalized away\n                    return;\n                }\n                var rangeRef = Editor.rangeRef(editor, at, {\n                    affinity: \"inward\"\n                });\n                var _Range$edges5 = Range.edges(at), _Range$edges6 = _slicedToArray(_Range$edges5, 2), start = _Range$edges6[0], end = _Range$edges6[1];\n                var splitMode = mode === \"lowest\" ? \"lowest\" : \"highest\";\n                var endAtEndOfNode = Editor.isEnd(editor, end, end.path);\n                Transforms.splitNodes(editor, {\n                    at: end,\n                    match: match,\n                    mode: splitMode,\n                    voids: voids,\n                    always: !endAtEndOfNode\n                });\n                var startAtStartOfNode = Editor.isStart(editor, start, start.path);\n                Transforms.splitNodes(editor, {\n                    at: start,\n                    match: match,\n                    mode: splitMode,\n                    voids: voids,\n                    always: !startAtStartOfNode\n                });\n                at = rangeRef.unref();\n                if (options.at == null) {\n                    Transforms.select(editor, at);\n                }\n            }\n            if (!compare) {\n                compare = function compare(prop, nodeProp) {\n                    return prop !== nodeProp;\n                };\n            }\n            var _iterator2 = _createForOfIteratorHelper$1(Editor.nodes(editor, {\n                at: at,\n                match: match,\n                mode: mode,\n                voids: voids\n            })), _step2;\n            try {\n                for(_iterator2.s(); !(_step2 = _iterator2.n()).done;){\n                    var _step2$value = _slicedToArray(_step2.value, 2), node = _step2$value[0], path = _step2$value[1];\n                    var properties = {};\n                    var newProperties = {}; // You can't set properties on the editor node.\n                    if (path.length === 0) {\n                        continue;\n                    }\n                    var hasChanges = false;\n                    for(var k in props){\n                        if (k === \"children\" || k === \"text\") {\n                            continue;\n                        }\n                        if (compare(props[k], node[k])) {\n                            hasChanges = true; // Omit new properties from the old properties list\n                            if (node.hasOwnProperty(k)) properties[k] = node[k]; // Omit properties that have been removed from the new properties list\n                            if (merge) {\n                                if (props[k] != null) newProperties[k] = merge(node[k], props[k]);\n                            } else {\n                                if (props[k] != null) newProperties[k] = props[k];\n                            }\n                        }\n                    }\n                    if (hasChanges) {\n                        editor.apply({\n                            type: \"set_node\",\n                            path: path,\n                            properties: properties,\n                            newProperties: newProperties\n                        });\n                    }\n                }\n            } catch (err) {\n                _iterator2.e(err);\n            } finally{\n                _iterator2.f();\n            }\n        });\n    },\n    /**\r\n   * Split the nodes at a specific location.\r\n   */ splitNodes: function splitNodes(editor) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        Editor.withoutNormalizing(editor, function() {\n            var _options$mode7 = options.mode, mode = _options$mode7 === void 0 ? \"lowest\" : _options$mode7, _options$voids7 = options.voids, voids = _options$voids7 === void 0 ? false : _options$voids7;\n            var match = options.match, _options$at6 = options.at, at = _options$at6 === void 0 ? editor.selection : _options$at6, _options$height = options.height, height = _options$height === void 0 ? 0 : _options$height, _options$always = options.always, always = _options$always === void 0 ? false : _options$always;\n            if (match == null) {\n                match = function match(n) {\n                    return Element.isElement(n) && Editor.isBlock(editor, n);\n                };\n            }\n            if (Range.isRange(at)) {\n                at = deleteRange(editor, at);\n            } // If the target is a path, the default height-skipping and position\n            // counters need to account for us potentially splitting at a non-leaf.\n            if (Path.isPath(at)) {\n                var path = at;\n                var point = Editor.point(editor, path);\n                var _Editor$parent3 = Editor.parent(editor, path), _Editor$parent4 = _slicedToArray(_Editor$parent3, 1), parent = _Editor$parent4[0];\n                match = function match(n) {\n                    return n === parent;\n                };\n                height = point.path.length - path.length + 1;\n                at = point;\n                always = true;\n            }\n            if (!at) {\n                return;\n            }\n            var beforeRef = Editor.pointRef(editor, at, {\n                affinity: \"backward\"\n            });\n            var afterRef;\n            try {\n                var _Editor$nodes5 = Editor.nodes(editor, {\n                    at: at,\n                    match: match,\n                    mode: mode,\n                    voids: voids\n                }), _Editor$nodes6 = _slicedToArray(_Editor$nodes5, 1), highest = _Editor$nodes6[0];\n                if (!highest) {\n                    return;\n                }\n                var voidMatch = Editor[\"void\"](editor, {\n                    at: at,\n                    mode: \"highest\"\n                });\n                var nudge = 0;\n                if (!voids && voidMatch) {\n                    var _voidMatch = _slicedToArray(voidMatch, 2), voidNode = _voidMatch[0], voidPath = _voidMatch[1];\n                    if (Element.isElement(voidNode) && editor.isInline(voidNode)) {\n                        var after = Editor.after(editor, voidPath);\n                        if (!after) {\n                            var text = {\n                                text: \"\"\n                            };\n                            var afterPath = Path.next(voidPath);\n                            Transforms.insertNodes(editor, text, {\n                                at: afterPath,\n                                voids: voids\n                            });\n                            after = Editor.point(editor, afterPath);\n                        }\n                        at = after;\n                        always = true;\n                    }\n                    var siblingHeight = at.path.length - voidPath.length;\n                    height = siblingHeight + 1;\n                    always = true;\n                }\n                afterRef = Editor.pointRef(editor, at);\n                var depth = at.path.length - height;\n                var _highest = _slicedToArray(highest, 2), highestPath = _highest[1];\n                var lowestPath = at.path.slice(0, depth);\n                var position = height === 0 ? at.offset : at.path[depth] + nudge;\n                var _iterator3 = _createForOfIteratorHelper$1(Editor.levels(editor, {\n                    at: lowestPath,\n                    reverse: true,\n                    voids: voids\n                })), _step3;\n                try {\n                    for(_iterator3.s(); !(_step3 = _iterator3.n()).done;){\n                        var _step3$value = _slicedToArray(_step3.value, 2), node = _step3$value[0], _path2 = _step3$value[1];\n                        var split = false;\n                        if (_path2.length < highestPath.length || _path2.length === 0 || !voids && Element.isElement(node) && Editor.isVoid(editor, node)) {\n                            break;\n                        }\n                        var _point2 = beforeRef.current;\n                        var isEnd = Editor.isEnd(editor, _point2, _path2);\n                        if (always || !beforeRef || !Editor.isEdge(editor, _point2, _path2)) {\n                            split = true;\n                            var properties = Node.extractProps(node);\n                            editor.apply({\n                                type: \"split_node\",\n                                path: _path2,\n                                position: position,\n                                properties: properties\n                            });\n                        }\n                        position = _path2[_path2.length - 1] + (split || isEnd ? 1 : 0);\n                    }\n                } catch (err) {\n                    _iterator3.e(err);\n                } finally{\n                    _iterator3.f();\n                }\n                if (options.at == null) {\n                    var _point = afterRef.current || Editor.end(editor, []);\n                    Transforms.select(editor, _point);\n                }\n            } finally{\n                var _afterRef;\n                beforeRef.unref();\n                (_afterRef = afterRef) === null || _afterRef === void 0 ? void 0 : _afterRef.unref();\n            }\n        });\n    },\n    /**\r\n   * Unset properties on the nodes at a location.\r\n   */ unsetNodes: function unsetNodes(editor, props) {\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        if (!Array.isArray(props)) {\n            props = [\n                props\n            ];\n        }\n        var obj = {};\n        var _iterator4 = _createForOfIteratorHelper$1(props), _step4;\n        try {\n            for(_iterator4.s(); !(_step4 = _iterator4.n()).done;){\n                var key = _step4.value;\n                obj[key] = null;\n            }\n        } catch (err) {\n            _iterator4.e(err);\n        } finally{\n            _iterator4.f();\n        }\n        Transforms.setNodes(editor, obj, options);\n    },\n    /**\r\n   * Unwrap the nodes at a location from a parent node, splitting the parent if\r\n   * necessary to ensure that only the content in the range is unwrapped.\r\n   */ unwrapNodes: function unwrapNodes(editor) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        Editor.withoutNormalizing(editor, function() {\n            var _options$mode8 = options.mode, mode = _options$mode8 === void 0 ? \"lowest\" : _options$mode8, _options$split2 = options.split, split = _options$split2 === void 0 ? false : _options$split2, _options$voids8 = options.voids, voids = _options$voids8 === void 0 ? false : _options$voids8;\n            var _options$at7 = options.at, at = _options$at7 === void 0 ? editor.selection : _options$at7, match = options.match;\n            if (!at) {\n                return;\n            }\n            if (match == null) {\n                match = Path.isPath(at) ? matchPath(editor, at) : function(n) {\n                    return Element.isElement(n) && Editor.isBlock(editor, n);\n                };\n            }\n            if (Path.isPath(at)) {\n                at = Editor.range(editor, at);\n            }\n            var rangeRef = Range.isRange(at) ? Editor.rangeRef(editor, at) : null;\n            var matches = Editor.nodes(editor, {\n                at: at,\n                match: match,\n                mode: mode,\n                voids: voids\n            });\n            var pathRefs = Array.from(matches, function(_ref9) {\n                var _ref10 = _slicedToArray(_ref9, 2), p = _ref10[1];\n                return Editor.pathRef(editor, p);\n            } // unwrapNode will call liftNode which does not support splitting the node when nested.\n            ).reverse();\n            var _iterator5 = _createForOfIteratorHelper$1(pathRefs), _step5;\n            try {\n                var _loop = function _loop() {\n                    var pathRef = _step5.value;\n                    var path = pathRef.unref();\n                    var _Editor$node3 = Editor.node(editor, path), _Editor$node4 = _slicedToArray(_Editor$node3, 1), node = _Editor$node4[0];\n                    var range = Editor.range(editor, path);\n                    if (split && rangeRef) {\n                        range = Range.intersection(rangeRef.current, range);\n                    }\n                    Transforms.liftNodes(editor, {\n                        at: range,\n                        match: function match(n) {\n                            return Element.isAncestor(node) && node.children.includes(n);\n                        },\n                        voids: voids\n                    });\n                };\n                for(_iterator5.s(); !(_step5 = _iterator5.n()).done;){\n                    _loop();\n                }\n            } catch (err) {\n                _iterator5.e(err);\n            } finally{\n                _iterator5.f();\n            }\n            if (rangeRef) {\n                rangeRef.unref();\n            }\n        });\n    },\n    /**\r\n   * Wrap the nodes at a location in a new container node, splitting the edges\r\n   * of the range first to ensure that only the content in the range is wrapped.\r\n   */ wrapNodes: function wrapNodes(editor, element) {\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        Editor.withoutNormalizing(editor, function() {\n            var _options$mode9 = options.mode, mode = _options$mode9 === void 0 ? \"lowest\" : _options$mode9, _options$split3 = options.split, split = _options$split3 === void 0 ? false : _options$split3, _options$voids9 = options.voids, voids = _options$voids9 === void 0 ? false : _options$voids9;\n            var match = options.match, _options$at8 = options.at, at = _options$at8 === void 0 ? editor.selection : _options$at8;\n            if (!at) {\n                return;\n            }\n            if (match == null) {\n                if (Path.isPath(at)) {\n                    match = matchPath(editor, at);\n                } else if (editor.isInline(element)) {\n                    match = function match(n) {\n                        return Element.isElement(n) && Editor.isInline(editor, n) || Text.isText(n);\n                    };\n                } else {\n                    match = function match(n) {\n                        return Element.isElement(n) && Editor.isBlock(editor, n);\n                    };\n                }\n            }\n            if (split && Range.isRange(at)) {\n                var _Range$edges7 = Range.edges(at), _Range$edges8 = _slicedToArray(_Range$edges7, 2), start = _Range$edges8[0], end = _Range$edges8[1];\n                var rangeRef = Editor.rangeRef(editor, at, {\n                    affinity: \"inward\"\n                });\n                Transforms.splitNodes(editor, {\n                    at: end,\n                    match: match,\n                    voids: voids\n                });\n                Transforms.splitNodes(editor, {\n                    at: start,\n                    match: match,\n                    voids: voids\n                });\n                at = rangeRef.unref();\n                if (options.at == null) {\n                    Transforms.select(editor, at);\n                }\n            }\n            var roots = Array.from(Editor.nodes(editor, {\n                at: at,\n                match: editor.isInline(element) ? function(n) {\n                    return Element.isElement(n) && Editor.isBlock(editor, n);\n                } : function(n) {\n                    return Editor.isEditor(n);\n                },\n                mode: \"lowest\",\n                voids: voids\n            }));\n            for(var _i4 = 0, _roots = roots; _i4 < _roots.length; _i4++){\n                var _roots$_i = _slicedToArray(_roots[_i4], 2), rootPath = _roots$_i[1];\n                var a = Range.isRange(at) ? Range.intersection(at, Editor.range(editor, rootPath)) : at;\n                if (!a) {\n                    continue;\n                }\n                var matches = Array.from(Editor.nodes(editor, {\n                    at: a,\n                    match: match,\n                    mode: mode,\n                    voids: voids\n                }));\n                if (matches.length > 0) {\n                    var _ret = function() {\n                        var _matches = _slicedToArray(matches, 1), first = _matches[0];\n                        var last = matches[matches.length - 1];\n                        var _first = _slicedToArray(first, 2), firstPath = _first[1];\n                        var _last = _slicedToArray(last, 2), lastPath = _last[1];\n                        if (firstPath.length === 0 && lastPath.length === 0) {\n                            // if there's no matching parent - usually means the node is an editor - don't do anything\n                            return \"continue\";\n                        }\n                        var commonPath = Path.equals(firstPath, lastPath) ? Path.parent(firstPath) : Path.common(firstPath, lastPath);\n                        var range = Editor.range(editor, firstPath, lastPath);\n                        var commonNodeEntry = Editor.node(editor, commonPath);\n                        var _commonNodeEntry = _slicedToArray(commonNodeEntry, 1), commonNode = _commonNodeEntry[0];\n                        var depth = commonPath.length + 1;\n                        var wrapperPath = Path.next(lastPath.slice(0, depth));\n                        var wrapper = _objectSpread$2(_objectSpread$2({}, element), {}, {\n                            children: []\n                        });\n                        Transforms.insertNodes(editor, wrapper, {\n                            at: wrapperPath,\n                            voids: voids\n                        });\n                        Transforms.moveNodes(editor, {\n                            at: range,\n                            match: function match(n) {\n                                return Element.isAncestor(commonNode) && commonNode.children.includes(n);\n                            },\n                            to: wrapperPath.concat(0),\n                            voids: voids\n                        });\n                    }();\n                    if (_ret === \"continue\") continue;\n                }\n            }\n        });\n    }\n};\nvar hasSingleChildNest = function hasSingleChildNest(editor, node) {\n    if (Element.isElement(node)) {\n        var element = node;\n        if (Editor.isVoid(editor, node)) {\n            return true;\n        } else if (element.children.length === 1) {\n            return hasSingleChildNest(editor, element.children[0]);\n        } else {\n            return false;\n        }\n    } else if (Editor.isEditor(node)) {\n        return false;\n    } else {\n        return true;\n    }\n};\n/**\r\n * Convert a range into a point by deleting it's content.\r\n */ var deleteRange = function deleteRange(editor, range) {\n    if (Range.isCollapsed(range)) {\n        return range.anchor;\n    } else {\n        var _Range$edges9 = Range.edges(range), _Range$edges10 = _slicedToArray(_Range$edges9, 2), end = _Range$edges10[1];\n        var pointRef = Editor.pointRef(editor, end);\n        Transforms[\"delete\"](editor, {\n            at: range\n        });\n        return pointRef.unref();\n    }\n};\nvar matchPath = function matchPath(editor, path) {\n    var _Editor$node5 = Editor.node(editor, path), _Editor$node6 = _slicedToArray(_Editor$node5, 1), node = _Editor$node6[0];\n    return function(n) {\n        return n === node;\n    };\n};\nfunction ownKeys$1(object, enumerableOnly) {\n    var keys = Object.keys(object);\n    if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        if (enumerableOnly) {\n            symbols = symbols.filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n            });\n        }\n        keys.push.apply(keys, symbols);\n    }\n    return keys;\n}\nfunction _objectSpread$1(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = arguments[i] != null ? arguments[i] : {};\n        if (i % 2) {\n            ownKeys$1(Object(source), true).forEach(function(key) {\n                _defineProperty(target, key, source[key]);\n            });\n        } else if (Object.getOwnPropertyDescriptors) {\n            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n        } else {\n            ownKeys$1(Object(source)).forEach(function(key) {\n                Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n            });\n        }\n    }\n    return target;\n}\nvar SelectionTransforms = {\n    /**\r\n   * Collapse the selection.\r\n   */ collapse: function collapse(editor) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        var _options$edge = options.edge, edge = _options$edge === void 0 ? \"anchor\" : _options$edge;\n        var selection = editor.selection;\n        if (!selection) {\n            return;\n        } else if (edge === \"anchor\") {\n            Transforms.select(editor, selection.anchor);\n        } else if (edge === \"focus\") {\n            Transforms.select(editor, selection.focus);\n        } else if (edge === \"start\") {\n            var _Range$edges = Range.edges(selection), _Range$edges2 = _slicedToArray(_Range$edges, 1), start = _Range$edges2[0];\n            Transforms.select(editor, start);\n        } else if (edge === \"end\") {\n            var _Range$edges3 = Range.edges(selection), _Range$edges4 = _slicedToArray(_Range$edges3, 2), end = _Range$edges4[1];\n            Transforms.select(editor, end);\n        }\n    },\n    /**\r\n   * Unset the selection.\r\n   */ deselect: function deselect(editor) {\n        var selection = editor.selection;\n        if (selection) {\n            editor.apply({\n                type: \"set_selection\",\n                properties: selection,\n                newProperties: null\n            });\n        }\n    },\n    /**\r\n   * Move the selection's point forward or backward.\r\n   */ move: function move(editor) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        var selection = editor.selection;\n        var _options$distance = options.distance, distance = _options$distance === void 0 ? 1 : _options$distance, _options$unit = options.unit, unit = _options$unit === void 0 ? \"character\" : _options$unit, _options$reverse = options.reverse, reverse = _options$reverse === void 0 ? false : _options$reverse;\n        var _options$edge2 = options.edge, edge = _options$edge2 === void 0 ? null : _options$edge2;\n        if (!selection) {\n            return;\n        }\n        if (edge === \"start\") {\n            edge = Range.isBackward(selection) ? \"focus\" : \"anchor\";\n        }\n        if (edge === \"end\") {\n            edge = Range.isBackward(selection) ? \"anchor\" : \"focus\";\n        }\n        var anchor = selection.anchor, focus = selection.focus;\n        var opts = {\n            distance: distance,\n            unit: unit\n        };\n        var props = {};\n        if (edge == null || edge === \"anchor\") {\n            var point = reverse ? Editor.before(editor, anchor, opts) : Editor.after(editor, anchor, opts);\n            if (point) {\n                props.anchor = point;\n            }\n        }\n        if (edge == null || edge === \"focus\") {\n            var _point = reverse ? Editor.before(editor, focus, opts) : Editor.after(editor, focus, opts);\n            if (_point) {\n                props.focus = _point;\n            }\n        }\n        Transforms.setSelection(editor, props);\n    },\n    /**\r\n   * Set the selection to a new value.\r\n   */ select: function select(editor, target) {\n        var selection = editor.selection;\n        target = Editor.range(editor, target);\n        if (selection) {\n            Transforms.setSelection(editor, target);\n            return;\n        }\n        if (!Range.isRange(target)) {\n            throw new Error(\"When setting the selection and the current selection is `null` you must provide at least an `anchor` and `focus`, but you passed: \".concat(Scrubber.stringify(target)));\n        }\n        editor.apply({\n            type: \"set_selection\",\n            properties: selection,\n            newProperties: target\n        });\n    },\n    /**\r\n   * Set new properties on one of the selection's points.\r\n   */ setPoint: function setPoint(editor, props) {\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        var selection = editor.selection;\n        var _options$edge3 = options.edge, edge = _options$edge3 === void 0 ? \"both\" : _options$edge3;\n        if (!selection) {\n            return;\n        }\n        if (edge === \"start\") {\n            edge = Range.isBackward(selection) ? \"focus\" : \"anchor\";\n        }\n        if (edge === \"end\") {\n            edge = Range.isBackward(selection) ? \"anchor\" : \"focus\";\n        }\n        var anchor = selection.anchor, focus = selection.focus;\n        var point = edge === \"anchor\" ? anchor : focus;\n        Transforms.setSelection(editor, _defineProperty({}, edge === \"anchor\" ? \"anchor\" : \"focus\", _objectSpread$1(_objectSpread$1({}, point), props)));\n    },\n    /**\r\n   * Set new properties on the selection.\r\n   */ setSelection: function setSelection(editor, props) {\n        var selection = editor.selection;\n        var oldProps = {};\n        var newProps = {};\n        if (!selection) {\n            return;\n        }\n        for(var k in props){\n            if (k === \"anchor\" && props.anchor != null && !Point.equals(props.anchor, selection.anchor) || k === \"focus\" && props.focus != null && !Point.equals(props.focus, selection.focus) || k !== \"anchor\" && k !== \"focus\" && props[k] !== selection[k]) {\n                oldProps[k] = selection[k];\n                newProps[k] = props[k];\n            }\n        }\n        if (Object.keys(oldProps).length > 0) {\n            editor.apply({\n                type: \"set_selection\",\n                properties: oldProps,\n                newProperties: newProps\n            });\n        }\n    }\n};\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n    var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n    if (!it) {\n        if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n            if (it) o = it;\n            var i = 0;\n            var F = function F() {};\n            return {\n                s: F,\n                n: function n() {\n                    if (i >= o.length) return {\n                        done: true\n                    };\n                    return {\n                        done: false,\n                        value: o[i++]\n                    };\n                },\n                e: function e(_e) {\n                    throw _e;\n                },\n                f: F\n            };\n        }\n        throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n    }\n    var normalCompletion = true, didErr = false, err;\n    return {\n        s: function s() {\n            it = it.call(o);\n        },\n        n: function n() {\n            var step = it.next();\n            normalCompletion = step.done;\n            return step;\n        },\n        e: function e(_e2) {\n            didErr = true;\n            err = _e2;\n        },\n        f: function f() {\n            try {\n                if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n            } finally{\n                if (didErr) throw err;\n            }\n        }\n    };\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(o);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++){\n        arr2[i] = arr[i];\n    }\n    return arr2;\n}\nvar TextTransforms = {\n    /**\r\n   * Delete content in the editor.\r\n   */ \"delete\": function _delete(editor) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        Editor.withoutNormalizing(editor, function() {\n            var _options$reverse = options.reverse, reverse = _options$reverse === void 0 ? false : _options$reverse, _options$unit = options.unit, unit = _options$unit === void 0 ? \"character\" : _options$unit, _options$distance = options.distance, distance = _options$distance === void 0 ? 1 : _options$distance, _options$voids = options.voids, voids = _options$voids === void 0 ? false : _options$voids;\n            var _options$at = options.at, at = _options$at === void 0 ? editor.selection : _options$at, _options$hanging = options.hanging, hanging = _options$hanging === void 0 ? false : _options$hanging;\n            if (!at) {\n                return;\n            }\n            var isCollapsed = false;\n            if (Range.isRange(at) && Range.isCollapsed(at)) {\n                isCollapsed = true;\n                at = at.anchor;\n            }\n            if (Point.isPoint(at)) {\n                var furthestVoid = Editor[\"void\"](editor, {\n                    at: at,\n                    mode: \"highest\"\n                });\n                if (!voids && furthestVoid) {\n                    var _furthestVoid = _slicedToArray(furthestVoid, 2), voidPath = _furthestVoid[1];\n                    at = voidPath;\n                } else {\n                    var opts = {\n                        unit: unit,\n                        distance: distance\n                    };\n                    var target = reverse ? Editor.before(editor, at, opts) || Editor.start(editor, []) : Editor.after(editor, at, opts) || Editor.end(editor, []);\n                    at = {\n                        anchor: at,\n                        focus: target\n                    };\n                    hanging = true;\n                }\n            }\n            if (Path.isPath(at)) {\n                Transforms.removeNodes(editor, {\n                    at: at,\n                    voids: voids\n                });\n                return;\n            }\n            if (Range.isCollapsed(at)) {\n                return;\n            }\n            if (!hanging) {\n                var _Range$edges = Range.edges(at), _Range$edges2 = _slicedToArray(_Range$edges, 2), _end = _Range$edges2[1];\n                var endOfDoc = Editor.end(editor, []);\n                if (!Point.equals(_end, endOfDoc)) {\n                    at = Editor.unhangRange(editor, at, {\n                        voids: voids\n                    });\n                }\n            }\n            var _Range$edges3 = Range.edges(at), _Range$edges4 = _slicedToArray(_Range$edges3, 2), start = _Range$edges4[0], end = _Range$edges4[1];\n            var startBlock = Editor.above(editor, {\n                match: function match(n) {\n                    return Element.isElement(n) && Editor.isBlock(editor, n);\n                },\n                at: start,\n                voids: voids\n            });\n            var endBlock = Editor.above(editor, {\n                match: function match(n) {\n                    return Element.isElement(n) && Editor.isBlock(editor, n);\n                },\n                at: end,\n                voids: voids\n            });\n            var isAcrossBlocks = startBlock && endBlock && !Path.equals(startBlock[1], endBlock[1]);\n            var isSingleText = Path.equals(start.path, end.path);\n            var startVoid = voids ? null : Editor[\"void\"](editor, {\n                at: start,\n                mode: \"highest\"\n            });\n            var endVoid = voids ? null : Editor[\"void\"](editor, {\n                at: end,\n                mode: \"highest\"\n            }); // If the start or end points are inside an inline void, nudge them out.\n            if (startVoid) {\n                var before = Editor.before(editor, start);\n                if (before && startBlock && Path.isAncestor(startBlock[1], before.path)) {\n                    start = before;\n                }\n            }\n            if (endVoid) {\n                var after = Editor.after(editor, end);\n                if (after && endBlock && Path.isAncestor(endBlock[1], after.path)) {\n                    end = after;\n                }\n            } // Get the highest nodes that are completely inside the range, as well as\n            // the start and end nodes.\n            var matches = [];\n            var lastPath;\n            var _iterator = _createForOfIteratorHelper(Editor.nodes(editor, {\n                at: at,\n                voids: voids\n            })), _step;\n            try {\n                for(_iterator.s(); !(_step = _iterator.n()).done;){\n                    var entry = _step.value;\n                    var _entry = _slicedToArray(entry, 2), _node2 = _entry[0], _path2 = _entry[1];\n                    if (lastPath && Path.compare(_path2, lastPath) === 0) {\n                        continue;\n                    }\n                    if (!voids && Element.isElement(_node2) && Editor.isVoid(editor, _node2) || !Path.isCommon(_path2, start.path) && !Path.isCommon(_path2, end.path)) {\n                        matches.push(entry);\n                        lastPath = _path2;\n                    }\n                }\n            } catch (err) {\n                _iterator.e(err);\n            } finally{\n                _iterator.f();\n            }\n            var pathRefs = Array.from(matches, function(_ref) {\n                var _ref2 = _slicedToArray(_ref, 2), p = _ref2[1];\n                return Editor.pathRef(editor, p);\n            });\n            var startRef = Editor.pointRef(editor, start);\n            var endRef = Editor.pointRef(editor, end);\n            var removedText = \"\";\n            if (!isSingleText && !startVoid) {\n                var _point = startRef.current;\n                var _Editor$leaf = Editor.leaf(editor, _point), _Editor$leaf2 = _slicedToArray(_Editor$leaf, 1), node = _Editor$leaf2[0];\n                var path = _point.path;\n                var _start = start, offset = _start.offset;\n                var text = node.text.slice(offset);\n                if (text.length > 0) {\n                    editor.apply({\n                        type: \"remove_text\",\n                        path: path,\n                        offset: offset,\n                        text: text\n                    });\n                    removedText = text;\n                }\n            }\n            pathRefs.reverse().map(function(r) {\n                return r.unref();\n            }).filter(function(r) {\n                return r !== null;\n            }).forEach(function(p) {\n                return Transforms.removeNodes(editor, {\n                    at: p,\n                    voids: voids\n                });\n            });\n            if (!endVoid) {\n                var _point2 = endRef.current;\n                var _Editor$leaf3 = Editor.leaf(editor, _point2), _Editor$leaf4 = _slicedToArray(_Editor$leaf3, 1), _node = _Editor$leaf4[0];\n                var _path = _point2.path;\n                var _offset = isSingleText ? start.offset : 0;\n                var _text = _node.text.slice(_offset, end.offset);\n                if (_text.length > 0) {\n                    editor.apply({\n                        type: \"remove_text\",\n                        path: _path,\n                        offset: _offset,\n                        text: _text\n                    });\n                    removedText = _text;\n                }\n            }\n            if (!isSingleText && isAcrossBlocks && endRef.current && startRef.current) {\n                Transforms.mergeNodes(editor, {\n                    at: endRef.current,\n                    hanging: true,\n                    voids: voids\n                });\n            } // For Thai script, deleting N character(s) backward should delete\n            // N code point(s) instead of an entire grapheme cluster.\n            // Therefore, the remaining code points should be inserted back.\n            if (isCollapsed && reverse && unit === \"character\" && removedText.length > 1 && removedText.match(/[\\u0E00-\\u0E7F]+/)) {\n                Transforms.insertText(editor, removedText.slice(0, removedText.length - distance));\n            }\n            var startUnref = startRef.unref();\n            var endUnref = endRef.unref();\n            var point = reverse ? startUnref || endUnref : endUnref || startUnref;\n            if (options.at == null && point) {\n                Transforms.select(editor, point);\n            }\n        });\n    },\n    /**\r\n   * Insert a fragment at a specific location in the editor.\r\n   */ insertFragment: function insertFragment(editor, fragment) {\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        Editor.withoutNormalizing(editor, function() {\n            var _options$hanging2 = options.hanging, hanging = _options$hanging2 === void 0 ? false : _options$hanging2, _options$voids2 = options.voids, voids = _options$voids2 === void 0 ? false : _options$voids2;\n            var _options$at2 = options.at, at = _options$at2 === void 0 ? editor.selection : _options$at2;\n            if (!fragment.length) {\n                return;\n            }\n            if (!at) {\n                return;\n            } else if (Range.isRange(at)) {\n                if (!hanging) {\n                    at = Editor.unhangRange(editor, at, {\n                        voids: voids\n                    });\n                }\n                if (Range.isCollapsed(at)) {\n                    at = at.anchor;\n                } else {\n                    var _Range$edges5 = Range.edges(at), _Range$edges6 = _slicedToArray(_Range$edges5, 2), end = _Range$edges6[1];\n                    if (!voids && Editor[\"void\"](editor, {\n                        at: end\n                    })) {\n                        return;\n                    }\n                    var pointRef = Editor.pointRef(editor, end);\n                    Transforms[\"delete\"](editor, {\n                        at: at\n                    });\n                    at = pointRef.unref();\n                }\n            } else if (Path.isPath(at)) {\n                at = Editor.start(editor, at);\n            }\n            if (!voids && Editor[\"void\"](editor, {\n                at: at\n            })) {\n                return;\n            } // If the insert point is at the edge of an inline node, move it outside\n            // instead since it will need to be split otherwise.\n            var inlineElementMatch = Editor.above(editor, {\n                at: at,\n                match: function match(n) {\n                    return Element.isElement(n) && Editor.isInline(editor, n);\n                },\n                mode: \"highest\",\n                voids: voids\n            });\n            if (inlineElementMatch) {\n                var _inlineElementMatch = _slicedToArray(inlineElementMatch, 2), _inlinePath = _inlineElementMatch[1];\n                if (Editor.isEnd(editor, at, _inlinePath)) {\n                    var after = Editor.after(editor, _inlinePath);\n                    at = after;\n                } else if (Editor.isStart(editor, at, _inlinePath)) {\n                    var before = Editor.before(editor, _inlinePath);\n                    at = before;\n                }\n            }\n            var blockMatch = Editor.above(editor, {\n                match: function match(n) {\n                    return Element.isElement(n) && Editor.isBlock(editor, n);\n                },\n                at: at,\n                voids: voids\n            });\n            var _blockMatch = _slicedToArray(blockMatch, 2), blockPath = _blockMatch[1];\n            var isBlockStart = Editor.isStart(editor, at, blockPath);\n            var isBlockEnd = Editor.isEnd(editor, at, blockPath);\n            var isBlockEmpty = isBlockStart && isBlockEnd;\n            var mergeStart = !isBlockStart || isBlockStart && isBlockEnd;\n            var mergeEnd = !isBlockEnd;\n            var _Node$first = Node.first({\n                children: fragment\n            }, []), _Node$first2 = _slicedToArray(_Node$first, 2), firstPath = _Node$first2[1];\n            var _Node$last = Node.last({\n                children: fragment\n            }, []), _Node$last2 = _slicedToArray(_Node$last, 2), lastPath = _Node$last2[1];\n            var matches = [];\n            var matcher = function matcher(_ref3) {\n                var _ref4 = _slicedToArray(_ref3, 2), n = _ref4[0], p = _ref4[1];\n                var isRoot = p.length === 0;\n                if (isRoot) {\n                    return false;\n                }\n                if (isBlockEmpty) {\n                    return true;\n                }\n                if (mergeStart && Path.isAncestor(p, firstPath) && Element.isElement(n) && !editor.isVoid(n) && !editor.isInline(n)) {\n                    return false;\n                }\n                if (mergeEnd && Path.isAncestor(p, lastPath) && Element.isElement(n) && !editor.isVoid(n) && !editor.isInline(n)) {\n                    return false;\n                }\n                return true;\n            };\n            var _iterator2 = _createForOfIteratorHelper(Node.nodes({\n                children: fragment\n            }, {\n                pass: matcher\n            })), _step2;\n            try {\n                for(_iterator2.s(); !(_step2 = _iterator2.n()).done;){\n                    var entry = _step2.value;\n                    if (matcher(entry)) {\n                        matches.push(entry);\n                    }\n                }\n            } catch (err) {\n                _iterator2.e(err);\n            } finally{\n                _iterator2.f();\n            }\n            var starts = [];\n            var middles = [];\n            var ends = [];\n            var starting = true;\n            var hasBlocks = false;\n            for(var _i = 0, _matches = matches; _i < _matches.length; _i++){\n                var _matches$_i = _slicedToArray(_matches[_i], 1), node = _matches$_i[0];\n                if (Element.isElement(node) && !editor.isInline(node)) {\n                    starting = false;\n                    hasBlocks = true;\n                    middles.push(node);\n                } else if (starting) {\n                    starts.push(node);\n                } else {\n                    ends.push(node);\n                }\n            }\n            var _Editor$nodes = Editor.nodes(editor, {\n                at: at,\n                match: function match(n) {\n                    return Text.isText(n) || Editor.isInline(editor, n);\n                },\n                mode: \"highest\",\n                voids: voids\n            }), _Editor$nodes2 = _slicedToArray(_Editor$nodes, 1), inlineMatch = _Editor$nodes2[0];\n            var _inlineMatch = _slicedToArray(inlineMatch, 2), inlinePath = _inlineMatch[1];\n            var isInlineStart = Editor.isStart(editor, at, inlinePath);\n            var isInlineEnd = Editor.isEnd(editor, at, inlinePath);\n            var middleRef = Editor.pathRef(editor, isBlockEnd && !ends.length ? Path.next(blockPath) : blockPath);\n            var endRef = Editor.pathRef(editor, isInlineEnd ? Path.next(inlinePath) : inlinePath);\n            Transforms.splitNodes(editor, {\n                at: at,\n                match: function match(n) {\n                    return hasBlocks ? Element.isElement(n) && Editor.isBlock(editor, n) : Text.isText(n) || Editor.isInline(editor, n);\n                },\n                mode: hasBlocks ? \"lowest\" : \"highest\",\n                always: hasBlocks && (!isBlockStart || starts.length > 0) && (!isBlockEnd || ends.length > 0),\n                voids: voids\n            });\n            var startRef = Editor.pathRef(editor, !isInlineStart || isInlineStart && isInlineEnd ? Path.next(inlinePath) : inlinePath);\n            Transforms.insertNodes(editor, starts, {\n                at: startRef.current,\n                match: function match(n) {\n                    return Text.isText(n) || Editor.isInline(editor, n);\n                },\n                mode: \"highest\",\n                voids: voids\n            });\n            if (isBlockEmpty && !starts.length && middles.length && !ends.length) {\n                Transforms[\"delete\"](editor, {\n                    at: blockPath,\n                    voids: voids\n                });\n            }\n            Transforms.insertNodes(editor, middles, {\n                at: middleRef.current,\n                match: function match(n) {\n                    return Element.isElement(n) && Editor.isBlock(editor, n);\n                },\n                mode: \"lowest\",\n                voids: voids\n            });\n            Transforms.insertNodes(editor, ends, {\n                at: endRef.current,\n                match: function match(n) {\n                    return Text.isText(n) || Editor.isInline(editor, n);\n                },\n                mode: \"highest\",\n                voids: voids\n            });\n            if (!options.at) {\n                var path;\n                if (ends.length > 0 && endRef.current) {\n                    path = Path.previous(endRef.current);\n                } else if (middles.length > 0 && middleRef.current) {\n                    path = Path.previous(middleRef.current);\n                } else if (startRef.current) {\n                    path = Path.previous(startRef.current);\n                }\n                if (path) {\n                    var _end2 = Editor.end(editor, path);\n                    Transforms.select(editor, _end2);\n                }\n            }\n            startRef.unref();\n            middleRef.unref();\n            endRef.unref();\n        });\n    },\n    /**\r\n   * Insert a string of text in the Editor.\r\n   */ insertText: function insertText(editor, text) {\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        Editor.withoutNormalizing(editor, function() {\n            var _options$voids3 = options.voids, voids = _options$voids3 === void 0 ? false : _options$voids3;\n            var _options$at3 = options.at, at = _options$at3 === void 0 ? editor.selection : _options$at3;\n            if (!at) {\n                return;\n            }\n            if (Path.isPath(at)) {\n                at = Editor.range(editor, at);\n            }\n            if (Range.isRange(at)) {\n                if (Range.isCollapsed(at)) {\n                    at = at.anchor;\n                } else {\n                    var end = Range.end(at);\n                    if (!voids && Editor[\"void\"](editor, {\n                        at: end\n                    })) {\n                        return;\n                    }\n                    var start = Range.start(at);\n                    var startRef = Editor.pointRef(editor, start);\n                    var endRef = Editor.pointRef(editor, end);\n                    Transforms[\"delete\"](editor, {\n                        at: at,\n                        voids: voids\n                    });\n                    var startPoint = startRef.unref();\n                    var endPoint = endRef.unref();\n                    at = startPoint || endPoint;\n                    Transforms.setSelection(editor, {\n                        anchor: at,\n                        focus: at\n                    });\n                }\n            }\n            if (!voids && Editor[\"void\"](editor, {\n                at: at\n            })) {\n                return;\n            }\n            var _at = at, path = _at.path, offset = _at.offset;\n            if (text.length > 0) editor.apply({\n                type: \"insert_text\",\n                path: path,\n                offset: offset,\n                text: text\n            });\n        });\n    }\n};\nfunction ownKeys(object, enumerableOnly) {\n    var keys = Object.keys(object);\n    if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        if (enumerableOnly) {\n            symbols = symbols.filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n            });\n        }\n        keys.push.apply(keys, symbols);\n    }\n    return keys;\n}\nfunction _objectSpread(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = arguments[i] != null ? arguments[i] : {};\n        if (i % 2) {\n            ownKeys(Object(source), true).forEach(function(key) {\n                _defineProperty(target, key, source[key]);\n            });\n        } else if (Object.getOwnPropertyDescriptors) {\n            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n        } else {\n            ownKeys(Object(source)).forEach(function(key) {\n                Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n            });\n        }\n    }\n    return target;\n}\nvar Transforms = _objectSpread(_objectSpread(_objectSpread(_objectSpread({}, GeneralTransforms), NodeTransforms), SelectionTransforms), TextTransforms);\nexports.Editor = Editor;\nexports.Element = Element;\nexports.Location = Location;\nexports.Node = Node;\nexports.Operation = Operation;\nexports.Path = Path;\nexports.PathRef = PathRef;\nexports.Point = Point;\nexports.PointRef = PointRef;\nexports.Range = Range;\nexports.RangeRef = RangeRef;\nexports.Scrubber = Scrubber;\nexports.Span = Span;\nexports.Text = Text;\nexports.Transforms = Transforms;\nexports.createEditor = createEditor; //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2xhdGUvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUU3RCxJQUFJQyxnQkFBZ0JDLG1CQUFPQSxDQUFDO0FBQzVCLElBQUlDLFFBQVFELG1CQUFPQSxDQUFDO0FBRXBCLFNBQVNFLGNBQWVDLENBQUM7SUFDeEIsT0FBT0EsS0FBS0EsRUFBRUMsVUFBVSxJQUFJVCxPQUFPVSxTQUFTLENBQUNDLGNBQWMsQ0FBQ0MsSUFBSSxDQUFDSixHQUFHLGFBQWFBLENBQUMsQ0FBQyxVQUFVLEdBQUdBO0FBQ2pHO0FBRUEsU0FBU0sscUJBQXFCQyxFQUFFLEVBQUVDLE1BQU07SUFDdkMsT0FBT0EsU0FBUztRQUFFYixTQUFTLENBQUM7SUFBRSxHQUFHWSxHQUFHQyxRQUFRQSxPQUFPYixPQUFPLEdBQUdhLE9BQU9iLE9BQU87QUFDNUU7QUFFQSxJQUFJYyxtQkFBbUJILHFCQUFxQixTQUFVRSxNQUFNO0lBQzVELFNBQVNFLGtCQUFrQkMsR0FBRyxFQUFFQyxHQUFHO1FBQ2pDLElBQUlBLE9BQU8sUUFBUUEsTUFBTUQsSUFBSUUsTUFBTSxFQUFFRCxNQUFNRCxJQUFJRSxNQUFNO1FBRXJELElBQUssSUFBSUMsSUFBSSxHQUFHQyxPQUFPLElBQUlDLE1BQU1KLE1BQU1FLElBQUlGLEtBQUtFLElBQUs7WUFDbkRDLElBQUksQ0FBQ0QsRUFBRSxHQUFHSCxHQUFHLENBQUNHLEVBQUU7UUFDbEI7UUFFQSxPQUFPQztJQUNUO0lBRUFQLE9BQU9iLE9BQU8sR0FBR2U7SUFDakJGLE9BQU9iLE9BQU8sQ0FBQyxVQUFVLEdBQUdhLE9BQU9iLE9BQU8sRUFBRWEsT0FBT2IsT0FBTyxDQUFDTyxVQUFVLEdBQUc7QUFDeEU7QUFFQUYsY0FBY1M7QUFFZCxJQUFJUSxvQkFBb0JYLHFCQUFxQixTQUFVRSxNQUFNO0lBQzdELFNBQVNVLG1CQUFtQlAsR0FBRztRQUM3QixJQUFJSyxNQUFNRyxPQUFPLENBQUNSLE1BQU0sT0FBT0YsaUJBQWlCRTtJQUNsRDtJQUVBSCxPQUFPYixPQUFPLEdBQUd1QjtJQUNqQlYsT0FBT2IsT0FBTyxDQUFDLFVBQVUsR0FBR2EsT0FBT2IsT0FBTyxFQUFFYSxPQUFPYixPQUFPLENBQUNPLFVBQVUsR0FBRztBQUN4RTtBQUVBRixjQUFjaUI7QUFFZCxJQUFJRyxrQkFBa0JkLHFCQUFxQixTQUFVRSxNQUFNO0lBQzNELFNBQVNhLGlCQUFpQkMsSUFBSTtRQUM1QixJQUFJLE9BQU9DLFdBQVcsZUFBZUQsSUFBSSxDQUFDQyxPQUFPQyxRQUFRLENBQUMsSUFBSSxRQUFRRixJQUFJLENBQUMsYUFBYSxJQUFJLE1BQU0sT0FBT04sTUFBTVMsSUFBSSxDQUFDSDtJQUN0SDtJQUVBZCxPQUFPYixPQUFPLEdBQUcwQjtJQUNqQmIsT0FBT2IsT0FBTyxDQUFDLFVBQVUsR0FBR2EsT0FBT2IsT0FBTyxFQUFFYSxPQUFPYixPQUFPLENBQUNPLFVBQVUsR0FBRztBQUN4RTtBQUVBRixjQUFjb0I7QUFFZCxJQUFJTSw2QkFBNkJwQixxQkFBcUIsU0FBVUUsTUFBTTtJQUN0RSxTQUFTbUIsNEJBQTRCQyxDQUFDLEVBQUVDLE1BQU07UUFDNUMsSUFBSSxDQUFDRCxHQUFHO1FBQ1IsSUFBSSxPQUFPQSxNQUFNLFVBQVUsT0FBT25CLGlCQUFpQm1CLEdBQUdDO1FBQ3RELElBQUlDLElBQUlyQyxPQUFPVSxTQUFTLENBQUM0QixRQUFRLENBQUMxQixJQUFJLENBQUN1QixHQUFHSSxLQUFLLENBQUMsR0FBRyxDQUFDO1FBQ3BELElBQUlGLE1BQU0sWUFBWUYsRUFBRUssV0FBVyxFQUFFSCxJQUFJRixFQUFFSyxXQUFXLENBQUNDLElBQUk7UUFDM0QsSUFBSUosTUFBTSxTQUFTQSxNQUFNLE9BQU8sT0FBT2QsTUFBTVMsSUFBSSxDQUFDRztRQUNsRCxJQUFJRSxNQUFNLGVBQWUsMkNBQTJDSyxJQUFJLENBQUNMLElBQUksT0FBT3JCLGlCQUFpQm1CLEdBQUdDO0lBQzFHO0lBRUFyQixPQUFPYixPQUFPLEdBQUdnQztJQUNqQm5CLE9BQU9iLE9BQU8sQ0FBQyxVQUFVLEdBQUdhLE9BQU9iLE9BQU8sRUFBRWEsT0FBT2IsT0FBTyxDQUFDTyxVQUFVLEdBQUc7QUFDeEU7QUFFQUYsY0FBYzBCO0FBRWQsSUFBSVUsb0JBQW9COUIscUJBQXFCLFNBQVVFLE1BQU07SUFDN0QsU0FBUzZCO1FBQ1AsTUFBTSxJQUFJQyxVQUFVO0lBQ3RCO0lBRUE5QixPQUFPYixPQUFPLEdBQUcwQztJQUNqQjdCLE9BQU9iLE9BQU8sQ0FBQyxVQUFVLEdBQUdhLE9BQU9iLE9BQU8sRUFBRWEsT0FBT2IsT0FBTyxDQUFDTyxVQUFVLEdBQUc7QUFDeEU7QUFFQUYsY0FBY29DO0FBRWQsSUFBSUcsb0JBQW9CakMscUJBQXFCLFNBQVVFLE1BQU07SUFDN0QsU0FBU2dDLG1CQUFtQjdCLEdBQUc7UUFDN0IsT0FBT00sa0JBQWtCTixRQUFRUyxnQkFBZ0JULFFBQVFlLDJCQUEyQmYsUUFBUXlCO0lBQzlGO0lBRUE1QixPQUFPYixPQUFPLEdBQUc2QztJQUNqQmhDLE9BQU9iLE9BQU8sQ0FBQyxVQUFVLEdBQUdhLE9BQU9iLE9BQU8sRUFBRWEsT0FBT2IsT0FBTyxDQUFDTyxVQUFVLEdBQUc7QUFDeEU7QUFFQSxJQUFJc0MscUJBQXFCeEMsY0FBY3VDO0FBRXZDLElBQUk3QyxpQkFBaUJZLHFCQUFxQixTQUFVRSxNQUFNO0lBQzFELFNBQVNpQyxnQkFBZ0JDLEdBQUcsRUFBRUMsR0FBRyxFQUFFL0MsS0FBSztRQUN0QyxJQUFJK0MsT0FBT0QsS0FBSztZQUNkakQsT0FBT0MsY0FBYyxDQUFDZ0QsS0FBS0MsS0FBSztnQkFDOUIvQyxPQUFPQTtnQkFDUGdELFlBQVk7Z0JBQ1pDLGNBQWM7Z0JBQ2RDLFVBQVU7WUFDWjtRQUNGLE9BQU87WUFDTEosR0FBRyxDQUFDQyxJQUFJLEdBQUcvQztRQUNiO1FBRUEsT0FBTzhDO0lBQ1Q7SUFFQWxDLE9BQU9iLE9BQU8sR0FBRzhDO0lBQ2pCakMsT0FBT2IsT0FBTyxDQUFDLFVBQVUsR0FBR2EsT0FBT2IsT0FBTyxFQUFFYSxPQUFPYixPQUFPLENBQUNPLFVBQVUsR0FBRztBQUN4RTtBQUVBLElBQUl1QyxrQkFBa0J6QyxjQUFjTjtBQUVwQyxJQUFJcUQsaUJBQWlCekMscUJBQXFCLFNBQVVFLE1BQU07SUFDMUQsU0FBU3dDLGdCQUFnQnJDLEdBQUc7UUFDMUIsSUFBSUssTUFBTUcsT0FBTyxDQUFDUixNQUFNLE9BQU9BO0lBQ2pDO0lBRUFILE9BQU9iLE9BQU8sR0FBR3FEO0lBQ2pCeEMsT0FBT2IsT0FBTyxDQUFDLFVBQVUsR0FBR2EsT0FBT2IsT0FBTyxFQUFFYSxPQUFPYixPQUFPLENBQUNPLFVBQVUsR0FBRztBQUN4RTtBQUVBRixjQUFjK0M7QUFFZCxJQUFJRSx1QkFBdUIzQyxxQkFBcUIsU0FBVUUsTUFBTTtJQUNoRSxTQUFTMEMsc0JBQXNCdkMsR0FBRyxFQUFFRyxDQUFDO1FBQ25DLElBQUlxQyxLQUFLeEMsT0FBTyxPQUFPLE9BQU8sT0FBT1ksV0FBVyxlQUFlWixHQUFHLENBQUNZLE9BQU9DLFFBQVEsQ0FBQyxJQUFJYixHQUFHLENBQUMsYUFBYTtRQUV4RyxJQUFJd0MsTUFBTSxNQUFNO1FBQ2hCLElBQUlDLE9BQU8sRUFBRTtRQUNiLElBQUlDLEtBQUs7UUFDVCxJQUFJQyxLQUFLO1FBRVQsSUFBSUMsSUFBSUM7UUFFUixJQUFJO1lBQ0YsSUFBS0wsS0FBS0EsR0FBRzlDLElBQUksQ0FBQ00sTUFBTSxDQUFFMEMsQ0FBQUEsS0FBSyxDQUFDRSxLQUFLSixHQUFHTSxJQUFJLEVBQUMsRUFBR0MsSUFBSSxHQUFHTCxLQUFLLEtBQU07Z0JBQ2hFRCxLQUFLTyxJQUFJLENBQUNKLEdBQUczRCxLQUFLO2dCQUVsQixJQUFJa0IsS0FBS3NDLEtBQUt2QyxNQUFNLEtBQUtDLEdBQUc7WUFDOUI7UUFDRixFQUFFLE9BQU84QyxLQUFLO1lBQ1pOLEtBQUs7WUFDTEUsS0FBS0k7UUFDUCxTQUFVO1lBQ1IsSUFBSTtnQkFDRixJQUFJLENBQUNQLE1BQU1GLEVBQUUsQ0FBQyxTQUFTLElBQUksTUFBTUEsRUFBRSxDQUFDLFNBQVM7WUFDL0MsU0FBVTtnQkFDUixJQUFJRyxJQUFJLE1BQU1FO1lBQ2hCO1FBQ0Y7UUFFQSxPQUFPSjtJQUNUO0lBRUE1QyxPQUFPYixPQUFPLEdBQUd1RDtJQUNqQjFDLE9BQU9iLE9BQU8sQ0FBQyxVQUFVLEdBQUdhLE9BQU9iLE9BQU8sRUFBRWEsT0FBT2IsT0FBTyxDQUFDTyxVQUFVLEdBQUc7QUFDeEU7QUFFQUYsY0FBY2lEO0FBRWQsSUFBSVksa0JBQWtCdkQscUJBQXFCLFNBQVVFLE1BQU07SUFDM0QsU0FBU3NEO1FBQ1AsTUFBTSxJQUFJeEIsVUFBVTtJQUN0QjtJQUVBOUIsT0FBT2IsT0FBTyxHQUFHbUU7SUFDakJ0RCxPQUFPYixPQUFPLENBQUMsVUFBVSxHQUFHYSxPQUFPYixPQUFPLEVBQUVhLE9BQU9iLE9BQU8sQ0FBQ08sVUFBVSxHQUFHO0FBQ3hFO0FBRUFGLGNBQWM2RDtBQUVkLElBQUlFLGdCQUFnQnpELHFCQUFxQixTQUFVRSxNQUFNO0lBQ3pELFNBQVN3RCxlQUFlckQsR0FBRyxFQUFFRyxDQUFDO1FBQzVCLE9BQU9pQyxlQUFlcEMsUUFBUXNDLHFCQUFxQnRDLEtBQUtHLE1BQU1ZLDJCQUEyQmYsS0FBS0csTUFBTStDO0lBQ3RHO0lBRUFyRCxPQUFPYixPQUFPLEdBQUdxRTtJQUNqQnhELE9BQU9iLE9BQU8sQ0FBQyxVQUFVLEdBQUdhLE9BQU9iLE9BQU8sRUFBRWEsT0FBT2IsT0FBTyxDQUFDTyxVQUFVLEdBQUc7QUFDeEU7QUFFQSxJQUFJOEQsaUJBQWlCaEUsY0FBYytEO0FBRW5DLElBQUlFLGNBQWMsSUFBSUM7QUFDdEIsSUFBSUMsa0JBQWtCLElBQUlEO0FBQzFCLElBQUlFLFdBQVcsSUFBSUY7QUFDbkIsSUFBSUcsY0FBYyxJQUFJSDtBQUN0QixJQUFJSSxZQUFZLElBQUlKO0FBQ3BCLElBQUlLLGFBQWEsSUFBSUw7QUFDckIsSUFBSU0sYUFBYSxJQUFJTjtBQUVyQixTQUFTTyxVQUFVQyxNQUFNLEVBQUVDLGNBQWM7SUFBSSxJQUFJQyxPQUFPbkYsT0FBT21GLElBQUksQ0FBQ0Y7SUFBUyxJQUFJakYsT0FBT29GLHFCQUFxQixFQUFFO1FBQUUsSUFBSUMsVUFBVXJGLE9BQU9vRixxQkFBcUIsQ0FBQ0g7UUFBUyxJQUFJQyxnQkFBZ0I7WUFBRUcsVUFBVUEsUUFBUUMsTUFBTSxDQUFDLFNBQVVDLEdBQUc7Z0JBQUksT0FBT3ZGLE9BQU93Rix3QkFBd0IsQ0FBQ1AsUUFBUU0sS0FBS3BDLFVBQVU7WUFBRTtRQUFJO1FBQUVnQyxLQUFLakIsSUFBSSxDQUFDdUIsS0FBSyxDQUFDTixNQUFNRTtJQUFVO0lBQUUsT0FBT0Y7QUFBTTtBQUUxVixTQUFTTyxnQkFBZ0JDLE1BQU07SUFBSSxJQUFLLElBQUl0RSxJQUFJLEdBQUdBLElBQUl1RSxVQUFVeEUsTUFBTSxFQUFFQyxJQUFLO1FBQUUsSUFBSXdFLFNBQVNELFNBQVMsQ0FBQ3ZFLEVBQUUsSUFBSSxPQUFPdUUsU0FBUyxDQUFDdkUsRUFBRSxHQUFHLENBQUM7UUFBRyxJQUFJQSxJQUFJLEdBQUc7WUFBRTJELFVBQVVoRixPQUFPNkYsU0FBUyxNQUFNQyxPQUFPLENBQUMsU0FBVTVDLEdBQUc7Z0JBQUlGLGdCQUFnQjJDLFFBQVF6QyxLQUFLMkMsTUFBTSxDQUFDM0MsSUFBSTtZQUFHO1FBQUksT0FBTyxJQUFJbEQsT0FBTytGLHlCQUF5QixFQUFFO1lBQUUvRixPQUFPZ0csZ0JBQWdCLENBQUNMLFFBQVEzRixPQUFPK0YseUJBQXlCLENBQUNGO1FBQVUsT0FBTztZQUFFYixVQUFVaEYsT0FBTzZGLFNBQVNDLE9BQU8sQ0FBQyxTQUFVNUMsR0FBRztnQkFBSWxELE9BQU9DLGNBQWMsQ0FBQzBGLFFBQVF6QyxLQUFLbEQsT0FBT3dGLHdCQUF3QixDQUFDSyxRQUFRM0M7WUFBTztRQUFJO0lBQUU7SUFBRSxPQUFPeUM7QUFBUTtBQUUzaEIsU0FBU00sNkJBQTZCOUQsQ0FBQyxFQUFFK0QsY0FBYztJQUFJLElBQUlDLEtBQUssT0FBT3JFLFdBQVcsZUFBZUssQ0FBQyxDQUFDTCxPQUFPQyxRQUFRLENBQUMsSUFBSUksQ0FBQyxDQUFDLGFBQWE7SUFBRSxJQUFJLENBQUNnRSxJQUFJO1FBQUUsSUFBSTVFLE1BQU1HLE9BQU8sQ0FBQ1MsTUFBT2dFLENBQUFBLEtBQUtDLDhCQUE4QmpFLEVBQUMsS0FBTStELGtCQUFrQi9ELEtBQUssT0FBT0EsRUFBRWYsTUFBTSxLQUFLLFVBQVU7WUFBRSxJQUFJK0UsSUFBSWhFLElBQUlnRTtZQUFJLElBQUk5RSxJQUFJO1lBQUcsSUFBSWdGLElBQUksU0FBU0EsS0FBSztZQUFHLE9BQU87Z0JBQUVDLEdBQUdEO2dCQUFHaEUsR0FBRyxTQUFTQTtvQkFBTSxJQUFJaEIsS0FBS2MsRUFBRWYsTUFBTSxFQUFFLE9BQU87d0JBQUU2QyxNQUFNO29CQUFLO29CQUFHLE9BQU87d0JBQUVBLE1BQU07d0JBQU85RCxPQUFPZ0MsQ0FBQyxDQUFDZCxJQUFJO29CQUFDO2dCQUFHO2dCQUFHa0YsR0FBRyxTQUFTQSxFQUFFeEMsRUFBRTtvQkFBSSxNQUFNQTtnQkFBSTtnQkFBR3lDLEdBQUdIO1lBQUU7UUFBRztRQUFFLE1BQU0sSUFBSXhELFVBQVU7SUFBMEk7SUFBRSxJQUFJNEQsbUJBQW1CLE1BQU1DLFNBQVMsT0FBT3ZDO0lBQUssT0FBTztRQUFFbUMsR0FBRyxTQUFTQTtZQUFNSCxLQUFLQSxHQUFHdkYsSUFBSSxDQUFDdUI7UUFBSTtRQUFHRSxHQUFHLFNBQVNBO1lBQU0sSUFBSXNFLE9BQU9SLEdBQUduQyxJQUFJO1lBQUl5QyxtQkFBbUJFLEtBQUsxQyxJQUFJO1lBQUUsT0FBTzBDO1FBQU07UUFBR0osR0FBRyxTQUFTQSxFQUFFSyxHQUFHO1lBQUlGLFNBQVM7WUFBTXZDLE1BQU15QztRQUFLO1FBQUdKLEdBQUcsU0FBU0E7WUFBTSxJQUFJO2dCQUFFLElBQUksQ0FBQ0Msb0JBQW9CTixFQUFFLENBQUMsU0FBUyxJQUFJLE1BQU1BLEVBQUUsQ0FBQyxTQUFTO1lBQUksU0FBVTtnQkFBRSxJQUFJTyxRQUFRLE1BQU12QztZQUFLO1FBQUU7SUFBRTtBQUFHO0FBRS8rQixTQUFTaUMsOEJBQThCakUsQ0FBQyxFQUFFQyxNQUFNO0lBQUksSUFBSSxDQUFDRCxHQUFHO0lBQVEsSUFBSSxPQUFPQSxNQUFNLFVBQVUsT0FBTzBFLG9CQUFvQjFFLEdBQUdDO0lBQVMsSUFBSUMsSUFBSXJDLE9BQU9VLFNBQVMsQ0FBQzRCLFFBQVEsQ0FBQzFCLElBQUksQ0FBQ3VCLEdBQUdJLEtBQUssQ0FBQyxHQUFHLENBQUM7SUFBSSxJQUFJRixNQUFNLFlBQVlGLEVBQUVLLFdBQVcsRUFBRUgsSUFBSUYsRUFBRUssV0FBVyxDQUFDQyxJQUFJO0lBQUUsSUFBSUosTUFBTSxTQUFTQSxNQUFNLE9BQU8sT0FBT2QsTUFBTVMsSUFBSSxDQUFDRztJQUFJLElBQUlFLE1BQU0sZUFBZSwyQ0FBMkNLLElBQUksQ0FBQ0wsSUFBSSxPQUFPd0Usb0JBQW9CMUUsR0FBR0M7QUFBUztBQUVyYSxTQUFTeUUsb0JBQW9CM0YsR0FBRyxFQUFFQyxHQUFHO0lBQUksSUFBSUEsT0FBTyxRQUFRQSxNQUFNRCxJQUFJRSxNQUFNLEVBQUVELE1BQU1ELElBQUlFLE1BQU07SUFBRSxJQUFLLElBQUlDLElBQUksR0FBR0MsT0FBTyxJQUFJQyxNQUFNSixNQUFNRSxJQUFJRixLQUFLRSxJQUFLO1FBQUVDLElBQUksQ0FBQ0QsRUFBRSxHQUFHSCxHQUFHLENBQUNHLEVBQUU7SUFBRTtJQUFFLE9BQU9DO0FBQU07QUFDeEw7O0NBRUMsR0FFRCxJQUFJd0YsZUFBZSxTQUFTQTtJQUMxQixJQUFJQyxTQUFTO1FBQ1hDLFVBQVUsRUFBRTtRQUNaQyxZQUFZLEVBQUU7UUFDZEMsV0FBVztRQUNYQyxPQUFPO1FBQ1BDLFVBQVUsU0FBU0E7WUFDakIsT0FBTztRQUNUO1FBQ0FDLFFBQVEsU0FBU0E7WUFDZixPQUFPO1FBQ1Q7UUFDQUMsY0FBYyxTQUFTQTtZQUNyQixPQUFPO1FBQ1Q7UUFDQUMsVUFBVSxTQUFTQSxZQUFZO1FBQy9COUIsT0FBTyxTQUFTQSxNQUFNK0IsRUFBRTtZQUN0QixJQUFJQyxZQUFZeEIsNkJBQTZCeUIsT0FBT0MsUUFBUSxDQUFDWixVQUN6RGE7WUFFSixJQUFJO2dCQUNGLElBQUtILFVBQVVuQixDQUFDLElBQUksQ0FBQyxDQUFDc0IsUUFBUUgsVUFBVXBGLENBQUMsRUFBQyxFQUFHNEIsSUFBSSxFQUFHO29CQUNsRCxJQUFJNEQsTUFBTUQsTUFBTXpILEtBQUs7b0JBQ3JCMkgsUUFBUUMsU0FBUyxDQUFDRixLQUFLTDtnQkFDekI7WUFDRixFQUFFLE9BQU9yRCxLQUFLO2dCQUNac0QsVUFBVWxCLENBQUMsQ0FBQ3BDO1lBQ2QsU0FBVTtnQkFDUnNELFVBQVVqQixDQUFDO1lBQ2I7WUFFQSxJQUFJd0IsYUFBYS9CLDZCQUE2QnlCLE9BQU9PLFNBQVMsQ0FBQ2xCLFVBQzNEbUI7WUFFSixJQUFJO2dCQUNGLElBQUtGLFdBQVcxQixDQUFDLElBQUksQ0FBQyxDQUFDNEIsU0FBU0YsV0FBVzNGLENBQUMsRUFBQyxFQUFHNEIsSUFBSSxFQUFHO29CQUNyRCxJQUFJa0UsT0FBT0QsT0FBTy9ILEtBQUs7b0JBQ3ZCaUksU0FBU0wsU0FBUyxDQUFDSSxNQUFNWDtnQkFDM0I7WUFDRixFQUFFLE9BQU9yRCxLQUFLO2dCQUNaNkQsV0FBV3pCLENBQUMsQ0FBQ3BDO1lBQ2YsU0FBVTtnQkFDUjZELFdBQVd4QixDQUFDO1lBQ2Q7WUFFQSxJQUFJNkIsYUFBYXBDLDZCQUE2QnlCLE9BQU9ZLFNBQVMsQ0FBQ3ZCLFVBQzNEd0I7WUFFSixJQUFJO2dCQUNGLElBQUtGLFdBQVcvQixDQUFDLElBQUksQ0FBQyxDQUFDaUMsU0FBU0YsV0FBV2hHLENBQUMsRUFBQyxFQUFHNEIsSUFBSSxFQUFHO29CQUNyRCxJQUFJdUUsUUFBUUQsT0FBT3BJLEtBQUs7b0JBQ3hCc0ksU0FBU1YsU0FBUyxDQUFDUyxPQUFPaEI7Z0JBQzVCO1lBQ0YsRUFBRSxPQUFPckQsS0FBSztnQkFDWmtFLFdBQVc5QixDQUFDLENBQUNwQztZQUNmLFNBQVU7Z0JBQ1JrRSxXQUFXN0IsQ0FBQztZQUNkO1lBRUEsSUFBSWtDLGdCQUFnQmxFLFlBQVltRSxHQUFHLENBQUM1QixXQUFXLEVBQUU7WUFDakQsSUFBSTZCLG1CQUFtQmxFLGdCQUFnQmlFLEdBQUcsQ0FBQzVCLFdBQVcsSUFBSThCO1lBQzFELElBQUlDO1lBQ0osSUFBSUM7WUFFSixJQUFJQyxNQUFNLFNBQVNBLElBQUlDLElBQUk7Z0JBQ3pCLElBQUlBLE1BQU07b0JBQ1IsSUFBSS9GLE1BQU0rRixLQUFLQyxJQUFJLENBQUM7b0JBRXBCLElBQUksQ0FBQ0gsY0FBY0ksR0FBRyxDQUFDakcsTUFBTTt3QkFDM0I2RixjQUFjQyxHQUFHLENBQUM5Rjt3QkFDbEI0RixXQUFXNUUsSUFBSSxDQUFDK0U7b0JBQ2xCO2dCQUNGO1lBQ0Y7WUFFQSxJQUFJRyxLQUFLQyx5QkFBeUIsQ0FBQzdCLEtBQUs7Z0JBQ3RDc0IsYUFBYSxFQUFFO2dCQUNmQyxnQkFBZ0IsSUFBSUY7Z0JBRXBCLElBQUlTLGFBQWFyRCw2QkFBNkJ5QyxnQkFDMUNhO2dCQUVKLElBQUk7b0JBQ0YsSUFBS0QsV0FBV2hELENBQUMsSUFBSSxDQUFDLENBQUNpRCxTQUFTRCxXQUFXakgsQ0FBQyxFQUFDLEVBQUc0QixJQUFJLEVBQUc7d0JBQ3JELElBQUlnRixPQUFPTSxPQUFPcEosS0FBSzt3QkFDdkIsSUFBSXFKLFVBQVVKLEtBQUtyQixTQUFTLENBQUNrQixNQUFNekI7d0JBQ25Dd0IsSUFBSVE7b0JBQ047Z0JBQ0YsRUFBRSxPQUFPckYsS0FBSztvQkFDWm1GLFdBQVcvQyxDQUFDLENBQUNwQztnQkFDZixTQUFVO29CQUNSbUYsV0FBVzlDLENBQUM7Z0JBQ2Q7WUFDRixPQUFPO2dCQUNMc0MsYUFBYUo7Z0JBQ2JLLGdCQUFnQkg7WUFDbEI7WUFFQSxJQUFJYSxnQkFBZ0IxQyxPQUFPMkMsYUFBYSxDQUFDbEM7WUFFekMsSUFBSW1DLGFBQWExRCw2QkFBNkJ3RCxnQkFDMUNHO1lBRUosSUFBSTtnQkFDRixJQUFLRCxXQUFXckQsQ0FBQyxJQUFJLENBQUMsQ0FBQ3NELFNBQVNELFdBQVd0SCxDQUFDLEVBQUMsRUFBRzRCLElBQUksRUFBRztvQkFDckQsSUFBSTRGLFFBQVFELE9BQU96SixLQUFLO29CQUN4QjZJLElBQUlhO2dCQUNOO1lBQ0YsRUFBRSxPQUFPMUYsS0FBSztnQkFDWndGLFdBQVdwRCxDQUFDLENBQUNwQztZQUNmLFNBQVU7Z0JBQ1J3RixXQUFXbkQsQ0FBQztZQUNkO1lBRUFoQyxZQUFZc0YsR0FBRyxDQUFDL0MsUUFBUStCO1lBQ3hCcEUsZ0JBQWdCb0YsR0FBRyxDQUFDL0MsUUFBUWdDO1lBQzVCZ0IsV0FBV2hDLFNBQVMsQ0FBQ2hCLFFBQVFTO1lBQzdCVCxPQUFPRSxVQUFVLENBQUMvQyxJQUFJLENBQUNzRDtZQUN2QkUsT0FBT3NDLFNBQVMsQ0FBQ2pELFFBQVE7Z0JBQ3ZCa0QsV0FBV3pDO1lBQ2IsSUFBSSxvRUFBb0U7WUFFeEUsSUFBSUEsR0FBRzBDLElBQUksS0FBSyxpQkFBaUI7Z0JBQy9CbkQsT0FBT0ksS0FBSyxHQUFHO1lBQ2pCO1lBRUEsSUFBSSxDQUFDeEMsU0FBU2dFLEdBQUcsQ0FBQzVCLFNBQVM7Z0JBQ3pCcEMsU0FBU21GLEdBQUcsQ0FBQy9DLFFBQVE7Z0JBQ3JCb0QsUUFBUUMsT0FBTyxHQUFHQyxJQUFJLENBQUM7b0JBQ3JCMUYsU0FBU21GLEdBQUcsQ0FBQy9DLFFBQVE7b0JBQ3JCQSxPQUFPUSxRQUFRLENBQUM7d0JBQ2QwQyxXQUFXekM7b0JBQ2I7b0JBQ0FULE9BQU9FLFVBQVUsR0FBRyxFQUFFO2dCQUN4QjtZQUNGO1FBQ0Y7UUFDQXFELFNBQVMsU0FBU0EsUUFBUXBILEdBQUcsRUFBRS9DLEtBQUs7WUFDbEMsSUFBSStHLFlBQVlILE9BQU9HLFNBQVM7WUFDNUJILE9BQU9PLFlBQVk7WUFFdkIsSUFBSUosV0FBVztnQkFDYixJQUFJcUQsUUFBUSxTQUFTQSxNQUFNQyxJQUFJLEVBQUV2QixJQUFJO29CQUNuQyxJQUFJLENBQUN3QixLQUFLQyxNQUFNLENBQUNGLE9BQU87d0JBQ3RCLE9BQU8sT0FBTyxvQ0FBb0M7b0JBQ3BEO29CQUVBLElBQUlHLGlCQUFpQmpELE9BQU9rRCxNQUFNLENBQUM3RCxRQUFRa0MsT0FDdkM0QixrQkFBa0J0RyxlQUFlb0csZ0JBQWdCLElBQ2pERyxhQUFhRCxlQUFlLENBQUMsRUFBRTtvQkFDL0JBLGVBQWUsQ0FBQyxFQUFFO29CQUV0QixPQUFPLENBQUM5RCxPQUFPTSxNQUFNLENBQUN5RCxlQUFlL0QsT0FBT08sWUFBWSxDQUFDd0Q7Z0JBQzNEO2dCQUVBLElBQUlDLG9CQUFvQkMsTUFBTUMsVUFBVSxDQUFDL0Q7Z0JBQ3pDLElBQUlnRSw0QkFBNEI7Z0JBRWhDLElBQUksQ0FBQ0gsbUJBQW1CO29CQUN0QixJQUFJSSxlQUFlekQsT0FBTzhDLElBQUksQ0FBQ3pELFFBQVFHLFlBQ25Da0UsZ0JBQWdCN0csZUFBZTRHLGNBQWMsSUFDN0NFLGVBQWVELGFBQWEsQ0FBQyxFQUFFLEVBQy9CRSxlQUFlRixhQUFhLENBQUMsRUFBRTtvQkFFbkMsSUFBSUMsZ0JBQWdCZCxNQUFNYyxjQUFjQyxlQUFlO3dCQUNyRCxJQUFJQyxrQkFBa0I3RCxPQUFPa0QsTUFBTSxDQUFDN0QsUUFBUXVFLGVBQ3hDRSxrQkFBa0JqSCxlQUFlZ0gsaUJBQWlCLElBQ2xEVCxhQUFhVSxlQUFlLENBQUMsRUFBRTt3QkFFbkNOLDRCQUE0QkosY0FBYy9ELE9BQU9PLFlBQVksQ0FBQ3dEO29CQUNoRTtnQkFDRjtnQkFFQSxJQUFJQyxxQkFBcUJHLDJCQUEyQjtvQkFDbERuQixXQUFXMEIsUUFBUSxDQUFDMUUsUUFBUS9ELGdCQUFnQixDQUFDLEdBQUdFLEtBQUsvQyxRQUFRO3dCQUMzRG9LLE9BQU9BO3dCQUNQbUIsT0FBTzt3QkFDUEMsT0FBTztvQkFDVDtnQkFDRixPQUFPO29CQUNMLElBQUl4RSxRQUFRekIsZ0JBQWdCQSxnQkFBZ0IsQ0FBQyxHQUFHZ0MsT0FBT1AsS0FBSyxDQUFDSixXQUFXLENBQUMsSUFBSSxDQUFDLEdBQUcvRCxnQkFBZ0IsQ0FBQyxHQUFHRSxLQUFLL0M7b0JBRTFHNEcsT0FBT0ksS0FBSyxHQUFHQTtvQkFFZixJQUFJLENBQUN4QyxTQUFTZ0UsR0FBRyxDQUFDNUIsU0FBUzt3QkFDekJBLE9BQU9RLFFBQVE7b0JBQ2pCO2dCQUNGO1lBQ0Y7UUFDRjtRQUNBcUUsZ0JBQWdCLFNBQVNBLGVBQWVDLElBQUk7WUFDMUMsSUFBSTNFLFlBQVlILE9BQU9HLFNBQVM7WUFFaEMsSUFBSUEsYUFBYThELE1BQU1jLFdBQVcsQ0FBQzVFLFlBQVk7Z0JBQzdDNkMsVUFBVSxDQUFDLFNBQVMsQ0FBQ2hELFFBQVE7b0JBQzNCOEUsTUFBTUE7b0JBQ05FLFNBQVM7Z0JBQ1g7WUFDRjtRQUNGO1FBQ0FDLGVBQWUsU0FBU0EsY0FBY0gsSUFBSTtZQUN4QyxJQUFJM0UsWUFBWUgsT0FBT0csU0FBUztZQUVoQyxJQUFJQSxhQUFhOEQsTUFBTWMsV0FBVyxDQUFDNUUsWUFBWTtnQkFDN0M2QyxVQUFVLENBQUMsU0FBUyxDQUFDaEQsUUFBUTtvQkFDM0I4RSxNQUFNQTtnQkFDUjtZQUNGO1FBQ0Y7UUFDQUksZ0JBQWdCLFNBQVNBLGVBQWVDLFNBQVM7WUFDL0MsSUFBSWhGLFlBQVlILE9BQU9HLFNBQVM7WUFFaEMsSUFBSUEsYUFBYThELE1BQU1DLFVBQVUsQ0FBQy9ELFlBQVk7Z0JBQzVDNkMsVUFBVSxDQUFDLFNBQVMsQ0FBQ2hELFFBQVE7b0JBQzNCZ0YsU0FBU0csY0FBYztnQkFDekI7WUFDRjtRQUNGO1FBQ0FDLGFBQWEsU0FBU0E7WUFDcEIsSUFBSWpGLFlBQVlILE9BQU9HLFNBQVM7WUFFaEMsSUFBSUEsV0FBVztnQkFDYixPQUFPa0YsS0FBS0MsUUFBUSxDQUFDdEYsUUFBUUc7WUFDL0I7WUFFQSxPQUFPLEVBQUU7UUFDWDtRQUNBb0YsYUFBYSxTQUFTQTtZQUNwQnZDLFdBQVd3QyxVQUFVLENBQUN4RixRQUFRO2dCQUM1QnlGLFFBQVE7WUFDVjtRQUNGO1FBQ0FDLGlCQUFpQixTQUFTQTtZQUN4QjFDLFdBQVd3QyxVQUFVLENBQUN4RixRQUFRO2dCQUM1QnlGLFFBQVE7WUFDVjtRQUNGO1FBQ0FFLGdCQUFnQixTQUFTQSxlQUFlTCxRQUFRO1lBQzlDdEMsV0FBVzJDLGNBQWMsQ0FBQzNGLFFBQVFzRjtRQUNwQztRQUNBTSxZQUFZLFNBQVNBLFdBQVduQyxJQUFJO1lBQ2xDVCxXQUFXNkMsV0FBVyxDQUFDN0YsUUFBUXlEO1FBQ2pDO1FBQ0FxQyxZQUFZLFNBQVNBLFdBQVdDLElBQUk7WUFDbEMsSUFBSTVGLFlBQVlILE9BQU9HLFNBQVMsRUFDNUJDLFFBQVFKLE9BQU9JLEtBQUs7WUFFeEIsSUFBSUQsV0FBVztnQkFDYixJQUFJQyxPQUFPO29CQUNULElBQUlxRCxPQUFPOUUsZ0JBQWdCO3dCQUN6Qm9ILE1BQU1BO29CQUNSLEdBQUczRjtvQkFFSDRDLFdBQVc2QyxXQUFXLENBQUM3RixRQUFReUQ7Z0JBQ2pDLE9BQU87b0JBQ0xULFdBQVc4QyxVQUFVLENBQUM5RixRQUFRK0Y7Z0JBQ2hDO2dCQUVBL0YsT0FBT0ksS0FBSyxHQUFHO1lBQ2pCO1FBQ0Y7UUFDQTRGLGVBQWUsU0FBU0EsY0FBY0MsS0FBSztZQUN6QyxJQUFJQyxTQUFTMUksZUFBZXlJLE9BQU8sSUFDL0J4QyxPQUFPeUMsTUFBTSxDQUFDLEVBQUUsRUFDaEJoRSxPQUFPZ0UsTUFBTSxDQUFDLEVBQUUsRUFBRSxtREFBbUQ7WUFHekUsSUFBSXhDLEtBQUtDLE1BQU0sQ0FBQ0YsT0FBTztnQkFDckI7WUFDRixFQUFFLG1FQUFtRTtZQUdyRSxJQUFJMEMsUUFBUUMsU0FBUyxDQUFDM0MsU0FBU0EsS0FBS3hELFFBQVEsQ0FBQzVGLE1BQU0sS0FBSyxHQUFHO2dCQUN6RCxJQUFJZ00sUUFBUTtvQkFDVk4sTUFBTTtnQkFDUjtnQkFDQS9DLFdBQVc2QyxXQUFXLENBQUM3RixRQUFRcUcsT0FBTztvQkFDcENDLElBQUlwRSxLQUFLcUUsTUFBTSxDQUFDO29CQUNoQjNCLE9BQU87Z0JBQ1Q7Z0JBQ0E7WUFDRixFQUFFLG1FQUFtRTtZQUdyRSxJQUFJNEIsb0JBQW9CN0YsT0FBTzhGLFFBQVEsQ0FBQ2hELFFBQVEsUUFBUTBDLFFBQVFDLFNBQVMsQ0FBQzNDLFNBQVV6RCxDQUFBQSxPQUFPSyxRQUFRLENBQUNvRCxTQUFTQSxLQUFLeEQsUUFBUSxDQUFDNUYsTUFBTSxLQUFLLEtBQUtxSixLQUFLQyxNQUFNLENBQUNGLEtBQUt4RCxRQUFRLENBQUMsRUFBRSxLQUFLRCxPQUFPSyxRQUFRLENBQUNvRCxLQUFLeEQsUUFBUSxDQUFDLEVBQUUsSUFBSSx1RUFBdUU7WUFDdlIsbURBQW1EO1lBRW5ELElBQUkzRSxJQUFJO1lBRVIsSUFBSyxJQUFJaEIsSUFBSSxHQUFHQSxJQUFJbUosS0FBS3hELFFBQVEsQ0FBQzVGLE1BQU0sRUFBRUMsS0FBS2dCLElBQUs7Z0JBQ2xELElBQUlvTCxjQUFjckIsS0FBS3pELEdBQUcsQ0FBQzVCLFFBQVFrQztnQkFDbkMsSUFBSXdCLEtBQUtDLE1BQU0sQ0FBQytDLGNBQWM7Z0JBQzlCLElBQUlDLFNBQVNsRCxLQUFLeEQsUUFBUSxDQUFDM0YsRUFBRTtnQkFDN0IsSUFBSXNNLE9BQU9GLFlBQVl6RyxRQUFRLENBQUMzRSxJQUFJLEVBQUU7Z0JBQ3RDLElBQUl1TCxTQUFTdk0sTUFBTW1KLEtBQUt4RCxRQUFRLENBQUM1RixNQUFNLEdBQUc7Z0JBQzFDLElBQUl5TSxpQkFBaUJwRCxLQUFLQyxNQUFNLENBQUNnRCxXQUFXUixRQUFRQyxTQUFTLENBQUNPLFdBQVczRyxPQUFPSyxRQUFRLENBQUNzRyxTQUFTLHFFQUFxRTtnQkFDdkssdUVBQXVFO2dCQUN2RSxxRUFBcUU7Z0JBQ3JFLFFBQVE7Z0JBRVIsSUFBSUcsbUJBQW1CTixtQkFBbUI7b0JBQ3hDeEQsV0FBVytELFdBQVcsQ0FBQy9HLFFBQVE7d0JBQzdCc0csSUFBSXBFLEtBQUtxRSxNQUFNLENBQUNqTDt3QkFDaEJzSixPQUFPO29CQUNUO29CQUNBdEo7Z0JBQ0YsT0FBTyxJQUFJNkssUUFBUUMsU0FBUyxDQUFDTyxTQUFTO29CQUNwQyx5REFBeUQ7b0JBQ3pELElBQUkzRyxPQUFPSyxRQUFRLENBQUNzRyxTQUFTO3dCQUMzQixJQUFJQyxRQUFRLFFBQVEsQ0FBQ2xELEtBQUtDLE1BQU0sQ0FBQ2lELE9BQU87NEJBQ3RDLElBQUlJLFdBQVc7Z0NBQ2JqQixNQUFNOzRCQUNSOzRCQUNBL0MsV0FBVzZDLFdBQVcsQ0FBQzdGLFFBQVFnSCxVQUFVO2dDQUN2Q1YsSUFBSXBFLEtBQUtxRSxNQUFNLENBQUNqTDtnQ0FDaEJzSixPQUFPOzRCQUNUOzRCQUNBdEo7d0JBQ0YsT0FBTyxJQUFJdUwsUUFBUTs0QkFDakIsSUFBSUksWUFBWTtnQ0FDZGxCLE1BQU07NEJBQ1I7NEJBQ0EvQyxXQUFXNkMsV0FBVyxDQUFDN0YsUUFBUWlILFdBQVc7Z0NBQ3hDWCxJQUFJcEUsS0FBS3FFLE1BQU0sQ0FBQ2pMLElBQUk7Z0NBQ3BCc0osT0FBTzs0QkFDVDs0QkFDQXRKO3dCQUNGO29CQUNGO2dCQUNGLE9BQU87b0JBQ0wscURBQXFEO29CQUNyRCxJQUFJc0wsUUFBUSxRQUFRbEQsS0FBS0MsTUFBTSxDQUFDaUQsT0FBTzt3QkFDckMsSUFBSWxELEtBQUt3RCxNQUFNLENBQUNQLFFBQVFDLE1BQU07NEJBQzVCTyxPQUFPO3dCQUNULElBQUk7NEJBQ0ZuRSxXQUFXb0UsVUFBVSxDQUFDcEgsUUFBUTtnQ0FDNUJzRyxJQUFJcEUsS0FBS3FFLE1BQU0sQ0FBQ2pMO2dDQUNoQnNKLE9BQU87NEJBQ1Q7NEJBQ0F0Sjt3QkFDRixPQUFPLElBQUlzTCxLQUFLYixJQUFJLEtBQUssSUFBSTs0QkFDM0IvQyxXQUFXK0QsV0FBVyxDQUFDL0csUUFBUTtnQ0FDN0JzRyxJQUFJcEUsS0FBS3FFLE1BQU0sQ0FBQ2pMLElBQUk7Z0NBQ3BCc0osT0FBTzs0QkFDVDs0QkFDQXRKO3dCQUNGLE9BQU8sSUFBSXFMLE9BQU9aLElBQUksS0FBSyxJQUFJOzRCQUM3Qi9DLFdBQVcrRCxXQUFXLENBQUMvRyxRQUFRO2dDQUM3QnNHLElBQUlwRSxLQUFLcUUsTUFBTSxDQUFDakw7Z0NBQ2hCc0osT0FBTzs0QkFDVDs0QkFDQXRKO3dCQUNGO29CQUNGO2dCQUNGO1lBQ0Y7UUFDRjtRQUNBK0wsWUFBWSxTQUFTQSxXQUFXbEwsR0FBRztZQUNqQyxJQUFJZ0UsWUFBWUgsT0FBT0csU0FBUztZQUVoQyxJQUFJQSxXQUFXO2dCQUNiLElBQUlxRCxRQUFRLFNBQVNBLE1BQU1DLElBQUksRUFBRXZCLElBQUk7b0JBQ25DLElBQUksQ0FBQ3dCLEtBQUtDLE1BQU0sQ0FBQ0YsT0FBTzt3QkFDdEIsT0FBTyxPQUFPLG9DQUFvQztvQkFDcEQ7b0JBRUEsSUFBSTZELGtCQUFrQjNHLE9BQU9rRCxNQUFNLENBQUM3RCxRQUFRa0MsT0FDeENxRixrQkFBa0IvSixlQUFlOEosaUJBQWlCLElBQ2xEdkQsYUFBYXdELGVBQWUsQ0FBQyxFQUFFO29CQUMvQkEsZUFBZSxDQUFDLEVBQUU7b0JBRXRCLE9BQU8sQ0FBQ3ZILE9BQU9NLE1BQU0sQ0FBQ3lELGVBQWUvRCxPQUFPTyxZQUFZLENBQUN3RDtnQkFDM0Q7Z0JBRUEsSUFBSUMsb0JBQW9CQyxNQUFNQyxVQUFVLENBQUMvRDtnQkFDekMsSUFBSWdFLDRCQUE0QjtnQkFFaEMsSUFBSSxDQUFDSCxtQkFBbUI7b0JBQ3RCLElBQUl3RCxnQkFBZ0I3RyxPQUFPOEMsSUFBSSxDQUFDekQsUUFBUUcsWUFDcENzSCxnQkFBZ0JqSyxlQUFlZ0ssZUFBZSxJQUM5Q2xELGVBQWVtRCxhQUFhLENBQUMsRUFBRSxFQUMvQmxELGVBQWVrRCxhQUFhLENBQUMsRUFBRTtvQkFFbkMsSUFBSW5ELGdCQUFnQmQsTUFBTWMsY0FBY0MsZUFBZTt3QkFDckQsSUFBSW1ELGtCQUFrQi9HLE9BQU9rRCxNQUFNLENBQUM3RCxRQUFRdUUsZUFDeENvRCxrQkFBa0JuSyxlQUFla0ssaUJBQWlCLElBQ2xEM0QsYUFBYTRELGVBQWUsQ0FBQyxFQUFFO3dCQUVuQ3hELDRCQUE0QkosY0FBYy9ELE9BQU9PLFlBQVksQ0FBQ3dEO29CQUNoRTtnQkFDRjtnQkFFQSxJQUFJQyxxQkFBcUJHLDJCQUEyQjtvQkFDbERuQixXQUFXNEUsVUFBVSxDQUFDNUgsUUFBUTdELEtBQUs7d0JBQ2pDcUgsT0FBT0E7d0JBQ1BtQixPQUFPO3dCQUNQQyxPQUFPO29CQUNUO2dCQUNGLE9BQU87b0JBQ0wsSUFBSXhFLFFBQVF6QixnQkFBZ0IsQ0FBQyxHQUFHZ0MsT0FBT1AsS0FBSyxDQUFDSixXQUFXLENBQUM7b0JBRXpELE9BQU9JLEtBQUssQ0FBQ2pFLElBQUk7b0JBQ2pCNkQsT0FBT0ksS0FBSyxHQUFHQTtvQkFFZixJQUFJLENBQUN4QyxTQUFTZ0UsR0FBRyxDQUFDNUIsU0FBUzt3QkFDekJBLE9BQU9RLFFBQVE7b0JBQ2pCO2dCQUNGO1lBQ0Y7UUFDRjtRQUVBOztLQUVDLEdBQ0RtQyxlQUFlLFNBQVNBLGNBQWNsQyxFQUFFO1lBQ3RDLE9BQVFBLEdBQUcwQyxJQUFJO2dCQUNiLEtBQUs7Z0JBQ0wsS0FBSztnQkFDTCxLQUFLO29CQUNIO3dCQUNFLElBQUlqQixPQUFPekIsR0FBR3lCLElBQUk7d0JBQ2xCLE9BQU9HLEtBQUt3RixNQUFNLENBQUMzRjtvQkFDckI7Z0JBRUYsS0FBSztvQkFDSDt3QkFDRSxJQUFJdUIsT0FBT2hELEdBQUdnRCxJQUFJLEVBQ2RxRSxTQUFTckgsR0FBR3lCLElBQUk7d0JBQ3BCLElBQUkyRixTQUFTeEYsS0FBS3dGLE1BQU0sQ0FBQ0M7d0JBQ3pCLElBQUlDLGNBQWNyRSxLQUFLQyxNQUFNLENBQUNGLFFBQVEsRUFBRSxHQUFHakosTUFBTVMsSUFBSSxDQUFDb0ssS0FBSzJDLEtBQUssQ0FBQ3ZFLE9BQU8sU0FBVXdFLEtBQUs7NEJBQ3JGLElBQUlDLFFBQVExSyxlQUFleUssT0FBTyxJQUM5QkUsSUFBSUQsS0FBSyxDQUFDLEVBQUU7NEJBRWhCLE9BQU9KLE9BQU92QixNQUFNLENBQUM0Qjt3QkFDdkI7d0JBQ0EsT0FBTyxFQUFFLENBQUM1QixNQUFNLENBQUN2SyxtQkFBbUI2TCxTQUFTN0wsbUJBQW1CK0w7b0JBQ2xFO2dCQUVGLEtBQUs7b0JBQ0g7d0JBQ0UsSUFBSUssU0FBUzNILEdBQUd5QixJQUFJO3dCQUNwQixJQUFJbUcsWUFBWWhHLEtBQUtnRyxTQUFTLENBQUNEO3dCQUMvQixJQUFJRSxlQUFlakcsS0FBS2tHLFFBQVEsQ0FBQ0g7d0JBQ2pDLE9BQU8sRUFBRSxDQUFDN0IsTUFBTSxDQUFDdkssbUJBQW1CcU0sWUFBWTs0QkFBQ0M7eUJBQWE7b0JBQ2hFO2dCQUVGLEtBQUs7b0JBQ0g7d0JBQ0UsSUFBSUUsU0FBUy9ILEdBQUd5QixJQUFJLEVBQ2hCTyxVQUFVaEMsR0FBR2dDLE9BQU87d0JBRXhCLElBQUlKLEtBQUs2RSxNQUFNLENBQUNzQixRQUFRL0YsVUFBVTs0QkFDaEMsT0FBTyxFQUFFO3dCQUNYO3dCQUVBLElBQUlnRyxlQUFlLEVBQUU7d0JBQ3JCLElBQUlDLGVBQWUsRUFBRTt3QkFFckIsSUFBSUMsYUFBYXpKLDZCQUE2Qm1ELEtBQUtnRyxTQUFTLENBQUNHLFVBQ3pESTt3QkFFSixJQUFJOzRCQUNGLElBQUtELFdBQVdwSixDQUFDLElBQUksQ0FBQyxDQUFDcUosU0FBU0QsV0FBV3JOLENBQUMsRUFBQyxFQUFHNEIsSUFBSSxFQUFHO2dDQUNyRCxJQUFJMkwsV0FBV0QsT0FBT3hQLEtBQUs7Z0NBQzNCLElBQUkrTyxJQUFJOUYsS0FBS3JCLFNBQVMsQ0FBQzZILFVBQVVwSTtnQ0FDakNnSSxhQUFhdEwsSUFBSSxDQUFDZ0w7NEJBQ3BCO3dCQUNGLEVBQUUsT0FBTy9LLEtBQUs7NEJBQ1p1TCxXQUFXbkosQ0FBQyxDQUFDcEM7d0JBQ2YsU0FBVTs0QkFDUnVMLFdBQVdsSixDQUFDO3dCQUNkO3dCQUVBLElBQUlxSixhQUFhNUosNkJBQTZCbUQsS0FBS2dHLFNBQVMsQ0FBQzVGLFdBQ3pEc0c7d0JBRUosSUFBSTs0QkFDRixJQUFLRCxXQUFXdkosQ0FBQyxJQUFJLENBQUMsQ0FBQ3dKLFNBQVNELFdBQVd4TixDQUFDLEVBQUMsRUFBRzRCLElBQUksRUFBRztnQ0FDckQsSUFBSThMLFlBQVlELE9BQU8zUCxLQUFLO2dDQUU1QixJQUFJNlAsS0FBSzVHLEtBQUtyQixTQUFTLENBQUNnSSxXQUFXdkk7Z0NBRW5DaUksYUFBYXZMLElBQUksQ0FBQzhMOzRCQUNwQjt3QkFDRixFQUFFLE9BQU83TCxLQUFLOzRCQUNaMEwsV0FBV3RKLENBQUMsQ0FBQ3BDO3dCQUNmLFNBQVU7NEJBQ1IwTCxXQUFXckosQ0FBQzt3QkFDZDt3QkFFQSxJQUFJeUosWUFBWVIsWUFBWSxDQUFDQSxhQUFhck8sTUFBTSxHQUFHLEVBQUU7d0JBQ3JELElBQUk4TyxXQUFXMUcsT0FBTyxDQUFDQSxRQUFRcEksTUFBTSxHQUFHLEVBQUU7d0JBQzFDLElBQUkrTyxhQUFhRixVQUFVM0MsTUFBTSxDQUFDNEM7d0JBQ2xDLE9BQU8sRUFBRSxDQUFDNUMsTUFBTSxDQUFDa0MsY0FBY0MsY0FBYzs0QkFBQ1U7eUJBQVc7b0JBQzNEO2dCQUVGLEtBQUs7b0JBQ0g7d0JBQ0UsSUFBSUMsU0FBUzVJLEdBQUd5QixJQUFJO3dCQUVwQixJQUFJb0gsYUFBYWpILEtBQUtnRyxTQUFTLENBQUNnQjt3QkFFaEMsT0FBT3JOLG1CQUFtQnNOO29CQUM1QjtnQkFFRixLQUFLO29CQUNIO3dCQUNFLElBQUlDLFNBQVM5SSxHQUFHeUIsSUFBSTt3QkFFcEIsSUFBSXNILFVBQVVuSCxLQUFLd0YsTUFBTSxDQUFDMEI7d0JBRTFCLElBQUlFLFdBQVdwSCxLQUFLcEYsSUFBSSxDQUFDc007d0JBQ3pCLE9BQU8sRUFBRSxDQUFDaEQsTUFBTSxDQUFDdkssbUJBQW1Cd04sVUFBVTs0QkFBQ0M7eUJBQVM7b0JBQzFEO2dCQUVGO29CQUNFO3dCQUNFLE9BQU8sRUFBRTtvQkFDWDtZQUNKO1FBQ0Y7UUFDQUMsaUJBQWlCLFNBQVNBLGdCQUFnQkMsS0FBSztZQUM3QyxJQUFJQyxZQUFZRCxNQUFNQyxTQUFTLEVBQzNCQywwQkFBMEJGLE1BQU1FLHVCQUF1QjtZQUMzRCxJQUFJQyxnQkFBZ0JELDBCQUEwQixJQUFJLG9CQUFvQjtZQUV0RSxJQUFJRCxZQUFZRSxlQUFlO2dCQUM3QixNQUFNLElBQUlDLE1BQU0sbURBQW1EeEQsTUFBTSxDQUFDdUQsZUFBZTtZQUMzRjtZQUVBLE9BQU87UUFDVDtJQUNGO0lBQ0EsT0FBTzlKO0FBQ1Q7QUFFQSxJQUFJZ0ssK0JBQStCbFEscUJBQXFCLFNBQVVFLE1BQU07SUFDeEUsU0FBU2lRLDhCQUE4Qm5MLE1BQU0sRUFBRW9MLFFBQVE7UUFDckQsSUFBSXBMLFVBQVUsTUFBTSxPQUFPLENBQUM7UUFDNUIsSUFBSUYsU0FBUyxDQUFDO1FBQ2QsSUFBSXVMLGFBQWFsUixPQUFPbUYsSUFBSSxDQUFDVTtRQUM3QixJQUFJM0MsS0FBSzdCO1FBRVQsSUFBS0EsSUFBSSxHQUFHQSxJQUFJNlAsV0FBVzlQLE1BQU0sRUFBRUMsSUFBSztZQUN0QzZCLE1BQU1nTyxVQUFVLENBQUM3UCxFQUFFO1lBQ25CLElBQUk0UCxTQUFTRSxPQUFPLENBQUNqTyxRQUFRLEdBQUc7WUFDaEN5QyxNQUFNLENBQUN6QyxJQUFJLEdBQUcyQyxNQUFNLENBQUMzQyxJQUFJO1FBQzNCO1FBRUEsT0FBT3lDO0lBQ1Q7SUFFQTVFLE9BQU9iLE9BQU8sR0FBRzhRO0lBQ2pCalEsT0FBT2IsT0FBTyxDQUFDLFVBQVUsR0FBR2EsT0FBT2IsT0FBTyxFQUFFYSxPQUFPYixPQUFPLENBQUNPLFVBQVUsR0FBRztBQUN4RTtBQUVBRixjQUFjd1E7QUFFZCxJQUFJSywwQkFBMEJ2USxxQkFBcUIsU0FBVUUsTUFBTTtJQUNuRSxTQUFTc1EseUJBQXlCeEwsTUFBTSxFQUFFb0wsUUFBUTtRQUNoRCxJQUFJcEwsVUFBVSxNQUFNLE9BQU8sQ0FBQztRQUM1QixJQUFJRixTQUFTb0wsNkJBQTZCbEwsUUFBUW9MO1FBQ2xELElBQUkvTixLQUFLN0I7UUFFVCxJQUFJckIsT0FBT29GLHFCQUFxQixFQUFFO1lBQ2hDLElBQUlrTSxtQkFBbUJ0UixPQUFPb0YscUJBQXFCLENBQUNTO1lBRXBELElBQUt4RSxJQUFJLEdBQUdBLElBQUlpUSxpQkFBaUJsUSxNQUFNLEVBQUVDLElBQUs7Z0JBQzVDNkIsTUFBTW9PLGdCQUFnQixDQUFDalEsRUFBRTtnQkFDekIsSUFBSTRQLFNBQVNFLE9BQU8sQ0FBQ2pPLFFBQVEsR0FBRztnQkFDaEMsSUFBSSxDQUFDbEQsT0FBT1UsU0FBUyxDQUFDNlEsb0JBQW9CLENBQUMzUSxJQUFJLENBQUNpRixRQUFRM0MsTUFBTTtnQkFDOUR5QyxNQUFNLENBQUN6QyxJQUFJLEdBQUcyQyxNQUFNLENBQUMzQyxJQUFJO1lBQzNCO1FBQ0Y7UUFFQSxPQUFPeUM7SUFDVDtJQUVBNUUsT0FBT2IsT0FBTyxHQUFHbVI7SUFDakJ0USxPQUFPYixPQUFPLENBQUMsVUFBVSxHQUFHYSxPQUFPYixPQUFPLEVBQUVhLE9BQU9iLE9BQU8sQ0FBQ08sVUFBVSxHQUFHO0FBQ3hFO0FBRUEsSUFBSTRRLDJCQUEyQjlRLGNBQWM2UTtBQUU3QyxTQUFTSSw2QkFBNkJyUCxDQUFDLEVBQUUrRCxjQUFjO0lBQUksSUFBSUMsS0FBSyxPQUFPckUsV0FBVyxlQUFlSyxDQUFDLENBQUNMLE9BQU9DLFFBQVEsQ0FBQyxJQUFJSSxDQUFDLENBQUMsYUFBYTtJQUFFLElBQUksQ0FBQ2dFLElBQUk7UUFBRSxJQUFJNUUsTUFBTUcsT0FBTyxDQUFDUyxNQUFPZ0UsQ0FBQUEsS0FBS3NMLDhCQUE4QnRQLEVBQUMsS0FBTStELGtCQUFrQi9ELEtBQUssT0FBT0EsRUFBRWYsTUFBTSxLQUFLLFVBQVU7WUFBRSxJQUFJK0UsSUFBSWhFLElBQUlnRTtZQUFJLElBQUk5RSxJQUFJO1lBQUcsSUFBSWdGLElBQUksU0FBU0EsS0FBSztZQUFHLE9BQU87Z0JBQUVDLEdBQUdEO2dCQUFHaEUsR0FBRyxTQUFTQTtvQkFBTSxJQUFJaEIsS0FBS2MsRUFBRWYsTUFBTSxFQUFFLE9BQU87d0JBQUU2QyxNQUFNO29CQUFLO29CQUFHLE9BQU87d0JBQUVBLE1BQU07d0JBQU85RCxPQUFPZ0MsQ0FBQyxDQUFDZCxJQUFJO29CQUFDO2dCQUFHO2dCQUFHa0YsR0FBRyxTQUFTQSxFQUFFeEMsRUFBRTtvQkFBSSxNQUFNQTtnQkFBSTtnQkFBR3lDLEdBQUdIO1lBQUU7UUFBRztRQUFFLE1BQU0sSUFBSXhELFVBQVU7SUFBMEk7SUFBRSxJQUFJNEQsbUJBQW1CLE1BQU1DLFNBQVMsT0FBT3ZDO0lBQUssT0FBTztRQUFFbUMsR0FBRyxTQUFTQTtZQUFNSCxLQUFLQSxHQUFHdkYsSUFBSSxDQUFDdUI7UUFBSTtRQUFHRSxHQUFHLFNBQVNBO1lBQU0sSUFBSXNFLE9BQU9SLEdBQUduQyxJQUFJO1lBQUl5QyxtQkFBbUJFLEtBQUsxQyxJQUFJO1lBQUUsT0FBTzBDO1FBQU07UUFBR0osR0FBRyxTQUFTQSxFQUFFSyxHQUFHO1lBQUlGLFNBQVM7WUFBTXZDLE1BQU15QztRQUFLO1FBQUdKLEdBQUcsU0FBU0E7WUFBTSxJQUFJO2dCQUFFLElBQUksQ0FBQ0Msb0JBQW9CTixFQUFFLENBQUMsU0FBUyxJQUFJLE1BQU1BLEVBQUUsQ0FBQyxTQUFTO1lBQUksU0FBVTtnQkFBRSxJQUFJTyxRQUFRLE1BQU12QztZQUFLO1FBQUU7SUFBRTtBQUFHO0FBRS8rQixTQUFTc04sOEJBQThCdFAsQ0FBQyxFQUFFQyxNQUFNO0lBQUksSUFBSSxDQUFDRCxHQUFHO0lBQVEsSUFBSSxPQUFPQSxNQUFNLFVBQVUsT0FBT3VQLG9CQUFvQnZQLEdBQUdDO0lBQVMsSUFBSUMsSUFBSXJDLE9BQU9VLFNBQVMsQ0FBQzRCLFFBQVEsQ0FBQzFCLElBQUksQ0FBQ3VCLEdBQUdJLEtBQUssQ0FBQyxHQUFHLENBQUM7SUFBSSxJQUFJRixNQUFNLFlBQVlGLEVBQUVLLFdBQVcsRUFBRUgsSUFBSUYsRUFBRUssV0FBVyxDQUFDQyxJQUFJO0lBQUUsSUFBSUosTUFBTSxTQUFTQSxNQUFNLE9BQU8sT0FBT2QsTUFBTVMsSUFBSSxDQUFDRztJQUFJLElBQUlFLE1BQU0sZUFBZSwyQ0FBMkNLLElBQUksQ0FBQ0wsSUFBSSxPQUFPcVAsb0JBQW9CdlAsR0FBR0M7QUFBUztBQUVyYSxTQUFTc1Asb0JBQW9CeFEsR0FBRyxFQUFFQyxHQUFHO0lBQUksSUFBSUEsT0FBTyxRQUFRQSxNQUFNRCxJQUFJRSxNQUFNLEVBQUVELE1BQU1ELElBQUlFLE1BQU07SUFBRSxJQUFLLElBQUlDLElBQUksR0FBR0MsT0FBTyxJQUFJQyxNQUFNSixNQUFNRSxJQUFJRixLQUFLRSxJQUFLO1FBQUVDLElBQUksQ0FBQ0QsRUFBRSxHQUFHSCxHQUFHLENBQUNHLEVBQUU7SUFBRTtJQUFFLE9BQU9DO0FBQU07QUFFeEwsc0VBQXNFO0FBQ3RFLDhGQUE4RjtBQUM5RixFQUFFO0FBQ0YsY0FBYztBQUNkLEVBQUU7QUFDRiwyRUFBMkU7QUFDM0Usd0ZBQXdGO0FBQ3hGLHFGQUFxRjtBQUNyRixvRkFBb0Y7QUFFcEY7O0NBRUMsR0FDRCxJQUFJcVEsdUJBQXVCLFNBQVNBLHFCQUFxQkMsR0FBRztJQUMxRCxJQUFJQyxRQUFRak0sVUFBVXhFLE1BQU0sR0FBRyxLQUFLd0UsU0FBUyxDQUFDLEVBQUUsS0FBS2tNLFlBQVlsTSxTQUFTLENBQUMsRUFBRSxHQUFHO0lBQ2hGLElBQUltTSxRQUFRLENBQUNGO0lBQ2IsSUFBSUcsYUFBYUgsUUFBUUksc0JBQXNCTCxPQUFPQTtJQUN0RCxJQUFJTSxPQUFPQyxjQUFjQyxJQUFJO0lBQzdCLElBQUlDLFFBQVFGLGNBQWNDLElBQUk7SUFDOUIsSUFBSUUsV0FBVyxHQUFHLCtDQUErQztJQUVqRSxJQUFJQyxPQUFPLE1BQU0sc0JBQXNCO0lBRXZDLElBQUlDLFdBQVcsTUFBTSw4QkFBOEI7SUFFbkQsSUFBSS9LLFlBQVkrSiw2QkFBNkJRLGFBQ3pDcEs7SUFFSixJQUFJO1FBQ0YsSUFBS0gsVUFBVW5CLENBQUMsSUFBSSxDQUFDLENBQUNzQixRQUFRSCxVQUFVcEYsQ0FBQyxFQUFDLEVBQUc0QixJQUFJLEVBQUc7WUFDbEQsSUFBSXdPLFFBQVE3SyxNQUFNekgsS0FBSztZQUV2QixJQUFJdVMsT0FBT0QsTUFBTUUsV0FBVyxDQUFDO1lBRTdCLElBQUksQ0FBQ0QsTUFBTTtZQUNYLElBQUl4SSxPQUFPMEksaUJBQWlCSCxPQUFPQztZQUVuQyxJQUFJdkssT0FBTzRKLFFBQVE7Z0JBQUNNO2dCQUFPbkk7YUFBSyxHQUFHO2dCQUFDQTtnQkFBTWdJO2FBQUs7WUFFL0MsSUFBSTFKLFFBQVFqRSxlQUFlNEQsTUFBTTtZQUVqQytKLE9BQU8xSixLQUFLLENBQUMsRUFBRTtZQUNmNkosUUFBUTdKLEtBQUssQ0FBQyxFQUFFO1lBRWhCLElBQUlxSyxXQUFXWCxNQUFNQyxjQUFjVyxHQUFHLEtBQUtELFdBQVdSLE9BQU9GLGNBQWNZLE9BQU8sR0FBRztnQkFDbkYsSUFBSWhCLE9BQU87b0JBQ1RRLE9BQU9TLGlCQUFpQnBCLElBQUlxQixTQUFTLENBQUMsR0FBR1g7Z0JBQzNDLE9BQU87b0JBQ0xDLE9BQU9TLGlCQUFpQnBCLElBQUlxQixTQUFTLENBQUMsR0FBR3JCLElBQUl4USxNQUFNLEdBQUdrUjtnQkFDeEQ7Z0JBRUEsSUFBSSxDQUFDQyxNQUFNO1lBQ2I7WUFFQSxJQUFJTSxXQUFXWCxNQUFNQyxjQUFjZSxFQUFFLEtBQUtMLFdBQVdSLE9BQU9GLGNBQWNlLEVBQUUsR0FBRztnQkFDN0UsSUFBSVYsYUFBYSxNQUFNO29CQUNyQkEsV0FBVyxDQUFDQTtnQkFDZCxPQUFPO29CQUNMLElBQUlULE9BQU87d0JBQ1RTLFdBQVc7b0JBQ2IsT0FBTzt3QkFDTEEsV0FBV1csdUJBQXVCdkIsSUFBSXFCLFNBQVMsQ0FBQyxHQUFHckIsSUFBSXhRLE1BQU0sR0FBR2tSO29CQUNsRTtnQkFDRjtnQkFFQSxJQUFJLENBQUNFLFVBQVU7WUFDakI7WUFFQSxJQUFJTixTQUFTQyxjQUFjQyxJQUFJLElBQUlDLFVBQVVGLGNBQWNDLElBQUksSUFBSWdCLGVBQWVsQixNQUFNRyxRQUFRO2dCQUM5RjtZQUNGO1lBRUFDLFlBQVlHLE1BQU1yUixNQUFNO1FBQzFCO0lBQ0YsRUFBRSxPQUFPK0MsS0FBSztRQUNac0QsVUFBVWxCLENBQUMsQ0FBQ3BDO0lBQ2QsU0FBVTtRQUNSc0QsVUFBVWpCLENBQUM7SUFDYjtJQUVBLE9BQU84TCxZQUFZO0FBQ3JCO0FBQ0EsSUFBSWUsUUFBUTtBQUNaLElBQUlDLGNBQWM7QUFDbEIsSUFBSUMsWUFBWTtBQUNoQjs7Q0FFQyxHQUVELElBQUlDLGtCQUFrQixTQUFTQSxnQkFBZ0IxRyxJQUFJO0lBQ2pELElBQUkrRSxRQUFRak0sVUFBVXhFLE1BQU0sR0FBRyxLQUFLd0UsU0FBUyxDQUFDLEVBQUUsS0FBS2tNLFlBQVlsTSxTQUFTLENBQUMsRUFBRSxHQUFHO0lBQ2hGLElBQUk2TixPQUFPO0lBQ1gsSUFBSUMsVUFBVTtJQUVkLE1BQU81RyxLQUFLMUwsTUFBTSxHQUFHLEVBQUc7UUFDdEIsSUFBSXVTLFdBQVdoQyxxQkFBcUI3RSxNQUFNK0U7UUFFMUMsSUFBSStCLHdCQUF3QkMseUJBQXlCL0csTUFBTTZHLFVBQVU5QixRQUNqRWlDLHlCQUF5QnZQLGVBQWVxUCx1QkFBdUIsSUFDL0RHLFNBQVNELHNCQUFzQixDQUFDLEVBQUUsRUFDbENFLFlBQVlGLHNCQUFzQixDQUFDLEVBQUU7UUFFekMsSUFBSUcsZ0JBQWdCRixRQUFRQyxXQUFXbkMsUUFBUTtZQUM3QzZCLFVBQVU7WUFDVkQsUUFBUUU7UUFDVixPQUFPLElBQUksQ0FBQ0QsU0FBUztZQUNuQkQsUUFBUUU7UUFDVixPQUFPO1lBQ0w7UUFDRjtRQUVBN0csT0FBT2tIO0lBQ1Q7SUFFQSxPQUFPUDtBQUNUO0FBQ0E7OztDQUdDLEdBRUQsSUFBSUksMkJBQTJCLFNBQVNBLHlCQUF5QmpDLEdBQUcsRUFBRTZCLElBQUksRUFBRTVCLEtBQUs7SUFDL0UsSUFBSUEsT0FBTztRQUNULElBQUl4RSxLQUFLdUUsSUFBSXhRLE1BQU0sR0FBR3FTO1FBQ3RCLE9BQU87WUFBQzdCLElBQUlyUCxLQUFLLENBQUM4SyxJQUFJdUUsSUFBSXhRLE1BQU07WUFBR3dRLElBQUlyUCxLQUFLLENBQUMsR0FBRzhLO1NBQUk7SUFDdEQ7SUFFQSxPQUFPO1FBQUN1RSxJQUFJclAsS0FBSyxDQUFDLEdBQUdrUjtRQUFPN0IsSUFBSXJQLEtBQUssQ0FBQ2tSO0tBQU07QUFDOUM7QUFDQTs7O0NBR0MsR0FFRCxJQUFJUSxrQkFBa0IsU0FBU0EsZ0JBQWdCQyxNQUFNLEVBQUVGLFNBQVM7SUFDOUQsSUFBSW5DLFFBQVFqTSxVQUFVeEUsTUFBTSxHQUFHLEtBQUt3RSxTQUFTLENBQUMsRUFBRSxLQUFLa00sWUFBWWxNLFNBQVMsQ0FBQyxFQUFFLEdBQUc7SUFFaEYsSUFBSXlOLE1BQU0zUSxJQUFJLENBQUN3UixTQUFTO1FBQ3RCLE9BQU87SUFDVCxFQUFFLHVFQUF1RTtJQUN6RSw2REFBNkQ7SUFHN0QsSUFBSVgsVUFBVTdRLElBQUksQ0FBQ3dSLFNBQVM7UUFDMUIsSUFBSVAsV0FBV2hDLHFCQUFxQnFDLFdBQVduQztRQUUvQyxJQUFJc0MseUJBQXlCTix5QkFBeUJHLFdBQVdMLFVBQVU5QixRQUN2RXVDLHlCQUF5QjdQLGVBQWU0UCx3QkFBd0IsSUFDaEVFLFdBQVdELHNCQUFzQixDQUFDLEVBQUUsRUFDcENFLGdCQUFnQkYsc0JBQXNCLENBQUMsRUFBRTtRQUU3QyxJQUFJSCxnQkFBZ0JJLFVBQVVDLGVBQWV6QyxRQUFRO1lBQ25ELE9BQU87UUFDVDtJQUNGO0lBRUEsSUFBSXlCLFlBQVk1USxJQUFJLENBQUN3UixTQUFTO1FBQzVCLE9BQU87SUFDVDtJQUVBLE9BQU87QUFDVDtBQUNBOztDQUVDLEdBR0QsSUFBSWpDLHdCQUF3QixVQUFVQSxzQkFBc0JMLEdBQUc7SUFDN0QsSUFBSTJDLE1BQU0zQyxJQUFJeFEsTUFBTSxHQUFHO0lBRXZCLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJdVEsSUFBSXhRLE1BQU0sRUFBRUMsSUFBSztRQUNuQyxJQUFJbVQsUUFBUTVDLElBQUk2QyxNQUFNLENBQUNGLE1BQU1sVDtRQUU3QixJQUFJcVQsZUFBZUYsTUFBTUcsVUFBVSxDQUFDLEtBQUs7WUFDdkMsSUFBSUMsUUFBUWhELElBQUk2QyxNQUFNLENBQUNGLE1BQU1sVCxJQUFJO1lBRWpDLElBQUl3VCxnQkFBZ0JELE1BQU1ELFVBQVUsQ0FBQyxLQUFLO2dCQUN4QyxNQUFNQyxRQUFRSjtnQkFDZG5UO2dCQUNBO1lBQ0Y7UUFDRjtRQUVBLE1BQU1tVDtJQUNSO0FBQ0Y7QUFDQTs7OztDQUlDLEdBRUQsSUFBSUssa0JBQWtCLFNBQVNBLGdCQUFnQkMsUUFBUTtJQUNyRCxPQUFPQSxZQUFZLFVBQVVBLFlBQVk7QUFDM0M7QUFDQTs7OztDQUlDLEdBR0QsSUFBSUosaUJBQWlCLFNBQVNBLGVBQWVJLFFBQVE7SUFDbkQsT0FBT0EsWUFBWSxVQUFVQSxZQUFZO0FBQzNDO0FBRUEsSUFBSTNDO0FBRUgsVUFBVUEsYUFBYTtJQUN0QkEsYUFBYSxDQUFDQSxhQUFhLENBQUMsT0FBTyxHQUFHLEVBQUUsR0FBRztJQUMzQ0EsYUFBYSxDQUFDQSxhQUFhLENBQUMsU0FBUyxHQUFHLEVBQUUsR0FBRztJQUM3Q0EsYUFBYSxDQUFDQSxhQUFhLENBQUMsTUFBTSxHQUFHLEVBQUUsR0FBRztJQUMxQ0EsYUFBYSxDQUFDQSxhQUFhLENBQUMsS0FBSyxHQUFHLEVBQUUsR0FBRztJQUN6Q0EsYUFBYSxDQUFDQSxhQUFhLENBQUMsVUFBVSxHQUFHLEVBQUUsR0FBRztJQUM5Q0EsYUFBYSxDQUFDQSxhQUFhLENBQUMsY0FBYyxHQUFHLEdBQUcsR0FBRztJQUNuREEsYUFBYSxDQUFDQSxhQUFhLENBQUMsSUFBSSxHQUFHLEdBQUcsR0FBRztJQUN6Q0EsYUFBYSxDQUFDQSxhQUFhLENBQUMsSUFBSSxHQUFHLEdBQUcsR0FBRztJQUN6Q0EsYUFBYSxDQUFDQSxhQUFhLENBQUMsSUFBSSxHQUFHLElBQUksR0FBRztJQUMxQ0EsYUFBYSxDQUFDQSxhQUFhLENBQUMsS0FBSyxHQUFHLElBQUksR0FBRztJQUMzQ0EsYUFBYSxDQUFDQSxhQUFhLENBQUMsTUFBTSxHQUFHLElBQUksR0FBRztJQUM1Q0EsYUFBYSxDQUFDQSxhQUFhLENBQUMsVUFBVSxHQUFHLEtBQUssR0FBRztJQUNqREEsYUFBYSxDQUFDQSxhQUFhLENBQUMsTUFBTSxHQUFHLEtBQUssR0FBRztBQUMvQyxHQUFHQSxpQkFBa0JBLENBQUFBLGdCQUFnQixDQUFDO0FBRXRDLElBQUk0QyxXQUFXO0FBQ2YsSUFBSUMsWUFBWTtBQUNoQixJQUFJQyxnQkFBZ0I7QUFDcEIsSUFBSUMsTUFBTTtBQUNWLElBQUlDLE1BQU07QUFDVixJQUFJQyxNQUFNO0FBQ1YsSUFBSUMsT0FBTztBQUNYLElBQUlDLFFBQVE7QUFDWixJQUFJQyxZQUFZO0FBRWhCLElBQUkzQyxtQkFBbUIsU0FBU0EsaUJBQWlCNEMsTUFBTSxFQUFFOUMsSUFBSTtJQUMzRCxJQUFJeEksT0FBT2lJLGNBQWNzRCxHQUFHO0lBRTVCLElBQUlELE9BQU9FLE1BQU0sQ0FBQ1gsY0FBYyxDQUFDLEdBQUc7UUFDbEM3SyxRQUFRaUksY0FBY3dELE1BQU07SUFDOUI7SUFFQSxJQUFJakQsU0FBUyxRQUFRO1FBQ25CeEksUUFBUWlJLGNBQWNXLEdBQUc7SUFDM0I7SUFFQSxJQUFJSixRQUFRLFdBQVdBLFFBQVEsU0FBUztRQUN0Q3hJLFFBQVFpSSxjQUFjZSxFQUFFO0lBQzFCO0lBRUEsSUFBSXNDLE9BQU9FLE1BQU0sQ0FBQ1YsZUFBZSxDQUFDLEdBQUc7UUFDbkM5SyxRQUFRaUksY0FBY3lELE9BQU87SUFDL0I7SUFFQSxJQUFJSixPQUFPRSxNQUFNLENBQUNULG1CQUFtQixDQUFDLEdBQUc7UUFDdkMvSyxRQUFRaUksY0FBYzBELFdBQVc7SUFDbkM7SUFFQSxJQUFJTCxPQUFPRSxNQUFNLENBQUNSLFNBQVMsQ0FBQyxHQUFHO1FBQzdCaEwsUUFBUWlJLGNBQWMyRCxDQUFDO0lBQ3pCO0lBRUEsSUFBSU4sT0FBT0UsTUFBTSxDQUFDUCxTQUFTLENBQUMsR0FBRztRQUM3QmpMLFFBQVFpSSxjQUFjNEQsQ0FBQztJQUN6QjtJQUVBLElBQUlQLE9BQU9FLE1BQU0sQ0FBQ04sU0FBUyxDQUFDLEdBQUc7UUFDN0JsTCxRQUFRaUksY0FBYzZELENBQUM7SUFDekI7SUFFQSxJQUFJUixPQUFPRSxNQUFNLENBQUNMLFVBQVUsQ0FBQyxHQUFHO1FBQzlCbkwsUUFBUWlJLGNBQWM4RCxFQUFFO0lBQzFCO0lBRUEsSUFBSVQsT0FBT0UsTUFBTSxDQUFDSixXQUFXLENBQUMsR0FBRztRQUMvQnBMLFFBQVFpSSxjQUFjK0QsR0FBRztJQUMzQjtJQUVBLElBQUlWLE9BQU9FLE1BQU0sQ0FBQ0gsZUFBZSxDQUFDLEdBQUc7UUFDbkNyTCxRQUFRaUksY0FBY1ksT0FBTztJQUMvQjtJQUVBLE9BQU83STtBQUNUO0FBRUEsU0FBUzJJLFdBQVdyUyxDQUFDLEVBQUUyVixDQUFDO0lBQ3RCLE9BQU8sQ0FBQzNWLElBQUkyVixDQUFBQSxNQUFPO0FBQ3JCO0FBRUEsSUFBSUMsbUJBQW1CO0lBQ3ZCO1FBQUNqRSxjQUFjMkQsQ0FBQztRQUFFM0QsY0FBYzJELENBQUMsR0FBRzNELGNBQWM0RCxDQUFDLEdBQUc1RCxjQUFjOEQsRUFBRSxHQUFHOUQsY0FBYytELEdBQUc7S0FBQztJQUMzRjtRQUFDL0QsY0FBYzhELEVBQUUsR0FBRzlELGNBQWM0RCxDQUFDO1FBQUU1RCxjQUFjNEQsQ0FBQyxHQUFHNUQsY0FBYzZELENBQUM7S0FBQztJQUN2RTtRQUFDN0QsY0FBYytELEdBQUcsR0FBRy9ELGNBQWM2RCxDQUFDO1FBQUU3RCxjQUFjNkQsQ0FBQztLQUFDO0lBQ3REO1FBQUM3RCxjQUFjc0QsR0FBRztRQUFFdEQsY0FBY3dELE1BQU0sR0FBR3hELGNBQWNXLEdBQUc7S0FBQztJQUM3RDtRQUFDWCxjQUFjc0QsR0FBRztRQUFFdEQsY0FBYzBELFdBQVc7S0FBQztJQUM5QztRQUFDMUQsY0FBY3lELE9BQU87UUFBRXpELGNBQWNzRCxHQUFHO0tBQUM7SUFDMUM7UUFBQ3RELGNBQWNXLEdBQUc7UUFBRVgsY0FBY1ksT0FBTztLQUFDO0lBQzFDO1FBQUNaLGNBQWNlLEVBQUU7UUFBRWYsY0FBY2UsRUFBRTtLQUFDO0NBQUM7QUFFckMsU0FBU0UsZUFBZWxCLElBQUksRUFBRUcsS0FBSztJQUNqQyxPQUFPK0QsaUJBQWlCQyxTQUFTLENBQUMsU0FBVUMsQ0FBQztRQUMzQyxPQUFPekQsV0FBV1gsTUFBTW9FLENBQUMsQ0FBQyxFQUFFLEtBQUt6RCxXQUFXUixPQUFPaUUsQ0FBQyxDQUFDLEVBQUU7SUFDekQsT0FBTyxDQUFDO0FBQ1Y7QUFFQSxJQUFJQyxpQkFBaUI7QUFFckIsSUFBSXZELG1CQUFtQixTQUFTQSxpQkFBaUJwQixHQUFHO0lBQ2xELE9BQU9BLElBQUk4RCxNQUFNLENBQUNhLG9CQUFvQixDQUFDO0FBQ3pDO0FBRUEsSUFBSUMsWUFBWTtBQUVoQixJQUFJckQseUJBQXlCLFNBQVNBLHVCQUF1QnZCLEdBQUc7SUFDOUQsSUFBSXJILFFBQVFxSCxJQUFJckgsS0FBSyxDQUFDaU07SUFFdEIsSUFBSWpNLFVBQVUsTUFBTTtRQUNsQixPQUFPO0lBQ1QsT0FBTztRQUNMLDJDQUEyQztRQUMzQyxJQUFJa00sU0FBU2xNLEtBQUssQ0FBQyxFQUFFLENBQUNuSixNQUFNLEdBQUc7UUFDL0IsT0FBT3FWLFNBQVMsTUFBTTtJQUN4QjtBQUNGO0FBRUE7O0NBRUMsR0FFRCxJQUFJdEosWUFBWSxTQUFTQSxVQUFVaE4sS0FBSztJQUN0QyxPQUFPQyxjQUFjQSxhQUFhLENBQUNELFVBQVVpTSxLQUFLc0ssVUFBVSxDQUFDdlcsTUFBTTZHLFFBQVEsS0FBSyxDQUFDVSxPQUFPOEYsUUFBUSxDQUFDck47QUFDbkcsR0FBRyx3Q0FBd0M7QUFHM0MsSUFBSStNLFVBQVU7SUFDWjs7R0FFQyxHQUNEeUosWUFBWSxTQUFTQSxXQUFXeFcsS0FBSztRQUNuQyxPQUFPQyxjQUFjQSxhQUFhLENBQUNELFVBQVVpTSxLQUFLc0ssVUFBVSxDQUFDdlcsTUFBTTZHLFFBQVE7SUFDN0U7SUFFQTs7R0FFQyxHQUNEbUcsV0FBV0E7SUFFWDs7R0FFQyxHQUNEeUosZUFBZSxTQUFTQSxjQUFjelcsS0FBSztRQUN6QyxPQUFPb0IsTUFBTUcsT0FBTyxDQUFDdkIsVUFBVUEsTUFBTTBXLEtBQUssQ0FBQyxTQUFVQyxHQUFHO1lBQ3RELE9BQU81SixRQUFRQyxTQUFTLENBQUMySjtRQUMzQjtJQUNGO0lBRUE7O0dBRUMsR0FDREMsZ0JBQWdCLFNBQVNBLGVBQWVDLEtBQUs7UUFDM0MsT0FBT0EsTUFBTWhRLFFBQVEsS0FBSzhLO0lBQzVCO0lBRUE7OztHQUdDLEdBQ0RtRixlQUFlLFNBQVNBLGNBQWM5VyxLQUFLLEVBQUUrVyxVQUFVO1FBQ3JELElBQUlDLGFBQWF2UixVQUFVeEUsTUFBTSxHQUFHLEtBQUt3RSxTQUFTLENBQUMsRUFBRSxLQUFLa00sWUFBWWxNLFNBQVMsQ0FBQyxFQUFFLEdBQUc7UUFDckYsT0FBT3VILFVBQVVoTixVQUFVQSxLQUFLLENBQUNnWCxXQUFXLEtBQUtEO0lBQ25EO0lBRUE7Ozs7O0dBS0MsR0FDREUsU0FBUyxTQUFTQSxRQUFRQyxPQUFPLEVBQUVMLEtBQUs7UUFDdEMsSUFBSyxJQUFJOVQsT0FBTzhULE1BQU87WUFDckIsSUFBSTlULFFBQVEsWUFBWTtnQkFDdEI7WUFDRjtZQUVBLElBQUltVSxPQUFPLENBQUNuVSxJQUFJLEtBQUs4VCxLQUFLLENBQUM5VCxJQUFJLEVBQUU7Z0JBQy9CLE9BQU87WUFDVDtRQUNGO1FBRUEsT0FBTztJQUNUO0FBQ0Y7QUFFQSxJQUFJb1UsY0FBYztJQUFDO0NBQU8sRUFDdEJDLGVBQWU7SUFBQztDQUFPO0FBRTNCLFNBQVNDLFVBQVV2UyxNQUFNLEVBQUVDLGNBQWM7SUFBSSxJQUFJQyxPQUFPbkYsT0FBT21GLElBQUksQ0FBQ0Y7SUFBUyxJQUFJakYsT0FBT29GLHFCQUFxQixFQUFFO1FBQUUsSUFBSUMsVUFBVXJGLE9BQU9vRixxQkFBcUIsQ0FBQ0g7UUFBUyxJQUFJQyxnQkFBZ0I7WUFBRUcsVUFBVUEsUUFBUUMsTUFBTSxDQUFDLFNBQVVDLEdBQUc7Z0JBQUksT0FBT3ZGLE9BQU93Rix3QkFBd0IsQ0FBQ1AsUUFBUU0sS0FBS3BDLFVBQVU7WUFBRTtRQUFJO1FBQUVnQyxLQUFLakIsSUFBSSxDQUFDdUIsS0FBSyxDQUFDTixNQUFNRTtJQUFVO0lBQUUsT0FBT0Y7QUFBTTtBQUUxVixTQUFTc1MsZ0JBQWdCOVIsTUFBTTtJQUFJLElBQUssSUFBSXRFLElBQUksR0FBR0EsSUFBSXVFLFVBQVV4RSxNQUFNLEVBQUVDLElBQUs7UUFBRSxJQUFJd0UsU0FBU0QsU0FBUyxDQUFDdkUsRUFBRSxJQUFJLE9BQU91RSxTQUFTLENBQUN2RSxFQUFFLEdBQUcsQ0FBQztRQUFHLElBQUlBLElBQUksR0FBRztZQUFFbVcsVUFBVXhYLE9BQU82RixTQUFTLE1BQU1DLE9BQU8sQ0FBQyxTQUFVNUMsR0FBRztnQkFBSUYsZ0JBQWdCMkMsUUFBUXpDLEtBQUsyQyxNQUFNLENBQUMzQyxJQUFJO1lBQUc7UUFBSSxPQUFPLElBQUlsRCxPQUFPK0YseUJBQXlCLEVBQUU7WUFBRS9GLE9BQU9nRyxnQkFBZ0IsQ0FBQ0wsUUFBUTNGLE9BQU8rRix5QkFBeUIsQ0FBQ0Y7UUFBVSxPQUFPO1lBQUUyUixVQUFVeFgsT0FBTzZGLFNBQVNDLE9BQU8sQ0FBQyxTQUFVNUMsR0FBRztnQkFBSWxELE9BQU9DLGNBQWMsQ0FBQzBGLFFBQVF6QyxLQUFLbEQsT0FBT3dGLHdCQUF3QixDQUFDSyxRQUFRM0M7WUFBTztRQUFJO0lBQUU7SUFBRSxPQUFPeUM7QUFBUTtBQUUzaEIsU0FBUytSLDZCQUE2QnZWLENBQUMsRUFBRStELGNBQWM7SUFBSSxJQUFJQyxLQUFLLE9BQU9yRSxXQUFXLGVBQWVLLENBQUMsQ0FBQ0wsT0FBT0MsUUFBUSxDQUFDLElBQUlJLENBQUMsQ0FBQyxhQUFhO0lBQUUsSUFBSSxDQUFDZ0UsSUFBSTtRQUFFLElBQUk1RSxNQUFNRyxPQUFPLENBQUNTLE1BQU9nRSxDQUFBQSxLQUFLd1IsOEJBQThCeFYsRUFBQyxLQUFNK0Qsa0JBQWtCL0QsS0FBSyxPQUFPQSxFQUFFZixNQUFNLEtBQUssVUFBVTtZQUFFLElBQUkrRSxJQUFJaEUsSUFBSWdFO1lBQUksSUFBSTlFLElBQUk7WUFBRyxJQUFJZ0YsSUFBSSxTQUFTQSxLQUFLO1lBQUcsT0FBTztnQkFBRUMsR0FBR0Q7Z0JBQUdoRSxHQUFHLFNBQVNBO29CQUFNLElBQUloQixLQUFLYyxFQUFFZixNQUFNLEVBQUUsT0FBTzt3QkFBRTZDLE1BQU07b0JBQUs7b0JBQUcsT0FBTzt3QkFBRUEsTUFBTTt3QkFBTzlELE9BQU9nQyxDQUFDLENBQUNkLElBQUk7b0JBQUM7Z0JBQUc7Z0JBQUdrRixHQUFHLFNBQVNBLEVBQUV4QyxFQUFFO29CQUFJLE1BQU1BO2dCQUFJO2dCQUFHeUMsR0FBR0g7WUFBRTtRQUFHO1FBQUUsTUFBTSxJQUFJeEQsVUFBVTtJQUEwSTtJQUFFLElBQUk0RCxtQkFBbUIsTUFBTUMsU0FBUyxPQUFPdkM7SUFBSyxPQUFPO1FBQUVtQyxHQUFHLFNBQVNBO1lBQU1ILEtBQUtBLEdBQUd2RixJQUFJLENBQUN1QjtRQUFJO1FBQUdFLEdBQUcsU0FBU0E7WUFBTSxJQUFJc0UsT0FBT1IsR0FBR25DLElBQUk7WUFBSXlDLG1CQUFtQkUsS0FBSzFDLElBQUk7WUFBRSxPQUFPMEM7UUFBTTtRQUFHSixHQUFHLFNBQVNBLEVBQUVLLEdBQUc7WUFBSUYsU0FBUztZQUFNdkMsTUFBTXlDO1FBQUs7UUFBR0osR0FBRyxTQUFTQTtZQUFNLElBQUk7Z0JBQUUsSUFBSSxDQUFDQyxvQkFBb0JOLEVBQUUsQ0FBQyxTQUFTLElBQUksTUFBTUEsRUFBRSxDQUFDLFNBQVM7WUFBSSxTQUFVO2dCQUFFLElBQUlPLFFBQVEsTUFBTXZDO1lBQUs7UUFBRTtJQUFFO0FBQUc7QUFFLytCLFNBQVN3VCw4QkFBOEJ4VixDQUFDLEVBQUVDLE1BQU07SUFBSSxJQUFJLENBQUNELEdBQUc7SUFBUSxJQUFJLE9BQU9BLE1BQU0sVUFBVSxPQUFPeVYsb0JBQW9CelYsR0FBR0M7SUFBUyxJQUFJQyxJQUFJckMsT0FBT1UsU0FBUyxDQUFDNEIsUUFBUSxDQUFDMUIsSUFBSSxDQUFDdUIsR0FBR0ksS0FBSyxDQUFDLEdBQUcsQ0FBQztJQUFJLElBQUlGLE1BQU0sWUFBWUYsRUFBRUssV0FBVyxFQUFFSCxJQUFJRixFQUFFSyxXQUFXLENBQUNDLElBQUk7SUFBRSxJQUFJSixNQUFNLFNBQVNBLE1BQU0sT0FBTyxPQUFPZCxNQUFNUyxJQUFJLENBQUNHO0lBQUksSUFBSUUsTUFBTSxlQUFlLDJDQUEyQ0ssSUFBSSxDQUFDTCxJQUFJLE9BQU91VixvQkFBb0J6VixHQUFHQztBQUFTO0FBRXJhLFNBQVN3VixvQkFBb0IxVyxHQUFHLEVBQUVDLEdBQUc7SUFBSSxJQUFJQSxPQUFPLFFBQVFBLE1BQU1ELElBQUlFLE1BQU0sRUFBRUQsTUFBTUQsSUFBSUUsTUFBTTtJQUFFLElBQUssSUFBSUMsSUFBSSxHQUFHQyxPQUFPLElBQUlDLE1BQU1KLE1BQU1FLElBQUlGLEtBQUtFLElBQUs7UUFBRUMsSUFBSSxDQUFDRCxFQUFFLEdBQUdILEdBQUcsQ0FBQ0csRUFBRTtJQUFFO0lBQUUsT0FBT0M7QUFBTTtBQUN4TCxJQUFJdVcsa0JBQWtCLElBQUlwVCxXQUFXLHdDQUF3QztBQUU3RSxJQUFJaUQsU0FBUztJQUNYOztHQUVDLEdBQ0RvUSxPQUFPLFNBQVNBLE1BQU0vUSxNQUFNO1FBQzFCLElBQUlnUixVQUFVblMsVUFBVXhFLE1BQU0sR0FBRyxLQUFLd0UsU0FBUyxDQUFDLEVBQUUsS0FBS2tNLFlBQVlsTSxTQUFTLENBQUMsRUFBRSxHQUFHLENBQUM7UUFDbkYsSUFBSW9TLGlCQUFpQkQsUUFBUXBNLEtBQUssRUFDOUJBLFFBQVFxTSxtQkFBbUIsS0FBSyxJQUFJLFFBQVFBLGdCQUM1Q0MsZ0JBQWdCRixRQUFRRyxJQUFJLEVBQzVCQSxPQUFPRCxrQkFBa0IsS0FBSyxJQUFJLFdBQVdBLGVBQzdDRSxjQUFjSixRQUFRMUssRUFBRSxFQUN4QkEsS0FBSzhLLGdCQUFnQixLQUFLLElBQUlwUixPQUFPRyxTQUFTLEdBQUdpUixhQUNqRDVOLFFBQVF3TixRQUFReE4sS0FBSztRQUV6QixJQUFJLENBQUM4QyxJQUFJO1lBQ1A7UUFDRjtRQUVBLElBQUlwRSxPQUFPdkIsT0FBT3VCLElBQUksQ0FBQ2xDLFFBQVFzRztRQUMvQixJQUFJdEIsVUFBVW1NLFNBQVM7UUFFdkIsSUFBSXpRLFlBQVlpUSw2QkFBNkJoUSxPQUFPa0gsTUFBTSxDQUFDN0gsUUFBUTtZQUNqRXNHLElBQUlwRTtZQUNKMEMsT0FBT0E7WUFDUHBCLE9BQU9BO1lBQ1B3QixTQUFTQTtRQUNYLEtBQ0luRTtRQUVKLElBQUk7WUFDRixJQUFLSCxVQUFVbkIsQ0FBQyxJQUFJLENBQUMsQ0FBQ3NCLFFBQVFILFVBQVVwRixDQUFDLEVBQUMsRUFBRzRCLElBQUksRUFBRztnQkFDbEQsSUFBSW1VLGNBQWM3VCxlQUFlcUQsTUFBTXpILEtBQUssRUFBRSxJQUMxQ2tDLElBQUkrVixXQUFXLENBQUMsRUFBRSxFQUNsQmxKLElBQUlrSixXQUFXLENBQUMsRUFBRTtnQkFFdEIsSUFBSTNOLEtBQUtDLE1BQU0sQ0FBQ3JJLElBQUk7Z0JBRXBCLElBQUkySSxNQUFNcU4sT0FBTyxDQUFDaEwsS0FBSztvQkFDckIsSUFBSWpFLEtBQUt1TixVQUFVLENBQUN6SCxHQUFHN0IsR0FBR2lMLE1BQU0sQ0FBQ3JQLElBQUksS0FBS0csS0FBS3VOLFVBQVUsQ0FBQ3pILEdBQUc3QixHQUFHa0wsS0FBSyxDQUFDdFAsSUFBSSxHQUFHO3dCQUMzRSxPQUFPOzRCQUFDNUc7NEJBQUc2TTt5QkFBRTtvQkFDZjtnQkFDRixPQUFPO29CQUNMLElBQUksQ0FBQzlGLEtBQUs2RSxNQUFNLENBQUNoRixNQUFNaUcsSUFBSTt3QkFDekIsT0FBTzs0QkFBQzdNOzRCQUFHNk07eUJBQUU7b0JBQ2Y7Z0JBQ0Y7WUFDRjtRQUNGLEVBQUUsT0FBTy9LLEtBQUs7WUFDWnNELFVBQVVsQixDQUFDLENBQUNwQztRQUNkLFNBQVU7WUFDUnNELFVBQVVqQixDQUFDO1FBQ2I7SUFDRjtJQUVBOzs7OztHQUtDLEdBQ0Q4RCxTQUFTLFNBQVNBLFFBQVF2RCxNQUFNLEVBQUU3RCxHQUFHLEVBQUUvQyxLQUFLO1FBQzFDNEcsT0FBT3VELE9BQU8sQ0FBQ3BILEtBQUsvQztJQUN0QjtJQUVBOztHQUVDLEdBQ0RxWSxPQUFPLFNBQVNBLE1BQU16UixNQUFNLEVBQUVzRyxFQUFFO1FBQzlCLElBQUkwSyxVQUFVblMsVUFBVXhFLE1BQU0sR0FBRyxLQUFLd0UsU0FBUyxDQUFDLEVBQUUsS0FBS2tNLFlBQVlsTSxTQUFTLENBQUMsRUFBRSxHQUFHLENBQUM7UUFDbkYsSUFBSTBTLFNBQVM1USxPQUFPK1EsS0FBSyxDQUFDMVIsUUFBUXNHLElBQUk7WUFDcENxTCxNQUFNO1FBQ1I7UUFDQSxJQUFJSCxRQUFRN1EsT0FBTzZNLEdBQUcsQ0FBQ3hOLFFBQVEsRUFBRTtRQUNqQyxJQUFJNFIsUUFBUTtZQUNWTCxRQUFRQTtZQUNSQyxPQUFPQTtRQUNUO1FBQ0EsSUFBSUssb0JBQW9CYixRQUFRekYsUUFBUSxFQUNwQ0EsV0FBV3NHLHNCQUFzQixLQUFLLElBQUksSUFBSUE7UUFDbEQsSUFBSUMsSUFBSTtRQUNSLElBQUlsVDtRQUVKLElBQUlxQyxhQUFhMFAsNkJBQTZCaFEsT0FBT29SLFNBQVMsQ0FBQy9SLFFBQVEwUSxnQkFBZ0JBLGdCQUFnQixDQUFDLEdBQUdNLFVBQVUsQ0FBQyxHQUFHO1lBQ3ZIMUssSUFBSXNMO1FBQ04sTUFDSXpRO1FBRUosSUFBSTtZQUNGLElBQUtGLFdBQVcxQixDQUFDLElBQUksQ0FBQyxDQUFDNEIsU0FBU0YsV0FBVzNGLENBQUMsRUFBQyxFQUFHNEIsSUFBSSxFQUFHO2dCQUNyRCxJQUFJaUwsSUFBSWhILE9BQU8vSCxLQUFLO2dCQUVwQixJQUFJMFksSUFBSXZHLFVBQVU7b0JBQ2hCO2dCQUNGO2dCQUVBLElBQUl1RyxNQUFNLEdBQUc7b0JBQ1hsVCxTQUFTdUo7Z0JBQ1g7Z0JBRUEySjtZQUNGO1FBQ0YsRUFBRSxPQUFPMVUsS0FBSztZQUNaNkQsV0FBV3pCLENBQUMsQ0FBQ3BDO1FBQ2YsU0FBVTtZQUNSNkQsV0FBV3hCLENBQUM7UUFDZDtRQUVBLE9BQU9iO0lBQ1Q7SUFFQTs7R0FFQyxHQUNEb1QsUUFBUSxTQUFTQSxPQUFPaFMsTUFBTSxFQUFFc0csRUFBRTtRQUNoQyxJQUFJMEssVUFBVW5TLFVBQVV4RSxNQUFNLEdBQUcsS0FBS3dFLFNBQVMsQ0FBQyxFQUFFLEtBQUtrTSxZQUFZbE0sU0FBUyxDQUFDLEVBQUUsR0FBRyxDQUFDO1FBQ25GLElBQUkwUyxTQUFTNVEsT0FBT3NSLEtBQUssQ0FBQ2pTLFFBQVEsRUFBRTtRQUNwQyxJQUFJd1IsUUFBUTdRLE9BQU8rUSxLQUFLLENBQUMxUixRQUFRc0csSUFBSTtZQUNuQ3FMLE1BQU07UUFDUjtRQUNBLElBQUlDLFFBQVE7WUFDVkwsUUFBUUE7WUFDUkMsT0FBT0E7UUFDVDtRQUNBLElBQUlVLHFCQUFxQmxCLFFBQVF6RixRQUFRLEVBQ3JDQSxXQUFXMkcsdUJBQXVCLEtBQUssSUFBSSxJQUFJQTtRQUNuRCxJQUFJSixJQUFJO1FBQ1IsSUFBSWxUO1FBRUosSUFBSTBDLGFBQWFxUCw2QkFBNkJoUSxPQUFPb1IsU0FBUyxDQUFDL1IsUUFBUTBRLGdCQUFnQkEsZ0JBQWdCLENBQUMsR0FBR00sVUFBVSxDQUFDLEdBQUc7WUFDdkgxSyxJQUFJc0w7WUFDSjVNLFNBQVM7UUFDWCxNQUNJeEQ7UUFFSixJQUFJO1lBQ0YsSUFBS0YsV0FBVy9CLENBQUMsSUFBSSxDQUFDLENBQUNpQyxTQUFTRixXQUFXaEcsQ0FBQyxFQUFDLEVBQUc0QixJQUFJLEVBQUc7Z0JBQ3JELElBQUlpTCxJQUFJM0csT0FBT3BJLEtBQUs7Z0JBRXBCLElBQUkwWSxJQUFJdkcsVUFBVTtvQkFDaEI7Z0JBQ0Y7Z0JBRUEsSUFBSXVHLE1BQU0sR0FBRztvQkFDWGxULFNBQVN1SjtnQkFDWDtnQkFFQTJKO1lBQ0Y7UUFDRixFQUFFLE9BQU8xVSxLQUFLO1lBQ1prRSxXQUFXOUIsQ0FBQyxDQUFDcEM7UUFDZixTQUFVO1lBQ1JrRSxXQUFXN0IsQ0FBQztRQUNkO1FBRUEsT0FBT2I7SUFDVDtJQUVBOztHQUVDLEdBQ0RpRyxnQkFBZ0IsU0FBU0EsZUFBZTdFLE1BQU07UUFDNUMsSUFBSWdSLFVBQVVuUyxVQUFVeEUsTUFBTSxHQUFHLEtBQUt3RSxTQUFTLENBQUMsRUFBRSxLQUFLa00sWUFBWWxNLFNBQVMsQ0FBQyxFQUFFLEdBQUcsQ0FBQztRQUNuRixJQUFJc1QsZ0JBQWdCbkIsUUFBUWxNLElBQUksRUFDNUJBLE9BQU9xTixrQkFBa0IsS0FBSyxJQUFJLGNBQWNBO1FBQ3BEblMsT0FBTzZFLGNBQWMsQ0FBQ0M7SUFDeEI7SUFFQTs7R0FFQyxHQUNERyxlQUFlLFNBQVNBLGNBQWNqRixNQUFNO1FBQzFDLElBQUlnUixVQUFVblMsVUFBVXhFLE1BQU0sR0FBRyxLQUFLd0UsU0FBUyxDQUFDLEVBQUUsS0FBS2tNLFlBQVlsTSxTQUFTLENBQUMsRUFBRSxHQUFHLENBQUM7UUFDbkYsSUFBSXVULGlCQUFpQnBCLFFBQVFsTSxJQUFJLEVBQzdCQSxPQUFPc04sbUJBQW1CLEtBQUssSUFBSSxjQUFjQTtRQUNyRHBTLE9BQU9pRixhQUFhLENBQUNIO0lBQ3ZCO0lBRUE7O0dBRUMsR0FDREksZ0JBQWdCLFNBQVNBLGVBQWVsRixNQUFNO1FBQzVDLElBQUlnUixVQUFVblMsVUFBVXhFLE1BQU0sR0FBRyxLQUFLd0UsU0FBUyxDQUFDLEVBQUUsS0FBS2tNLFlBQVlsTSxTQUFTLENBQUMsRUFBRSxHQUFHLENBQUM7UUFDbkYsSUFBSXdULHFCQUFxQnJCLFFBQVE3TCxTQUFTLEVBQ3RDQSxZQUFZa04sdUJBQXVCLEtBQUssSUFBSSxZQUFZQTtRQUM1RHJTLE9BQU9rRixjQUFjLENBQUNDO0lBQ3hCO0lBRUE7O0dBRUMsR0FDRG1OLE9BQU8sU0FBU0EsTUFBTXRTLE1BQU0sRUFBRXNHLEVBQUU7UUFDOUIsT0FBTztZQUFDM0YsT0FBT3NSLEtBQUssQ0FBQ2pTLFFBQVFzRztZQUFLM0YsT0FBTzZNLEdBQUcsQ0FBQ3hOLFFBQVFzRztTQUFJO0lBQzNEO0lBRUE7O0dBRUMsR0FDRGtILEtBQUssU0FBU0EsSUFBSXhOLE1BQU0sRUFBRXNHLEVBQUU7UUFDMUIsT0FBTzNGLE9BQU8rUSxLQUFLLENBQUMxUixRQUFRc0csSUFBSTtZQUM5QnFMLE1BQU07UUFDUjtJQUNGO0lBRUE7O0dBRUMsR0FDRFksT0FBTyxTQUFTQSxNQUFNdlMsTUFBTSxFQUFFc0csRUFBRTtRQUM5QixJQUFJcEUsT0FBT3ZCLE9BQU91QixJQUFJLENBQUNsQyxRQUFRc0csSUFBSTtZQUNqQ3FMLE1BQU07UUFDUjtRQUNBLE9BQU9oUixPQUFPOEMsSUFBSSxDQUFDekQsUUFBUWtDO0lBQzdCO0lBRUE7O0dBRUMsR0FDRG9ELFVBQVUsU0FBU0EsU0FBU3RGLE1BQU0sRUFBRXNHLEVBQUU7UUFDcEMsSUFBSXNMLFFBQVFqUixPQUFPaVIsS0FBSyxDQUFDNVIsUUFBUXNHO1FBQ2pDLElBQUloQixXQUFXRCxLQUFLQyxRQUFRLENBQUN0RixRQUFRNFI7UUFDckMsT0FBT3RNO0lBQ1Q7SUFFQTs7R0FFQyxHQUNEa04sV0FBVyxTQUFTQSxVQUFVeFMsTUFBTSxFQUFFc1EsT0FBTztRQUMzQyxPQUFPQSxRQUFRclEsUUFBUSxDQUFDd1MsSUFBSSxDQUFDLFNBQVVuWCxDQUFDO1lBQ3RDLE9BQU82SyxRQUFRQyxTQUFTLENBQUM5SyxNQUFNcUYsT0FBTytSLE9BQU8sQ0FBQzFTLFFBQVExRTtRQUN4RDtJQUNGO0lBRUE7O0dBRUMsR0FDRHFYLFlBQVksU0FBU0EsV0FBVzNTLE1BQU0sRUFBRXNRLE9BQU87UUFDN0MsT0FBT0EsUUFBUXJRLFFBQVEsQ0FBQ3dTLElBQUksQ0FBQyxTQUFVblgsQ0FBQztZQUN0QyxPQUFPb0ksS0FBS0MsTUFBTSxDQUFDckksTUFBTXFGLE9BQU9OLFFBQVEsQ0FBQ0wsUUFBUTFFO1FBQ25EO0lBQ0Y7SUFFQTs7R0FFQyxHQUNEc1gsVUFBVSxTQUFTQSxTQUFTNVMsTUFBTSxFQUFFc1EsT0FBTztRQUN6QyxPQUFPQSxRQUFRclEsUUFBUSxDQUFDNlAsS0FBSyxDQUFDLFNBQVV4VSxDQUFDO1lBQ3ZDLE9BQU9vSSxLQUFLQyxNQUFNLENBQUNySTtRQUNyQjtJQUNGO0lBRUE7Ozs7R0FJQyxHQUNEaUssYUFBYSxTQUFTQSxZQUFZdkYsTUFBTTtRQUN0Q0EsT0FBT3VGLFdBQVc7SUFDcEI7SUFFQTs7OztHQUlDLEdBQ0RHLGlCQUFpQixTQUFTQSxnQkFBZ0IxRixNQUFNO1FBQzlDQSxPQUFPMEYsZUFBZTtJQUN4QjtJQUVBOzs7O0dBSUMsR0FDREMsZ0JBQWdCLFNBQVNBLGVBQWUzRixNQUFNLEVBQUVzRixRQUFRO1FBQ3REdEYsT0FBTzJGLGNBQWMsQ0FBQ0w7SUFDeEI7SUFFQTs7OztHQUlDLEdBQ0RNLFlBQVksU0FBU0EsV0FBVzVGLE1BQU0sRUFBRXlELElBQUk7UUFDMUN6RCxPQUFPNEYsVUFBVSxDQUFDbkM7SUFDcEI7SUFFQTs7OztHQUlDLEdBQ0RxQyxZQUFZLFNBQVNBLFdBQVc5RixNQUFNLEVBQUUrRixJQUFJO1FBQzFDL0YsT0FBTzhGLFVBQVUsQ0FBQ0M7SUFDcEI7SUFFQTs7R0FFQyxHQUNEMk0sU0FBUyxTQUFTQSxRQUFRMVMsTUFBTSxFQUFFNUcsS0FBSztRQUNyQyxPQUFPLENBQUM0RyxPQUFPSyxRQUFRLENBQUNqSDtJQUMxQjtJQUVBOztHQUVDLEdBQ0RxTixVQUFVLFNBQVNBLFNBQVNyTixLQUFLO1FBQy9CLElBQUl5WixpQkFBaUIvQixnQkFBZ0JsUCxHQUFHLENBQUN4STtRQUV6QyxJQUFJeVosbUJBQW1COUgsV0FBVztZQUNoQyxPQUFPOEg7UUFDVDtRQUVBLElBQUksQ0FBQ3haLGNBQWNBLGFBQWEsQ0FBQ0QsUUFBUTtZQUN2QyxPQUFPO1FBQ1Q7UUFFQSxJQUFJcU4sV0FBVyxPQUFPck4sTUFBTW1LLE9BQU8sS0FBSyxjQUFjLE9BQU9uSyxNQUFNc0YsS0FBSyxLQUFLLGNBQWMsT0FBT3RGLE1BQU15TCxjQUFjLEtBQUssY0FBYyxPQUFPekwsTUFBTTZMLGFBQWEsS0FBSyxjQUFjLE9BQU83TCxNQUFNOEwsY0FBYyxLQUFLLGNBQWMsT0FBTzlMLE1BQU1tTSxXQUFXLEtBQUssY0FBYyxPQUFPbk0sTUFBTXNNLGVBQWUsS0FBSyxjQUFjLE9BQU90TSxNQUFNdU0sY0FBYyxLQUFLLGNBQWMsT0FBT3ZNLE1BQU13TSxVQUFVLEtBQUssY0FBYyxPQUFPeE0sTUFBTTBNLFVBQVUsS0FBSyxjQUFjLE9BQU8xTSxNQUFNaUgsUUFBUSxLQUFLLGNBQWMsT0FBT2pILE1BQU1rSCxNQUFNLEtBQUssY0FBYyxPQUFPbEgsTUFBTTRNLGFBQWEsS0FBSyxjQUFjLE9BQU81TSxNQUFNb0gsUUFBUSxLQUFLLGNBQWMsT0FBT3BILE1BQU1pTyxVQUFVLEtBQUssY0FBYyxPQUFPak8sTUFBTXVKLGFBQWEsS0FBSyxjQUFldkosQ0FBQUEsTUFBTWdILEtBQUssS0FBSyxRQUFRL0csY0FBY0EsYUFBYSxDQUFDRCxNQUFNZ0gsS0FBSyxNQUFPaEgsQ0FBQUEsTUFBTStHLFNBQVMsS0FBSyxRQUFROEQsTUFBTXFOLE9BQU8sQ0FBQ2xZLE1BQU0rRyxTQUFTLE1BQU1rRixLQUFLc0ssVUFBVSxDQUFDdlcsTUFBTTZHLFFBQVEsS0FBSzZTLFVBQVVDLGVBQWUsQ0FBQzNaLE1BQU04RyxVQUFVO1FBQzc0QjRRLGdCQUFnQi9OLEdBQUcsQ0FBQzNKLE9BQU9xTjtRQUMzQixPQUFPQTtJQUNUO0lBRUE7O0dBRUMsR0FDRHVNLE9BQU8sU0FBU0EsTUFBTWhULE1BQU0sRUFBRTBSLEtBQUssRUFBRXBMLEVBQUU7UUFDckMsSUFBSWtILE1BQU03TSxPQUFPNk0sR0FBRyxDQUFDeE4sUUFBUXNHO1FBQzdCLE9BQU8yTSxNQUFNL0wsTUFBTSxDQUFDd0ssT0FBT2xFO0lBQzdCO0lBRUE7O0dBRUMsR0FDRDBGLFFBQVEsU0FBU0EsT0FBT2xULE1BQU0sRUFBRTBSLEtBQUssRUFBRXBMLEVBQUU7UUFDdkMsT0FBTzNGLE9BQU93UyxPQUFPLENBQUNuVCxRQUFRMFIsT0FBT3BMLE9BQU8zRixPQUFPcVMsS0FBSyxDQUFDaFQsUUFBUTBSLE9BQU9wTDtJQUMxRTtJQUVBOztHQUVDLEdBQ0Q4TSxTQUFTLFNBQVNBLFFBQVFwVCxNQUFNLEVBQUVzUSxPQUFPO1FBQ3ZDLElBQUlyUSxXQUFXcVEsUUFBUXJRLFFBQVE7UUFFL0IsSUFBSW9ULFlBQVk3VixlQUFleUMsVUFBVSxJQUNyQ3NTLFFBQVFjLFNBQVMsQ0FBQyxFQUFFO1FBRXhCLE9BQU9wVCxTQUFTNUYsTUFBTSxLQUFLLEtBQUs0RixTQUFTNUYsTUFBTSxLQUFLLEtBQUtxSixLQUFLQyxNQUFNLENBQUM0TyxVQUFVQSxNQUFNeE0sSUFBSSxLQUFLLE1BQU0sQ0FBQy9GLE9BQU9NLE1BQU0sQ0FBQ2dRO0lBQ3JIO0lBRUE7O0dBRUMsR0FDRGpRLFVBQVUsU0FBU0EsU0FBU0wsTUFBTSxFQUFFNUcsS0FBSztRQUN2QyxPQUFPNEcsT0FBT0ssUUFBUSxDQUFDakg7SUFDekI7SUFFQTs7R0FFQyxHQUNEa2EsZUFBZSxTQUFTQSxjQUFjdFQsTUFBTTtRQUMxQyxJQUFJc1QsZ0JBQWdCelYsWUFBWStELEdBQUcsQ0FBQzVCO1FBQ3BDLE9BQU9zVCxrQkFBa0J2SSxZQUFZLE9BQU91STtJQUM5QztJQUVBOztHQUVDLEdBQ0RILFNBQVMsU0FBU0EsUUFBUW5ULE1BQU0sRUFBRTBSLEtBQUssRUFBRXBMLEVBQUU7UUFDekMsNERBQTREO1FBQzVELElBQUlvTCxNQUFNNkIsTUFBTSxLQUFLLEdBQUc7WUFDdEIsT0FBTztRQUNUO1FBRUEsSUFBSXRCLFFBQVF0UixPQUFPc1IsS0FBSyxDQUFDalMsUUFBUXNHO1FBQ2pDLE9BQU8yTSxNQUFNL0wsTUFBTSxDQUFDd0ssT0FBT087SUFDN0I7SUFFQTs7R0FFQyxHQUNEM1IsUUFBUSxTQUFTQSxPQUFPTixNQUFNLEVBQUU1RyxLQUFLO1FBQ25DLE9BQU80RyxPQUFPTSxNQUFNLENBQUNsSDtJQUN2QjtJQUVBOztHQUVDLEdBQ0RvYSxNQUFNLFNBQVNBLEtBQUt4VCxNQUFNLEVBQUVzRyxFQUFFO1FBQzVCLElBQUlwRSxPQUFPdkIsT0FBT3VCLElBQUksQ0FBQ2xDLFFBQVFzRyxJQUFJO1lBQ2pDcUwsTUFBTTtRQUNSO1FBQ0EsT0FBT2hSLE9BQU84QyxJQUFJLENBQUN6RCxRQUFRa0M7SUFDN0I7SUFFQTs7R0FFQyxHQUNEdVIsTUFBTSxTQUFTQSxLQUFLelQsTUFBTSxFQUFFc0csRUFBRTtRQUM1QixJQUFJMEssVUFBVW5TLFVBQVV4RSxNQUFNLEdBQUcsS0FBS3dFLFNBQVMsQ0FBQyxFQUFFLEtBQUtrTSxZQUFZbE0sU0FBUyxDQUFDLEVBQUUsR0FBRyxDQUFDO1FBQ25GLElBQUlxRCxPQUFPdkIsT0FBT3VCLElBQUksQ0FBQ2xDLFFBQVFzRyxJQUFJMEs7UUFDbkMsSUFBSXZOLE9BQU80QixLQUFLb08sSUFBSSxDQUFDelQsUUFBUWtDO1FBQzdCLE9BQU87WUFBQ3VCO1lBQU12QjtTQUFLO0lBQ3JCO0lBRUE7O0dBRUMsR0FDRDJGLFFBQVEsVUFBVUEsT0FBTzdILE1BQU07UUFDN0IsSUFBSWdSLFVBQVVuUyxVQUFVeEUsTUFBTSxHQUFHLEtBQUt3RSxTQUFTLENBQUMsRUFBRSxLQUFLa00sWUFBWWxNLFNBQVMsQ0FBQyxFQUFFLEdBQUcsQ0FBQztRQUNuRixJQUFJNlUsZUFBZTFDLFFBQVExSyxFQUFFLEVBQ3pCQSxLQUFLb04saUJBQWlCLEtBQUssSUFBSTFULE9BQU9HLFNBQVMsR0FBR3VULGNBQ2xEQyxtQkFBbUIzQyxRQUFRaE0sT0FBTyxFQUNsQ0EsVUFBVTJPLHFCQUFxQixLQUFLLElBQUksUUFBUUEsa0JBQ2hEQyxrQkFBa0I1QyxRQUFRcE0sS0FBSyxFQUMvQkEsUUFBUWdQLG9CQUFvQixLQUFLLElBQUksUUFBUUE7UUFDakQsSUFBSXBRLFFBQVF3TixRQUFReE4sS0FBSztRQUV6QixJQUFJQSxTQUFTLE1BQU07WUFDakJBLFFBQVEsU0FBU0E7Z0JBQ2YsT0FBTztZQUNUO1FBQ0Y7UUFFQSxJQUFJLENBQUM4QyxJQUFJO1lBQ1A7UUFDRjtRQUVBLElBQUl1QixTQUFTLEVBQUU7UUFDZixJQUFJM0YsT0FBT3ZCLE9BQU91QixJQUFJLENBQUNsQyxRQUFRc0c7UUFFL0IsSUFBSS9ELGFBQWFvTyw2QkFBNkJ0TCxLQUFLd0MsTUFBTSxDQUFDN0gsUUFBUWtDLFFBQzlETTtRQUVKLElBQUk7WUFDRixJQUFLRCxXQUFXaEQsQ0FBQyxJQUFJLENBQUMsQ0FBQ2lELFNBQVNELFdBQVdqSCxDQUFDLEVBQUMsRUFBRzRCLElBQUksRUFBRztnQkFDckQsSUFBSTJXLGVBQWVyVyxlQUFlZ0YsT0FBT3BKLEtBQUssRUFBRSxJQUM1Q2tDLElBQUl1WSxZQUFZLENBQUMsRUFBRSxFQUNuQjFMLElBQUkwTCxZQUFZLENBQUMsRUFBRTtnQkFFdkIsSUFBSSxDQUFDclEsTUFBTWxJLEdBQUc2TSxJQUFJO29CQUNoQjtnQkFDRjtnQkFFQU4sT0FBTzFLLElBQUksQ0FBQztvQkFBQzdCO29CQUFHNk07aUJBQUU7Z0JBRWxCLElBQUksQ0FBQ3ZELFNBQVN1QixRQUFRQyxTQUFTLENBQUM5SyxNQUFNcUYsT0FBT0wsTUFBTSxDQUFDTixRQUFRMUUsSUFBSTtvQkFDOUQ7Z0JBQ0Y7WUFDRjtRQUNGLEVBQUUsT0FBTzhCLEtBQUs7WUFDWm1GLFdBQVcvQyxDQUFDLENBQUNwQztRQUNmLFNBQVU7WUFDUm1GLFdBQVc5QyxDQUFDO1FBQ2Q7UUFFQSxJQUFJdUYsU0FBUztZQUNYNkMsT0FBTzdDLE9BQU87UUFDaEI7UUFFQSxPQUFPNkM7SUFDVDtJQUVBOztHQUVDLEdBQ0R6SCxPQUFPLFNBQVNBLE1BQU1KLE1BQU07UUFDMUIsSUFBSUksUUFBUUosT0FBT0ksS0FBSyxFQUNwQkQsWUFBWUgsT0FBT0csU0FBUztRQUVoQyxJQUFJLENBQUNBLFdBQVc7WUFDZCxPQUFPO1FBQ1Q7UUFFQSxJQUFJQyxPQUFPO1lBQ1QsT0FBT0E7UUFDVDtRQUVBLElBQUk2RCxNQUFNQyxVQUFVLENBQUMvRCxZQUFZO1lBQy9CLElBQUkyVCxnQkFBZ0JuVCxPQUFPcUgsS0FBSyxDQUFDaEksUUFBUTtnQkFDdkN3RCxPQUFPRSxLQUFLQyxNQUFNO1lBQ3BCLElBQ0lvUSxpQkFBaUJ2VyxlQUFlc1csZUFBZSxJQUMvQ3RRLFFBQVF1USxjQUFjLENBQUMsRUFBRTtZQUU3QixJQUFJdlEsT0FBTztnQkFDVCxJQUFJd1EsU0FBU3hXLGVBQWVnRyxPQUFPLElBQy9CeVEsUUFBUUQsTUFBTSxDQUFDLEVBQUU7Z0JBRXJCQyxNQUFNbE8sSUFBSTtnQkFDTixJQUFJbU8sUUFBUTVKLHlCQUF5QjJKLE9BQU8xRDtnQkFFaEQsT0FBTzJEO1lBQ1QsT0FBTztnQkFDTCxPQUFPLENBQUM7WUFDVjtRQUNGO1FBRUEsSUFBSTNDLFNBQVNwUixVQUFVb1IsTUFBTTtRQUM3QixJQUFJclAsT0FBT3FQLE9BQU9yUCxJQUFJO1FBRXRCLElBQUlpUyxlQUFleFQsT0FBTzhTLElBQUksQ0FBQ3pULFFBQVFrQyxPQUNuQ2tTLGdCQUFnQjVXLGVBQWUyVyxjQUFjLElBQzdDMVEsT0FBTzJRLGFBQWEsQ0FBQyxFQUFFO1FBRTNCLElBQUk3QyxPQUFPZ0MsTUFBTSxLQUFLLEdBQUc7WUFDdkIsSUFBSTNNLE9BQU9qRyxPQUFPNEgsUUFBUSxDQUFDdkksUUFBUTtnQkFDakNzRyxJQUFJcEU7Z0JBQ0pzQixPQUFPRSxLQUFLQyxNQUFNO1lBQ3BCO1lBQ0EsSUFBSTBRLGFBQWExVCxPQUFPb1EsS0FBSyxDQUFDL1EsUUFBUTtnQkFDcEN3RCxPQUFPLFNBQVNBLE1BQU1sSSxDQUFDO29CQUNyQixPQUFPNkssUUFBUUMsU0FBUyxDQUFDOUssTUFBTXFGLE9BQU9MLE1BQU0sQ0FBQ04sUUFBUTFFLE1BQU0wRSxPQUFPTyxZQUFZLENBQUNqRjtnQkFDakY7WUFDRjtZQUVBLElBQUksQ0FBQytZLFlBQVk7Z0JBQ2YsSUFBSUMsUUFBUTNULE9BQU9vUSxLQUFLLENBQUMvUSxRQUFRO29CQUMvQndELE9BQU8sU0FBU0EsTUFBTWxJLENBQUM7d0JBQ3JCLE9BQU82SyxRQUFRQyxTQUFTLENBQUM5SyxNQUFNcUYsT0FBTytSLE9BQU8sQ0FBQzFTLFFBQVExRTtvQkFDeEQ7Z0JBQ0Y7Z0JBRUEsSUFBSXNMLFFBQVEwTixPQUFPO29CQUNqQixJQUFJQyxRQUFRL1csZUFBZW9KLE1BQU0sSUFDN0I0TixXQUFXRCxLQUFLLENBQUMsRUFBRSxFQUNuQkUsV0FBV0YsS0FBSyxDQUFDLEVBQUU7b0JBRXZCLElBQUlHLFNBQVNsWCxlQUFlOFcsT0FBTyxJQUMvQkssWUFBWUQsTUFBTSxDQUFDLEVBQUU7b0JBRXpCLElBQUlyUyxLQUFLdU4sVUFBVSxDQUFDK0UsV0FBV0YsV0FBVzt3QkFDeENoUixPQUFPK1E7b0JBQ1Q7Z0JBQ0Y7WUFDRjtRQUNGO1FBRUEsSUFBSUksU0FBU25SO1FBQ1RtUixPQUFPN08sSUFBSTtRQUNYLElBQUk4TyxPQUFPdksseUJBQXlCc0ssUUFBUXBFO1FBRWhELE9BQU9xRTtJQUNUO0lBRUE7O0dBRUMsR0FDRDVYLE1BQU0sU0FBU0EsS0FBSytDLE1BQU07UUFDeEIsSUFBSWdSLFVBQVVuUyxVQUFVeEUsTUFBTSxHQUFHLEtBQUt3RSxTQUFTLENBQUMsRUFBRSxLQUFLa00sWUFBWWxNLFNBQVMsQ0FBQyxFQUFFLEdBQUcsQ0FBQztRQUNuRixJQUFJaVcsaUJBQWlCOUQsUUFBUUcsSUFBSSxFQUM3QkEsT0FBTzJELG1CQUFtQixLQUFLLElBQUksV0FBV0EsZ0JBQzlDQyxrQkFBa0IvRCxRQUFRcE0sS0FBSyxFQUMvQkEsUUFBUW1RLG9CQUFvQixLQUFLLElBQUksUUFBUUE7UUFDakQsSUFBSXZSLFFBQVF3TixRQUFReE4sS0FBSyxFQUNyQndSLGVBQWVoRSxRQUFRMUssRUFBRSxFQUN6QkEsS0FBSzBPLGlCQUFpQixLQUFLLElBQUloVixPQUFPRyxTQUFTLEdBQUc2VTtRQUV0RCxJQUFJLENBQUMxTyxJQUFJO1lBQ1A7UUFDRjtRQUVBLElBQUkyTyxxQkFBcUJ0VSxPQUFPOFEsS0FBSyxDQUFDelIsUUFBUXNHLElBQUk7WUFDaEQxQixPQUFPQTtRQUNUO1FBQ0EsSUFBSSxDQUFDcVEsb0JBQW9CO1FBRXpCLElBQUlDLGVBQWV2VSxPQUFPNlMsSUFBSSxDQUFDeFQsUUFBUSxFQUFFLEdBQ3JDbVYsZ0JBQWdCM1gsZUFBZTBYLGNBQWMsSUFDN0NFLEtBQUtELGFBQWEsQ0FBQyxFQUFFO1FBRXpCLElBQUlFLE9BQU87WUFBQ0osbUJBQW1CL1MsSUFBSTtZQUFFa1Q7U0FBRztRQUV4QyxJQUFJL1MsS0FBS2lULE1BQU0sQ0FBQ2hQLE9BQU9BLEdBQUdqTSxNQUFNLEtBQUssR0FBRztZQUN0QyxNQUFNLElBQUkwUCxNQUFNO1FBQ2xCO1FBRUEsSUFBSXZHLFNBQVMsTUFBTTtZQUNqQixJQUFJbkIsS0FBS2lULE1BQU0sQ0FBQ2hQLEtBQUs7Z0JBQ25CLElBQUkxQyxpQkFBaUJqRCxPQUFPa0QsTUFBTSxDQUFDN0QsUUFBUXNHLEtBQ3ZDeEMsa0JBQWtCdEcsZUFBZW9HLGdCQUFnQixJQUNqREMsU0FBU0MsZUFBZSxDQUFDLEVBQUU7Z0JBRS9CTixRQUFRLFNBQVNBLE1BQU1sSSxDQUFDO29CQUN0QixPQUFPdUksT0FBTzVELFFBQVEsQ0FBQ3NWLFFBQVEsQ0FBQ2phO2dCQUNsQztZQUNGLE9BQU87Z0JBQ0xrSSxRQUFRLFNBQVNBO29CQUNmLE9BQU87Z0JBQ1Q7WUFDRjtRQUNGO1FBRUEsSUFBSWdTLGlCQUFpQjdVLE9BQU9xSCxLQUFLLENBQUNoSSxRQUFRO1lBQ3hDc0csSUFBSStPO1lBQ0o3UixPQUFPQTtZQUNQMk4sTUFBTUE7WUFDTnZNLE9BQU9BO1FBQ1QsSUFDSTZRLGlCQUFpQmpZLGVBQWVnWSxnQkFBZ0IsSUFDaER2WSxPQUFPd1ksY0FBYyxDQUFDLEVBQUU7UUFFNUIsT0FBT3hZO0lBQ1Q7SUFFQTs7R0FFQyxHQUNEd0csTUFBTSxTQUFTQSxLQUFLekQsTUFBTSxFQUFFc0csRUFBRTtRQUM1QixJQUFJMEssVUFBVW5TLFVBQVV4RSxNQUFNLEdBQUcsS0FBS3dFLFNBQVMsQ0FBQyxFQUFFLEtBQUtrTSxZQUFZbE0sU0FBUyxDQUFDLEVBQUUsR0FBRyxDQUFDO1FBQ25GLElBQUlxRCxPQUFPdkIsT0FBT3VCLElBQUksQ0FBQ2xDLFFBQVFzRyxJQUFJMEs7UUFDbkMsSUFBSXZOLE9BQU80QixLQUFLekQsR0FBRyxDQUFDNUIsUUFBUWtDO1FBQzVCLE9BQU87WUFBQ3VCO1lBQU12QjtTQUFLO0lBQ3JCO0lBRUE7O0dBRUMsR0FDRDhGLE9BQU8sVUFBVUEsTUFBTWhJLE1BQU07UUFDM0IsSUFBSWdSLFVBQVVuUyxVQUFVeEUsTUFBTSxHQUFHLEtBQUt3RSxTQUFTLENBQUMsRUFBRSxLQUFLa00sWUFBWWxNLFNBQVMsQ0FBQyxFQUFFLEdBQUcsQ0FBQztRQUNuRixJQUFJNlcsZUFBZTFFLFFBQVExSyxFQUFFLEVBQ3pCQSxLQUFLb1AsaUJBQWlCLEtBQUssSUFBSTFWLE9BQU9HLFNBQVMsR0FBR3VWLGNBQ2xEQyxpQkFBaUIzRSxRQUFRRyxJQUFJLEVBQzdCQSxPQUFPd0UsbUJBQW1CLEtBQUssSUFBSSxRQUFRQSxnQkFDM0NDLHFCQUFxQjVFLFFBQVE2RSxTQUFTLEVBQ3RDQSxZQUFZRCx1QkFBdUIsS0FBSyxJQUFJLFFBQVFBLG9CQUNwREUsb0JBQW9COUUsUUFBUWhNLE9BQU8sRUFDbkNBLFVBQVU4USxzQkFBc0IsS0FBSyxJQUFJLFFBQVFBLG1CQUNqREMsa0JBQWtCL0UsUUFBUXBNLEtBQUssRUFDL0JBLFFBQVFtUixvQkFBb0IsS0FBSyxJQUFJLFFBQVFBO1FBQ2pELElBQUl2UyxRQUFRd04sUUFBUXhOLEtBQUs7UUFFekIsSUFBSSxDQUFDQSxPQUFPO1lBQ1ZBLFFBQVEsU0FBU0E7Z0JBQ2YsT0FBTztZQUNUO1FBQ0Y7UUFFQSxJQUFJLENBQUM4QyxJQUFJO1lBQ1A7UUFDRjtRQUVBLElBQUlyTDtRQUNKLElBQUltYTtRQUVKLElBQUlZLEtBQUtDLE1BQU0sQ0FBQzNQLEtBQUs7WUFDbkJyTCxPQUFPcUwsRUFBRSxDQUFDLEVBQUU7WUFDWjhPLEtBQUs5TyxFQUFFLENBQUMsRUFBRTtRQUNaLE9BQU87WUFDTCxJQUFJaU0sUUFBUTVSLE9BQU91QixJQUFJLENBQUNsQyxRQUFRc0csSUFBSTtnQkFDbENxTCxNQUFNO1lBQ1I7WUFDQSxJQUFJNkIsT0FBTzdTLE9BQU91QixJQUFJLENBQUNsQyxRQUFRc0csSUFBSTtnQkFDakNxTCxNQUFNO1lBQ1I7WUFDQTFXLE9BQU8rSixVQUFVd08sT0FBT2pCO1lBQ3hCNkMsS0FBS3BRLFVBQVV1TixRQUFRaUI7UUFDekI7UUFFQSxJQUFJMEMsY0FBYzdRLEtBQUsyQyxLQUFLLENBQUNoSSxRQUFRO1lBQ25DZ0YsU0FBU0E7WUFDVC9KLE1BQU1BO1lBQ05tYSxJQUFJQTtZQUNKZSxNQUFNLFNBQVNBLEtBQUsvVSxJQUFJO2dCQUN0QixJQUFJSyxRQUFRakUsZUFBZTRELE1BQU0sSUFDN0I5RixJQUFJbUcsS0FBSyxDQUFDLEVBQUU7Z0JBRWhCLE9BQU9tRCxRQUFRLFFBQVF1QixRQUFRQyxTQUFTLENBQUM5SyxNQUFNcUYsT0FBT0wsTUFBTSxDQUFDTixRQUFRMUU7WUFDdkU7UUFDRjtRQUNBLElBQUkrVSxVQUFVLEVBQUU7UUFDaEIsSUFBSStGO1FBRUosSUFBSXhULGFBQWErTiw2QkFBNkJ1RixjQUMxQ3JUO1FBRUosSUFBSTtZQUNGLElBQUtELFdBQVdyRCxDQUFDLElBQUksQ0FBQyxDQUFDc0QsU0FBU0QsV0FBV3RILENBQUMsRUFBQyxFQUFHNEIsSUFBSSxFQUFHO2dCQUNyRCxJQUFJbVosZUFBZTdZLGVBQWVxRixPQUFPekosS0FBSyxFQUFFLElBQzVDcUssT0FBTzRTLFlBQVksQ0FBQyxFQUFFLEVBQ3RCblUsT0FBT21VLFlBQVksQ0FBQyxFQUFFO2dCQUUxQixJQUFJQyxVQUFVRixPQUFPL1QsS0FBS2tVLE9BQU8sQ0FBQ3JVLE1BQU1rVSxHQUFHLENBQUMsRUFBRSxNQUFNLEdBQUcsbUVBQW1FO2dCQUUxSCxJQUFJakYsU0FBUyxhQUFhbUYsU0FBUztvQkFDakM7Z0JBQ0Y7Z0JBRUEsSUFBSSxDQUFDOVMsTUFBTUMsTUFBTXZCLE9BQU87b0JBQ3RCLHVFQUF1RTtvQkFDdkUscUVBQXFFO29CQUNyRSxvQ0FBb0M7b0JBQ3BDLElBQUkyVCxhQUFhLENBQUNTLFdBQVc1UyxLQUFLQyxNQUFNLENBQUNGLE9BQU87d0JBQzlDO29CQUNGLE9BQU87d0JBQ0w7b0JBQ0Y7Z0JBQ0YsRUFBRSxtRUFBbUU7Z0JBR3JFLElBQUkwTixTQUFTLFlBQVltRixTQUFTO29CQUNoQ0YsTUFBTTt3QkFBQzNTO3dCQUFNdkI7cUJBQUs7b0JBQ2xCO2dCQUNGLEVBQUUsb0VBQW9FO2dCQUd0RSxJQUFJc1UsT0FBT3JGLFNBQVMsV0FBV2lGLE1BQU07b0JBQUMzUztvQkFBTXZCO2lCQUFLO2dCQUVqRCxJQUFJc1UsTUFBTTtvQkFDUixJQUFJWCxXQUFXO3dCQUNieEYsUUFBUWxULElBQUksQ0FBQ3FaO29CQUNmLE9BQU87d0JBQ0wsTUFBTUE7b0JBQ1I7Z0JBQ0Y7Z0JBRUFKLE1BQU07b0JBQUMzUztvQkFBTXZCO2lCQUFLO1lBQ3BCLEVBQUUsbUVBQW1FO1FBRXZFLEVBQUUsT0FBTzlFLEtBQUs7WUFDWndGLFdBQVdwRCxDQUFDLENBQUNwQztRQUNmLFNBQVU7WUFDUndGLFdBQVduRCxDQUFDO1FBQ2Q7UUFFQSxJQUFJMFIsU0FBUyxZQUFZaUYsS0FBSztZQUM1QixJQUFJUCxXQUFXO2dCQUNieEYsUUFBUWxULElBQUksQ0FBQ2laO1lBQ2YsT0FBTztnQkFDTCxNQUFNQTtZQUNSO1FBQ0YsRUFBRSwwRUFBMEU7UUFDNUUsNENBQTRDO1FBRzVDLElBQUlQLFdBQVc7WUFDYixPQUFPeEY7UUFDVDtJQUNGO0lBRUE7O0dBRUMsR0FDRHBOLFdBQVcsU0FBU0EsVUFBVWpELE1BQU07UUFDbEMsSUFBSWdSLFVBQVVuUyxVQUFVeEUsTUFBTSxHQUFHLEtBQUt3RSxTQUFTLENBQUMsRUFBRSxLQUFLa00sWUFBWWxNLFNBQVMsQ0FBQyxFQUFFLEdBQUcsQ0FBQztRQUNuRixJQUFJNFgsaUJBQWlCekYsUUFBUTBGLEtBQUssRUFDOUJBLFFBQVFELG1CQUFtQixLQUFLLElBQUksUUFBUUEsZ0JBQzVDdlQsWUFBWThOLFFBQVE5TixTQUFTO1FBRWpDLElBQUlQLGdCQUFnQixTQUFTQSxjQUFjM0MsTUFBTTtZQUMvQyxPQUFPdkMsWUFBWW1FLEdBQUcsQ0FBQzVCLFdBQVcsRUFBRTtRQUN0QztRQUVBLElBQUkyVyxtQkFBbUIsU0FBU0EsaUJBQWlCM1csTUFBTTtZQUNyRCxPQUFPckMsZ0JBQWdCaUUsR0FBRyxDQUFDNUIsV0FBVyxJQUFJOEI7UUFDNUM7UUFFQSxJQUFJOFUsZUFBZSxTQUFTQSxhQUFhNVcsTUFBTTtZQUM3QyxJQUFJa0MsT0FBT1MsY0FBYzNDLFFBQVE2VyxHQUFHO1lBQ3BDLElBQUkxYSxNQUFNK0YsS0FBS0MsSUFBSSxDQUFDO1lBQ3BCd1UsaUJBQWlCM1csT0FBTyxDQUFDLFNBQVMsQ0FBQzdEO1lBQ25DLE9BQU8rRjtRQUNUO1FBRUEsSUFBSSxDQUFDdkIsT0FBTzJTLGFBQWEsQ0FBQ3RULFNBQVM7WUFDakM7UUFDRjtRQUVBLElBQUkwVyxPQUFPO1lBQ1QsSUFBSUksV0FBV3RjLE1BQU1TLElBQUksQ0FBQ29LLEtBQUsyQyxLQUFLLENBQUNoSSxTQUFTLFNBQVVpSSxLQUFLO2dCQUMzRCxJQUFJQyxRQUFRMUssZUFBZXlLLE9BQU8sSUFDOUJFLElBQUlELEtBQUssQ0FBQyxFQUFFO2dCQUVoQixPQUFPQztZQUNUO1lBQ0EsSUFBSTRPLGNBQWMsSUFBSWpWLElBQUlnVixTQUFTRSxHQUFHLENBQUMsU0FBVTdPLENBQUM7Z0JBQ2hELE9BQU9BLEVBQUVoRyxJQUFJLENBQUM7WUFDaEI7WUFDQTFFLFlBQVlzRixHQUFHLENBQUMvQyxRQUFROFc7WUFDeEJuWixnQkFBZ0JvRixHQUFHLENBQUMvQyxRQUFRK1c7UUFDOUI7UUFFQSxJQUFJcFUsY0FBYzNDLFFBQVEzRixNQUFNLEtBQUssR0FBRztZQUN0QztRQUNGO1FBRUFzRyxPQUFPc1csa0JBQWtCLENBQUNqWCxRQUFRO1lBQ2hDOzs7O01BSUEsR0FDQSxJQUFJMkksYUFBYWdJLDZCQUE2QmhPLGNBQWMzQyxVQUN4RDRJO1lBRUosSUFBSTtnQkFDRixJQUFLRCxXQUFXcEosQ0FBQyxJQUFJLENBQUMsQ0FBQ3FKLFNBQVNELFdBQVdyTixDQUFDLEVBQUMsRUFBRzRCLElBQUksRUFBRztvQkFDckQsSUFBSWdhLGFBQWF0TyxPQUFPeFAsS0FBSztvQkFFN0IsSUFBSWlNLEtBQUtqRCxHQUFHLENBQUNwQyxRQUFRa1gsYUFBYTt3QkFDaEMsSUFBSWhSLFNBQVN2RixPQUFPOEMsSUFBSSxDQUFDekQsUUFBUWtYO3dCQUVqQyxJQUFJQyxVQUFVM1osZUFBZTBJLFFBQVEsSUFDakN6QyxPQUFPMFQsT0FBTyxDQUFDLEVBQUUsRUFDakJDLElBQUlELE9BQU8sQ0FBQyxFQUFFO3dCQUNsQjs7Ozs7WUFLQSxHQUdBLElBQUloUixRQUFRQyxTQUFTLENBQUMzQyxTQUFTQSxLQUFLeEQsUUFBUSxDQUFDNUYsTUFBTSxLQUFLLEdBQUc7NEJBQ3pEMkYsT0FBT2dHLGFBQWEsQ0FBQ0UsUUFBUTtnQ0FDM0JoRCxXQUFXQTs0QkFDYjt3QkFDRjtvQkFDRjtnQkFDRjtZQUNGLEVBQUUsT0FBTzlGLEtBQUs7Z0JBQ1p1TCxXQUFXbkosQ0FBQyxDQUFDcEM7WUFDZixTQUFVO2dCQUNSdUwsV0FBV2xKLENBQUM7WUFDZDtZQUVBLElBQUlzQyxhQUFhWSxjQUFjM0M7WUFDL0IsSUFBSTZKLDBCQUEwQjlILFdBQVcxSCxNQUFNO1lBQy9DLElBQUl1UCxZQUFZO1lBRWhCLE1BQU83SCxXQUFXMUgsTUFBTSxLQUFLLEVBQUc7Z0JBQzlCLElBQUksQ0FBQzJGLE9BQU8wSixlQUFlLENBQUM7b0JBQzFCM0gsWUFBWUE7b0JBQ1o2SCxXQUFXQTtvQkFDWEMseUJBQXlCQTtvQkFDekIzRyxXQUFXQTtnQkFDYixJQUFJO29CQUNGO2dCQUNGO2dCQUVBLElBQUltVSxZQUFZVCxhQUFhNVcsU0FBUyw0RUFBNEU7Z0JBRWxILElBQUlxRixLQUFLakQsR0FBRyxDQUFDcEMsUUFBUXFYLFlBQVk7b0JBQy9CLElBQUlwUixRQUFRdEYsT0FBTzhDLElBQUksQ0FBQ3pELFFBQVFxWDtvQkFDaENyWCxPQUFPZ0csYUFBYSxDQUFDQyxPQUFPO3dCQUMxQi9DLFdBQVdBO29CQUNiO2dCQUNGO2dCQUVBMEc7Z0JBQ0E3SCxhQUFhWSxjQUFjM0M7WUFDN0I7UUFDRjtJQUNGO0lBRUE7O0dBRUMsR0FDRDZELFFBQVEsU0FBU0EsT0FBTzdELE1BQU0sRUFBRXNHLEVBQUU7UUFDaEMsSUFBSTBLLFVBQVVuUyxVQUFVeEUsTUFBTSxHQUFHLEtBQUt3RSxTQUFTLENBQUMsRUFBRSxLQUFLa00sWUFBWWxNLFNBQVMsQ0FBQyxFQUFFLEdBQUcsQ0FBQztRQUNuRixJQUFJcUQsT0FBT3ZCLE9BQU91QixJQUFJLENBQUNsQyxRQUFRc0csSUFBSTBLO1FBQ25DLElBQUlzRyxhQUFhalYsS0FBS3dCLE1BQU0sQ0FBQzNCO1FBQzdCLElBQUkrRCxRQUFRdEYsT0FBTzhDLElBQUksQ0FBQ3pELFFBQVFzWDtRQUNoQyxPQUFPclI7SUFDVDtJQUVBOztHQUVDLEdBQ0QvRCxNQUFNLFNBQVNBLEtBQUtsQyxNQUFNLEVBQUVzRyxFQUFFO1FBQzVCLElBQUkwSyxVQUFVblMsVUFBVXhFLE1BQU0sR0FBRyxLQUFLd0UsU0FBUyxDQUFDLEVBQUUsS0FBS2tNLFlBQVlsTSxTQUFTLENBQUMsRUFBRSxHQUFHLENBQUM7UUFDbkYsSUFBSTBZLFFBQVF2RyxRQUFRdUcsS0FBSyxFQUNyQjVGLE9BQU9YLFFBQVFXLElBQUk7UUFFdkIsSUFBSXRQLEtBQUtpVCxNQUFNLENBQUNoUCxLQUFLO1lBQ25CLElBQUlxTCxTQUFTLFNBQVM7Z0JBQ3BCLElBQUk2RixjQUFjblMsS0FBS2tOLEtBQUssQ0FBQ3ZTLFFBQVFzRyxLQUNqQ21SLGVBQWVqYSxlQUFlZ2EsYUFBYSxJQUMzQ0UsWUFBWUQsWUFBWSxDQUFDLEVBQUU7Z0JBRS9CblIsS0FBS29SO1lBQ1AsT0FBTyxJQUFJL0YsU0FBUyxPQUFPO2dCQUN6QixJQUFJZ0csYUFBYXRTLEtBQUttTyxJQUFJLENBQUN4VCxRQUFRc0csS0FDL0JzUixjQUFjcGEsZUFBZW1hLFlBQVksSUFDekNFLFdBQVdELFdBQVcsQ0FBQyxFQUFFO2dCQUU3QnRSLEtBQUt1UjtZQUNQO1FBQ0Y7UUFFQSxJQUFJNVQsTUFBTXFOLE9BQU8sQ0FBQ2hMLEtBQUs7WUFDckIsSUFBSXFMLFNBQVMsU0FBUztnQkFDcEJyTCxLQUFLckMsTUFBTWdPLEtBQUssQ0FBQzNMO1lBQ25CLE9BQU8sSUFBSXFMLFNBQVMsT0FBTztnQkFDekJyTCxLQUFLckMsTUFBTXVKLEdBQUcsQ0FBQ2xIO1lBQ2pCLE9BQU87Z0JBQ0xBLEtBQUtqRSxLQUFLeVYsTUFBTSxDQUFDeFIsR0FBR2lMLE1BQU0sQ0FBQ3JQLElBQUksRUFBRW9FLEdBQUdrTCxLQUFLLENBQUN0UCxJQUFJO1lBQ2hEO1FBQ0Y7UUFFQSxJQUFJK1EsTUFBTThFLE9BQU8sQ0FBQ3pSLEtBQUs7WUFDckJBLEtBQUtBLEdBQUdwRSxJQUFJO1FBQ2Q7UUFFQSxJQUFJcVYsU0FBUyxNQUFNO1lBQ2pCalIsS0FBS0EsR0FBRzlLLEtBQUssQ0FBQyxHQUFHK2I7UUFDbkI7UUFFQSxPQUFPalI7SUFDVDtJQUNBMFIsU0FBUyxTQUFTQSxRQUFRaFksTUFBTSxFQUFFa0MsSUFBSTtRQUNwQyxPQUFPbUQsS0FBS2pELEdBQUcsQ0FBQ3BDLFFBQVFrQztJQUMxQjtJQUVBOzs7R0FHQyxHQUNEK1YsU0FBUyxTQUFTQSxRQUFRalksTUFBTSxFQUFFa0MsSUFBSTtRQUNwQyxJQUFJOE8sVUFBVW5TLFVBQVV4RSxNQUFNLEdBQUcsS0FBS3dFLFNBQVMsQ0FBQyxFQUFFLEtBQUtrTSxZQUFZbE0sU0FBUyxDQUFDLEVBQUUsR0FBRyxDQUFDO1FBQ25GLElBQUlxWixvQkFBb0JsSCxRQUFRbUgsUUFBUSxFQUNwQ0EsV0FBV0Qsc0JBQXNCLEtBQUssSUFBSSxZQUFZQTtRQUMxRCxJQUFJcFgsTUFBTTtZQUNSc1gsU0FBU2xXO1lBQ1RpVyxVQUFVQTtZQUNWRSxPQUFPLFNBQVNBO2dCQUNkLElBQUlELFVBQVV0WCxJQUFJc1gsT0FBTztnQkFDekIsSUFBSXhYLFdBQVdELE9BQU9DLFFBQVEsQ0FBQ1o7Z0JBQy9CWSxRQUFRLENBQUMsU0FBUyxDQUFDRTtnQkFDbkJBLElBQUlzWCxPQUFPLEdBQUc7Z0JBQ2QsT0FBT0E7WUFDVDtRQUNGO1FBQ0EsSUFBSUUsT0FBTzNYLE9BQU9DLFFBQVEsQ0FBQ1o7UUFDM0JzWSxLQUFLclcsR0FBRyxDQUFDbkI7UUFDVCxPQUFPQTtJQUNUO0lBRUE7O0dBRUMsR0FDREYsVUFBVSxTQUFTQSxTQUFTWixNQUFNO1FBQ2hDLElBQUlzWSxPQUFPeGEsVUFBVThELEdBQUcsQ0FBQzVCO1FBRXpCLElBQUksQ0FBQ3NZLE1BQU07WUFDVEEsT0FBTyxJQUFJeFc7WUFDWGhFLFVBQVVpRixHQUFHLENBQUMvQyxRQUFRc1k7UUFDeEI7UUFFQSxPQUFPQTtJQUNUO0lBRUE7O0dBRUMsR0FDRDVHLE9BQU8sU0FBU0EsTUFBTTFSLE1BQU0sRUFBRXNHLEVBQUU7UUFDOUIsSUFBSTBLLFVBQVVuUyxVQUFVeEUsTUFBTSxHQUFHLEtBQUt3RSxTQUFTLENBQUMsRUFBRSxLQUFLa00sWUFBWWxNLFNBQVMsQ0FBQyxFQUFFLEdBQUcsQ0FBQztRQUNuRixJQUFJMFosZ0JBQWdCdkgsUUFBUVcsSUFBSSxFQUM1QkEsT0FBTzRHLGtCQUFrQixLQUFLLElBQUksVUFBVUE7UUFFaEQsSUFBSWxXLEtBQUtpVCxNQUFNLENBQUNoUCxLQUFLO1lBQ25CLElBQUlwRTtZQUVKLElBQUl5UCxTQUFTLE9BQU87Z0JBQ2xCLElBQUk2RyxjQUFjblQsS0FBS21PLElBQUksQ0FBQ3hULFFBQVFzRyxLQUNoQ21TLGNBQWNqYixlQUFlZ2IsYUFBYSxJQUMxQ1gsV0FBV1ksV0FBVyxDQUFDLEVBQUU7Z0JBRTdCdlcsT0FBTzJWO1lBQ1QsT0FBTztnQkFDTCxJQUFJYSxlQUFlclQsS0FBS2tOLEtBQUssQ0FBQ3ZTLFFBQVFzRyxLQUNsQ3FTLGVBQWVuYixlQUFla2IsY0FBYyxJQUM1Q2hCLFlBQVlpQixZQUFZLENBQUMsRUFBRTtnQkFFL0J6VyxPQUFPd1Y7WUFDVDtZQUVBLElBQUlqVSxPQUFPNEIsS0FBS3pELEdBQUcsQ0FBQzVCLFFBQVFrQztZQUU1QixJQUFJLENBQUN3QixLQUFLQyxNQUFNLENBQUNGLE9BQU87Z0JBQ3RCLE1BQU0sSUFBSXNHLE1BQU0sa0JBQWtCeEQsTUFBTSxDQUFDb0wsTUFBTSxnQ0FBZ0NwTCxNQUFNLENBQUNELElBQUksd0JBQXdCQyxNQUFNLENBQUNvTCxNQUFNO1lBQ2pJO1lBRUEsT0FBTztnQkFDTHpQLE1BQU1BO2dCQUNOcVIsUUFBUTVCLFNBQVMsUUFBUWxPLEtBQUtzQyxJQUFJLENBQUMxTCxNQUFNLEdBQUc7WUFDOUM7UUFDRjtRQUVBLElBQUk0SixNQUFNcU4sT0FBTyxDQUFDaEwsS0FBSztZQUNyQixJQUFJc1MsZUFBZTNVLE1BQU1xTyxLQUFLLENBQUNoTSxLQUMzQnVTLGdCQUFnQnJiLGVBQWVvYixjQUFjLElBQzdDM0csUUFBUTRHLGFBQWEsQ0FBQyxFQUFFLEVBQ3hCckwsTUFBTXFMLGFBQWEsQ0FBQyxFQUFFO1lBRTFCLE9BQU9sSCxTQUFTLFVBQVVNLFFBQVF6RTtRQUNwQztRQUVBLE9BQU9sSDtJQUNUO0lBRUE7OztHQUdDLEdBQ0R3UyxVQUFVLFNBQVNBLFNBQVM5WSxNQUFNLEVBQUUwUixLQUFLO1FBQ3ZDLElBQUlWLFVBQVVuUyxVQUFVeEUsTUFBTSxHQUFHLEtBQUt3RSxTQUFTLENBQUMsRUFBRSxLQUFLa00sWUFBWWxNLFNBQVMsQ0FBQyxFQUFFLEdBQUcsQ0FBQztRQUNuRixJQUFJa2EscUJBQXFCL0gsUUFBUW1ILFFBQVEsRUFDckNBLFdBQVdZLHVCQUF1QixLQUFLLElBQUksWUFBWUE7UUFDM0QsSUFBSWpZLE1BQU07WUFDUnNYLFNBQVMxRztZQUNUeUcsVUFBVUE7WUFDVkUsT0FBTyxTQUFTQTtnQkFDZCxJQUFJRCxVQUFVdFgsSUFBSXNYLE9BQU87Z0JBQ3pCLElBQUlsWCxZQUFZUCxPQUFPTyxTQUFTLENBQUNsQjtnQkFDakNrQixTQUFTLENBQUMsU0FBUyxDQUFDSjtnQkFDcEJBLElBQUlzWCxPQUFPLEdBQUc7Z0JBQ2QsT0FBT0E7WUFDVDtRQUNGO1FBQ0EsSUFBSUUsT0FBTzNYLE9BQU9PLFNBQVMsQ0FBQ2xCO1FBQzVCc1ksS0FBS3JXLEdBQUcsQ0FBQ25CO1FBQ1QsT0FBT0E7SUFDVDtJQUVBOztHQUVDLEdBQ0RJLFdBQVcsU0FBU0EsVUFBVWxCLE1BQU07UUFDbEMsSUFBSXNZLE9BQU92YSxXQUFXNkQsR0FBRyxDQUFDNUI7UUFFMUIsSUFBSSxDQUFDc1ksTUFBTTtZQUNUQSxPQUFPLElBQUl4VztZQUNYL0QsV0FBV2dGLEdBQUcsQ0FBQy9DLFFBQVFzWTtRQUN6QjtRQUVBLE9BQU9BO0lBQ1Q7SUFFQTs7Ozs7Ozs7Ozs7R0FXQyxHQUNEdkcsV0FBVyxVQUFVQSxVQUFVL1IsTUFBTTtRQUNuQyxJQUFJZ1IsVUFBVW5TLFVBQVV4RSxNQUFNLEdBQUcsS0FBS3dFLFNBQVMsQ0FBQyxFQUFFLEtBQUtrTSxZQUFZbE0sU0FBUyxDQUFDLEVBQUUsR0FBRyxDQUFDO1FBQ25GLElBQUltYSxlQUFlaEksUUFBUTFLLEVBQUUsRUFDekJBLEtBQUswUyxpQkFBaUIsS0FBSyxJQUFJaFosT0FBT0csU0FBUyxHQUFHNlksY0FDbERDLGlCQUFpQmpJLFFBQVFsTSxJQUFJLEVBQzdCQSxPQUFPbVUsbUJBQW1CLEtBQUssSUFBSSxXQUFXQSxnQkFDOUNDLG9CQUFvQmxJLFFBQVFoTSxPQUFPLEVBQ25DQSxVQUFVa1Usc0JBQXNCLEtBQUssSUFBSSxRQUFRQSxtQkFDakRDLGtCQUFrQm5JLFFBQVFwTSxLQUFLLEVBQy9CQSxRQUFRdVUsb0JBQW9CLEtBQUssSUFBSSxRQUFRQTtRQUVqRCxJQUFJLENBQUM3UyxJQUFJO1lBQ1A7UUFDRjtRQUNBOzs7Ozs7Ozs7Ozs7Ozs7O0tBZ0JDLEdBR0QsSUFBSXNMLFFBQVFqUixPQUFPaVIsS0FBSyxDQUFDNVIsUUFBUXNHO1FBRWpDLElBQUk4UyxnQkFBZ0JuVixNQUFNcU8sS0FBSyxDQUFDVixRQUM1QnlILGdCQUFnQjdiLGVBQWU0YixlQUFlLElBQzlDbkgsUUFBUW9ILGFBQWEsQ0FBQyxFQUFFLEVBQ3hCN0wsTUFBTTZMLGFBQWEsQ0FBQyxFQUFFO1FBRTFCLElBQUk5RyxRQUFRdk4sVUFBVXdJLE1BQU15RTtRQUM1QixJQUFJcUgsYUFBYTtRQUNqQixJQUFJQyxZQUFZO1FBQ2hCLElBQUloTyxXQUFXLEdBQUcsa0RBQWtEO1FBRXBFLElBQUlpTyxvQkFBb0I7UUFDeEIsSUFBSUMsaUJBQWlCLEdBQUcsc0VBQXNFO1FBQzlGLDJEQUEyRDtRQUMzRCx5RUFBeUU7UUFDekUsMEVBQTBFO1FBQzFFLDBFQUEwRTtRQUMxRSw4Q0FBOEM7UUFFOUMsSUFBSTNRLGFBQWE2SCw2QkFBNkJoUSxPQUFPcUgsS0FBSyxDQUFDaEksUUFBUTtZQUNqRXNHLElBQUlBO1lBQ0p0QixTQUFTQTtZQUNUSixPQUFPQTtRQUNULEtBQ0ltRTtRQUVKLElBQUk7WUFDRixJQUFLRCxXQUFXdkosQ0FBQyxJQUFJLENBQUMsQ0FBQ3dKLFNBQVNELFdBQVd4TixDQUFDLEVBQUMsRUFBRzRCLElBQUksRUFBRztnQkFDckQsSUFBSXdjLGVBQWVsYyxlQUFldUwsT0FBTzNQLEtBQUssRUFBRSxJQUM1Q3FLLE9BQU9pVyxZQUFZLENBQUMsRUFBRSxFQUN0QnhYLE9BQU93WCxZQUFZLENBQUMsRUFBRTtnQkFFMUI7O1NBRUMsR0FDRCxJQUFJdlQsUUFBUUMsU0FBUyxDQUFDM0MsT0FBTztvQkFDM0IsOERBQThEO29CQUM5RCxpRUFBaUU7b0JBQ2pFLDJDQUEyQztvQkFDM0MsSUFBSSxDQUFDbUIsU0FBUzVFLE9BQU9NLE1BQU0sQ0FBQ21ELE9BQU87d0JBQ2pDLE1BQU05QyxPQUFPc1IsS0FBSyxDQUFDalMsUUFBUWtDO3dCQUMzQjtvQkFDRixFQUFFLDREQUE0RDtvQkFDOUQsNkRBQTZEO29CQUM3RCxlQUFlO29CQUdmLElBQUlsQyxPQUFPSyxRQUFRLENBQUNvRCxPQUFPLFVBQVUsNERBQTREO29CQUVqRyxJQUFJOUMsT0FBT2dTLFVBQVUsQ0FBQzNTLFFBQVF5RCxPQUFPO3dCQUNuQywrREFBK0Q7d0JBQy9ELHFDQUFxQzt3QkFDckMscUNBQXFDO3dCQUNyQyxtREFBbUQ7d0JBQ25ELHVEQUF1RDt3QkFDdkQseURBQXlEO3dCQUN6RCxzREFBc0Q7d0JBQ3RELHFFQUFxRTt3QkFDckUsb0VBQW9FO3dCQUNwRSw2REFBNkQ7d0JBQzdELElBQUlqRSxJQUFJNkMsS0FBS3VOLFVBQVUsQ0FBQzFOLE1BQU1zTCxJQUFJdEwsSUFBSSxJQUFJc0wsTUFBTTdNLE9BQU82TSxHQUFHLENBQUN4TixRQUFRa0M7d0JBQ25FLElBQUkzQyxJQUFJOEMsS0FBS3VOLFVBQVUsQ0FBQzFOLE1BQU0rUCxNQUFNL1AsSUFBSSxJQUFJK1AsUUFBUXRSLE9BQU9zUixLQUFLLENBQUNqUyxRQUFRa0M7d0JBQ3pFcVgsWUFBWTVZLE9BQU9nWixNQUFNLENBQUMzWixRQUFROzRCQUNoQ3VSLFFBQVFoUzs0QkFDUmlTLE9BQU9oUzt3QkFDVCxHQUFHOzRCQUNEb0YsT0FBT0E7d0JBQ1Q7d0JBQ0EwVSxhQUFhO29CQUNmO2dCQUNGO2dCQUNBOzs7U0FHQyxHQUdELElBQUk1VixLQUFLQyxNQUFNLENBQUNGLE9BQU87b0JBQ3JCLElBQUltVyxVQUFVdlgsS0FBSzZFLE1BQU0sQ0FBQ2hGLE1BQU1xUSxNQUFNclEsSUFBSSxHQUFHLHlFQUF5RTtvQkFDdEgsMkNBQTJDO29CQUMzQyxtREFBbUQ7b0JBQ25ELHVEQUF1RDtvQkFDdkQsK0NBQStDO29CQUUvQyxJQUFJMFgsU0FBUzt3QkFDWEosb0JBQW9CeFUsVUFBVXVOLE1BQU1nQixNQUFNLEdBQUc5UCxLQUFLc0MsSUFBSSxDQUFDMUwsTUFBTSxHQUFHa1ksTUFBTWdCLE1BQU07d0JBQzVFa0csaUJBQWlCbEgsTUFBTWdCLE1BQU0sRUFBRSx5QkFBeUI7b0JBQzFELE9BQU87d0JBQ0xpRyxvQkFBb0IvVixLQUFLc0MsSUFBSSxDQUFDMUwsTUFBTTt3QkFDcENvZixpQkFBaUJ6VSxVQUFVd1Usb0JBQW9CO29CQUNqRCxFQUFFLHFEQUFxRDtvQkFHdkQsSUFBSUksV0FBV04sY0FBY3hVLFNBQVMsVUFBVTt3QkFDOUMsTUFBTTs0QkFDSjVDLE1BQU1BOzRCQUNOcVIsUUFBUWtHO3dCQUNWO3dCQUNBSCxhQUFhO29CQUNmLEVBQUUsb0VBQW9FO29CQUd0RSxNQUFPLEtBQU07d0JBQ1gsNkRBQTZEO3dCQUM3RCxrRUFBa0U7d0JBQ2xFLDZEQUE2RDt3QkFDN0QsSUFBSS9OLGFBQWEsR0FBRzs0QkFDbEIsSUFBSWdPLGNBQWMsSUFBSTs0QkFDdEJoTyxXQUFXc08sYUFBYU4sV0FBV3pVLE1BQU1FLFVBQVUsZ0VBQWdFOzRCQUNuSCwyQ0FBMkM7NEJBRTNDdVUsWUFBWXpNLHlCQUF5QnlNLFdBQVdoTyxVQUFVdkcsUUFBUSxDQUFDLEVBQUU7d0JBQ3ZFLEVBQUUsZ0RBQWdEO3dCQUdsRHlVLGlCQUFpQnpVLFVBQVV5VSxpQkFBaUJsTyxXQUFXa08saUJBQWlCbE87d0JBQ3hFaU8sb0JBQW9CQSxvQkFBb0JqTyxVQUFVLDJEQUEyRDt3QkFDN0csNERBQTREO3dCQUM1RCxvREFBb0Q7d0JBRXBELElBQUlpTyxvQkFBb0IsR0FBRzs0QkFDekJqTyxXQUFXLENBQUNpTzs0QkFDWjt3QkFDRixFQUFFLDREQUE0RDt3QkFDOUQsMkRBQTJEO3dCQUMzRCx3Q0FBd0M7d0JBR3hDak8sV0FBVzt3QkFDWCxNQUFNOzRCQUNKckosTUFBTUE7NEJBQ05xUixRQUFRa0c7d0JBQ1Y7b0JBQ0Y7Z0JBQ0Y7WUFDRixFQUFFLHdFQUF3RTtRQUMxRSx3RUFBd0U7UUFDeEUsbUVBQW1FO1FBQ25FLFVBQVU7UUFDViw0RUFBNEU7UUFFOUUsRUFBRSxPQUFPcmMsS0FBSztZQUNaMEwsV0FBV3RKLENBQUMsQ0FBQ3BDO1FBQ2YsU0FBVTtZQUNSMEwsV0FBV3JKLENBQUM7UUFDZDtRQUVBLFNBQVNvYSxhQUFhOVQsSUFBSSxFQUFFakIsSUFBSSxFQUFFRSxPQUFPO1lBQ3ZDLElBQUlGLFNBQVMsYUFBYTtnQkFDeEIsT0FBTzhGLHFCQUFxQjdFLE1BQU1mO1lBQ3BDLE9BQU8sSUFBSUYsU0FBUyxRQUFRO2dCQUMxQixPQUFPMkgsZ0JBQWdCMUcsTUFBTWY7WUFDL0IsT0FBTyxJQUFJRixTQUFTLFVBQVVBLFNBQVMsU0FBUztnQkFDOUMsT0FBT2lCLEtBQUsxTCxNQUFNO1lBQ3BCO1lBRUEsT0FBTztRQUNUO0lBQ0Y7SUFFQTs7R0FFQyxHQUNEa08sVUFBVSxTQUFTQSxTQUFTdkksTUFBTTtRQUNoQyxJQUFJZ1IsVUFBVW5TLFVBQVV4RSxNQUFNLEdBQUcsS0FBS3dFLFNBQVMsQ0FBQyxFQUFFLEtBQUtrTSxZQUFZbE0sU0FBUyxDQUFDLEVBQUUsR0FBRyxDQUFDO1FBQ25GLElBQUlpYixpQkFBaUI5SSxRQUFRRyxJQUFJLEVBQzdCQSxPQUFPMkksbUJBQW1CLEtBQUssSUFBSSxXQUFXQSxnQkFDOUNDLGtCQUFrQi9JLFFBQVFwTSxLQUFLLEVBQy9CQSxRQUFRbVYsb0JBQW9CLEtBQUssSUFBSSxRQUFRQTtRQUNqRCxJQUFJdlcsUUFBUXdOLFFBQVF4TixLQUFLLEVBQ3JCd1csZUFBZWhKLFFBQVExSyxFQUFFLEVBQ3pCQSxLQUFLMFQsaUJBQWlCLEtBQUssSUFBSWhhLE9BQU9HLFNBQVMsR0FBRzZaO1FBRXRELElBQUksQ0FBQzFULElBQUk7WUFDUDtRQUNGO1FBRUEsSUFBSTJULHNCQUFzQnRaLE9BQU9xUixNQUFNLENBQUNoUyxRQUFRc0csSUFBSTtZQUNsRDFCLE9BQU9BO1FBQ1Q7UUFFQSxJQUFJLENBQUNxVixxQkFBcUI7WUFDeEI7UUFDRjtRQUVBLElBQUlDLGdCQUFnQnZaLE9BQU80UixLQUFLLENBQUN2UyxRQUFRLEVBQUUsR0FDdkNtYSxpQkFBaUIzYyxlQUFlMGMsZUFBZSxJQUMvQzlFLEtBQUsrRSxjQUFjLENBQUMsRUFBRSxFQUFFLHVFQUF1RTtRQUNuRywwQ0FBMEM7UUFHMUMsSUFBSTlFLE9BQU87WUFBQzRFLG9CQUFvQi9YLElBQUk7WUFBRWtUO1NBQUc7UUFFekMsSUFBSS9TLEtBQUtpVCxNQUFNLENBQUNoUCxPQUFPQSxHQUFHak0sTUFBTSxLQUFLLEdBQUc7WUFDdEMsTUFBTSxJQUFJMFAsTUFBTTtRQUNsQjtRQUVBLElBQUl2RyxTQUFTLE1BQU07WUFDakIsSUFBSW5CLEtBQUtpVCxNQUFNLENBQUNoUCxLQUFLO2dCQUNuQixJQUFJOUIsa0JBQWtCN0QsT0FBT2tELE1BQU0sQ0FBQzdELFFBQVFzRyxLQUN4QzdCLGtCQUFrQmpILGVBQWVnSCxpQkFBaUIsSUFDbERYLFNBQVNZLGVBQWUsQ0FBQyxFQUFFO2dCQUUvQmpCLFFBQVEsU0FBU0EsTUFBTWxJLENBQUM7b0JBQ3RCLE9BQU91SSxPQUFPNUQsUUFBUSxDQUFDc1YsUUFBUSxDQUFDamE7Z0JBQ2xDO1lBQ0YsT0FBTztnQkFDTGtJLFFBQVEsU0FBU0E7b0JBQ2YsT0FBTztnQkFDVDtZQUNGO1FBQ0Y7UUFFQSxJQUFJNFcsaUJBQWlCelosT0FBT3FILEtBQUssQ0FBQ2hJLFFBQVE7WUFDeENnRixTQUFTO1lBQ1RzQixJQUFJK087WUFDSjdSLE9BQU9BO1lBQ1AyTixNQUFNQTtZQUNOdk0sT0FBT0E7UUFDVCxJQUNJeVYsaUJBQWlCN2MsZUFBZTRjLGdCQUFnQixJQUNoRDdSLFdBQVc4UixjQUFjLENBQUMsRUFBRTtRQUVoQyxPQUFPOVI7SUFDVDtJQUVBOztHQUVDLEdBQ0RxSixPQUFPLFNBQVNBLE1BQU01UixNQUFNLEVBQUVzRyxFQUFFLEVBQUU4TyxFQUFFO1FBQ2xDLElBQUluUixNQUFNcU4sT0FBTyxDQUFDaEwsT0FBTyxDQUFDOE8sSUFBSTtZQUM1QixPQUFPOU87UUFDVDtRQUVBLElBQUkyTCxRQUFRdFIsT0FBT3NSLEtBQUssQ0FBQ2pTLFFBQVFzRztRQUNqQyxJQUFJa0gsTUFBTTdNLE9BQU82TSxHQUFHLENBQUN4TixRQUFRb1YsTUFBTTlPO1FBQ25DLE9BQU87WUFDTGlMLFFBQVFVO1lBQ1JULE9BQU9oRTtRQUNUO0lBQ0Y7SUFFQTs7O0dBR0MsR0FDRDhNLFVBQVUsU0FBU0EsU0FBU3RhLE1BQU0sRUFBRTRSLEtBQUs7UUFDdkMsSUFBSVosVUFBVW5TLFVBQVV4RSxNQUFNLEdBQUcsS0FBS3dFLFNBQVMsQ0FBQyxFQUFFLEtBQUtrTSxZQUFZbE0sU0FBUyxDQUFDLEVBQUUsR0FBRyxDQUFDO1FBQ25GLElBQUkwYixxQkFBcUJ2SixRQUFRbUgsUUFBUSxFQUNyQ0EsV0FBV29DLHVCQUF1QixLQUFLLElBQUksWUFBWUE7UUFDM0QsSUFBSXpaLE1BQU07WUFDUnNYLFNBQVN4RztZQUNUdUcsVUFBVUE7WUFDVkUsT0FBTyxTQUFTQTtnQkFDZCxJQUFJRCxVQUFVdFgsSUFBSXNYLE9BQU87Z0JBQ3pCLElBQUk3VyxZQUFZWixPQUFPWSxTQUFTLENBQUN2QjtnQkFDakN1QixTQUFTLENBQUMsU0FBUyxDQUFDVDtnQkFDcEJBLElBQUlzWCxPQUFPLEdBQUc7Z0JBQ2QsT0FBT0E7WUFDVDtRQUNGO1FBQ0EsSUFBSUUsT0FBTzNYLE9BQU9ZLFNBQVMsQ0FBQ3ZCO1FBQzVCc1ksS0FBS3JXLEdBQUcsQ0FBQ25CO1FBQ1QsT0FBT0E7SUFDVDtJQUVBOztHQUVDLEdBQ0RTLFdBQVcsU0FBU0EsVUFBVXZCLE1BQU07UUFDbEMsSUFBSXNZLE9BQU90YSxXQUFXNEQsR0FBRyxDQUFDNUI7UUFFMUIsSUFBSSxDQUFDc1ksTUFBTTtZQUNUQSxPQUFPLElBQUl4VztZQUNYOUQsV0FBVytFLEdBQUcsQ0FBQy9DLFFBQVFzWTtRQUN6QjtRQUVBLE9BQU9BO0lBQ1Q7SUFFQTs7Ozs7O0dBTUMsR0FDRGpSLFlBQVksU0FBU0EsV0FBV3JILE1BQU0sRUFBRTdELEdBQUc7UUFDekM2RCxPQUFPcUgsVUFBVSxDQUFDbEw7SUFDcEI7SUFFQTs7Ozs7R0FLQyxHQUNEcWUsZ0JBQWdCLFNBQVNBLGVBQWV4YSxNQUFNLEVBQUVzVCxhQUFhO1FBQzNEelYsWUFBWWtGLEdBQUcsQ0FBQy9DLFFBQVFzVDtJQUMxQjtJQUVBOztHQUVDLEdBQ0RyQixPQUFPLFNBQVNBLE1BQU1qUyxNQUFNLEVBQUVzRyxFQUFFO1FBQzlCLE9BQU8zRixPQUFPK1EsS0FBSyxDQUFDMVIsUUFBUXNHLElBQUk7WUFDOUJxTCxNQUFNO1FBQ1I7SUFDRjtJQUVBOzs7OztHQUtDLEdBQ0RnSSxRQUFRLFNBQVNBLE9BQU8zWixNQUFNLEVBQUVzRyxFQUFFO1FBQ2hDLElBQUkwSyxVQUFVblMsVUFBVXhFLE1BQU0sR0FBRyxLQUFLd0UsU0FBUyxDQUFDLEVBQUUsS0FBS2tNLFlBQVlsTSxTQUFTLENBQUMsRUFBRSxHQUFHLENBQUM7UUFDbkYsSUFBSTRiLGtCQUFrQnpKLFFBQVFwTSxLQUFLLEVBQy9CQSxRQUFRNlYsb0JBQW9CLEtBQUssSUFBSSxRQUFRQTtRQUNqRCxJQUFJN0ksUUFBUWpSLE9BQU9pUixLQUFLLENBQUM1UixRQUFRc0c7UUFFakMsSUFBSW9VLGdCQUFnQnpXLE1BQU1xTyxLQUFLLENBQUNWLFFBQzVCK0ksZ0JBQWdCbmQsZUFBZWtkLGVBQWUsSUFDOUN6SSxRQUFRMEksYUFBYSxDQUFDLEVBQUUsRUFDeEJuTixNQUFNbU4sYUFBYSxDQUFDLEVBQUU7UUFFMUIsSUFBSTVVLE9BQU87UUFFWCxJQUFJNlUsYUFBYWpLLDZCQUE2QmhRLE9BQU9xSCxLQUFLLENBQUNoSSxRQUFRO1lBQ2pFc0csSUFBSXNMO1lBQ0pwTyxPQUFPRSxLQUFLQyxNQUFNO1lBQ2xCaUIsT0FBT0E7UUFDVCxLQUNJaVc7UUFFSixJQUFJO1lBQ0YsSUFBS0QsV0FBV3JiLENBQUMsSUFBSSxDQUFDLENBQUNzYixTQUFTRCxXQUFXdGYsQ0FBQyxFQUFDLEVBQUc0QixJQUFJLEVBQUc7Z0JBQ3JELElBQUk0ZCxlQUFldGQsZUFBZXFkLE9BQU96aEIsS0FBSyxFQUFFLElBQzVDcUssT0FBT3FYLFlBQVksQ0FBQyxFQUFFLEVBQ3RCNVksT0FBTzRZLFlBQVksQ0FBQyxFQUFFO2dCQUUxQixJQUFJQyxJQUFJdFgsS0FBS3NDLElBQUk7Z0JBRWpCLElBQUkxRCxLQUFLNkUsTUFBTSxDQUFDaEYsTUFBTXNMLElBQUl0TCxJQUFJLEdBQUc7b0JBQy9CNlksSUFBSUEsRUFBRXZmLEtBQUssQ0FBQyxHQUFHZ1MsSUFBSStGLE1BQU07Z0JBQzNCO2dCQUVBLElBQUlsUixLQUFLNkUsTUFBTSxDQUFDaEYsTUFBTStQLE1BQU0vUCxJQUFJLEdBQUc7b0JBQ2pDNlksSUFBSUEsRUFBRXZmLEtBQUssQ0FBQ3lXLE1BQU1zQixNQUFNO2dCQUMxQjtnQkFFQXhOLFFBQVFnVjtZQUNWO1FBQ0YsRUFBRSxPQUFPM2QsS0FBSztZQUNad2QsV0FBV3BiLENBQUMsQ0FBQ3BDO1FBQ2YsU0FBVTtZQUNSd2QsV0FBV25iLENBQUM7UUFDZDtRQUVBLE9BQU9zRztJQUNUO0lBRUE7O0dBRUMsR0FDRGlWLGFBQWEsU0FBU0EsWUFBWWhiLE1BQU0sRUFBRTRSLEtBQUs7UUFDN0MsSUFBSVosVUFBVW5TLFVBQVV4RSxNQUFNLEdBQUcsS0FBS3dFLFNBQVMsQ0FBQyxFQUFFLEtBQUtrTSxZQUFZbE0sU0FBUyxDQUFDLEVBQUUsR0FBRyxDQUFDO1FBQ25GLElBQUlvYyxrQkFBa0JqSyxRQUFRcE0sS0FBSyxFQUMvQkEsUUFBUXFXLG9CQUFvQixLQUFLLElBQUksUUFBUUE7UUFFakQsSUFBSUMsZ0JBQWdCalgsTUFBTXFPLEtBQUssQ0FBQ1YsUUFDNUJ1SixnQkFBZ0IzZCxlQUFlMGQsZUFBZSxJQUM5Q2pKLFFBQVFrSixhQUFhLENBQUMsRUFBRSxFQUN4QjNOLE1BQU0yTixhQUFhLENBQUMsRUFBRSxFQUFFLHFFQUFxRTtRQUdqRyxJQUFJbEosTUFBTXNCLE1BQU0sS0FBSyxLQUFLL0YsSUFBSStGLE1BQU0sS0FBSyxLQUFLdFAsTUFBTWMsV0FBVyxDQUFDNk0sVUFBVXZQLEtBQUsrWSxXQUFXLENBQUM1TixJQUFJdEwsSUFBSSxHQUFHO1lBQ3BHLE9BQU8wUDtRQUNUO1FBRUEsSUFBSXlKLFdBQVcxYSxPQUFPb1EsS0FBSyxDQUFDL1EsUUFBUTtZQUNsQ3NHLElBQUlrSDtZQUNKaEssT0FBTyxTQUFTQSxNQUFNbEksQ0FBQztnQkFDckIsT0FBTzZLLFFBQVFDLFNBQVMsQ0FBQzlLLE1BQU1xRixPQUFPK1IsT0FBTyxDQUFDMVMsUUFBUTFFO1lBQ3hEO1lBQ0FzSixPQUFPQTtRQUNUO1FBQ0EsSUFBSStQLFlBQVkwRyxXQUFXQSxRQUFRLENBQUMsRUFBRSxHQUFHLEVBQUU7UUFDM0MsSUFBSTlJLFFBQVE1UixPQUFPc1IsS0FBSyxDQUFDalMsUUFBUWlTO1FBQ2pDLElBQUlELFNBQVM7WUFDWFQsUUFBUWdCO1lBQ1JmLE9BQU9oRTtRQUNUO1FBQ0EsSUFBSThOLE9BQU87UUFFWCxJQUFJQyxhQUFhNUssNkJBQTZCaFEsT0FBT3FILEtBQUssQ0FBQ2hJLFFBQVE7WUFDakVzRyxJQUFJMEw7WUFDSnhPLE9BQU9FLEtBQUtDLE1BQU07WUFDbEJxQixTQUFTO1lBQ1RKLE9BQU9BO1FBQ1QsS0FDSTRXO1FBRUosSUFBSTtZQUNGLElBQUtELFdBQVdoYyxDQUFDLElBQUksQ0FBQyxDQUFDaWMsU0FBU0QsV0FBV2pnQixDQUFDLEVBQUMsRUFBRzRCLElBQUksRUFBRztnQkFDckQsSUFBSXVlLGVBQWVqZSxlQUFlZ2UsT0FBT3BpQixLQUFLLEVBQUUsSUFDNUNxSyxPQUFPZ1ksWUFBWSxDQUFDLEVBQUUsRUFDdEJ2WixPQUFPdVosWUFBWSxDQUFDLEVBQUU7Z0JBRTFCLElBQUlILE1BQU07b0JBQ1JBLE9BQU87b0JBQ1A7Z0JBQ0Y7Z0JBRUEsSUFBSTdYLEtBQUtzQyxJQUFJLEtBQUssTUFBTTFELEtBQUtxWixRQUFRLENBQUN4WixNQUFNeVMsWUFBWTtvQkFDdERuSCxNQUFNO3dCQUNKdEwsTUFBTUE7d0JBQ05xUixRQUFROVAsS0FBS3NDLElBQUksQ0FBQzFMLE1BQU07b0JBQzFCO29CQUNBO2dCQUNGO1lBQ0Y7UUFDRixFQUFFLE9BQU8rQyxLQUFLO1lBQ1ptZSxXQUFXL2IsQ0FBQyxDQUFDcEM7UUFDZixTQUFVO1lBQ1JtZSxXQUFXOWIsQ0FBQztRQUNkO1FBRUEsT0FBTztZQUNMOFIsUUFBUVU7WUFDUlQsT0FBT2hFO1FBQ1Q7SUFDRjtJQUVBOztHQUVDLEdBQ0QsUUFBUSxTQUFTbU8sTUFBTTNiLE1BQU07UUFDM0IsSUFBSWdSLFVBQVVuUyxVQUFVeEUsTUFBTSxHQUFHLEtBQUt3RSxTQUFTLENBQUMsRUFBRSxLQUFLa00sWUFBWWxNLFNBQVMsQ0FBQyxFQUFFLEdBQUcsQ0FBQztRQUNuRixPQUFPOEIsT0FBT29RLEtBQUssQ0FBQy9RLFFBQVEwUSxnQkFBZ0JBLGdCQUFnQixDQUFDLEdBQUdNLFVBQVUsQ0FBQyxHQUFHO1lBQzVFeE4sT0FBTyxTQUFTQSxNQUFNbEksQ0FBQztnQkFDckIsT0FBTzZLLFFBQVFDLFNBQVMsQ0FBQzlLLE1BQU1xRixPQUFPTCxNQUFNLENBQUNOLFFBQVExRTtZQUN2RDtRQUNGO0lBQ0Y7SUFFQTs7R0FFQyxHQUNEMmIsb0JBQW9CLFNBQVNBLG1CQUFtQmpYLE1BQU0sRUFBRWpHLEVBQUU7UUFDeEQsSUFBSVgsUUFBUXVILE9BQU8yUyxhQUFhLENBQUN0VDtRQUNqQ1csT0FBTzZaLGNBQWMsQ0FBQ3hhLFFBQVE7UUFFOUIsSUFBSTtZQUNGakc7UUFDRixTQUFVO1lBQ1I0RyxPQUFPNlosY0FBYyxDQUFDeGEsUUFBUTVHO1FBQ2hDO1FBRUF1SCxPQUFPc0MsU0FBUyxDQUFDakQ7SUFDbkI7QUFDRjtBQUVBLElBQUk0YixXQUFXO0lBQ2I7O0dBRUMsR0FDREMsWUFBWSxTQUFTQSxXQUFXemlCLEtBQUs7UUFDbkMsT0FBT2lKLEtBQUtpVCxNQUFNLENBQUNsYyxVQUFVNlosTUFBTThFLE9BQU8sQ0FBQzNlLFVBQVU2SyxNQUFNcU4sT0FBTyxDQUFDbFk7SUFDckU7QUFDRixHQUFHLHdDQUF3QztBQUUzQyxJQUFJNGMsT0FBTztJQUNUOztHQUVDLEdBQ0RDLFFBQVEsU0FBU0EsT0FBTzdjLEtBQUs7UUFDM0IsT0FBT29CLE1BQU1HLE9BQU8sQ0FBQ3ZCLFVBQVVBLE1BQU1pQixNQUFNLEtBQUssS0FBS2pCLE1BQU0wVyxLQUFLLENBQUN6TixLQUFLaVQsTUFBTTtJQUM5RTtBQUNGO0FBRUEsSUFBSXdHLGNBQWM7SUFBQztDQUFXLEVBQzFCQyxlQUFlO0lBQUM7Q0FBTztBQUUzQixTQUFTQyw2QkFBNkI1Z0IsQ0FBQyxFQUFFK0QsY0FBYztJQUFJLElBQUlDLEtBQUssT0FBT3JFLFdBQVcsZUFBZUssQ0FBQyxDQUFDTCxPQUFPQyxRQUFRLENBQUMsSUFBSUksQ0FBQyxDQUFDLGFBQWE7SUFBRSxJQUFJLENBQUNnRSxJQUFJO1FBQUUsSUFBSTVFLE1BQU1HLE9BQU8sQ0FBQ1MsTUFBT2dFLENBQUFBLEtBQUs2Yyw4QkFBOEI3Z0IsRUFBQyxLQUFNK0Qsa0JBQWtCL0QsS0FBSyxPQUFPQSxFQUFFZixNQUFNLEtBQUssVUFBVTtZQUFFLElBQUkrRSxJQUFJaEUsSUFBSWdFO1lBQUksSUFBSTlFLElBQUk7WUFBRyxJQUFJZ0YsSUFBSSxTQUFTQSxLQUFLO1lBQUcsT0FBTztnQkFBRUMsR0FBR0Q7Z0JBQUdoRSxHQUFHLFNBQVNBO29CQUFNLElBQUloQixLQUFLYyxFQUFFZixNQUFNLEVBQUUsT0FBTzt3QkFBRTZDLE1BQU07b0JBQUs7b0JBQUcsT0FBTzt3QkFBRUEsTUFBTTt3QkFBTzlELE9BQU9nQyxDQUFDLENBQUNkLElBQUk7b0JBQUM7Z0JBQUc7Z0JBQUdrRixHQUFHLFNBQVNBLEVBQUV4QyxFQUFFO29CQUFJLE1BQU1BO2dCQUFJO2dCQUFHeUMsR0FBR0g7WUFBRTtRQUFHO1FBQUUsTUFBTSxJQUFJeEQsVUFBVTtJQUEwSTtJQUFFLElBQUk0RCxtQkFBbUIsTUFBTUMsU0FBUyxPQUFPdkM7SUFBSyxPQUFPO1FBQUVtQyxHQUFHLFNBQVNBO1lBQU1ILEtBQUtBLEdBQUd2RixJQUFJLENBQUN1QjtRQUFJO1FBQUdFLEdBQUcsU0FBU0E7WUFBTSxJQUFJc0UsT0FBT1IsR0FBR25DLElBQUk7WUFBSXlDLG1CQUFtQkUsS0FBSzFDLElBQUk7WUFBRSxPQUFPMEM7UUFBTTtRQUFHSixHQUFHLFNBQVNBLEVBQUVLLEdBQUc7WUFBSUYsU0FBUztZQUFNdkMsTUFBTXlDO1FBQUs7UUFBR0osR0FBRyxTQUFTQTtZQUFNLElBQUk7Z0JBQUUsSUFBSSxDQUFDQyxvQkFBb0JOLEVBQUUsQ0FBQyxTQUFTLElBQUksTUFBTUEsRUFBRSxDQUFDLFNBQVM7WUFBSSxTQUFVO2dCQUFFLElBQUlPLFFBQVEsTUFBTXZDO1lBQUs7UUFBRTtJQUFFO0FBQUc7QUFFLytCLFNBQVM2ZSw4QkFBOEI3Z0IsQ0FBQyxFQUFFQyxNQUFNO0lBQUksSUFBSSxDQUFDRCxHQUFHO0lBQVEsSUFBSSxPQUFPQSxNQUFNLFVBQVUsT0FBTzhnQixvQkFBb0I5Z0IsR0FBR0M7SUFBUyxJQUFJQyxJQUFJckMsT0FBT1UsU0FBUyxDQUFDNEIsUUFBUSxDQUFDMUIsSUFBSSxDQUFDdUIsR0FBR0ksS0FBSyxDQUFDLEdBQUcsQ0FBQztJQUFJLElBQUlGLE1BQU0sWUFBWUYsRUFBRUssV0FBVyxFQUFFSCxJQUFJRixFQUFFSyxXQUFXLENBQUNDLElBQUk7SUFBRSxJQUFJSixNQUFNLFNBQVNBLE1BQU0sT0FBTyxPQUFPZCxNQUFNUyxJQUFJLENBQUNHO0lBQUksSUFBSUUsTUFBTSxlQUFlLDJDQUEyQ0ssSUFBSSxDQUFDTCxJQUFJLE9BQU80Z0Isb0JBQW9COWdCLEdBQUdDO0FBQVM7QUFFcmEsU0FBUzZnQixvQkFBb0IvaEIsR0FBRyxFQUFFQyxHQUFHO0lBQUksSUFBSUEsT0FBTyxRQUFRQSxNQUFNRCxJQUFJRSxNQUFNLEVBQUVELE1BQU1ELElBQUlFLE1BQU07SUFBRSxJQUFLLElBQUlDLElBQUksR0FBR0MsT0FBTyxJQUFJQyxNQUFNSixNQUFNRSxJQUFJRixLQUFLRSxJQUFLO1FBQUVDLElBQUksQ0FBQ0QsRUFBRSxHQUFHSCxHQUFHLENBQUNHLEVBQUU7SUFBRTtJQUFFLE9BQU9DO0FBQU07QUFDeEwsSUFBSTRoQixxQkFBcUIsSUFBSXplLFdBQVcsd0NBQXdDO0FBRWhGLElBQUkySCxPQUFPO0lBQ1Q7O0dBRUMsR0FDRHdELFVBQVUsU0FBU0EsU0FBU3VULElBQUksRUFBRWxhLElBQUk7UUFDcEMsSUFBSXVCLE9BQU80QixLQUFLekQsR0FBRyxDQUFDd2EsTUFBTWxhO1FBRTFCLElBQUl3QixLQUFLQyxNQUFNLENBQUNGLE9BQU87WUFDckIsTUFBTSxJQUFJc0csTUFBTSx5Q0FBeUN4RCxNQUFNLENBQUNyRSxNQUFNLGdEQUFnRHFFLE1BQU0sQ0FBQzhWLFNBQVNDLFNBQVMsQ0FBQzdZO1FBQ2xKO1FBRUEsT0FBT0E7SUFDVDtJQUVBOzs7OztHQUtDLEdBQ0Q0RSxXQUFXLFVBQVVBLFVBQVUrVCxJQUFJLEVBQUVsYSxJQUFJO1FBQ3ZDLElBQUk4TyxVQUFVblMsVUFBVXhFLE1BQU0sR0FBRyxLQUFLd0UsU0FBUyxDQUFDLEVBQUUsS0FBS2tNLFlBQVlsTSxTQUFTLENBQUMsRUFBRSxHQUFHLENBQUM7UUFFbkYsSUFBSTZCLFlBQVlzYiw2QkFBNkIzWixLQUFLZ0csU0FBUyxDQUFDbkcsTUFBTThPLFdBQzlEblE7UUFFSixJQUFJO1lBQ0YsSUFBS0gsVUFBVW5CLENBQUMsSUFBSSxDQUFDLENBQUNzQixRQUFRSCxVQUFVcEYsQ0FBQyxFQUFDLEVBQUc0QixJQUFJLEVBQUc7Z0JBQ2xELElBQUlpTCxJQUFJdEgsTUFBTXpILEtBQUs7Z0JBQ25CLElBQUlrQyxJQUFJK0osS0FBS3dELFFBQVEsQ0FBQ3VULE1BQU1qVTtnQkFDNUIsSUFBSWxDLFFBQVE7b0JBQUMzSztvQkFBRzZNO2lCQUFFO2dCQUNsQixNQUFNbEM7WUFDUjtRQUNGLEVBQUUsT0FBTzdJLEtBQUs7WUFDWnNELFVBQVVsQixDQUFDLENBQUNwQztRQUNkLFNBQVU7WUFDUnNELFVBQVVqQixDQUFDO1FBQ2I7SUFDRjtJQUVBOztHQUVDLEdBQ0Q0RyxPQUFPLFNBQVNBLE1BQU0rVixJQUFJLEVBQUVHLEtBQUs7UUFDL0IsSUFBSTdZLEtBQUtDLE1BQU0sQ0FBQ3lZLE9BQU87WUFDckIsTUFBTSxJQUFJclMsTUFBTSx3Q0FBd0N4RCxNQUFNLENBQUM4VixTQUFTQyxTQUFTLENBQUNGO1FBQ3BGO1FBRUEsSUFBSUksSUFBSUosS0FBS25jLFFBQVEsQ0FBQ3NjLE1BQU07UUFFNUIsSUFBSUMsS0FBSyxNQUFNO1lBQ2IsTUFBTSxJQUFJelMsTUFBTSw4QkFBOEJ4RCxNQUFNLENBQUNnVyxPQUFPLGVBQWVoVyxNQUFNLENBQUM4VixTQUFTQyxTQUFTLENBQUNGO1FBQ3ZHO1FBRUEsT0FBT0k7SUFDVDtJQUVBOztHQUVDLEdBQ0R2YyxVQUFVLFVBQVVBLFNBQVNtYyxJQUFJLEVBQUVsYSxJQUFJO1FBQ3JDLElBQUk4TyxVQUFVblMsVUFBVXhFLE1BQU0sR0FBRyxLQUFLd0UsU0FBUyxDQUFDLEVBQUUsS0FBS2tNLFlBQVlsTSxTQUFTLENBQUMsRUFBRSxHQUFHLENBQUM7UUFDbkYsSUFBSThVLG1CQUFtQjNDLFFBQVFoTSxPQUFPLEVBQ2xDQSxVQUFVMk8scUJBQXFCLEtBQUssSUFBSSxRQUFRQTtRQUNwRCxJQUFJOUssV0FBV3hELEtBQUt3RCxRQUFRLENBQUN1VCxNQUFNbGE7UUFDbkMsSUFBSWpDLFdBQVc0SSxTQUFTNUksUUFBUTtRQUNoQyxJQUFJc2MsUUFBUXZYLFVBQVUvRSxTQUFTNUYsTUFBTSxHQUFHLElBQUk7UUFFNUMsTUFBTzJLLFVBQVV1WCxTQUFTLElBQUlBLFFBQVF0YyxTQUFTNUYsTUFBTSxDQUFFO1lBQ3JELElBQUlnTSxRQUFRaEIsS0FBS2dCLEtBQUssQ0FBQ3dDLFVBQVUwVDtZQUNqQyxJQUFJRSxZQUFZdmEsS0FBS3FFLE1BQU0sQ0FBQ2dXO1lBQzVCLE1BQU07Z0JBQUNsVztnQkFBT29XO2FBQVU7WUFDeEJGLFFBQVF2WCxVQUFVdVgsUUFBUSxJQUFJQSxRQUFRO1FBQ3hDO0lBQ0Y7SUFFQTs7R0FFQyxHQUNEekUsUUFBUSxTQUFTQSxPQUFPc0UsSUFBSSxFQUFFbGEsSUFBSSxFQUFFd2EsT0FBTztRQUN6QyxJQUFJdlUsSUFBSTlGLEtBQUt5VixNQUFNLENBQUM1VixNQUFNd2E7UUFDMUIsSUFBSXBoQixJQUFJK0osS0FBS3pELEdBQUcsQ0FBQ3dhLE1BQU1qVTtRQUN2QixPQUFPO1lBQUM3TTtZQUFHNk07U0FBRTtJQUNmO0lBRUE7O0dBRUMsR0FDRHdVLFlBQVksU0FBU0EsV0FBV1AsSUFBSSxFQUFFbGEsSUFBSTtRQUN4QyxJQUFJdUIsT0FBTzRCLEtBQUt6RCxHQUFHLENBQUN3YSxNQUFNbGE7UUFFMUIsSUFBSXZCLE9BQU84RixRQUFRLENBQUNoRCxPQUFPO1lBQ3pCLE1BQU0sSUFBSXNHLE1BQU0sMkNBQTJDeEQsTUFBTSxDQUFDckUsTUFBTSx5REFBeURxRSxNQUFNLENBQUM4VixTQUFTQyxTQUFTLENBQUM3WTtRQUM3SjtRQUVBLE9BQU9BO0lBQ1Q7SUFFQTs7R0FFQyxHQUNEc0UsYUFBYSxVQUFVQSxZQUFZcVUsSUFBSTtRQUNyQyxJQUFJcEwsVUFBVW5TLFVBQVV4RSxNQUFNLEdBQUcsS0FBS3dFLFNBQVMsQ0FBQyxFQUFFLEtBQUtrTSxZQUFZbE0sU0FBUyxDQUFDLEVBQUUsR0FBRyxDQUFDO1FBRW5GLElBQUlvQyxhQUFhK2EsNkJBQTZCM1csS0FBSzJDLEtBQUssQ0FBQ29VLE1BQU1wTCxXQUMzRDdQO1FBRUosSUFBSTtZQUNGLElBQUtGLFdBQVcxQixDQUFDLElBQUksQ0FBQyxDQUFDNEIsU0FBU0YsV0FBVzNGLENBQUMsRUFBQyxFQUFHNEIsSUFBSSxFQUFHO2dCQUNyRCxJQUFJMGYsZUFBZXBmLGVBQWUyRCxPQUFPL0gsS0FBSyxFQUFFLElBQzVDcUssT0FBT21aLFlBQVksQ0FBQyxFQUFFLEVBQ3RCMWEsT0FBTzBhLFlBQVksQ0FBQyxFQUFFO2dCQUUxQixJQUFJMWEsS0FBSzdILE1BQU0sS0FBSyxHQUFHO29CQUNyQix1RUFBdUU7b0JBQ3ZFLHdFQUF3RTtvQkFDeEUsTUFBTTt3QkFBQ29KO3dCQUFNdkI7cUJBQUs7Z0JBQ3BCO1lBQ0Y7UUFDRixFQUFFLE9BQU85RSxLQUFLO1lBQ1o2RCxXQUFXekIsQ0FBQyxDQUFDcEM7UUFDZixTQUFVO1lBQ1I2RCxXQUFXeEIsQ0FBQztRQUNkO0lBQ0Y7SUFFQTs7OztHQUlDLEdBQ0RvZCxVQUFVLFVBQVVBLFNBQVNULElBQUk7UUFDL0IsSUFBSXBMLFVBQVVuUyxVQUFVeEUsTUFBTSxHQUFHLEtBQUt3RSxTQUFTLENBQUMsRUFBRSxLQUFLa00sWUFBWWxNLFNBQVMsQ0FBQyxFQUFFLEdBQUcsQ0FBQztRQUVuRixJQUFJeUMsYUFBYTBhLDZCQUE2QjNXLEtBQUsyQyxLQUFLLENBQUNvVSxNQUFNcEwsV0FDM0R4UDtRQUVKLElBQUk7WUFDRixJQUFLRixXQUFXL0IsQ0FBQyxJQUFJLENBQUMsQ0FBQ2lDLFNBQVNGLFdBQVdoRyxDQUFDLEVBQUMsRUFBRzRCLElBQUksRUFBRztnQkFDckQsSUFBSTRmLGVBQWV0ZixlQUFlZ0UsT0FBT3BJLEtBQUssRUFBRSxJQUM1Q3FLLE9BQU9xWixZQUFZLENBQUMsRUFBRSxFQUN0QjVhLE9BQU80YSxZQUFZLENBQUMsRUFBRTtnQkFFMUIsSUFBSTNXLFFBQVFDLFNBQVMsQ0FBQzNDLE9BQU87b0JBQzNCLE1BQU07d0JBQUNBO3dCQUFNdkI7cUJBQUs7Z0JBQ3BCO1lBQ0Y7UUFDRixFQUFFLE9BQU85RSxLQUFLO1lBQ1prRSxXQUFXOUIsQ0FBQyxDQUFDcEM7UUFDZixTQUFVO1lBQ1JrRSxXQUFXN0IsQ0FBQztRQUNkO0lBQ0Y7SUFFQTs7R0FFQyxHQUNEc2QsY0FBYyxTQUFTQSxhQUFhdFosSUFBSTtRQUN0QyxJQUFJMEMsUUFBUXlKLFVBQVUsQ0FBQ25NLE9BQU87WUFDNUJBLEtBQUt4RCxRQUFRO1lBQ1QsSUFBSStjLGFBQWExUyx5QkFBeUI3RyxNQUFNcVk7WUFFcEQsT0FBT2tCO1FBQ1QsT0FBTztZQUNMdlosS0FBS3NDLElBQUk7WUFDTCxJQUFJa1gsY0FBYzNTLHlCQUF5QjdHLE1BQU1zWTtZQUVyRCxPQUFPa0I7UUFDVDtJQUNGO0lBRUE7O0dBRUMsR0FDRDFLLE9BQU8sU0FBU0EsTUFBTTZKLElBQUksRUFBRWxhLElBQUk7UUFDOUIsSUFBSWlHLElBQUlqRyxLQUFLMUcsS0FBSztRQUNsQixJQUFJRixJQUFJK0osS0FBS3pELEdBQUcsQ0FBQ3dhLE1BQU1qVTtRQUV2QixNQUFPN00sRUFBRztZQUNSLElBQUlvSSxLQUFLQyxNQUFNLENBQUNySSxNQUFNQSxFQUFFMkUsUUFBUSxDQUFDNUYsTUFBTSxLQUFLLEdBQUc7Z0JBQzdDO1lBQ0YsT0FBTztnQkFDTGlCLElBQUlBLEVBQUUyRSxRQUFRLENBQUMsRUFBRTtnQkFDakJrSSxFQUFFaEwsSUFBSSxDQUFDO1lBQ1Q7UUFDRjtRQUVBLE9BQU87WUFBQzdCO1lBQUc2TTtTQUFFO0lBQ2Y7SUFFQTs7R0FFQyxHQUNEN0MsVUFBVSxTQUFTQSxTQUFTOFcsSUFBSSxFQUFFeEssS0FBSztRQUNyQyxJQUFJbE8sS0FBS0MsTUFBTSxDQUFDeVksT0FBTztZQUNyQixNQUFNLElBQUlyUyxNQUFNLHlEQUF5RHhELE1BQU0sQ0FBQzhWLFNBQVNDLFNBQVMsQ0FBQ0Y7UUFDckc7UUFFQSxJQUFJYyxVQUFVM2pCLE1BQU00akIsT0FBTyxDQUFDO1lBQzFCbGQsVUFBVW1jLEtBQUtuYyxRQUFRO1FBQ3pCLEdBQUcsU0FBVXNQLENBQUM7WUFDWixJQUFJcUosZUFBZTNVLE1BQU1xTyxLQUFLLENBQUNWLFFBQzNCaUgsZ0JBQWdCcmIsZUFBZW9iLGNBQWMsSUFDN0MzRyxRQUFRNEcsYUFBYSxDQUFDLEVBQUUsRUFDeEJyTCxNQUFNcUwsYUFBYSxDQUFDLEVBQUU7WUFFMUIsSUFBSTNDLGNBQWM3USxLQUFLMkMsS0FBSyxDQUFDdUgsR0FBRztnQkFDOUJ2SyxTQUFTO2dCQUNUbVIsTUFBTSxTQUFTQSxLQUFLL1UsSUFBSTtvQkFDdEIsSUFBSUssUUFBUWpFLGVBQWU0RCxNQUFNLElBQzdCYyxPQUFPVCxLQUFLLENBQUMsRUFBRTtvQkFFbkIsT0FBTyxDQUFDd0MsTUFBTXNSLFFBQVEsQ0FBQzNELE9BQU8xUDtnQkFDaEM7WUFDRjtZQUVBLElBQUlLLGFBQWF5Wiw2QkFBNkI5RixjQUMxQzFUO1lBRUosSUFBSTtnQkFDRixJQUFLRCxXQUFXaEQsQ0FBQyxJQUFJLENBQUMsQ0FBQ2lELFNBQVNELFdBQVdqSCxDQUFDLEVBQUMsRUFBRzRCLElBQUksRUFBRztvQkFDckQsSUFBSTJXLGVBQWVyVyxlQUFlZ0YsT0FBT3BKLEtBQUssRUFBRSxJQUM1QzhJLE9BQU8yUixZQUFZLENBQUMsRUFBRTtvQkFFMUIsSUFBSSxDQUFDNVAsTUFBTXNSLFFBQVEsQ0FBQzNELE9BQU8xUCxPQUFPO3dCQUNoQyxJQUFJMkIsU0FBU3dCLEtBQUt4QixNQUFNLENBQUMwTCxHQUFHck47d0JBQzVCLElBQUlxYSxRQUFRcmEsSUFBSSxDQUFDQSxLQUFLN0gsTUFBTSxHQUFHLEVBQUU7d0JBQ2pDd0osT0FBTzVELFFBQVEsQ0FBQ21kLE1BQU0sQ0FBQ2IsT0FBTztvQkFDaEM7b0JBRUEsSUFBSWxhLEtBQUs2RSxNQUFNLENBQUNoRixNQUFNc0wsSUFBSXRMLElBQUksR0FBRzt3QkFDL0IsSUFBSXVSLE9BQU9wTyxLQUFLb08sSUFBSSxDQUFDbEUsR0FBR3JOO3dCQUN4QnVSLEtBQUsxTixJQUFJLEdBQUcwTixLQUFLMU4sSUFBSSxDQUFDdkssS0FBSyxDQUFDLEdBQUdnUyxJQUFJK0YsTUFBTTtvQkFDM0M7b0JBRUEsSUFBSWxSLEtBQUs2RSxNQUFNLENBQUNoRixNQUFNK1AsTUFBTS9QLElBQUksR0FBRzt3QkFDakMsSUFBSW1iLFFBQVFoWSxLQUFLb08sSUFBSSxDQUFDbEUsR0FBR3JOO3dCQUV6Qm1iLE1BQU10WCxJQUFJLEdBQUdzWCxNQUFNdFgsSUFBSSxDQUFDdkssS0FBSyxDQUFDeVcsTUFBTXNCLE1BQU07b0JBQzVDO2dCQUNGO1lBQ0YsRUFBRSxPQUFPblcsS0FBSztnQkFDWm1GLFdBQVcvQyxDQUFDLENBQUNwQztZQUNmLFNBQVU7Z0JBQ1JtRixXQUFXOUMsQ0FBQztZQUNkO1lBRUEsSUFBSWtCLE9BQU84RixRQUFRLENBQUM4SSxJQUFJO2dCQUN0QkEsRUFBRXBQLFNBQVMsR0FBRztZQUNoQjtRQUNGO1FBQ0EsT0FBTytjLFFBQVFqZCxRQUFRO0lBQ3pCO0lBRUE7OztHQUdDLEdBQ0QyQixLQUFLLFNBQVNBLElBQUl3YSxJQUFJLEVBQUVsYSxJQUFJO1FBQzFCLElBQUl1QixPQUFPMlk7UUFFWCxJQUFLLElBQUk5aEIsSUFBSSxHQUFHQSxJQUFJNEgsS0FBSzdILE1BQU0sRUFBRUMsSUFBSztZQUNwQyxJQUFJNk4sSUFBSWpHLElBQUksQ0FBQzVILEVBQUU7WUFFZixJQUFJb0osS0FBS0MsTUFBTSxDQUFDRixTQUFTLENBQUNBLEtBQUt4RCxRQUFRLENBQUNrSSxFQUFFLEVBQUU7Z0JBQzFDLE1BQU0sSUFBSTRCLE1BQU0scUNBQXFDeEQsTUFBTSxDQUFDckUsTUFBTSxlQUFlcUUsTUFBTSxDQUFDOFYsU0FBU0MsU0FBUyxDQUFDRjtZQUM3RztZQUVBM1ksT0FBT0EsS0FBS3hELFFBQVEsQ0FBQ2tJLEVBQUU7UUFDekI7UUFFQSxPQUFPMUU7SUFDVDtJQUVBOztHQUVDLEdBQ0RyQixLQUFLLFNBQVNBLElBQUlnYSxJQUFJLEVBQUVsYSxJQUFJO1FBQzFCLElBQUl1QixPQUFPMlk7UUFFWCxJQUFLLElBQUk5aEIsSUFBSSxHQUFHQSxJQUFJNEgsS0FBSzdILE1BQU0sRUFBRUMsSUFBSztZQUNwQyxJQUFJNk4sSUFBSWpHLElBQUksQ0FBQzVILEVBQUU7WUFFZixJQUFJb0osS0FBS0MsTUFBTSxDQUFDRixTQUFTLENBQUNBLEtBQUt4RCxRQUFRLENBQUNrSSxFQUFFLEVBQUU7Z0JBQzFDLE9BQU87WUFDVDtZQUVBMUUsT0FBT0EsS0FBS3hELFFBQVEsQ0FBQ2tJLEVBQUU7UUFDekI7UUFFQSxPQUFPO0lBQ1Q7SUFFQTs7R0FFQyxHQUNEbVYsUUFBUSxTQUFTQSxPQUFPbGtCLEtBQUs7UUFDM0IsT0FBT3NLLEtBQUtDLE1BQU0sQ0FBQ3ZLLFVBQVUrTSxRQUFRQyxTQUFTLENBQUNoTixVQUFVdUgsT0FBTzhGLFFBQVEsQ0FBQ3JOO0lBQzNFO0lBRUE7O0dBRUMsR0FDRHVXLFlBQVksU0FBU0EsV0FBV3ZXLEtBQUs7UUFDbkMsSUFBSSxDQUFDb0IsTUFBTUcsT0FBTyxDQUFDdkIsUUFBUTtZQUN6QixPQUFPO1FBQ1Q7UUFFQSxJQUFJbWtCLGVBQWVwQixtQkFBbUJ2YSxHQUFHLENBQUN4STtRQUUxQyxJQUFJbWtCLGlCQUFpQnhTLFdBQVc7WUFDOUIsT0FBT3dTO1FBQ1Q7UUFFQSxJQUFJNU4sYUFBYXZXLE1BQU0wVyxLQUFLLENBQUMsU0FBVUMsR0FBRztZQUN4QyxPQUFPMUssS0FBS2lZLE1BQU0sQ0FBQ3ZOO1FBQ3JCO1FBQ0FvTSxtQkFBbUJwWixHQUFHLENBQUMzSixPQUFPdVc7UUFDOUIsT0FBT0E7SUFDVDtJQUVBOztHQUVDLEdBQ0Q2RCxNQUFNLFNBQVNBLEtBQUs0SSxJQUFJLEVBQUVsYSxJQUFJO1FBQzVCLElBQUlpRyxJQUFJakcsS0FBSzFHLEtBQUs7UUFDbEIsSUFBSUYsSUFBSStKLEtBQUt6RCxHQUFHLENBQUN3YSxNQUFNalU7UUFFdkIsTUFBTzdNLEVBQUc7WUFDUixJQUFJb0ksS0FBS0MsTUFBTSxDQUFDckksTUFBTUEsRUFBRTJFLFFBQVEsQ0FBQzVGLE1BQU0sS0FBSyxHQUFHO2dCQUM3QztZQUNGLE9BQU87Z0JBQ0wsSUFBSUMsSUFBSWdCLEVBQUUyRSxRQUFRLENBQUM1RixNQUFNLEdBQUc7Z0JBQzVCaUIsSUFBSUEsRUFBRTJFLFFBQVEsQ0FBQzNGLEVBQUU7Z0JBQ2pCNk4sRUFBRWhMLElBQUksQ0FBQzdDO1lBQ1Q7UUFDRjtRQUVBLE9BQU87WUFBQ2dCO1lBQUc2TTtTQUFFO0lBQ2Y7SUFFQTs7R0FFQyxHQUNEc0wsTUFBTSxTQUFTQSxLQUFLMkksSUFBSSxFQUFFbGEsSUFBSTtRQUM1QixJQUFJdUIsT0FBTzRCLEtBQUt6RCxHQUFHLENBQUN3YSxNQUFNbGE7UUFFMUIsSUFBSSxDQUFDd0IsS0FBS0MsTUFBTSxDQUFDRixPQUFPO1lBQ3RCLE1BQU0sSUFBSXNHLE1BQU0scUNBQXFDeEQsTUFBTSxDQUFDckUsTUFBTSw0Q0FBNENxRSxNQUFNLENBQUM4VixTQUFTQyxTQUFTLENBQUM3WTtRQUMxSTtRQUVBLE9BQU9BO0lBQ1Q7SUFFQTs7Ozs7R0FLQyxHQUNEb0UsUUFBUSxVQUFVQSxPQUFPdVUsSUFBSSxFQUFFbGEsSUFBSTtRQUNqQyxJQUFJOE8sVUFBVW5TLFVBQVV4RSxNQUFNLEdBQUcsS0FBS3dFLFNBQVMsQ0FBQyxFQUFFLEtBQUtrTSxZQUFZbE0sU0FBUyxDQUFDLEVBQUUsR0FBRyxDQUFDO1FBRW5GLElBQUkrRCxhQUFhb1osNkJBQTZCM1osS0FBS3dGLE1BQU0sQ0FBQzNGLE1BQU04TyxXQUM1RG5PO1FBRUosSUFBSTtZQUNGLElBQUtELFdBQVdyRCxDQUFDLElBQUksQ0FBQyxDQUFDc0QsU0FBU0QsV0FBV3RILENBQUMsRUFBQyxFQUFHNEIsSUFBSSxFQUFHO2dCQUNyRCxJQUFJaUwsSUFBSXRGLE9BQU96SixLQUFLO2dCQUNwQixJQUFJa0MsSUFBSStKLEtBQUt6RCxHQUFHLENBQUN3YSxNQUFNalU7Z0JBQ3ZCLE1BQU07b0JBQUM3TTtvQkFBRzZNO2lCQUFFO1lBQ2Q7UUFDRixFQUFFLE9BQU8vSyxLQUFLO1lBQ1p3RixXQUFXcEQsQ0FBQyxDQUFDcEM7UUFDZixTQUFVO1lBQ1J3RixXQUFXbkQsQ0FBQztRQUNkO0lBQ0Y7SUFFQTs7R0FFQyxHQUNENFEsU0FBUyxTQUFTQSxRQUFRNU0sSUFBSSxFQUFFd00sS0FBSztRQUNuQyxPQUFPOUosUUFBUUMsU0FBUyxDQUFDM0MsU0FBUzBDLFFBQVE2SixjQUFjLENBQUNDLFVBQVU5SixRQUFRa0ssT0FBTyxDQUFDNU0sTUFBTXdNLFVBQVV2TSxLQUFLQyxNQUFNLENBQUNGLFNBQVNDLEtBQUs4WixXQUFXLENBQUN2TixVQUFVdk0sS0FBSzJNLE9BQU8sQ0FBQzVNLE1BQU13TTtJQUN4SztJQUVBOzs7O0dBSUMsR0FDRGpJLE9BQU8sVUFBVUEsTUFBTW9VLElBQUk7UUFDekIsSUFBSXBMLFVBQVVuUyxVQUFVeEUsTUFBTSxHQUFHLEtBQUt3RSxTQUFTLENBQUMsRUFBRSxLQUFLa00sWUFBWWxNLFNBQVMsQ0FBQyxFQUFFLEdBQUcsQ0FBQztRQUNuRixJQUFJc1gsT0FBT25GLFFBQVFtRixJQUFJLEVBQ25CTCxvQkFBb0I5RSxRQUFRaE0sT0FBTyxFQUNuQ0EsVUFBVThRLHNCQUFzQixLQUFLLElBQUksUUFBUUE7UUFDckQsSUFBSTJILGdCQUFnQnpNLFFBQVEvVixJQUFJLEVBQzVCQSxPQUFPd2lCLGtCQUFrQixLQUFLLElBQUksRUFBRSxHQUFHQSxlQUN2Q3JJLEtBQUtwRSxRQUFRb0UsRUFBRTtRQUNuQixJQUFJc0ksVUFBVSxJQUFJNWI7UUFDbEIsSUFBSXFHLElBQUksRUFBRTtRQUNWLElBQUk3TSxJQUFJOGdCO1FBRVIsTUFBTyxLQUFNO1lBQ1gsSUFBSWhILE1BQU9wUSxDQUFBQSxVQUFVM0MsS0FBS3FaLFFBQVEsQ0FBQ3ZULEdBQUdpTixNQUFNL1MsS0FBS3NiLE9BQU8sQ0FBQ3hWLEdBQUdpTixHQUFFLEdBQUk7Z0JBQ2hFO1lBQ0Y7WUFFQSxJQUFJLENBQUNzSSxRQUFRdGIsR0FBRyxDQUFDOUcsSUFBSTtnQkFDbkIsTUFBTTtvQkFBQ0E7b0JBQUc2TTtpQkFBRTtZQUNkLEVBQUUsb0VBQW9FO1lBR3RFLElBQUksQ0FBQ3VWLFFBQVF0YixHQUFHLENBQUM5RyxNQUFNLENBQUNvSSxLQUFLQyxNQUFNLENBQUNySSxNQUFNQSxFQUFFMkUsUUFBUSxDQUFDNUYsTUFBTSxLQUFLLEtBQU04YixDQUFBQSxRQUFRLFFBQVFBLEtBQUs7Z0JBQUM3YTtnQkFBRzZNO2FBQUUsTUFBTSxLQUFJLEdBQUk7Z0JBQzdHdVYsUUFBUXpiLEdBQUcsQ0FBQzNHO2dCQUNaLElBQUlzaUIsWUFBWTVZLFVBQVUxSixFQUFFMkUsUUFBUSxDQUFDNUYsTUFBTSxHQUFHLElBQUk7Z0JBRWxELElBQUlnSSxLQUFLdU4sVUFBVSxDQUFDekgsR0FBR2xOLE9BQU87b0JBQzVCMmlCLFlBQVkzaUIsSUFBSSxDQUFDa04sRUFBRTlOLE1BQU0sQ0FBQztnQkFDNUI7Z0JBRUE4TixJQUFJQSxFQUFFNUIsTUFBTSxDQUFDcVg7Z0JBQ2J0aUIsSUFBSStKLEtBQUt6RCxHQUFHLENBQUN3YSxNQUFNalU7Z0JBQ25CO1lBQ0YsRUFBRSx5REFBeUQ7WUFHM0QsSUFBSUEsRUFBRTlOLE1BQU0sS0FBSyxHQUFHO2dCQUNsQjtZQUNGLEVBQUUsNEJBQTRCO1lBRzlCLElBQUksQ0FBQzJLLFNBQVM7Z0JBQ1osSUFBSXZDLFVBQVVKLEtBQUtwRixJQUFJLENBQUNrTDtnQkFFeEIsSUFBSTlDLEtBQUtqRCxHQUFHLENBQUNnYSxNQUFNM1osVUFBVTtvQkFDM0IwRixJQUFJMUY7b0JBQ0puSCxJQUFJK0osS0FBS3pELEdBQUcsQ0FBQ3dhLE1BQU1qVTtvQkFDbkI7Z0JBQ0Y7WUFDRixFQUFFLDZCQUE2QjtZQUcvQixJQUFJbkQsV0FBV21ELENBQUMsQ0FBQ0EsRUFBRTlOLE1BQU0sR0FBRyxFQUFFLEtBQUssR0FBRztnQkFDcEMsSUFBSXdqQixXQUFXeGIsS0FBS2tHLFFBQVEsQ0FBQ0o7Z0JBRTdCQSxJQUFJMFY7Z0JBQ0p2aUIsSUFBSStKLEtBQUt6RCxHQUFHLENBQUN3YSxNQUFNalU7Z0JBQ25CO1lBQ0YsRUFBRSxrQ0FBa0M7WUFHcENBLElBQUk5RixLQUFLd0IsTUFBTSxDQUFDc0U7WUFDaEI3TSxJQUFJK0osS0FBS3pELEdBQUcsQ0FBQ3dhLE1BQU1qVTtZQUNuQnVWLFFBQVF6YixHQUFHLENBQUMzRztRQUNkO0lBQ0Y7SUFFQTs7R0FFQyxHQUNEdUksUUFBUSxTQUFTQSxPQUFPdVksSUFBSSxFQUFFbGEsSUFBSTtRQUNoQyxJQUFJb1YsYUFBYWpWLEtBQUt3QixNQUFNLENBQUMzQjtRQUM3QixJQUFJaUcsSUFBSTlDLEtBQUt6RCxHQUFHLENBQUN3YSxNQUFNOUU7UUFFdkIsSUFBSTVULEtBQUtDLE1BQU0sQ0FBQ3dFLElBQUk7WUFDbEIsTUFBTSxJQUFJNEIsTUFBTSxrQ0FBa0N4RCxNQUFNLENBQUNyRSxNQUFNO1FBQ2pFO1FBRUEsT0FBT2lHO0lBQ1Q7SUFFQTs7Ozs7O0dBTUMsR0FDRHdSLFFBQVEsU0FBU0EsT0FBT2xXLElBQUk7UUFDMUIsSUFBSUMsS0FBS0MsTUFBTSxDQUFDRixPQUFPO1lBQ3JCLE9BQU9BLEtBQUtzQyxJQUFJO1FBQ2xCLE9BQU87WUFDTCxPQUFPdEMsS0FBS3hELFFBQVEsQ0FBQytXLEdBQUcsQ0FBQzNSLEtBQUtzVSxNQUFNLEVBQUV4WCxJQUFJLENBQUM7UUFDN0M7SUFDRjtJQUVBOztHQUVDLEdBQ0QyYixPQUFPLFVBQVVBLE1BQU0xQixJQUFJO1FBQ3pCLElBQUlwTCxVQUFVblMsVUFBVXhFLE1BQU0sR0FBRyxLQUFLd0UsU0FBUyxDQUFDLEVBQUUsS0FBS2tNLFlBQVlsTSxTQUFTLENBQUMsRUFBRSxHQUFHLENBQUM7UUFFbkYsSUFBSThKLGFBQWFxVCw2QkFBNkIzVyxLQUFLMkMsS0FBSyxDQUFDb1UsTUFBTXBMLFdBQzNEcEk7UUFFSixJQUFJO1lBQ0YsSUFBS0QsV0FBV3BKLENBQUMsSUFBSSxDQUFDLENBQUNxSixTQUFTRCxXQUFXck4sQ0FBQyxFQUFDLEVBQUc0QixJQUFJLEVBQUc7Z0JBQ3JELElBQUk2Z0IsZUFBZXZnQixlQUFlb0wsT0FBT3hQLEtBQUssRUFBRSxJQUM1Q3FLLE9BQU9zYSxZQUFZLENBQUMsRUFBRSxFQUN0QjdiLE9BQU82YixZQUFZLENBQUMsRUFBRTtnQkFFMUIsSUFBSXJhLEtBQUtDLE1BQU0sQ0FBQ0YsT0FBTztvQkFDckIsTUFBTTt3QkFBQ0E7d0JBQU12QjtxQkFBSztnQkFDcEI7WUFDRjtRQUNGLEVBQUUsT0FBTzlFLEtBQUs7WUFDWnVMLFdBQVduSixDQUFDLENBQUNwQztRQUNmLFNBQVU7WUFDUnVMLFdBQVdsSixDQUFDO1FBQ2Q7SUFDRjtBQUNGO0FBRUEsU0FBU3VlLFVBQVU5ZixNQUFNLEVBQUVDLGNBQWM7SUFBSSxJQUFJQyxPQUFPbkYsT0FBT21GLElBQUksQ0FBQ0Y7SUFBUyxJQUFJakYsT0FBT29GLHFCQUFxQixFQUFFO1FBQUUsSUFBSUMsVUFBVXJGLE9BQU9vRixxQkFBcUIsQ0FBQ0g7UUFBUyxJQUFJQyxnQkFBZ0I7WUFBRUcsVUFBVUEsUUFBUUMsTUFBTSxDQUFDLFNBQVVDLEdBQUc7Z0JBQUksT0FBT3ZGLE9BQU93Rix3QkFBd0IsQ0FBQ1AsUUFBUU0sS0FBS3BDLFVBQVU7WUFBRTtRQUFJO1FBQUVnQyxLQUFLakIsSUFBSSxDQUFDdUIsS0FBSyxDQUFDTixNQUFNRTtJQUFVO0lBQUUsT0FBT0Y7QUFBTTtBQUUxVixTQUFTNmYsZ0JBQWdCcmYsTUFBTTtJQUFJLElBQUssSUFBSXRFLElBQUksR0FBR0EsSUFBSXVFLFVBQVV4RSxNQUFNLEVBQUVDLElBQUs7UUFBRSxJQUFJd0UsU0FBU0QsU0FBUyxDQUFDdkUsRUFBRSxJQUFJLE9BQU91RSxTQUFTLENBQUN2RSxFQUFFLEdBQUcsQ0FBQztRQUFHLElBQUlBLElBQUksR0FBRztZQUFFMGpCLFVBQVUva0IsT0FBTzZGLFNBQVMsTUFBTUMsT0FBTyxDQUFDLFNBQVU1QyxHQUFHO2dCQUFJRixnQkFBZ0IyQyxRQUFRekMsS0FBSzJDLE1BQU0sQ0FBQzNDLElBQUk7WUFBRztRQUFJLE9BQU8sSUFBSWxELE9BQU8rRix5QkFBeUIsRUFBRTtZQUFFL0YsT0FBT2dHLGdCQUFnQixDQUFDTCxRQUFRM0YsT0FBTytGLHlCQUF5QixDQUFDRjtRQUFVLE9BQU87WUFBRWtmLFVBQVUva0IsT0FBTzZGLFNBQVNDLE9BQU8sQ0FBQyxTQUFVNUMsR0FBRztnQkFBSWxELE9BQU9DLGNBQWMsQ0FBQzBGLFFBQVF6QyxLQUFLbEQsT0FBT3dGLHdCQUF3QixDQUFDSyxRQUFRM0M7WUFBTztRQUFJO0lBQUU7SUFBRSxPQUFPeUM7QUFBUTtBQUUzaEIsSUFBSWtVLFlBQVk7SUFDZDs7R0FFQyxHQUNEb0wsaUJBQWlCLFNBQVNBLGdCQUFnQjlrQixLQUFLO1FBQzdDLE9BQU8wWixVQUFVcUwsV0FBVyxDQUFDL2tCLFVBQVVBLE1BQU0rSixJQUFJLENBQUNpYixRQUFRLENBQUM7SUFDN0Q7SUFFQTs7R0FFQyxHQUNERCxhQUFhLFNBQVNBLFlBQVkva0IsS0FBSztRQUNyQyxJQUFJLENBQUNDLGNBQWNBLGFBQWEsQ0FBQ0QsUUFBUTtZQUN2QyxPQUFPO1FBQ1Q7UUFFQSxPQUFRQSxNQUFNK0osSUFBSTtZQUNoQixLQUFLO2dCQUNILE9BQU9kLEtBQUtpVCxNQUFNLENBQUNsYyxNQUFNOEksSUFBSSxLQUFLbUQsS0FBS2lZLE1BQU0sQ0FBQ2xrQixNQUFNcUssSUFBSTtZQUUxRCxLQUFLO2dCQUNILE9BQU8sT0FBT3JLLE1BQU1tYSxNQUFNLEtBQUssWUFBWSxPQUFPbmEsTUFBTTJNLElBQUksS0FBSyxZQUFZMUQsS0FBS2lULE1BQU0sQ0FBQ2xjLE1BQU04SSxJQUFJO1lBRXJHLEtBQUs7Z0JBQ0gsT0FBTyxPQUFPOUksTUFBTWlsQixRQUFRLEtBQUssWUFBWWhjLEtBQUtpVCxNQUFNLENBQUNsYyxNQUFNOEksSUFBSSxLQUFLN0ksY0FBY0EsYUFBYSxDQUFDRCxNQUFNNGpCLFVBQVU7WUFFdEgsS0FBSztnQkFDSCxPQUFPM2EsS0FBS2lULE1BQU0sQ0FBQ2xjLE1BQU04SSxJQUFJLEtBQUtHLEtBQUtpVCxNQUFNLENBQUNsYyxNQUFNcUosT0FBTztZQUU3RCxLQUFLO2dCQUNILE9BQU9KLEtBQUtpVCxNQUFNLENBQUNsYyxNQUFNOEksSUFBSSxLQUFLbUQsS0FBS2lZLE1BQU0sQ0FBQ2xrQixNQUFNcUssSUFBSTtZQUUxRCxLQUFLO2dCQUNILE9BQU8sT0FBT3JLLE1BQU1tYSxNQUFNLEtBQUssWUFBWSxPQUFPbmEsTUFBTTJNLElBQUksS0FBSyxZQUFZMUQsS0FBS2lULE1BQU0sQ0FBQ2xjLE1BQU04SSxJQUFJO1lBRXJHLEtBQUs7Z0JBQ0gsT0FBT0csS0FBS2lULE1BQU0sQ0FBQ2xjLE1BQU04SSxJQUFJLEtBQUs3SSxjQUFjQSxhQUFhLENBQUNELE1BQU00akIsVUFBVSxLQUFLM2pCLGNBQWNBLGFBQWEsQ0FBQ0QsTUFBTWtsQixhQUFhO1lBRXBJLEtBQUs7Z0JBQ0gsT0FBT2xsQixNQUFNNGpCLFVBQVUsS0FBSyxRQUFRL1ksTUFBTXFOLE9BQU8sQ0FBQ2xZLE1BQU1rbEIsYUFBYSxLQUFLbGxCLE1BQU1rbEIsYUFBYSxLQUFLLFFBQVFyYSxNQUFNcU4sT0FBTyxDQUFDbFksTUFBTTRqQixVQUFVLEtBQUszakIsY0FBY0EsYUFBYSxDQUFDRCxNQUFNNGpCLFVBQVUsS0FBSzNqQixjQUFjQSxhQUFhLENBQUNELE1BQU1rbEIsYUFBYTtZQUUvTyxLQUFLO2dCQUNILE9BQU9qYyxLQUFLaVQsTUFBTSxDQUFDbGMsTUFBTThJLElBQUksS0FBSyxPQUFPOUksTUFBTWlsQixRQUFRLEtBQUssWUFBWWhsQixjQUFjQSxhQUFhLENBQUNELE1BQU00akIsVUFBVTtZQUV0SDtnQkFDRSxPQUFPO1FBQ1g7SUFDRjtJQUVBOztHQUVDLEdBQ0RqSyxpQkFBaUIsU0FBU0EsZ0JBQWdCM1osS0FBSztRQUM3QyxPQUFPb0IsTUFBTUcsT0FBTyxDQUFDdkIsVUFBVUEsTUFBTTBXLEtBQUssQ0FBQyxTQUFVQyxHQUFHO1lBQ3RELE9BQU8rQyxVQUFVcUwsV0FBVyxDQUFDcE87UUFDL0I7SUFDRjtJQUVBOztHQUVDLEdBQ0R3TyxzQkFBc0IsU0FBU0EscUJBQXFCbmxCLEtBQUs7UUFDdkQsT0FBTzBaLFVBQVVxTCxXQUFXLENBQUMva0IsVUFBVUEsTUFBTStKLElBQUksQ0FBQ2liLFFBQVEsQ0FBQztJQUM3RDtJQUVBOztHQUVDLEdBQ0RJLGlCQUFpQixTQUFTQSxnQkFBZ0JwbEIsS0FBSztRQUM3QyxPQUFPMFosVUFBVXFMLFdBQVcsQ0FBQy9rQixVQUFVQSxNQUFNK0osSUFBSSxDQUFDaWIsUUFBUSxDQUFDO0lBQzdEO0lBRUE7OztHQUdDLEdBQ0RLLFNBQVMsU0FBU0EsUUFBUWhlLEVBQUU7UUFDMUIsT0FBUUEsR0FBRzBDLElBQUk7WUFDYixLQUFLO2dCQUNIO29CQUNFLE9BQU84YSxnQkFBZ0JBLGdCQUFnQixDQUFDLEdBQUd4ZCxLQUFLLENBQUMsR0FBRzt3QkFDbEQwQyxNQUFNO29CQUNSO2dCQUNGO1lBRUYsS0FBSztnQkFDSDtvQkFDRSxPQUFPOGEsZ0JBQWdCQSxnQkFBZ0IsQ0FBQyxHQUFHeGQsS0FBSyxDQUFDLEdBQUc7d0JBQ2xEMEMsTUFBTTtvQkFDUjtnQkFDRjtZQUVGLEtBQUs7Z0JBQ0g7b0JBQ0UsT0FBTzhhLGdCQUFnQkEsZ0JBQWdCLENBQUMsR0FBR3hkLEtBQUssQ0FBQyxHQUFHO3dCQUNsRDBDLE1BQU07d0JBQ05qQixNQUFNRyxLQUFLa0csUUFBUSxDQUFDOUgsR0FBR3lCLElBQUk7b0JBQzdCO2dCQUNGO1lBRUYsS0FBSztnQkFDSDtvQkFDRSxJQUFJTyxVQUFVaEMsR0FBR2dDLE9BQU8sRUFDcEJQLE9BQU96QixHQUFHeUIsSUFBSSxFQUFFLDREQUE0RDtvQkFFaEYsSUFBSUcsS0FBSzZFLE1BQU0sQ0FBQ3pFLFNBQVNQLE9BQU87d0JBQzlCLE9BQU96QjtvQkFDVCxFQUFFLHFFQUFxRTtvQkFDdkUsaURBQWlEO29CQUdqRCxJQUFJNEIsS0FBS3FjLFNBQVMsQ0FBQ3hjLE1BQU1PLFVBQVU7d0JBQ2pDLE9BQU93YixnQkFBZ0JBLGdCQUFnQixDQUFDLEdBQUd4ZCxLQUFLLENBQUMsR0FBRzs0QkFDbER5QixNQUFNTzs0QkFDTkEsU0FBU1A7d0JBQ1g7b0JBQ0YsRUFBRSxvRUFBb0U7b0JBQ3RFLHNFQUFzRTtvQkFDdEUseUVBQXlFO29CQUN6RSwyRUFBMkU7b0JBQzNFLG1FQUFtRTtvQkFDbkUsZ0NBQWdDO29CQUdoQyxJQUFJeWMsY0FBY3RjLEtBQUtyQixTQUFTLENBQUNrQixNQUFNekI7b0JBQ3ZDLElBQUltZSxpQkFBaUJ2YyxLQUFLckIsU0FBUyxDQUFDcUIsS0FBS3BGLElBQUksQ0FBQ2lGLE9BQU96QjtvQkFDckQsT0FBT3dkLGdCQUFnQkEsZ0JBQWdCLENBQUMsR0FBR3hkLEtBQUssQ0FBQyxHQUFHO3dCQUNsRHlCLE1BQU15Yzt3QkFDTmxjLFNBQVNtYztvQkFDWDtnQkFDRjtZQUVGLEtBQUs7Z0JBQ0g7b0JBQ0UsT0FBT1gsZ0JBQWdCQSxnQkFBZ0IsQ0FBQyxHQUFHeGQsS0FBSyxDQUFDLEdBQUc7d0JBQ2xEMEMsTUFBTTtvQkFDUjtnQkFDRjtZQUVGLEtBQUs7Z0JBQ0g7b0JBQ0UsT0FBTzhhLGdCQUFnQkEsZ0JBQWdCLENBQUMsR0FBR3hkLEtBQUssQ0FBQyxHQUFHO3dCQUNsRDBDLE1BQU07b0JBQ1I7Z0JBQ0Y7WUFFRixLQUFLO2dCQUNIO29CQUNFLElBQUk2WixhQUFhdmMsR0FBR3VjLFVBQVUsRUFDMUJzQixnQkFBZ0I3ZCxHQUFHNmQsYUFBYTtvQkFDcEMsT0FBT0wsZ0JBQWdCQSxnQkFBZ0IsQ0FBQyxHQUFHeGQsS0FBSyxDQUFDLEdBQUc7d0JBQ2xEdWMsWUFBWXNCO3dCQUNaQSxlQUFldEI7b0JBQ2pCO2dCQUNGO1lBRUYsS0FBSztnQkFDSDtvQkFDRSxJQUFJQyxjQUFjeGMsR0FBR3VjLFVBQVUsRUFDM0I2QixpQkFBaUJwZSxHQUFHNmQsYUFBYTtvQkFFckMsSUFBSXJCLGVBQWUsTUFBTTt3QkFDdkIsT0FBT2dCLGdCQUFnQkEsZ0JBQWdCLENBQUMsR0FBR3hkLEtBQUssQ0FBQyxHQUFHOzRCQUNsRHVjLFlBQVk2Qjs0QkFDWlAsZUFBZTt3QkFDakI7b0JBQ0YsT0FBTyxJQUFJTyxrQkFBa0IsTUFBTTt3QkFDakMsT0FBT1osZ0JBQWdCQSxnQkFBZ0IsQ0FBQyxHQUFHeGQsS0FBSyxDQUFDLEdBQUc7NEJBQ2xEdWMsWUFBWTs0QkFDWnNCLGVBQWVyQjt3QkFDakI7b0JBQ0YsT0FBTzt3QkFDTCxPQUFPZ0IsZ0JBQWdCQSxnQkFBZ0IsQ0FBQyxHQUFHeGQsS0FBSyxDQUFDLEdBQUc7NEJBQ2xEdWMsWUFBWTZCOzRCQUNaUCxlQUFlckI7d0JBQ2pCO29CQUNGO2dCQUNGO1lBRUYsS0FBSztnQkFDSDtvQkFDRSxPQUFPZ0IsZ0JBQWdCQSxnQkFBZ0IsQ0FBQyxHQUFHeGQsS0FBSyxDQUFDLEdBQUc7d0JBQ2xEMEMsTUFBTTt3QkFDTmpCLE1BQU1HLEtBQUtwRixJQUFJLENBQUN3RCxHQUFHeUIsSUFBSTtvQkFDekI7Z0JBQ0Y7UUFDSjtJQUNGO0FBQ0Y7QUFFQSx3Q0FBd0M7QUFDeEMsSUFBSUcsT0FBTztJQUNUOzs7OztHQUtDLEdBQ0RnRyxXQUFXLFNBQVNBLFVBQVVuRyxJQUFJO1FBQ2hDLElBQUk4TyxVQUFVblMsVUFBVXhFLE1BQU0sR0FBRyxLQUFLd0UsU0FBUyxDQUFDLEVBQUUsS0FBS2tNLFlBQVlsTSxTQUFTLENBQUMsRUFBRSxHQUFHLENBQUM7UUFDbkYsSUFBSThVLG1CQUFtQjNDLFFBQVFoTSxPQUFPLEVBQ2xDQSxVQUFVMk8scUJBQXFCLEtBQUssSUFBSSxRQUFRQTtRQUNwRCxJQUFJbUwsUUFBUXpjLEtBQUt3RixNQUFNLENBQUMzRixNQUFNOE87UUFFOUIsSUFBSWhNLFNBQVM7WUFDWDhaLFFBQVFBLE1BQU10akIsS0FBSyxDQUFDO1FBQ3RCLE9BQU87WUFDTHNqQixRQUFRQSxNQUFNdGpCLEtBQUssQ0FBQyxHQUFHLENBQUM7UUFDMUI7UUFFQSxPQUFPc2pCO0lBQ1Q7SUFFQTs7R0FFQyxHQUNEaEgsUUFBUSxTQUFTQSxPQUFPNVYsSUFBSSxFQUFFd2EsT0FBTztRQUNuQyxJQUFJNUUsU0FBUyxFQUFFO1FBRWYsSUFBSyxJQUFJeGQsSUFBSSxHQUFHQSxJQUFJNEgsS0FBSzdILE1BQU0sSUFBSUMsSUFBSW9pQixRQUFRcmlCLE1BQU0sRUFBRUMsSUFBSztZQUMxRCxJQUFJeWtCLEtBQUs3YyxJQUFJLENBQUM1SCxFQUFFO1lBQ2hCLElBQUkwa0IsS0FBS3RDLE9BQU8sQ0FBQ3BpQixFQUFFO1lBRW5CLElBQUl5a0IsT0FBT0MsSUFBSTtnQkFDYjtZQUNGO1lBRUFsSCxPQUFPM2EsSUFBSSxDQUFDNGhCO1FBQ2Q7UUFFQSxPQUFPakg7SUFDVDtJQUVBOzs7Ozs7O0dBT0MsR0FDRHZCLFNBQVMsU0FBU0EsUUFBUXJVLElBQUksRUFBRXdhLE9BQU87UUFDckMsSUFBSXVDLE1BQU1DLEtBQUtELEdBQUcsQ0FBQy9jLEtBQUs3SCxNQUFNLEVBQUVxaUIsUUFBUXJpQixNQUFNO1FBRTlDLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJMmtCLEtBQUsza0IsSUFBSztZQUM1QixJQUFJNEgsSUFBSSxDQUFDNUgsRUFBRSxHQUFHb2lCLE9BQU8sQ0FBQ3BpQixFQUFFLEVBQUUsT0FBTyxDQUFDO1lBQ2xDLElBQUk0SCxJQUFJLENBQUM1SCxFQUFFLEdBQUdvaUIsT0FBTyxDQUFDcGlCLEVBQUUsRUFBRSxPQUFPO1FBQ25DO1FBRUEsT0FBTztJQUNUO0lBRUE7O0dBRUMsR0FDRDZrQixXQUFXLFNBQVNBLFVBQVVqZCxJQUFJLEVBQUV3YSxPQUFPO1FBQ3pDLElBQUlwaUIsSUFBSTRILEtBQUs3SCxNQUFNLEdBQUc7UUFDdEIsSUFBSStrQixLQUFLbGQsS0FBSzFHLEtBQUssQ0FBQyxHQUFHbEI7UUFDdkIsSUFBSStrQixLQUFLM0MsUUFBUWxoQixLQUFLLENBQUMsR0FBR2xCO1FBQzFCLElBQUl5a0IsS0FBSzdjLElBQUksQ0FBQzVILEVBQUU7UUFDaEIsSUFBSTBrQixLQUFLdEMsT0FBTyxDQUFDcGlCLEVBQUU7UUFDbkIsT0FBTytILEtBQUs2RSxNQUFNLENBQUNrWSxJQUFJQyxPQUFPTixLQUFLQztJQUNyQztJQUVBOztHQUVDLEdBQ0RNLFFBQVEsU0FBU0EsT0FBT3BkLElBQUksRUFBRXdhLE9BQU87UUFDbkMsSUFBSXBpQixJQUFJNEgsS0FBSzdILE1BQU07UUFDbkIsSUFBSStrQixLQUFLbGQsS0FBSzFHLEtBQUssQ0FBQyxHQUFHbEI7UUFDdkIsSUFBSStrQixLQUFLM0MsUUFBUWxoQixLQUFLLENBQUMsR0FBR2xCO1FBQzFCLE9BQU8rSCxLQUFLNkUsTUFBTSxDQUFDa1ksSUFBSUM7SUFDekI7SUFFQTs7R0FFQyxHQUNERSxZQUFZLFNBQVNBLFdBQVdyZCxJQUFJLEVBQUV3YSxPQUFPO1FBQzNDLElBQUlwaUIsSUFBSTRILEtBQUs3SCxNQUFNLEdBQUc7UUFDdEIsSUFBSStrQixLQUFLbGQsS0FBSzFHLEtBQUssQ0FBQyxHQUFHbEI7UUFDdkIsSUFBSStrQixLQUFLM0MsUUFBUWxoQixLQUFLLENBQUMsR0FBR2xCO1FBQzFCLElBQUl5a0IsS0FBSzdjLElBQUksQ0FBQzVILEVBQUU7UUFDaEIsSUFBSTBrQixLQUFLdEMsT0FBTyxDQUFDcGlCLEVBQUU7UUFDbkIsT0FBTytILEtBQUs2RSxNQUFNLENBQUNrWSxJQUFJQyxPQUFPTixLQUFLQztJQUNyQztJQUVBOztHQUVDLEdBQ0Q5WCxRQUFRLFNBQVNBLE9BQU9oRixJQUFJLEVBQUV3YSxPQUFPO1FBQ25DLE9BQU94YSxLQUFLN0gsTUFBTSxLQUFLcWlCLFFBQVFyaUIsTUFBTSxJQUFJNkgsS0FBSzROLEtBQUssQ0FBQyxTQUFVeFUsQ0FBQyxFQUFFaEIsQ0FBQztZQUNoRSxPQUFPZ0IsTUFBTW9oQixPQUFPLENBQUNwaUIsRUFBRTtRQUN6QjtJQUNGO0lBRUE7O0dBRUMsR0FDRDhnQixhQUFhLFNBQVNBLFlBQVlsWixJQUFJO1FBQ3BDLE9BQU9BLElBQUksQ0FBQ0EsS0FBSzdILE1BQU0sR0FBRyxFQUFFLEdBQUc7SUFDakM7SUFFQTs7R0FFQyxHQUNEc2pCLFNBQVMsU0FBU0EsUUFBUXpiLElBQUksRUFBRXdhLE9BQU87UUFDckMsT0FBT3JhLEtBQUtrVSxPQUFPLENBQUNyVSxNQUFNd2EsYUFBYTtJQUN6QztJQUVBOztHQUVDLEdBQ0Q5TSxZQUFZLFNBQVNBLFdBQVcxTixJQUFJLEVBQUV3YSxPQUFPO1FBQzNDLE9BQU94YSxLQUFLN0gsTUFBTSxHQUFHcWlCLFFBQVFyaUIsTUFBTSxJQUFJZ0ksS0FBS2tVLE9BQU8sQ0FBQ3JVLE1BQU13YSxhQUFhO0lBQ3pFO0lBRUE7O0dBRUMsR0FDRGhCLFVBQVUsU0FBU0EsU0FBU3haLElBQUksRUFBRXdhLE9BQU87UUFDdkMsT0FBT3JhLEtBQUtrVSxPQUFPLENBQUNyVSxNQUFNd2EsYUFBYSxDQUFDO0lBQzFDO0lBRUE7O0dBRUMsR0FDRDhDLFNBQVMsU0FBU0EsUUFBUXRkLElBQUksRUFBRXdhLE9BQU87UUFDckMsT0FBT3hhLEtBQUs3SCxNQUFNLEtBQUtxaUIsUUFBUXJpQixNQUFNLEdBQUcsS0FBS2dJLEtBQUtrVSxPQUFPLENBQUNyVSxNQUFNd2EsYUFBYTtJQUMvRTtJQUVBOztHQUVDLEdBQ0QrQyxVQUFVLFNBQVNBLFNBQVN2ZCxJQUFJLEVBQUV3YSxPQUFPO1FBQ3ZDLE9BQU94YSxLQUFLN0gsTUFBTSxJQUFJcWlCLFFBQVFyaUIsTUFBTSxJQUFJZ0ksS0FBS2tVLE9BQU8sQ0FBQ3JVLE1BQU13YSxhQUFhO0lBQzFFO0lBRUE7O0dBRUMsR0FDRGdELGNBQWMsU0FBU0EsYUFBYXhkLElBQUksRUFBRXdhLE9BQU87UUFDL0MsT0FBT3hhLEtBQUs3SCxNQUFNLEdBQUdxaUIsUUFBUXJpQixNQUFNLElBQUlnSSxLQUFLa1UsT0FBTyxDQUFDclUsTUFBTXdhLGFBQWE7SUFDekU7SUFFQTs7R0FFQyxHQUNEaUQsVUFBVSxTQUFTQSxTQUFTemQsSUFBSSxFQUFFd2EsT0FBTztRQUN2QyxPQUFPeGEsS0FBSzdILE1BQU0sR0FBRyxNQUFNcWlCLFFBQVFyaUIsTUFBTSxJQUFJZ0ksS0FBS2tVLE9BQU8sQ0FBQ3JVLE1BQU13YSxhQUFhO0lBQy9FO0lBRUE7O0dBRUMsR0FDRHBILFFBQVEsU0FBU0EsT0FBT2xjLEtBQUs7UUFDM0IsT0FBT29CLE1BQU1HLE9BQU8sQ0FBQ3ZCLFVBQVdBLENBQUFBLE1BQU1pQixNQUFNLEtBQUssS0FBSyxPQUFPakIsS0FBSyxDQUFDLEVBQUUsS0FBSyxRQUFPO0lBQ25GO0lBRUE7O0dBRUMsR0FDRHNsQixXQUFXLFNBQVNBLFVBQVV4YyxJQUFJLEVBQUV3YSxPQUFPO1FBQ3pDLElBQUl4YSxLQUFLN0gsTUFBTSxLQUFLcWlCLFFBQVFyaUIsTUFBTSxFQUFFO1lBQ2xDLE9BQU87UUFDVDtRQUVBLElBQUkra0IsS0FBS2xkLEtBQUsxRyxLQUFLLENBQUMsR0FBRyxDQUFDO1FBQ3hCLElBQUk2akIsS0FBSzNDLFFBQVFsaEIsS0FBSyxDQUFDLEdBQUcsQ0FBQztRQUMzQixJQUFJb2tCLEtBQUsxZCxJQUFJLENBQUNBLEtBQUs3SCxNQUFNLEdBQUcsRUFBRTtRQUM5QixJQUFJd2xCLEtBQUtuRCxPQUFPLENBQUNBLFFBQVFyaUIsTUFBTSxHQUFHLEVBQUU7UUFDcEMsT0FBT3VsQixPQUFPQyxNQUFNeGQsS0FBSzZFLE1BQU0sQ0FBQ2tZLElBQUlDO0lBQ3RDO0lBRUE7Ozs7OztHQU1DLEdBQ0R4WCxRQUFRLFNBQVNBLE9BQU8zRixJQUFJO1FBQzFCLElBQUk4TyxVQUFVblMsVUFBVXhFLE1BQU0sR0FBRyxLQUFLd0UsU0FBUyxDQUFDLEVBQUUsS0FBS2tNLFlBQVlsTSxTQUFTLENBQUMsRUFBRSxHQUFHLENBQUM7UUFDbkYsSUFBSWlYLG9CQUFvQjlFLFFBQVFoTSxPQUFPLEVBQ25DQSxVQUFVOFEsc0JBQXNCLEtBQUssSUFBSSxRQUFRQTtRQUNyRCxJQUFJZ0ssT0FBTyxFQUFFO1FBRWIsSUFBSyxJQUFJeGxCLElBQUksR0FBR0EsS0FBSzRILEtBQUs3SCxNQUFNLEVBQUVDLElBQUs7WUFDckN3bEIsS0FBSzNpQixJQUFJLENBQUMrRSxLQUFLMUcsS0FBSyxDQUFDLEdBQUdsQjtRQUMxQjtRQUVBLElBQUkwSyxTQUFTO1lBQ1g4YSxLQUFLOWEsT0FBTztRQUNkO1FBRUEsT0FBTzhhO0lBQ1Q7SUFFQTs7R0FFQyxHQUNEN2lCLE1BQU0sU0FBU0EsS0FBS2lGLElBQUk7UUFDdEIsSUFBSUEsS0FBSzdILE1BQU0sS0FBSyxHQUFHO1lBQ3JCLE1BQU0sSUFBSTBQLE1BQU0sNENBQTRDeEQsTUFBTSxDQUFDckUsTUFBTTtRQUMzRTtRQUVBLElBQUlzUixPQUFPdFIsSUFBSSxDQUFDQSxLQUFLN0gsTUFBTSxHQUFHLEVBQUU7UUFDaEMsT0FBTzZILEtBQUsxRyxLQUFLLENBQUMsR0FBRyxDQUFDLEdBQUcrSyxNQUFNLENBQUNpTixPQUFPO0lBQ3pDO0lBRUE7Ozs7OztHQU1DLEdBQ0RsUiwyQkFBMkIsU0FBU0EsMEJBQTBCWSxTQUFTO1FBQ3JFLE9BQVFBLFVBQVVDLElBQUk7WUFDcEIsS0FBSztZQUNMLEtBQUs7WUFDTCxLQUFLO1lBQ0wsS0FBSztZQUNMLEtBQUs7Z0JBQ0gsT0FBTztZQUVUO2dCQUNFLE9BQU87UUFDWDtJQUNGO0lBRUE7O0dBRUMsR0FDRFUsUUFBUSxTQUFTQSxPQUFPM0IsSUFBSTtRQUMxQixJQUFJQSxLQUFLN0gsTUFBTSxLQUFLLEdBQUc7WUFDckIsTUFBTSxJQUFJMFAsTUFBTSxnREFBZ0R4RCxNQUFNLENBQUNyRSxNQUFNO1FBQy9FO1FBRUEsT0FBT0EsS0FBSzFHLEtBQUssQ0FBQyxHQUFHLENBQUM7SUFDeEI7SUFFQTs7R0FFQyxHQUNEK00sVUFBVSxTQUFTQSxTQUFTckcsSUFBSTtRQUM5QixJQUFJQSxLQUFLN0gsTUFBTSxLQUFLLEdBQUc7WUFDckIsTUFBTSxJQUFJMFAsTUFBTSxnREFBZ0R4RCxNQUFNLENBQUNyRSxNQUFNO1FBQy9FO1FBRUEsSUFBSXNSLE9BQU90UixJQUFJLENBQUNBLEtBQUs3SCxNQUFNLEdBQUcsRUFBRTtRQUVoQyxJQUFJbVosUUFBUSxHQUFHO1lBQ2IsTUFBTSxJQUFJekosTUFBTSx1REFBdUR4RCxNQUFNLENBQUNyRSxNQUFNO1FBQ3RGO1FBRUEsT0FBT0EsS0FBSzFHLEtBQUssQ0FBQyxHQUFHLENBQUMsR0FBRytLLE1BQU0sQ0FBQ2lOLE9BQU87SUFDekM7SUFFQTs7R0FFQyxHQUNEdU0sVUFBVSxTQUFTQSxTQUFTN2QsSUFBSSxFQUFFMkcsUUFBUTtRQUN4QyxJQUFJLENBQUN4RyxLQUFLdU4sVUFBVSxDQUFDL0csVUFBVTNHLFNBQVMsQ0FBQ0csS0FBSzZFLE1BQU0sQ0FBQ2hGLE1BQU0yRyxXQUFXO1lBQ3BFLE1BQU0sSUFBSWtCLE1BQU0sb0NBQW9DeEQsTUFBTSxDQUFDckUsTUFBTSx1QkFBdUJxRSxNQUFNLENBQUNzQyxVQUFVO1FBQzNHO1FBRUEsT0FBTzNHLEtBQUsxRyxLQUFLLENBQUNxTixTQUFTeE8sTUFBTTtJQUNuQztJQUVBOztHQUVDLEdBQ0QyRyxXQUFXLFNBQVNBLFVBQVVrQixJQUFJLEVBQUVnQixTQUFTO1FBQzNDLElBQUk4TixVQUFVblMsVUFBVXhFLE1BQU0sR0FBRyxLQUFLd0UsU0FBUyxDQUFDLEVBQUUsS0FBS2tNLFlBQVlsTSxTQUFTLENBQUMsRUFBRSxHQUFHLENBQUM7UUFDbkYsSUFBSSxDQUFDcUQsTUFBTSxPQUFPLE1BQU0seUNBQXlDO1FBRWpFLElBQUlpRyxJQUFJbk0sbUJBQW1Ca0c7UUFFM0IsSUFBSWdXLG9CQUFvQmxILFFBQVFtSCxRQUFRLEVBQ3BDQSxXQUFXRCxzQkFBc0IsS0FBSyxJQUFJLFlBQVlBLG1CQUFtQix5RUFBeUU7UUFFdEosSUFBSWhXLEtBQUs3SCxNQUFNLEtBQUssR0FBRztZQUNyQixPQUFPOE47UUFDVDtRQUVBLE9BQVFqRixVQUFVQyxJQUFJO1lBQ3BCLEtBQUs7Z0JBQ0g7b0JBQ0UsSUFBSTFDLEtBQUt5QyxVQUFVaEIsSUFBSTtvQkFFdkIsSUFBSUcsS0FBSzZFLE1BQU0sQ0FBQ3pHLElBQUkwSCxNQUFNOUYsS0FBS2tkLFVBQVUsQ0FBQzllLElBQUkwSCxNQUFNOUYsS0FBS3VOLFVBQVUsQ0FBQ25QLElBQUkwSCxJQUFJO3dCQUMxRUEsQ0FBQyxDQUFDMUgsR0FBR3BHLE1BQU0sR0FBRyxFQUFFLElBQUk7b0JBQ3RCO29CQUVBO2dCQUNGO1lBRUYsS0FBSztnQkFDSDtvQkFDRSxJQUFJMmxCLE1BQU05YyxVQUFVaEIsSUFBSTtvQkFFeEIsSUFBSUcsS0FBSzZFLE1BQU0sQ0FBQzhZLEtBQUs3WCxNQUFNOUYsS0FBS3VOLFVBQVUsQ0FBQ29RLEtBQUs3WCxJQUFJO3dCQUNsRCxPQUFPO29CQUNULE9BQU8sSUFBSTlGLEtBQUtrZCxVQUFVLENBQUNTLEtBQUs3WCxJQUFJO3dCQUNsQ0EsQ0FBQyxDQUFDNlgsSUFBSTNsQixNQUFNLEdBQUcsRUFBRSxJQUFJO29CQUN2QjtvQkFFQTtnQkFDRjtZQUVGLEtBQUs7Z0JBQ0g7b0JBQ0UsSUFBSTRsQixPQUFPL2MsVUFBVWhCLElBQUksRUFDckJtYyxXQUFXbmIsVUFBVW1iLFFBQVE7b0JBRWpDLElBQUloYyxLQUFLNkUsTUFBTSxDQUFDK1ksTUFBTTlYLE1BQU05RixLQUFLa2QsVUFBVSxDQUFDVSxNQUFNOVgsSUFBSTt3QkFDcERBLENBQUMsQ0FBQzhYLEtBQUs1bEIsTUFBTSxHQUFHLEVBQUUsSUFBSTtvQkFDeEIsT0FBTyxJQUFJZ0ksS0FBS3VOLFVBQVUsQ0FBQ3FRLE1BQU05WCxJQUFJO3dCQUNuQ0EsQ0FBQyxDQUFDOFgsS0FBSzVsQixNQUFNLEdBQUcsRUFBRSxJQUFJO3dCQUN0QjhOLENBQUMsQ0FBQzhYLEtBQUs1bEIsTUFBTSxDQUFDLElBQUlna0I7b0JBQ3BCO29CQUVBO2dCQUNGO1lBRUYsS0FBSztnQkFDSDtvQkFDRSxJQUFJNkIsT0FBT2hkLFVBQVVoQixJQUFJLEVBQ3JCaWUsWUFBWWpkLFVBQVVtYixRQUFRO29CQUVsQyxJQUFJaGMsS0FBSzZFLE1BQU0sQ0FBQ2daLE1BQU0vWCxJQUFJO3dCQUN4QixJQUFJZ1EsYUFBYSxXQUFXOzRCQUMxQmhRLENBQUMsQ0FBQ0EsRUFBRTlOLE1BQU0sR0FBRyxFQUFFLElBQUk7d0JBQ3JCLE9BQU8sSUFBSThkLGFBQWE7NkJBQW1COzRCQUN6QyxPQUFPO3dCQUNUO29CQUNGLE9BQU8sSUFBSTlWLEtBQUtrZCxVQUFVLENBQUNXLE1BQU0vWCxJQUFJO3dCQUNuQ0EsQ0FBQyxDQUFDK1gsS0FBSzdsQixNQUFNLEdBQUcsRUFBRSxJQUFJO29CQUN4QixPQUFPLElBQUlnSSxLQUFLdU4sVUFBVSxDQUFDc1EsTUFBTS9YLE1BQU1qRyxJQUFJLENBQUNnZSxLQUFLN2xCLE1BQU0sQ0FBQyxJQUFJOGxCLFdBQVc7d0JBQ3JFaFksQ0FBQyxDQUFDK1gsS0FBSzdsQixNQUFNLEdBQUcsRUFBRSxJQUFJO3dCQUN0QjhOLENBQUMsQ0FBQytYLEtBQUs3bEIsTUFBTSxDQUFDLElBQUk4bEI7b0JBQ3BCO29CQUVBO2dCQUNGO1lBRUYsS0FBSztnQkFDSDtvQkFDRSxJQUFJQyxPQUFPbGQsVUFBVWhCLElBQUksRUFDckJtZSxNQUFNbmQsVUFBVVQsT0FBTyxFQUFFLHNEQUFzRDtvQkFFbkYsSUFBSUosS0FBSzZFLE1BQU0sQ0FBQ2taLE1BQU1DLE1BQU07d0JBQzFCLE9BQU9sWTtvQkFDVDtvQkFFQSxJQUFJOUYsS0FBS3VOLFVBQVUsQ0FBQ3dRLE1BQU1qWSxNQUFNOUYsS0FBSzZFLE1BQU0sQ0FBQ2taLE1BQU1qWSxJQUFJO3dCQUNwRCxJQUFJbVksT0FBT0QsSUFBSTdrQixLQUFLO3dCQUVwQixJQUFJNkcsS0FBS2tkLFVBQVUsQ0FBQ2EsTUFBTUMsUUFBUUQsS0FBSy9sQixNQUFNLEdBQUdnbUIsSUFBSWhtQixNQUFNLEVBQUU7NEJBQzFEaW1CLElBQUksQ0FBQ0YsS0FBSy9sQixNQUFNLEdBQUcsRUFBRSxJQUFJO3dCQUMzQjt3QkFFQSxPQUFPaW1CLEtBQUsvWixNQUFNLENBQUM0QixFQUFFM00sS0FBSyxDQUFDNGtCLEtBQUsvbEIsTUFBTTtvQkFDeEMsT0FBTyxJQUFJZ0ksS0FBS3FjLFNBQVMsQ0FBQzBCLE1BQU1DLFFBQVNoZSxDQUFBQSxLQUFLdU4sVUFBVSxDQUFDeVEsS0FBS2xZLE1BQU05RixLQUFLNkUsTUFBTSxDQUFDbVosS0FBS2xZLEVBQUMsR0FBSTt3QkFDeEYsSUFBSTlGLEtBQUtrZCxVQUFVLENBQUNhLE1BQU1qWSxJQUFJOzRCQUM1QkEsQ0FBQyxDQUFDaVksS0FBSy9sQixNQUFNLEdBQUcsRUFBRSxJQUFJO3dCQUN4QixPQUFPOzRCQUNMOE4sQ0FBQyxDQUFDaVksS0FBSy9sQixNQUFNLEdBQUcsRUFBRSxJQUFJO3dCQUN4QjtvQkFDRixPQUFPLElBQUlnSSxLQUFLa2QsVUFBVSxDQUFDYyxLQUFLbFksTUFBTTlGLEtBQUs2RSxNQUFNLENBQUNtWixLQUFLbFksTUFBTTlGLEtBQUt1TixVQUFVLENBQUN5USxLQUFLbFksSUFBSTt3QkFDcEYsSUFBSTlGLEtBQUtrZCxVQUFVLENBQUNhLE1BQU1qWSxJQUFJOzRCQUM1QkEsQ0FBQyxDQUFDaVksS0FBSy9sQixNQUFNLEdBQUcsRUFBRSxJQUFJO3dCQUN4Qjt3QkFFQThOLENBQUMsQ0FBQ2tZLElBQUlobUIsTUFBTSxHQUFHLEVBQUUsSUFBSTtvQkFDdkIsT0FBTyxJQUFJZ0ksS0FBS2tkLFVBQVUsQ0FBQ2EsTUFBTWpZLElBQUk7d0JBQ25DLElBQUk5RixLQUFLNkUsTUFBTSxDQUFDbVosS0FBS2xZLElBQUk7NEJBQ3ZCQSxDQUFDLENBQUNrWSxJQUFJaG1CLE1BQU0sR0FBRyxFQUFFLElBQUk7d0JBQ3ZCO3dCQUVBOE4sQ0FBQyxDQUFDaVksS0FBSy9sQixNQUFNLEdBQUcsRUFBRSxJQUFJO29CQUN4QjtvQkFFQTtnQkFDRjtRQUNKO1FBRUEsT0FBTzhOO0lBQ1Q7QUFDRjtBQUVBLElBQUlwSCxVQUFVO0lBQ1o7O0dBRUMsR0FDREMsV0FBVyxTQUFTQSxVQUFVRixHQUFHLEVBQUVMLEVBQUU7UUFDbkMsSUFBSTJYLFVBQVV0WCxJQUFJc1gsT0FBTyxFQUNyQkQsV0FBV3JYLElBQUlxWCxRQUFRO1FBRTNCLElBQUlDLFdBQVcsTUFBTTtZQUNuQjtRQUNGO1FBRUEsSUFBSWxXLE9BQU9HLEtBQUtyQixTQUFTLENBQUNvWCxTQUFTM1gsSUFBSTtZQUNyQzBYLFVBQVVBO1FBQ1o7UUFDQXJYLElBQUlzWCxPQUFPLEdBQUdsVztRQUVkLElBQUlBLFFBQVEsTUFBTTtZQUNoQnBCLElBQUl1WCxLQUFLO1FBQ1g7SUFDRjtBQUNGO0FBRUEsU0FBU2tJLFVBQVVyaUIsTUFBTSxFQUFFQyxjQUFjO0lBQUksSUFBSUMsT0FBT25GLE9BQU9tRixJQUFJLENBQUNGO0lBQVMsSUFBSWpGLE9BQU9vRixxQkFBcUIsRUFBRTtRQUFFLElBQUlDLFVBQVVyRixPQUFPb0YscUJBQXFCLENBQUNIO1FBQVMsSUFBSUMsZ0JBQWdCO1lBQUVHLFVBQVVBLFFBQVFDLE1BQU0sQ0FBQyxTQUFVQyxHQUFHO2dCQUFJLE9BQU92RixPQUFPd0Ysd0JBQXdCLENBQUNQLFFBQVFNLEtBQUtwQyxVQUFVO1lBQUU7UUFBSTtRQUFFZ0MsS0FBS2pCLElBQUksQ0FBQ3VCLEtBQUssQ0FBQ04sTUFBTUU7SUFBVTtJQUFFLE9BQU9GO0FBQU07QUFFMVYsU0FBU29pQixnQkFBZ0I1aEIsTUFBTTtJQUFJLElBQUssSUFBSXRFLElBQUksR0FBR0EsSUFBSXVFLFVBQVV4RSxNQUFNLEVBQUVDLElBQUs7UUFBRSxJQUFJd0UsU0FBU0QsU0FBUyxDQUFDdkUsRUFBRSxJQUFJLE9BQU91RSxTQUFTLENBQUN2RSxFQUFFLEdBQUcsQ0FBQztRQUFHLElBQUlBLElBQUksR0FBRztZQUFFaW1CLFVBQVV0bkIsT0FBTzZGLFNBQVMsTUFBTUMsT0FBTyxDQUFDLFNBQVU1QyxHQUFHO2dCQUFJRixnQkFBZ0IyQyxRQUFRekMsS0FBSzJDLE1BQU0sQ0FBQzNDLElBQUk7WUFBRztRQUFJLE9BQU8sSUFBSWxELE9BQU8rRix5QkFBeUIsRUFBRTtZQUFFL0YsT0FBT2dHLGdCQUFnQixDQUFDTCxRQUFRM0YsT0FBTytGLHlCQUF5QixDQUFDRjtRQUFVLE9BQU87WUFBRXloQixVQUFVdG5CLE9BQU82RixTQUFTQyxPQUFPLENBQUMsU0FBVTVDLEdBQUc7Z0JBQUlsRCxPQUFPQyxjQUFjLENBQUMwRixRQUFRekMsS0FBS2xELE9BQU93Rix3QkFBd0IsQ0FBQ0ssUUFBUTNDO1lBQU87UUFBSTtJQUFFO0lBQUUsT0FBT3lDO0FBQVE7QUFFM2hCLElBQUlxVSxRQUFRO0lBQ1Y7OztHQUdDLEdBQ0RzRCxTQUFTLFNBQVNBLFFBQVE3RSxLQUFLLEVBQUVnTCxPQUFPO1FBQ3RDLElBQUkrRCxTQUFTcGUsS0FBS2tVLE9BQU8sQ0FBQzdFLE1BQU14UCxJQUFJLEVBQUV3YSxRQUFReGEsSUFBSTtRQUVsRCxJQUFJdWUsV0FBVyxHQUFHO1lBQ2hCLElBQUkvTyxNQUFNNkIsTUFBTSxHQUFHbUosUUFBUW5KLE1BQU0sRUFBRSxPQUFPLENBQUM7WUFDM0MsSUFBSTdCLE1BQU02QixNQUFNLEdBQUdtSixRQUFRbkosTUFBTSxFQUFFLE9BQU87WUFDMUMsT0FBTztRQUNUO1FBRUEsT0FBT2tOO0lBQ1Q7SUFFQTs7R0FFQyxHQUNEOUMsU0FBUyxTQUFTQSxRQUFRak0sS0FBSyxFQUFFZ0wsT0FBTztRQUN0QyxPQUFPekosTUFBTXNELE9BQU8sQ0FBQzdFLE9BQU9nTCxhQUFhO0lBQzNDO0lBRUE7O0dBRUMsR0FDRGhCLFVBQVUsU0FBU0EsU0FBU2hLLEtBQUssRUFBRWdMLE9BQU87UUFDeEMsT0FBT3pKLE1BQU1zRCxPQUFPLENBQUM3RSxPQUFPZ0wsYUFBYSxDQUFDO0lBQzVDO0lBRUE7O0dBRUMsR0FDRHhWLFFBQVEsU0FBU0EsT0FBT3dLLEtBQUssRUFBRWdMLE9BQU87UUFDcEMsNEVBQTRFO1FBQzVFLE9BQU9oTCxNQUFNNkIsTUFBTSxLQUFLbUosUUFBUW5KLE1BQU0sSUFBSWxSLEtBQUs2RSxNQUFNLENBQUN3SyxNQUFNeFAsSUFBSSxFQUFFd2EsUUFBUXhhLElBQUk7SUFDaEY7SUFFQTs7R0FFQyxHQUNENlYsU0FBUyxTQUFTQSxRQUFRM2UsS0FBSztRQUM3QixPQUFPQyxjQUFjQSxhQUFhLENBQUNELFVBQVUsT0FBT0EsTUFBTW1hLE1BQU0sS0FBSyxZQUFZbFIsS0FBS2lULE1BQU0sQ0FBQ2xjLE1BQU04SSxJQUFJO0lBQ3pHO0lBRUE7O0dBRUMsR0FDRGxCLFdBQVcsU0FBU0EsVUFBVTBRLEtBQUssRUFBRWpSLEVBQUU7UUFDckMsSUFBSXVRLFVBQVVuUyxVQUFVeEUsTUFBTSxHQUFHLEtBQUt3RSxTQUFTLENBQUMsRUFBRSxLQUFLa00sWUFBWWxNLFNBQVMsQ0FBQyxFQUFFLEdBQUcsQ0FBQztRQUNuRixPQUFPdEYsTUFBTTRqQixPQUFPLENBQUN6TCxPQUFPLFNBQVV2SixDQUFDO1lBQ3JDLElBQUlBLE1BQU0sTUFBTTtnQkFDZCxPQUFPO1lBQ1Q7WUFFQSxJQUFJK1Asb0JBQW9CbEgsUUFBUW1ILFFBQVEsRUFDcENBLFdBQVdELHNCQUFzQixLQUFLLElBQUksWUFBWUE7WUFDMUQsSUFBSWhXLE9BQU9pRyxFQUFFakcsSUFBSSxFQUNicVIsU0FBU3BMLEVBQUVvTCxNQUFNO1lBRXJCLE9BQVE5UyxHQUFHMEMsSUFBSTtnQkFDYixLQUFLO2dCQUNMLEtBQUs7b0JBQ0g7d0JBQ0VnRixFQUFFakcsSUFBSSxHQUFHRyxLQUFLckIsU0FBUyxDQUFDa0IsTUFBTXpCLElBQUl1UTt3QkFDbEM7b0JBQ0Y7Z0JBRUYsS0FBSztvQkFDSDt3QkFDRSxJQUFJM08sS0FBSzZFLE1BQU0sQ0FBQ3pHLEdBQUd5QixJQUFJLEVBQUVBLFNBQVV6QixDQUFBQSxHQUFHOFMsTUFBTSxHQUFHQSxVQUFVOVMsR0FBRzhTLE1BQU0sS0FBS0EsVUFBVTRFLGFBQWEsU0FBUSxHQUFJOzRCQUN4R2hRLEVBQUVvTCxNQUFNLElBQUk5UyxHQUFHc0YsSUFBSSxDQUFDMUwsTUFBTTt3QkFDNUI7d0JBRUE7b0JBQ0Y7Z0JBRUYsS0FBSztvQkFDSDt3QkFDRSxJQUFJZ0ksS0FBSzZFLE1BQU0sQ0FBQ3pHLEdBQUd5QixJQUFJLEVBQUVBLE9BQU87NEJBQzlCaUcsRUFBRW9MLE1BQU0sSUFBSTlTLEdBQUc0ZCxRQUFRO3dCQUN6Qjt3QkFFQWxXLEVBQUVqRyxJQUFJLEdBQUdHLEtBQUtyQixTQUFTLENBQUNrQixNQUFNekIsSUFBSXVRO3dCQUNsQztvQkFDRjtnQkFFRixLQUFLO29CQUNIO3dCQUNFLElBQUkzTyxLQUFLNkUsTUFBTSxDQUFDekcsR0FBR3lCLElBQUksRUFBRUEsU0FBU3pCLEdBQUc4UyxNQUFNLElBQUlBLFFBQVE7NEJBQ3JEcEwsRUFBRW9MLE1BQU0sSUFBSTJMLEtBQUtELEdBQUcsQ0FBQzFMLFNBQVM5UyxHQUFHOFMsTUFBTSxFQUFFOVMsR0FBR3NGLElBQUksQ0FBQzFMLE1BQU07d0JBQ3pEO3dCQUVBO29CQUNGO2dCQUVGLEtBQUs7b0JBQ0g7d0JBQ0UsSUFBSWdJLEtBQUs2RSxNQUFNLENBQUN6RyxHQUFHeUIsSUFBSSxFQUFFQSxTQUFTRyxLQUFLdU4sVUFBVSxDQUFDblAsR0FBR3lCLElBQUksRUFBRUEsT0FBTzs0QkFDaEUsT0FBTzt3QkFDVDt3QkFFQWlHLEVBQUVqRyxJQUFJLEdBQUdHLEtBQUtyQixTQUFTLENBQUNrQixNQUFNekIsSUFBSXVRO3dCQUNsQztvQkFDRjtnQkFFRixLQUFLO29CQUNIO3dCQUNFLElBQUkzTyxLQUFLNkUsTUFBTSxDQUFDekcsR0FBR3lCLElBQUksRUFBRUEsT0FBTzs0QkFDOUIsSUFBSXpCLEdBQUc0ZCxRQUFRLEtBQUs5SyxVQUFVNEUsWUFBWSxNQUFNO2dDQUM5QyxPQUFPOzRCQUNULE9BQU8sSUFBSTFYLEdBQUc0ZCxRQUFRLEdBQUc5SyxVQUFVOVMsR0FBRzRkLFFBQVEsS0FBSzlLLFVBQVU0RSxhQUFhLFdBQVc7Z0NBQ25GaFEsRUFBRW9MLE1BQU0sSUFBSTlTLEdBQUc0ZCxRQUFRO2dDQUN2QmxXLEVBQUVqRyxJQUFJLEdBQUdHLEtBQUtyQixTQUFTLENBQUNrQixNQUFNekIsSUFBSStmLGdCQUFnQkEsZ0JBQWdCLENBQUMsR0FBR3hQLFVBQVUsQ0FBQyxHQUFHO29DQUNsRm1ILFVBQVU7Z0NBQ1o7NEJBQ0Y7d0JBQ0YsT0FBTzs0QkFDTGhRLEVBQUVqRyxJQUFJLEdBQUdHLEtBQUtyQixTQUFTLENBQUNrQixNQUFNekIsSUFBSXVRO3dCQUNwQzt3QkFFQTtvQkFDRjtZQUNKO1FBQ0Y7SUFDRjtBQUNGO0FBRUEsSUFBSTNQLFdBQVc7SUFDYjs7R0FFQyxHQUNETCxXQUFXLFNBQVNBLFVBQVVGLEdBQUcsRUFBRUwsRUFBRTtRQUNuQyxJQUFJMlgsVUFBVXRYLElBQUlzWCxPQUFPLEVBQ3JCRCxXQUFXclgsSUFBSXFYLFFBQVE7UUFFM0IsSUFBSUMsV0FBVyxNQUFNO1lBQ25CO1FBQ0Y7UUFFQSxJQUFJMUcsUUFBUXVCLE1BQU1qUyxTQUFTLENBQUNvWCxTQUFTM1gsSUFBSTtZQUN2QzBYLFVBQVVBO1FBQ1o7UUFDQXJYLElBQUlzWCxPQUFPLEdBQUcxRztRQUVkLElBQUlBLFNBQVMsTUFBTTtZQUNqQjVRLElBQUl1WCxLQUFLO1FBQ1g7SUFDRjtBQUNGO0FBRUEsSUFBSXFJLGNBQWM7SUFBQztJQUFVO0NBQVE7QUFFckMsU0FBU0MsVUFBVXppQixNQUFNLEVBQUVDLGNBQWM7SUFBSSxJQUFJQyxPQUFPbkYsT0FBT21GLElBQUksQ0FBQ0Y7SUFBUyxJQUFJakYsT0FBT29GLHFCQUFxQixFQUFFO1FBQUUsSUFBSUMsVUFBVXJGLE9BQU9vRixxQkFBcUIsQ0FBQ0g7UUFBUyxJQUFJQyxnQkFBZ0I7WUFBRUcsVUFBVUEsUUFBUUMsTUFBTSxDQUFDLFNBQVVDLEdBQUc7Z0JBQUksT0FBT3ZGLE9BQU93Rix3QkFBd0IsQ0FBQ1AsUUFBUU0sS0FBS3BDLFVBQVU7WUFBRTtRQUFJO1FBQUVnQyxLQUFLakIsSUFBSSxDQUFDdUIsS0FBSyxDQUFDTixNQUFNRTtJQUFVO0lBQUUsT0FBT0Y7QUFBTTtBQUUxVixTQUFTd2lCLGdCQUFnQmhpQixNQUFNO0lBQUksSUFBSyxJQUFJdEUsSUFBSSxHQUFHQSxJQUFJdUUsVUFBVXhFLE1BQU0sRUFBRUMsSUFBSztRQUFFLElBQUl3RSxTQUFTRCxTQUFTLENBQUN2RSxFQUFFLElBQUksT0FBT3VFLFNBQVMsQ0FBQ3ZFLEVBQUUsR0FBRyxDQUFDO1FBQUcsSUFBSUEsSUFBSSxHQUFHO1lBQUVxbUIsVUFBVTFuQixPQUFPNkYsU0FBUyxNQUFNQyxPQUFPLENBQUMsU0FBVTVDLEdBQUc7Z0JBQUlGLGdCQUFnQjJDLFFBQVF6QyxLQUFLMkMsTUFBTSxDQUFDM0MsSUFBSTtZQUFHO1FBQUksT0FBTyxJQUFJbEQsT0FBTytGLHlCQUF5QixFQUFFO1lBQUUvRixPQUFPZ0csZ0JBQWdCLENBQUNMLFFBQVEzRixPQUFPK0YseUJBQXlCLENBQUNGO1FBQVUsT0FBTztZQUFFNmhCLFVBQVUxbkIsT0FBTzZGLFNBQVNDLE9BQU8sQ0FBQyxTQUFVNUMsR0FBRztnQkFBSWxELE9BQU9DLGNBQWMsQ0FBQzBGLFFBQVF6QyxLQUFLbEQsT0FBT3dGLHdCQUF3QixDQUFDSyxRQUFRM0M7WUFBTztRQUFJO0lBQUU7SUFBRSxPQUFPeUM7QUFBUTtBQUUzaEIsSUFBSXFGLFFBQVE7SUFDVjs7O0dBR0MsR0FDRHFPLE9BQU8sU0FBU0EsTUFBTVYsS0FBSztRQUN6QixJQUFJWixVQUFVblMsVUFBVXhFLE1BQU0sR0FBRyxLQUFLd0UsU0FBUyxDQUFDLEVBQUUsS0FBS2tNLFlBQVlsTSxTQUFTLENBQUMsRUFBRSxHQUFHLENBQUM7UUFDbkYsSUFBSThVLG1CQUFtQjNDLFFBQVFoTSxPQUFPLEVBQ2xDQSxVQUFVMk8scUJBQXFCLEtBQUssSUFBSSxRQUFRQTtRQUNwRCxJQUFJcEMsU0FBU0ssTUFBTUwsTUFBTSxFQUNyQkMsUUFBUUksTUFBTUosS0FBSztRQUN2QixPQUFPdk4sTUFBTTRjLFVBQVUsQ0FBQ2pQLFdBQVc1TSxVQUFVO1lBQUN1TTtZQUFRQztTQUFNLEdBQUc7WUFBQ0E7WUFBT0Q7U0FBTztJQUNoRjtJQUVBOztHQUVDLEdBQ0QvRCxLQUFLLFNBQVNBLElBQUlvRSxLQUFLO1FBQ3JCLElBQUlnSCxlQUFlM1UsTUFBTXFPLEtBQUssQ0FBQ1YsUUFDM0JpSCxnQkFBZ0JyYixlQUFlb2IsY0FBYyxJQUM3Q3BMLE1BQU1xTCxhQUFhLENBQUMsRUFBRTtRQUUxQixPQUFPckw7SUFDVDtJQUVBOztHQUVDLEdBQ0R0RyxRQUFRLFNBQVNBLE9BQU8wSyxLQUFLLEVBQUU4SyxPQUFPO1FBQ3BDLE9BQU96SixNQUFNL0wsTUFBTSxDQUFDMEssTUFBTUwsTUFBTSxFQUFFbUwsUUFBUW5MLE1BQU0sS0FBSzBCLE1BQU0vTCxNQUFNLENBQUMwSyxNQUFNSixLQUFLLEVBQUVrTCxRQUFRbEwsS0FBSztJQUM5RjtJQUVBOztHQUVDLEdBQ0QrRCxVQUFVLFNBQVNBLFNBQVMzRCxLQUFLLEVBQUVoVCxNQUFNO1FBQ3ZDLElBQUlxRixNQUFNcU4sT0FBTyxDQUFDMVMsU0FBUztZQUN6QixJQUFJcUYsTUFBTXNSLFFBQVEsQ0FBQzNELE9BQU9oVCxPQUFPMlMsTUFBTSxLQUFLdE4sTUFBTXNSLFFBQVEsQ0FBQzNELE9BQU9oVCxPQUFPNFMsS0FBSyxHQUFHO2dCQUMvRSxPQUFPO1lBQ1Q7WUFFQSxJQUFJNEgsZ0JBQWdCblYsTUFBTXFPLEtBQUssQ0FBQ1YsUUFDNUJ5SCxnQkFBZ0I3YixlQUFlNGIsZUFBZSxJQUM5QzBILEtBQUt6SCxhQUFhLENBQUMsRUFBRSxFQUNyQjBILEtBQUsxSCxhQUFhLENBQUMsRUFBRTtZQUV6QixJQUFJcUIsZ0JBQWdCelcsTUFBTXFPLEtBQUssQ0FBQzFULFNBQzVCK2IsZ0JBQWdCbmQsZUFBZWtkLGVBQWUsSUFDOUNzRyxLQUFLckcsYUFBYSxDQUFDLEVBQUUsRUFDckJzRyxLQUFLdEcsYUFBYSxDQUFDLEVBQUU7WUFFekIsT0FBTzFILE1BQU15SSxRQUFRLENBQUNvRixJQUFJRSxPQUFPL04sTUFBTTBLLE9BQU8sQ0FBQ29ELElBQUlFO1FBQ3JEO1FBRUEsSUFBSS9GLGdCQUFnQmpYLE1BQU1xTyxLQUFLLENBQUNWLFFBQzVCdUosZ0JBQWdCM2QsZUFBZTBkLGVBQWUsSUFDOUNqSixRQUFRa0osYUFBYSxDQUFDLEVBQUUsRUFDeEIzTixNQUFNMk4sYUFBYSxDQUFDLEVBQUU7UUFFMUIsSUFBSStGLGVBQWU7UUFDbkIsSUFBSUMsY0FBYztRQUVsQixJQUFJbE8sTUFBTThFLE9BQU8sQ0FBQ25aLFNBQVM7WUFDekJzaUIsZUFBZWpPLE1BQU1zRCxPQUFPLENBQUMzWCxRQUFRcVQsVUFBVTtZQUMvQ2tQLGNBQWNsTyxNQUFNc0QsT0FBTyxDQUFDM1gsUUFBUTRPLFFBQVE7UUFDOUMsT0FBTztZQUNMMFQsZUFBZTdlLEtBQUtrVSxPQUFPLENBQUMzWCxRQUFRcVQsTUFBTS9QLElBQUksS0FBSztZQUNuRGlmLGNBQWM5ZSxLQUFLa1UsT0FBTyxDQUFDM1gsUUFBUTRPLElBQUl0TCxJQUFJLEtBQUs7UUFDbEQ7UUFFQSxPQUFPZ2YsZ0JBQWdCQztJQUN6QjtJQUVBOztHQUVDLEdBQ0RDLGNBQWMsU0FBU0EsYUFBYXhQLEtBQUssRUFBRThLLE9BQU87UUFDaEQ5SyxNQUFNTCxNQUFNO1FBQ1JLLE1BQU1KLEtBQUs7UUFDWCxJQUFJcUQsT0FBT3ZLLHlCQUF5QnNILE9BQU84TztRQUUvQyxJQUFJVyxnQkFBZ0JwZCxNQUFNcU8sS0FBSyxDQUFDVixRQUM1QjBQLGlCQUFpQjlqQixlQUFlNmpCLGVBQWUsSUFDL0NFLEtBQUtELGNBQWMsQ0FBQyxFQUFFLEVBQ3RCRSxLQUFLRixjQUFjLENBQUMsRUFBRTtRQUUxQixJQUFJRyxpQkFBaUJ4ZCxNQUFNcU8sS0FBSyxDQUFDb0ssVUFDN0JnRixpQkFBaUJsa0IsZUFBZWlrQixnQkFBZ0IsSUFDaERFLEtBQUtELGNBQWMsQ0FBQyxFQUFFLEVBQ3RCRSxLQUFLRixjQUFjLENBQUMsRUFBRTtRQUUxQixJQUFJelAsUUFBUWdCLE1BQU15SSxRQUFRLENBQUM2RixJQUFJSSxNQUFNQSxLQUFLSjtRQUMxQyxJQUFJL1QsTUFBTXlGLE1BQU15SSxRQUFRLENBQUM4RixJQUFJSSxNQUFNSixLQUFLSTtRQUV4QyxJQUFJM08sTUFBTXlJLFFBQVEsQ0FBQ2xPLEtBQUt5RSxRQUFRO1lBQzlCLE9BQU87UUFDVCxPQUFPO1lBQ0wsT0FBTzJPLGdCQUFnQjtnQkFDckJyUCxRQUFRVTtnQkFDUlQsT0FBT2hFO1lBQ1QsR0FBR3FIO1FBQ0w7SUFDRjtJQUVBOzs7R0FHQyxHQUNEZ00sWUFBWSxTQUFTQSxXQUFXalAsS0FBSztRQUNuQyxJQUFJTCxTQUFTSyxNQUFNTCxNQUFNLEVBQ3JCQyxRQUFRSSxNQUFNSixLQUFLO1FBQ3ZCLE9BQU95QixNQUFNMEssT0FBTyxDQUFDcE0sUUFBUUM7SUFDL0I7SUFFQTs7O0dBR0MsR0FDRHpNLGFBQWEsU0FBU0EsWUFBWTZNLEtBQUs7UUFDckMsSUFBSUwsU0FBU0ssTUFBTUwsTUFBTSxFQUNyQkMsUUFBUUksTUFBTUosS0FBSztRQUN2QixPQUFPeUIsTUFBTS9MLE1BQU0sQ0FBQ3FLLFFBQVFDO0lBQzlCO0lBRUE7Ozs7R0FJQyxHQUNEdE4sWUFBWSxTQUFTQSxXQUFXME4sS0FBSztRQUNuQyxPQUFPLENBQUMzTixNQUFNYyxXQUFXLENBQUM2TTtJQUM1QjtJQUVBOzs7O0dBSUMsR0FDRGlRLFdBQVcsU0FBU0EsVUFBVWpRLEtBQUs7UUFDakMsT0FBTyxDQUFDM04sTUFBTTRjLFVBQVUsQ0FBQ2pQO0lBQzNCO0lBRUE7O0dBRUMsR0FDRE4sU0FBUyxTQUFTQSxRQUFRbFksS0FBSztRQUM3QixPQUFPQyxjQUFjQSxhQUFhLENBQUNELFVBQVU2WixNQUFNOEUsT0FBTyxDQUFDM2UsTUFBTW1ZLE1BQU0sS0FBSzBCLE1BQU04RSxPQUFPLENBQUMzZSxNQUFNb1ksS0FBSztJQUN2RztJQUVBOztHQUVDLEdBQ0RzUSxRQUFRLFVBQVVBLE9BQU9sUSxLQUFLO1FBQzVCLE1BQU07WUFBQ0EsTUFBTUwsTUFBTTtZQUFFO1NBQVM7UUFDOUIsTUFBTTtZQUFDSyxNQUFNSixLQUFLO1lBQUU7U0FBUTtJQUM5QjtJQUVBOztHQUVDLEdBQ0RTLE9BQU8sU0FBU0EsTUFBTUwsS0FBSztRQUN6QixJQUFJbVEsaUJBQWlCOWQsTUFBTXFPLEtBQUssQ0FBQ1YsUUFDN0JvUSxpQkFBaUJ4a0IsZUFBZXVrQixnQkFBZ0IsSUFDaEQ5UCxRQUFRK1AsY0FBYyxDQUFDLEVBQUU7UUFFN0IsT0FBTy9QO0lBQ1Q7SUFFQTs7R0FFQyxHQUNEalIsV0FBVyxTQUFTQSxVQUFVNFEsS0FBSyxFQUFFblIsRUFBRTtRQUNyQyxJQUFJdVEsVUFBVW5TLFVBQVV4RSxNQUFNLEdBQUcsS0FBS3dFLFNBQVMsQ0FBQyxFQUFFLEtBQUtrTSxZQUFZbE0sU0FBUyxDQUFDLEVBQUUsR0FBRyxDQUFDO1FBQ25GLE9BQU90RixNQUFNNGpCLE9BQU8sQ0FBQ3ZMLE9BQU8sU0FBVXJDLENBQUM7WUFDckMsSUFBSUEsTUFBTSxNQUFNO2dCQUNkLE9BQU87WUFDVDtZQUVBLElBQUkySSxvQkFBb0JsSCxRQUFRbUgsUUFBUSxFQUNwQ0EsV0FBV0Qsc0JBQXNCLEtBQUssSUFBSSxXQUFXQTtZQUN6RCxJQUFJK0o7WUFDSixJQUFJQztZQUVKLElBQUkvSixhQUFhLFVBQVU7Z0JBQ3pCLG1FQUFtRTtnQkFDbkUsd0VBQXdFO2dCQUN4RSxZQUFZO2dCQUNaLElBQUlwVCxjQUFjZCxNQUFNYyxXQUFXLENBQUN3SztnQkFFcEMsSUFBSXRMLE1BQU00ZCxTQUFTLENBQUN0UyxJQUFJO29CQUN0QjBTLGlCQUFpQjtvQkFDakJDLGdCQUFnQm5kLGNBQWNrZCxpQkFBaUI7Z0JBQ2pELE9BQU87b0JBQ0xBLGlCQUFpQjtvQkFDakJDLGdCQUFnQm5kLGNBQWNrZCxpQkFBaUI7Z0JBQ2pEO1lBQ0YsT0FBTyxJQUFJOUosYUFBYSxXQUFXO2dCQUNqQyxJQUFJbFUsTUFBTTRkLFNBQVMsQ0FBQ3RTLElBQUk7b0JBQ3RCMFMsaUJBQWlCO29CQUNqQkMsZ0JBQWdCO2dCQUNsQixPQUFPO29CQUNMRCxpQkFBaUI7b0JBQ2pCQyxnQkFBZ0I7Z0JBQ2xCO1lBQ0YsT0FBTztnQkFDTEQsaUJBQWlCOUo7Z0JBQ2pCK0osZ0JBQWdCL0o7WUFDbEI7WUFFQSxJQUFJNUcsU0FBUzBCLE1BQU1qUyxTQUFTLENBQUN1TyxFQUFFZ0MsTUFBTSxFQUFFOVEsSUFBSTtnQkFDekMwWCxVQUFVOEo7WUFDWjtZQUNBLElBQUl6USxRQUFReUIsTUFBTWpTLFNBQVMsQ0FBQ3VPLEVBQUVpQyxLQUFLLEVBQUUvUSxJQUFJO2dCQUN2QzBYLFVBQVUrSjtZQUNaO1lBRUEsSUFBSSxDQUFDM1EsVUFBVSxDQUFDQyxPQUFPO2dCQUNyQixPQUFPO1lBQ1Q7WUFFQWpDLEVBQUVnQyxNQUFNLEdBQUdBO1lBQ1hoQyxFQUFFaUMsS0FBSyxHQUFHQTtRQUNaO0lBQ0Y7QUFDRjtBQUVBLElBQUk5UCxXQUFXO0lBQ2I7O0dBRUMsR0FDRFYsV0FBVyxTQUFTQSxVQUFVRixHQUFHLEVBQUVMLEVBQUU7UUFDbkMsSUFBSTJYLFVBQVV0WCxJQUFJc1gsT0FBTyxFQUNyQkQsV0FBV3JYLElBQUlxWCxRQUFRO1FBRTNCLElBQUlDLFdBQVcsTUFBTTtZQUNuQjtRQUNGO1FBRUEsSUFBSWxXLE9BQU8rQixNQUFNakQsU0FBUyxDQUFDb1gsU0FBUzNYLElBQUk7WUFDdEMwWCxVQUFVQTtRQUNaO1FBQ0FyWCxJQUFJc1gsT0FBTyxHQUFHbFc7UUFFZCxJQUFJQSxRQUFRLE1BQU07WUFDaEJwQixJQUFJdVgsS0FBSztRQUNYO0lBQ0Y7QUFDRjtBQUVBLElBQUk4SixZQUFZcFg7QUFDaEI7Ozs7Ozs7Ozs7Ozs7O0NBY0MsR0FDRCx3Q0FBd0M7QUFFeEMsSUFBSXNSLFdBQVc7SUFDYitGLGFBQWEsU0FBU0EsWUFBWUMsUUFBUTtRQUN4Q0YsWUFBWUU7SUFDZDtJQUNBL0YsV0FBVyxTQUFTQSxVQUFVbGpCLEtBQUs7UUFDakMsT0FBT2twQixLQUFLaEcsU0FBUyxDQUFDbGpCLE9BQU8rb0I7SUFDL0I7QUFDRjtBQUVBOzs7Ozs7Ozs7Q0FTQyxHQUVELElBQUlJLGNBQWMsU0FBU0EsWUFBWTllLElBQUksRUFBRWlaLE9BQU87SUFDbEQsSUFBSyxJQUFJdmdCLE9BQU9zSCxLQUFNO1FBQ3BCLElBQUkrZSxJQUFJL2UsSUFBSSxDQUFDdEgsSUFBSTtRQUNqQixJQUFJc21CLElBQUkvRixPQUFPLENBQUN2Z0IsSUFBSTtRQUVwQixJQUFJOUMsY0FBY0EsYUFBYSxDQUFDbXBCLE1BQU1ucEIsY0FBY0EsYUFBYSxDQUFDb3BCLElBQUk7WUFDcEUsSUFBSSxDQUFDRixZQUFZQyxHQUFHQyxJQUFJLE9BQU87UUFDakMsT0FBTyxJQUFJam9CLE1BQU1HLE9BQU8sQ0FBQzZuQixNQUFNaG9CLE1BQU1HLE9BQU8sQ0FBQzhuQixJQUFJO1lBQy9DLElBQUlELEVBQUVub0IsTUFBTSxLQUFLb29CLEVBQUVwb0IsTUFBTSxFQUFFLE9BQU87WUFFbEMsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlrb0IsRUFBRW5vQixNQUFNLEVBQUVDLElBQUs7Z0JBQ2pDLElBQUlrb0IsQ0FBQyxDQUFDbG9CLEVBQUUsS0FBS21vQixDQUFDLENBQUNub0IsRUFBRSxFQUFFLE9BQU87WUFDNUI7UUFDRixPQUFPLElBQUlrb0IsTUFBTUMsR0FBRztZQUNsQixPQUFPO1FBQ1Q7SUFDRjtJQUNBOzs7O0VBSUEsR0FHQSxJQUFLLElBQUlDLFFBQVFoRyxRQUFTO1FBQ3hCLElBQUlqWixJQUFJLENBQUNpZixLQUFLLEtBQUszWCxhQUFhMlIsT0FBTyxDQUFDZ0csS0FBSyxLQUFLM1gsV0FBVztZQUMzRCxPQUFPO1FBQ1Q7SUFDRjtJQUVBLE9BQU87QUFDVDtBQUVBLElBQUk0WCxjQUFjO0lBQUM7Q0FBTyxFQUN0QkMsZUFBZTtJQUFDO0lBQVU7Q0FBUTtBQUV0QyxTQUFTQyw2QkFBNkJ6bkIsQ0FBQyxFQUFFK0QsY0FBYztJQUFJLElBQUlDLEtBQUssT0FBT3JFLFdBQVcsZUFBZUssQ0FBQyxDQUFDTCxPQUFPQyxRQUFRLENBQUMsSUFBSUksQ0FBQyxDQUFDLGFBQWE7SUFBRSxJQUFJLENBQUNnRSxJQUFJO1FBQUUsSUFBSTVFLE1BQU1HLE9BQU8sQ0FBQ1MsTUFBT2dFLENBQUFBLEtBQUswakIsOEJBQThCMW5CLEVBQUMsS0FBTStELGtCQUFrQi9ELEtBQUssT0FBT0EsRUFBRWYsTUFBTSxLQUFLLFVBQVU7WUFBRSxJQUFJK0UsSUFBSWhFLElBQUlnRTtZQUFJLElBQUk5RSxJQUFJO1lBQUcsSUFBSWdGLElBQUksU0FBU0EsS0FBSztZQUFHLE9BQU87Z0JBQUVDLEdBQUdEO2dCQUFHaEUsR0FBRyxTQUFTQTtvQkFBTSxJQUFJaEIsS0FBS2MsRUFBRWYsTUFBTSxFQUFFLE9BQU87d0JBQUU2QyxNQUFNO29CQUFLO29CQUFHLE9BQU87d0JBQUVBLE1BQU07d0JBQU85RCxPQUFPZ0MsQ0FBQyxDQUFDZCxJQUFJO29CQUFDO2dCQUFHO2dCQUFHa0YsR0FBRyxTQUFTQSxFQUFFeEMsRUFBRTtvQkFBSSxNQUFNQTtnQkFBSTtnQkFBR3lDLEdBQUdIO1lBQUU7UUFBRztRQUFFLE1BQU0sSUFBSXhELFVBQVU7SUFBMEk7SUFBRSxJQUFJNEQsbUJBQW1CLE1BQU1DLFNBQVMsT0FBT3ZDO0lBQUssT0FBTztRQUFFbUMsR0FBRyxTQUFTQTtZQUFNSCxLQUFLQSxHQUFHdkYsSUFBSSxDQUFDdUI7UUFBSTtRQUFHRSxHQUFHLFNBQVNBO1lBQU0sSUFBSXNFLE9BQU9SLEdBQUduQyxJQUFJO1lBQUl5QyxtQkFBbUJFLEtBQUsxQyxJQUFJO1lBQUUsT0FBTzBDO1FBQU07UUFBR0osR0FBRyxTQUFTQSxFQUFFSyxHQUFHO1lBQUlGLFNBQVM7WUFBTXZDLE1BQU15QztRQUFLO1FBQUdKLEdBQUcsU0FBU0E7WUFBTSxJQUFJO2dCQUFFLElBQUksQ0FBQ0Msb0JBQW9CTixFQUFFLENBQUMsU0FBUyxJQUFJLE1BQU1BLEVBQUUsQ0FBQyxTQUFTO1lBQUksU0FBVTtnQkFBRSxJQUFJTyxRQUFRLE1BQU12QztZQUFLO1FBQUU7SUFBRTtBQUFHO0FBRS8rQixTQUFTMGxCLDhCQUE4QjFuQixDQUFDLEVBQUVDLE1BQU07SUFBSSxJQUFJLENBQUNELEdBQUc7SUFBUSxJQUFJLE9BQU9BLE1BQU0sVUFBVSxPQUFPMm5CLG9CQUFvQjNuQixHQUFHQztJQUFTLElBQUlDLElBQUlyQyxPQUFPVSxTQUFTLENBQUM0QixRQUFRLENBQUMxQixJQUFJLENBQUN1QixHQUFHSSxLQUFLLENBQUMsR0FBRyxDQUFDO0lBQUksSUFBSUYsTUFBTSxZQUFZRixFQUFFSyxXQUFXLEVBQUVILElBQUlGLEVBQUVLLFdBQVcsQ0FBQ0MsSUFBSTtJQUFFLElBQUlKLE1BQU0sU0FBU0EsTUFBTSxPQUFPLE9BQU9kLE1BQU1TLElBQUksQ0FBQ0c7SUFBSSxJQUFJRSxNQUFNLGVBQWUsMkNBQTJDSyxJQUFJLENBQUNMLElBQUksT0FBT3luQixvQkFBb0IzbkIsR0FBR0M7QUFBUztBQUVyYSxTQUFTMG5CLG9CQUFvQjVvQixHQUFHLEVBQUVDLEdBQUc7SUFBSSxJQUFJQSxPQUFPLFFBQVFBLE1BQU1ELElBQUlFLE1BQU0sRUFBRUQsTUFBTUQsSUFBSUUsTUFBTTtJQUFFLElBQUssSUFBSUMsSUFBSSxHQUFHQyxPQUFPLElBQUlDLE1BQU1KLE1BQU1FLElBQUlGLEtBQUtFLElBQUs7UUFBRUMsSUFBSSxDQUFDRCxFQUFFLEdBQUdILEdBQUcsQ0FBQ0csRUFBRTtJQUFFO0lBQUUsT0FBT0M7QUFBTTtBQUV4TCxTQUFTeW9CLFVBQVU5a0IsTUFBTSxFQUFFQyxjQUFjO0lBQUksSUFBSUMsT0FBT25GLE9BQU9tRixJQUFJLENBQUNGO0lBQVMsSUFBSWpGLE9BQU9vRixxQkFBcUIsRUFBRTtRQUFFLElBQUlDLFVBQVVyRixPQUFPb0YscUJBQXFCLENBQUNIO1FBQVMsSUFBSUMsZ0JBQWdCO1lBQUVHLFVBQVVBLFFBQVFDLE1BQU0sQ0FBQyxTQUFVQyxHQUFHO2dCQUFJLE9BQU92RixPQUFPd0Ysd0JBQXdCLENBQUNQLFFBQVFNLEtBQUtwQyxVQUFVO1lBQUU7UUFBSTtRQUFFZ0MsS0FBS2pCLElBQUksQ0FBQ3VCLEtBQUssQ0FBQ04sTUFBTUU7SUFBVTtJQUFFLE9BQU9GO0FBQU07QUFFMVYsU0FBUzZrQixnQkFBZ0Jya0IsTUFBTTtJQUFJLElBQUssSUFBSXRFLElBQUksR0FBR0EsSUFBSXVFLFVBQVV4RSxNQUFNLEVBQUVDLElBQUs7UUFBRSxJQUFJd0UsU0FBU0QsU0FBUyxDQUFDdkUsRUFBRSxJQUFJLE9BQU91RSxTQUFTLENBQUN2RSxFQUFFLEdBQUcsQ0FBQztRQUFHLElBQUlBLElBQUksR0FBRztZQUFFMG9CLFVBQVUvcEIsT0FBTzZGLFNBQVMsTUFBTUMsT0FBTyxDQUFDLFNBQVU1QyxHQUFHO2dCQUFJRixnQkFBZ0IyQyxRQUFRekMsS0FBSzJDLE1BQU0sQ0FBQzNDLElBQUk7WUFBRztRQUFJLE9BQU8sSUFBSWxELE9BQU8rRix5QkFBeUIsRUFBRTtZQUFFL0YsT0FBT2dHLGdCQUFnQixDQUFDTCxRQUFRM0YsT0FBTytGLHlCQUF5QixDQUFDRjtRQUFVLE9BQU87WUFBRWtrQixVQUFVL3BCLE9BQU82RixTQUFTQyxPQUFPLENBQUMsU0FBVTVDLEdBQUc7Z0JBQUlsRCxPQUFPQyxjQUFjLENBQUMwRixRQUFRekMsS0FBS2xELE9BQU93Rix3QkFBd0IsQ0FBQ0ssUUFBUTNDO1lBQU87UUFBSTtJQUFFO0lBQUUsT0FBT3lDO0FBQVE7QUFFM2hCLElBQUk4RSxPQUFPO0lBQ1Q7Ozs7O0dBS0MsR0FDRHdELFFBQVEsU0FBU0EsT0FBT25CLElBQUksRUFBRTJXLE9BQU87UUFDbkMsSUFBSTFMLFVBQVVuUyxVQUFVeEUsTUFBTSxHQUFHLEtBQUt3RSxTQUFTLENBQUMsRUFBRSxLQUFLa00sWUFBWWxNLFNBQVMsQ0FBQyxFQUFFLEdBQUcsQ0FBQztRQUNuRixJQUFJcWtCLGlCQUFpQmxTLFFBQVE3SixLQUFLLEVBQzlCQSxRQUFRK2IsbUJBQW1CLEtBQUssSUFBSSxRQUFRQTtRQUVoRCxTQUFTQyxTQUFTam5CLEdBQUc7WUFDbkJBLElBQUk2SixJQUFJO1lBQ0osSUFBSThPLE9BQU92Syx5QkFBeUJwTyxLQUFLeW1CO1lBRTdDLE9BQU85TjtRQUNUO1FBRUEsT0FBTzBOLFlBQVlwYixRQUFRZ2MsU0FBU3BkLFFBQVFBLE1BQU1vQixRQUFRZ2MsU0FBU3pHLFdBQVdBO0lBQ2hGO0lBRUE7O0dBRUMsR0FDRC9ZLFFBQVEsU0FBU0EsT0FBT3ZLLEtBQUs7UUFDM0IsT0FBT0MsY0FBY0EsYUFBYSxDQUFDRCxVQUFVLE9BQU9BLE1BQU0yTSxJQUFJLEtBQUs7SUFDckU7SUFFQTs7R0FFQyxHQUNEcWQsWUFBWSxTQUFTQSxXQUFXaHFCLEtBQUs7UUFDbkMsT0FBT29CLE1BQU1HLE9BQU8sQ0FBQ3ZCLFVBQVVBLE1BQU0wVyxLQUFLLENBQUMsU0FBVUMsR0FBRztZQUN0RCxPQUFPck0sS0FBS0MsTUFBTSxDQUFDb007UUFDckI7SUFDRjtJQUVBOztHQUVDLEdBQ0R5TixhQUFhLFNBQVNBLFlBQVl2TixLQUFLO1FBQ3JDLE9BQU9BLE1BQU1sSyxJQUFJLEtBQUtnRjtJQUN4QjtJQUVBOzs7OztHQUtDLEdBQ0RzRixTQUFTLFNBQVNBLFFBQVF0SyxJQUFJLEVBQUVrSyxLQUFLO1FBQ25DLElBQUssSUFBSTlULE9BQU84VCxNQUFPO1lBQ3JCLElBQUk5VCxRQUFRLFFBQVE7Z0JBQ2xCO1lBQ0Y7WUFFQSxJQUFJLENBQUM0SixLQUFLbk0sY0FBYyxDQUFDdUMsUUFBUTRKLElBQUksQ0FBQzVKLElBQUksS0FBSzhULEtBQUssQ0FBQzlULElBQUksRUFBRTtnQkFDekQsT0FBTztZQUNUO1FBQ0Y7UUFFQSxPQUFPO0lBQ1Q7SUFFQTs7R0FFQyxHQUNEa25CLGFBQWEsU0FBU0EsWUFBWTVmLElBQUksRUFBRTZmLFlBQVk7UUFDbEQsSUFBSUMsU0FBUztZQUFDTixnQkFBZ0IsQ0FBQyxHQUFHeGY7U0FBTTtRQUV4QyxJQUFJL0MsWUFBWW1pQiw2QkFBNkJTLGVBQ3pDemlCO1FBRUosSUFBSTtZQUNGLElBQUtILFVBQVVuQixDQUFDLElBQUksQ0FBQyxDQUFDc0IsUUFBUUgsVUFBVXBGLENBQUMsRUFBQyxFQUFHNEIsSUFBSSxFQUFHO2dCQUNsRCxJQUFJc21CLE1BQU0zaUIsTUFBTXpILEtBQUs7Z0JBRXJCLElBQUltWSxTQUFTaVMsSUFBSWpTLE1BQU0sRUFDbkJDLFFBQVFnUyxJQUFJaFMsS0FBSyxFQUNqQnFELE9BQU92Syx5QkFBeUJrWixLQUFLWjtnQkFFekMsSUFBSWhLLGVBQWUzVSxNQUFNcU8sS0FBSyxDQUFDa1IsTUFDM0IzSyxnQkFBZ0JyYixlQUFlb2IsY0FBYyxJQUM3QzNHLFFBQVE0RyxhQUFhLENBQUMsRUFBRSxFQUN4QnJMLE1BQU1xTCxhQUFhLENBQUMsRUFBRTtnQkFFMUIsSUFBSTViLE9BQU8sRUFBRTtnQkFDYixJQUFJd21CLFVBQVU7Z0JBQ2QsSUFBSUMsa0JBQWtCelIsTUFBTXNCLE1BQU07Z0JBQ2xDLElBQUlvUSxnQkFBZ0JuVyxJQUFJK0YsTUFBTTtnQkFFOUIsSUFBSXRTLGFBQWE0aEIsNkJBQTZCVSxTQUMxQ3BpQjtnQkFFSixJQUFJO29CQUNGLElBQUtGLFdBQVcxQixDQUFDLElBQUksQ0FBQyxDQUFDNEIsU0FBU0YsV0FBVzNGLENBQUMsRUFBQyxFQUFHNEIsSUFBSSxFQUFHO3dCQUNyRCxJQUFJdVcsT0FBT3RTLE9BQU8vSCxLQUFLO3dCQUN2QixJQUFJaUIsU0FBU29aLEtBQUsxTixJQUFJLENBQUMxTCxNQUFNO3dCQUM3QixJQUFJdXBCLFlBQVlIO3dCQUNoQkEsV0FBV3BwQixRQUFRLDJEQUEyRDt3QkFFOUUsSUFBSXFwQixtQkFBbUJFLGFBQWFILFdBQVdFLGVBQWU7NEJBQzVEMXFCLE9BQU80cUIsTUFBTSxDQUFDcFEsTUFBTW9COzRCQUNwQjVYLEtBQUtFLElBQUksQ0FBQ3NXOzRCQUNWO3dCQUNGLEVBQUUsMEZBQTBGO3dCQUc1RixJQUFJaVEsb0JBQW9CQyxpQkFBa0JELENBQUFBLG9CQUFvQkQsV0FBV0Usa0JBQWtCQyxTQUFRLEtBQU1GLGtCQUFrQkQsV0FBV0UsZ0JBQWdCQyxhQUFhRCxrQkFBa0JDLGFBQWFBLGNBQWMsR0FBRzs0QkFDak4zbUIsS0FBS0UsSUFBSSxDQUFDc1c7NEJBQ1Y7d0JBQ0YsRUFBRSxtRUFBbUU7d0JBQ3JFLG1FQUFtRTt3QkFDbkUsaUVBQWlFO3dCQUdqRSxJQUFJcVEsU0FBU3JRO3dCQUNiLElBQUl6QixTQUFTLEtBQUs7d0JBQ2xCLElBQUlQLFFBQVEsS0FBSzt3QkFFakIsSUFBSWtTLGdCQUFnQkYsU0FBUzs0QkFDM0IsSUFBSU0sTUFBTUosZ0JBQWdCQzs0QkFDMUJuUyxRQUFRd1IsZ0JBQWdCQSxnQkFBZ0IsQ0FBQyxHQUFHYSxTQUFTLENBQUMsR0FBRztnQ0FDdkQvZCxNQUFNK2QsT0FBTy9kLElBQUksQ0FBQ3ZLLEtBQUssQ0FBQ3VvQjs0QkFDMUI7NEJBQ0FELFNBQVNiLGdCQUFnQkEsZ0JBQWdCLENBQUMsR0FBR2EsU0FBUyxDQUFDLEdBQUc7Z0NBQ3hEL2QsTUFBTStkLE9BQU8vZCxJQUFJLENBQUN2SyxLQUFLLENBQUMsR0FBR3VvQjs0QkFDN0I7d0JBQ0Y7d0JBRUEsSUFBSUwsa0JBQWtCRSxXQUFXOzRCQUMvQixJQUFJSSxPQUFPTixrQkFBa0JFOzRCQUU3QjVSLFNBQVNpUixnQkFBZ0JBLGdCQUFnQixDQUFDLEdBQUdhLFNBQVMsQ0FBQyxHQUFHO2dDQUN4RC9kLE1BQU0rZCxPQUFPL2QsSUFBSSxDQUFDdkssS0FBSyxDQUFDLEdBQUd3b0I7NEJBQzdCOzRCQUNBRixTQUFTYixnQkFBZ0JBLGdCQUFnQixDQUFDLEdBQUdhLFNBQVMsQ0FBQyxHQUFHO2dDQUN4RC9kLE1BQU0rZCxPQUFPL2QsSUFBSSxDQUFDdkssS0FBSyxDQUFDd29COzRCQUMxQjt3QkFDRjt3QkFFQS9xQixPQUFPNHFCLE1BQU0sQ0FBQ0MsUUFBUWpQO3dCQUV0QixJQUFJN0MsUUFBUTs0QkFDVi9VLEtBQUtFLElBQUksQ0FBQzZVO3dCQUNaO3dCQUVBL1UsS0FBS0UsSUFBSSxDQUFDMm1CO3dCQUVWLElBQUlyUyxPQUFPOzRCQUNUeFUsS0FBS0UsSUFBSSxDQUFDc1U7d0JBQ1o7b0JBQ0Y7Z0JBQ0YsRUFBRSxPQUFPclUsS0FBSztvQkFDWjZELFdBQVd6QixDQUFDLENBQUNwQztnQkFDZixTQUFVO29CQUNSNkQsV0FBV3hCLENBQUM7Z0JBQ2Q7Z0JBRUE4akIsU0FBU3RtQjtZQUNYO1FBQ0YsRUFBRSxPQUFPRyxLQUFLO1lBQ1pzRCxVQUFVbEIsQ0FBQyxDQUFDcEM7UUFDZCxTQUFVO1lBQ1JzRCxVQUFVakIsQ0FBQztRQUNiO1FBRUEsT0FBTzhqQjtJQUNUO0FBQ0Y7QUFFQSxTQUFTVSxVQUFVL2xCLE1BQU0sRUFBRUMsY0FBYztJQUFJLElBQUlDLE9BQU9uRixPQUFPbUYsSUFBSSxDQUFDRjtJQUFTLElBQUlqRixPQUFPb0YscUJBQXFCLEVBQUU7UUFBRSxJQUFJQyxVQUFVckYsT0FBT29GLHFCQUFxQixDQUFDSDtRQUFTLElBQUlDLGdCQUFnQjtZQUFFRyxVQUFVQSxRQUFRQyxNQUFNLENBQUMsU0FBVUMsR0FBRztnQkFBSSxPQUFPdkYsT0FBT3dGLHdCQUF3QixDQUFDUCxRQUFRTSxLQUFLcEMsVUFBVTtZQUFFO1FBQUk7UUFBRWdDLEtBQUtqQixJQUFJLENBQUN1QixLQUFLLENBQUNOLE1BQU1FO0lBQVU7SUFBRSxPQUFPRjtBQUFNO0FBRTFWLFNBQVM4bEIsZ0JBQWdCdGxCLE1BQU07SUFBSSxJQUFLLElBQUl0RSxJQUFJLEdBQUdBLElBQUl1RSxVQUFVeEUsTUFBTSxFQUFFQyxJQUFLO1FBQUUsSUFBSXdFLFNBQVNELFNBQVMsQ0FBQ3ZFLEVBQUUsSUFBSSxPQUFPdUUsU0FBUyxDQUFDdkUsRUFBRSxHQUFHLENBQUM7UUFBRyxJQUFJQSxJQUFJLEdBQUc7WUFBRTJwQixVQUFVaHJCLE9BQU82RixTQUFTLE1BQU1DLE9BQU8sQ0FBQyxTQUFVNUMsR0FBRztnQkFBSUYsZ0JBQWdCMkMsUUFBUXpDLEtBQUsyQyxNQUFNLENBQUMzQyxJQUFJO1lBQUc7UUFBSSxPQUFPLElBQUlsRCxPQUFPK0YseUJBQXlCLEVBQUU7WUFBRS9GLE9BQU9nRyxnQkFBZ0IsQ0FBQ0wsUUFBUTNGLE9BQU8rRix5QkFBeUIsQ0FBQ0Y7UUFBVSxPQUFPO1lBQUVtbEIsVUFBVWhyQixPQUFPNkYsU0FBU0MsT0FBTyxDQUFDLFNBQVU1QyxHQUFHO2dCQUFJbEQsT0FBT0MsY0FBYyxDQUFDMEYsUUFBUXpDLEtBQUtsRCxPQUFPd0Ysd0JBQXdCLENBQUNLLFFBQVEzQztZQUFPO1FBQUk7SUFBRTtJQUFFLE9BQU95QztBQUFRO0FBRTNoQixTQUFTdWxCLDZCQUE2Qi9vQixDQUFDLEVBQUUrRCxjQUFjO0lBQUksSUFBSUMsS0FBSyxPQUFPckUsV0FBVyxlQUFlSyxDQUFDLENBQUNMLE9BQU9DLFFBQVEsQ0FBQyxJQUFJSSxDQUFDLENBQUMsYUFBYTtJQUFFLElBQUksQ0FBQ2dFLElBQUk7UUFBRSxJQUFJNUUsTUFBTUcsT0FBTyxDQUFDUyxNQUFPZ0UsQ0FBQUEsS0FBS2dsQiw4QkFBOEJocEIsRUFBQyxLQUFNK0Qsa0JBQWtCL0QsS0FBSyxPQUFPQSxFQUFFZixNQUFNLEtBQUssVUFBVTtZQUFFLElBQUkrRSxJQUFJaEUsSUFBSWdFO1lBQUksSUFBSTlFLElBQUk7WUFBRyxJQUFJZ0YsSUFBSSxTQUFTQSxLQUFLO1lBQUcsT0FBTztnQkFBRUMsR0FBR0Q7Z0JBQUdoRSxHQUFHLFNBQVNBO29CQUFNLElBQUloQixLQUFLYyxFQUFFZixNQUFNLEVBQUUsT0FBTzt3QkFBRTZDLE1BQU07b0JBQUs7b0JBQUcsT0FBTzt3QkFBRUEsTUFBTTt3QkFBTzlELE9BQU9nQyxDQUFDLENBQUNkLElBQUk7b0JBQUM7Z0JBQUc7Z0JBQUdrRixHQUFHLFNBQVNBLEVBQUV4QyxFQUFFO29CQUFJLE1BQU1BO2dCQUFJO2dCQUFHeUMsR0FBR0g7WUFBRTtRQUFHO1FBQUUsTUFBTSxJQUFJeEQsVUFBVTtJQUEwSTtJQUFFLElBQUk0RCxtQkFBbUIsTUFBTUMsU0FBUyxPQUFPdkM7SUFBSyxPQUFPO1FBQUVtQyxHQUFHLFNBQVNBO1lBQU1ILEtBQUtBLEdBQUd2RixJQUFJLENBQUN1QjtRQUFJO1FBQUdFLEdBQUcsU0FBU0E7WUFBTSxJQUFJc0UsT0FBT1IsR0FBR25DLElBQUk7WUFBSXlDLG1CQUFtQkUsS0FBSzFDLElBQUk7WUFBRSxPQUFPMEM7UUFBTTtRQUFHSixHQUFHLFNBQVNBLEVBQUVLLEdBQUc7WUFBSUYsU0FBUztZQUFNdkMsTUFBTXlDO1FBQUs7UUFBR0osR0FBRyxTQUFTQTtZQUFNLElBQUk7Z0JBQUUsSUFBSSxDQUFDQyxvQkFBb0JOLEVBQUUsQ0FBQyxTQUFTLElBQUksTUFBTUEsRUFBRSxDQUFDLFNBQVM7WUFBSSxTQUFVO2dCQUFFLElBQUlPLFFBQVEsTUFBTXZDO1lBQUs7UUFBRTtJQUFFO0FBQUc7QUFFLytCLFNBQVNnbkIsOEJBQThCaHBCLENBQUMsRUFBRUMsTUFBTTtJQUFJLElBQUksQ0FBQ0QsR0FBRztJQUFRLElBQUksT0FBT0EsTUFBTSxVQUFVLE9BQU9pcEIsb0JBQW9CanBCLEdBQUdDO0lBQVMsSUFBSUMsSUFBSXJDLE9BQU9VLFNBQVMsQ0FBQzRCLFFBQVEsQ0FBQzFCLElBQUksQ0FBQ3VCLEdBQUdJLEtBQUssQ0FBQyxHQUFHLENBQUM7SUFBSSxJQUFJRixNQUFNLFlBQVlGLEVBQUVLLFdBQVcsRUFBRUgsSUFBSUYsRUFBRUssV0FBVyxDQUFDQyxJQUFJO0lBQUUsSUFBSUosTUFBTSxTQUFTQSxNQUFNLE9BQU8sT0FBT2QsTUFBTVMsSUFBSSxDQUFDRztJQUFJLElBQUlFLE1BQU0sZUFBZSwyQ0FBMkNLLElBQUksQ0FBQ0wsSUFBSSxPQUFPK29CLG9CQUFvQmpwQixHQUFHQztBQUFTO0FBRXJhLFNBQVNncEIsb0JBQW9CbHFCLEdBQUcsRUFBRUMsR0FBRztJQUFJLElBQUlBLE9BQU8sUUFBUUEsTUFBTUQsSUFBSUUsTUFBTSxFQUFFRCxNQUFNRCxJQUFJRSxNQUFNO0lBQUUsSUFBSyxJQUFJQyxJQUFJLEdBQUdDLE9BQU8sSUFBSUMsTUFBTUosTUFBTUUsSUFBSUYsS0FBS0UsSUFBSztRQUFFQyxJQUFJLENBQUNELEVBQUUsR0FBR0gsR0FBRyxDQUFDRyxFQUFFO0lBQUU7SUFBRSxPQUFPQztBQUFNO0FBRXhMLElBQUkrcEIsZUFBZSxTQUFTQSxhQUFhdGtCLE1BQU0sRUFBRUcsU0FBUyxFQUFFTSxFQUFFO0lBQzVELE9BQVFBLEdBQUcwQyxJQUFJO1FBQ2IsS0FBSztZQUNIO2dCQUNFLElBQUlqQixPQUFPekIsR0FBR3lCLElBQUksRUFDZHVCLE9BQU9oRCxHQUFHZ0QsSUFBSTtnQkFDbEIsSUFBSUksU0FBU3dCLEtBQUt4QixNQUFNLENBQUM3RCxRQUFRa0M7Z0JBQ2pDLElBQUlxYSxRQUFRcmEsSUFBSSxDQUFDQSxLQUFLN0gsTUFBTSxHQUFHLEVBQUU7Z0JBRWpDLElBQUlraUIsUUFBUTFZLE9BQU81RCxRQUFRLENBQUM1RixNQUFNLEVBQUU7b0JBQ2xDLE1BQU0sSUFBSTBQLE1BQU0sb0RBQXNEeEQsTUFBTSxDQUFDckUsTUFBTTtnQkFDckY7Z0JBRUEyQixPQUFPNUQsUUFBUSxDQUFDbWQsTUFBTSxDQUFDYixPQUFPLEdBQUc5WTtnQkFFakMsSUFBSXRELFdBQVc7b0JBQ2IsSUFBSU8sWUFBWXlqQiw2QkFBNkJsZ0IsTUFBTTZkLE1BQU0sQ0FBQzNoQixhQUN0RFU7b0JBRUosSUFBSTt3QkFDRixJQUFLSCxVQUFVbkIsQ0FBQyxJQUFJLENBQUMsQ0FBQ3NCLFFBQVFILFVBQVVwRixDQUFDLEVBQUMsRUFBRzRCLElBQUksRUFBRzs0QkFDbEQsSUFBSW1VLGNBQWM3VCxlQUFlcUQsTUFBTXpILEtBQUssRUFBRSxJQUMxQ3NZLFFBQVFMLFdBQVcsQ0FBQyxFQUFFLEVBQ3RCbFYsTUFBTWtWLFdBQVcsQ0FBQyxFQUFFOzRCQUV4QmxSLFNBQVMsQ0FBQ2hFLElBQUksR0FBRzhXLE1BQU1qUyxTQUFTLENBQUMwUSxPQUFPalI7d0JBQzFDO29CQUNGLEVBQUUsT0FBT3JELEtBQUs7d0JBQ1pzRCxVQUFVbEIsQ0FBQyxDQUFDcEM7b0JBQ2QsU0FBVTt3QkFDUnNELFVBQVVqQixDQUFDO29CQUNiO2dCQUNGO2dCQUVBO1lBQ0Y7UUFFRixLQUFLO1lBQ0g7Z0JBQ0UsSUFBSXFELFFBQVFyQyxHQUFHeUIsSUFBSSxFQUNmcVIsU0FBUzlTLEdBQUc4UyxNQUFNLEVBQ2xCeE4sT0FBT3RGLEdBQUdzRixJQUFJO2dCQUNsQixJQUFJQSxLQUFLMUwsTUFBTSxLQUFLLEdBQUc7Z0JBRXZCLElBQUk0WixRQUFRNU8sS0FBS29PLElBQUksQ0FBQ3pULFFBQVE4QztnQkFFOUIsSUFBSWtQLFNBQVNpQyxNQUFNbE8sSUFBSSxDQUFDdkssS0FBSyxDQUFDLEdBQUcrWDtnQkFFakMsSUFBSTlCLFFBQVF3QyxNQUFNbE8sSUFBSSxDQUFDdkssS0FBSyxDQUFDK1g7Z0JBRTdCVSxNQUFNbE8sSUFBSSxHQUFHaU0sU0FBU2pNLE9BQU8wTDtnQkFFN0IsSUFBSXRSLFdBQVc7b0JBQ2IsSUFBSWMsYUFBYWtqQiw2QkFBNkJsZ0IsTUFBTTZkLE1BQU0sQ0FBQzNoQixhQUN2RGdCO29CQUVKLElBQUk7d0JBQ0YsSUFBS0YsV0FBVzFCLENBQUMsSUFBSSxDQUFDLENBQUM0QixTQUFTRixXQUFXM0YsQ0FBQyxFQUFDLEVBQUc0QixJQUFJLEVBQUc7NEJBQ3JELElBQUkwZixlQUFlcGYsZUFBZTJELE9BQU8vSCxLQUFLLEVBQUUsSUFDNUNtckIsU0FBUzNILFlBQVksQ0FBQyxFQUFFLEVBQ3hCOEYsT0FBTzlGLFlBQVksQ0FBQyxFQUFFOzRCQUUxQnpjLFNBQVMsQ0FBQ3VpQixLQUFLLEdBQUd6UCxNQUFNalMsU0FBUyxDQUFDdWpCLFFBQVE5akI7d0JBQzVDO29CQUNGLEVBQUUsT0FBT3JELEtBQUs7d0JBQ1o2RCxXQUFXekIsQ0FBQyxDQUFDcEM7b0JBQ2YsU0FBVTt3QkFDUjZELFdBQVd4QixDQUFDO29CQUNkO2dCQUNGO2dCQUVBO1lBQ0Y7UUFFRixLQUFLO1lBQ0g7Z0JBQ0UsSUFBSXFJLFNBQVNySCxHQUFHeUIsSUFBSTtnQkFFcEIsSUFBSTBTLFNBQVN2UCxLQUFLekQsR0FBRyxDQUFDNUIsUUFBUThIO2dCQUU5QixJQUFJMk0sV0FBV3BTLEtBQUtrRyxRQUFRLENBQUNUO2dCQUM3QixJQUFJbEIsT0FBT3ZCLEtBQUt6RCxHQUFHLENBQUM1QixRQUFReVU7Z0JBRTVCLElBQUkrUCxVQUFVbmYsS0FBS3hCLE1BQU0sQ0FBQzdELFFBQVE4SDtnQkFFbEMsSUFBSTJjLFNBQVMzYyxNQUFNLENBQUNBLE9BQU96TixNQUFNLEdBQUcsRUFBRTtnQkFFdEMsSUFBSXFKLEtBQUtDLE1BQU0sQ0FBQ2lSLFdBQVdsUixLQUFLQyxNQUFNLENBQUNpRCxPQUFPO29CQUM1Q0EsS0FBS2IsSUFBSSxJQUFJNk8sT0FBTzdPLElBQUk7Z0JBQzFCLE9BQU8sSUFBSSxDQUFDckMsS0FBS0MsTUFBTSxDQUFDaVIsV0FBVyxDQUFDbFIsS0FBS0MsTUFBTSxDQUFDaUQsT0FBTztvQkFDckQsSUFBSThkO29CQUVIQSxDQUFBQSxpQkFBaUI5ZCxLQUFLM0csUUFBUSxFQUFFOUMsSUFBSSxDQUFDdUIsS0FBSyxDQUFDZ21CLGdCQUFnQjFvQixtQkFBbUI0WSxPQUFPM1UsUUFBUTtnQkFDaEcsT0FBTztvQkFDTCxNQUFNLElBQUk4SixNQUFNLGtEQUFvRHhELE1BQU0sQ0FBQ3VCLFFBQVEsd0NBQXdDdkIsTUFBTSxDQUFDOFYsU0FBU0MsU0FBUyxDQUFDMUgsU0FBUyxLQUFLck8sTUFBTSxDQUFDOFYsU0FBU0MsU0FBUyxDQUFDMVY7Z0JBQy9MO2dCQUVBNGQsUUFBUXZrQixRQUFRLENBQUNtZCxNQUFNLENBQUNxSCxRQUFRO2dCQUVoQyxJQUFJdGtCLFdBQVc7b0JBQ2IsSUFBSW1CLGFBQWE2aUIsNkJBQTZCbGdCLE1BQU02ZCxNQUFNLENBQUMzaEIsYUFDdkRxQjtvQkFFSixJQUFJO3dCQUNGLElBQUtGLFdBQVcvQixDQUFDLElBQUksQ0FBQyxDQUFDaUMsU0FBU0YsV0FBV2hHLENBQUMsRUFBQyxFQUFHNEIsSUFBSSxFQUFHOzRCQUNyRCxJQUFJNGYsZUFBZXRmLGVBQWVnRSxPQUFPcEksS0FBSyxFQUFFLElBQzVDdXJCLFVBQVU3SCxZQUFZLENBQUMsRUFBRSxFQUN6QjhILFFBQVE5SCxZQUFZLENBQUMsRUFBRTs0QkFFM0IzYyxTQUFTLENBQUN5a0IsTUFBTSxHQUFHM1IsTUFBTWpTLFNBQVMsQ0FBQzJqQixTQUFTbGtCO3dCQUM5QztvQkFDRixFQUFFLE9BQU9yRCxLQUFLO3dCQUNaa0UsV0FBVzlCLENBQUMsQ0FBQ3BDO29CQUNmLFNBQVU7d0JBQ1JrRSxXQUFXN0IsQ0FBQztvQkFDZDtnQkFDRjtnQkFFQTtZQUNGO1FBRUYsS0FBSztZQUNIO2dCQUNFLElBQUkySSxTQUFTM0gsR0FBR3lCLElBQUksRUFDaEJPLFVBQVVoQyxHQUFHZ0MsT0FBTztnQkFFeEIsSUFBSUosS0FBS3VOLFVBQVUsQ0FBQ3hILFFBQVEzRixVQUFVO29CQUNwQyxNQUFNLElBQUlzSCxNQUFNLHVCQUF1QnhELE1BQU0sQ0FBQzZCLFFBQVEsbUJBQW1CN0IsTUFBTSxDQUFDOUQsU0FBUztnQkFDM0Y7Z0JBRUEsSUFBSW9pQixTQUFTeGYsS0FBS3pELEdBQUcsQ0FBQzVCLFFBQVFvSTtnQkFFOUIsSUFBSTBjLFdBQVd6ZixLQUFLeEIsTUFBTSxDQUFDN0QsUUFBUW9JO2dCQUVuQyxJQUFJMmMsVUFBVTNjLE1BQU0sQ0FBQ0EsT0FBTy9OLE1BQU0sR0FBRyxFQUFFLEVBQUUsbUVBQW1FO2dCQUM1Ryw4REFBOEQ7Z0JBQzlELG9FQUFvRTtnQkFDcEUsNkRBQTZEO2dCQUM3RCxxRUFBcUU7Z0JBQ3JFLDZCQUE2QjtnQkFFN0J5cUIsU0FBUzdrQixRQUFRLENBQUNtZCxNQUFNLENBQUMySCxTQUFTO2dCQUVsQyxJQUFJQyxXQUFXM2lCLEtBQUtyQixTQUFTLENBQUNvSCxRQUFRM0g7Z0JBQ3RDLElBQUl5SSxZQUFZN0QsS0FBS3pELEdBQUcsQ0FBQzVCLFFBQVFxQyxLQUFLd0IsTUFBTSxDQUFDbWhCO2dCQUM3QyxJQUFJN2IsV0FBVzZiLFFBQVEsQ0FBQ0EsU0FBUzNxQixNQUFNLEdBQUcsRUFBRTtnQkFDNUM2TyxVQUFVakosUUFBUSxDQUFDbWQsTUFBTSxDQUFDalUsVUFBVSxHQUFHMGI7Z0JBRXZDLElBQUkxa0IsV0FBVztvQkFDYixJQUFJb0MsYUFBYTRoQiw2QkFBNkJsZ0IsTUFBTTZkLE1BQU0sQ0FBQzNoQixhQUN2RHFDO29CQUVKLElBQUk7d0JBQ0YsSUFBS0QsV0FBV2hELENBQUMsSUFBSSxDQUFDLENBQUNpRCxTQUFTRCxXQUFXakgsQ0FBQyxFQUFDLEVBQUc0QixJQUFJLEVBQUc7NEJBQ3JELElBQUkyVyxlQUFlclcsZUFBZWdGLE9BQU9wSixLQUFLLEVBQUUsSUFDNUM2ckIsVUFBVXBSLFlBQVksQ0FBQyxFQUFFLEVBQ3pCcVIsUUFBUXJSLFlBQVksQ0FBQyxFQUFFOzRCQUUzQjFULFNBQVMsQ0FBQytrQixNQUFNLEdBQUdqUyxNQUFNalMsU0FBUyxDQUFDaWtCLFNBQVN4a0I7d0JBQzlDO29CQUNGLEVBQUUsT0FBT3JELEtBQUs7d0JBQ1ptRixXQUFXL0MsQ0FBQyxDQUFDcEM7b0JBQ2YsU0FBVTt3QkFDUm1GLFdBQVc5QyxDQUFDO29CQUNkO2dCQUNGO2dCQUVBO1lBQ0Y7UUFFRixLQUFLO1lBQ0g7Z0JBQ0UsSUFBSStJLFNBQVMvSCxHQUFHeUIsSUFBSTtnQkFDcEIsSUFBSWlqQixVQUFVM2MsTUFBTSxDQUFDQSxPQUFPbk8sTUFBTSxHQUFHLEVBQUU7Z0JBRXZDLElBQUkrcUIsV0FBVy9mLEtBQUt4QixNQUFNLENBQUM3RCxRQUFRd0k7Z0JBRW5DNGMsU0FBU25sQixRQUFRLENBQUNtZCxNQUFNLENBQUMrSCxTQUFTLElBQUksd0VBQXdFO2dCQUM5RyxrRUFBa0U7Z0JBR2xFLElBQUlobEIsV0FBVztvQkFDYixJQUFJeUMsYUFBYXVoQiw2QkFBNkJsZ0IsTUFBTTZkLE1BQU0sQ0FBQzNoQixhQUN2RDBDO29CQUVKLElBQUk7d0JBQ0YsSUFBS0QsV0FBV3JELENBQUMsSUFBSSxDQUFDLENBQUNzRCxTQUFTRCxXQUFXdEgsQ0FBQyxFQUFDLEVBQUc0QixJQUFJLEVBQUc7NEJBQ3JELElBQUltWixlQUFlN1ksZUFBZXFGLE9BQU96SixLQUFLLEVBQUUsSUFDNUNpc0IsVUFBVWhQLFlBQVksQ0FBQyxFQUFFLEVBQ3pCaVAsUUFBUWpQLFlBQVksQ0FBQyxFQUFFOzRCQUUzQixJQUFJb0ssU0FBU3hOLE1BQU1qUyxTQUFTLENBQUNxa0IsU0FBUzVrQjs0QkFFdEMsSUFBSU4sYUFBYSxRQUFRc2dCLFVBQVUsTUFBTTtnQ0FDdkN0Z0IsU0FBUyxDQUFDbWxCLE1BQU0sR0FBRzdFOzRCQUNyQixPQUFPO2dDQUNMLElBQUlsTSxRQUFRLEtBQUs7Z0NBRWpCLElBQUl0WCxPQUFPLEtBQUs7Z0NBRWhCLElBQUkwTCxhQUFhd2IsNkJBQTZCOWUsS0FBS3lZLEtBQUssQ0FBQzlkLFVBQ3JENEk7Z0NBRUosSUFBSTtvQ0FDRixJQUFLRCxXQUFXcEosQ0FBQyxJQUFJLENBQUMsQ0FBQ3FKLFNBQVNELFdBQVdyTixDQUFDLEVBQUMsRUFBRzRCLElBQUksRUFBRzt3Q0FDckQsSUFBSTZnQixlQUFldmdCLGVBQWVvTCxPQUFPeFAsS0FBSyxFQUFFLElBQzVDa0MsSUFBSXlpQixZQUFZLENBQUMsRUFBRSxFQUNuQjVWLElBQUk0VixZQUFZLENBQUMsRUFBRTt3Q0FFdkIsSUFBSTFiLEtBQUtrVSxPQUFPLENBQUNwTyxHQUFHSyxZQUFZLENBQUMsR0FBRzs0Q0FDbEMrTCxRQUFRO2dEQUFDalo7Z0RBQUc2TTs2Q0FBRTt3Q0FDaEIsT0FBTzs0Q0FDTGxMLE9BQU87Z0RBQUMzQjtnREFBRzZNOzZDQUFFOzRDQUNiO3dDQUNGO29DQUNGO2dDQUNGLEVBQUUsT0FBTy9LLEtBQUs7b0NBQ1p1TCxXQUFXbkosQ0FBQyxDQUFDcEM7Z0NBQ2YsU0FBVTtvQ0FDUnVMLFdBQVdsSixDQUFDO2dDQUNkO2dDQUVBLElBQUk4bEIsYUFBYTtnQ0FFakIsSUFBSWhSLFNBQVN0WCxNQUFNO29DQUNqQixJQUFJb0YsS0FBSzZFLE1BQU0sQ0FBQ2pLLElBQUksQ0FBQyxFQUFFLEVBQUV1TCxTQUFTO3dDQUNoQytjLGFBQWEsQ0FBQ2xqQixLQUFLK1ksV0FBVyxDQUFDbmUsSUFBSSxDQUFDLEVBQUU7b0NBQ3hDLE9BQU87d0NBQ0xzb0IsYUFBYWxqQixLQUFLeVYsTUFBTSxDQUFDdkQsS0FBSyxDQUFDLEVBQUUsRUFBRS9MLFFBQVFuTyxNQUFNLEdBQUdnSSxLQUFLeVYsTUFBTSxDQUFDN2EsSUFBSSxDQUFDLEVBQUUsRUFBRXVMLFFBQVFuTyxNQUFNO29DQUN6RjtnQ0FDRjtnQ0FFQSxJQUFJa2EsU0FBUyxDQUFDZ1IsWUFBWTtvQ0FDeEJGLFFBQVFuakIsSUFBSSxHQUFHcVMsS0FBSyxDQUFDLEVBQUU7b0NBQ3ZCOFEsUUFBUTlSLE1BQU0sR0FBR2dCLEtBQUssQ0FBQyxFQUFFLENBQUN4TyxJQUFJLENBQUMxTCxNQUFNO2dDQUN2QyxPQUFPLElBQUk0QyxNQUFNO29DQUNmb29CLFFBQVFuakIsSUFBSSxHQUFHakYsSUFBSSxDQUFDLEVBQUU7b0NBQ3RCb29CLFFBQVE5UixNQUFNLEdBQUc7Z0NBQ25CLE9BQU87b0NBQ0xwVCxZQUFZO2dDQUNkOzRCQUNGO3dCQUNGO29CQUNGLEVBQUUsT0FBTy9DLEtBQUs7d0JBQ1p3RixXQUFXcEQsQ0FBQyxDQUFDcEM7b0JBQ2YsU0FBVTt3QkFDUndGLFdBQVduRCxDQUFDO29CQUNkO2dCQUNGO2dCQUVBO1lBQ0Y7UUFFRixLQUFLO1lBQ0g7Z0JBQ0UsSUFBSTRKLFNBQVM1SSxHQUFHeUIsSUFBSSxFQUNoQnNqQixVQUFVL2tCLEdBQUc4UyxNQUFNLEVBQ25Ca1MsUUFBUWhsQixHQUFHc0YsSUFBSTtnQkFDbkIsSUFBSTBmLE1BQU1wckIsTUFBTSxLQUFLLEdBQUc7Z0JBRXhCLElBQUlxckIsU0FBU3JnQixLQUFLb08sSUFBSSxDQUFDelQsUUFBUXFKO2dCQUUvQixJQUFJc2MsVUFBVUQsT0FBTzNmLElBQUksQ0FBQ3ZLLEtBQUssQ0FBQyxHQUFHZ3FCO2dCQUVuQyxJQUFJSSxTQUFTRixPQUFPM2YsSUFBSSxDQUFDdkssS0FBSyxDQUFDZ3FCLFVBQVVDLE1BQU1wckIsTUFBTTtnQkFFckRxckIsT0FBTzNmLElBQUksR0FBRzRmLFVBQVVDO2dCQUV4QixJQUFJemxCLFdBQVc7b0JBQ2IsSUFBSTJJLGFBQWFxYiw2QkFBNkJsZ0IsTUFBTTZkLE1BQU0sQ0FBQzNoQixhQUN2RDRJO29CQUVKLElBQUk7d0JBQ0YsSUFBS0QsV0FBV3ZKLENBQUMsSUFBSSxDQUFDLENBQUN3SixTQUFTRCxXQUFXeE4sQ0FBQyxFQUFDLEVBQUc0QixJQUFJLEVBQUc7NEJBQ3JELElBQUl3YyxlQUFlbGMsZUFBZXVMLE9BQU8zUCxLQUFLLEVBQUUsSUFDNUN5c0IsVUFBVW5NLFlBQVksQ0FBQyxFQUFFLEVBQ3pCb00sUUFBUXBNLFlBQVksQ0FBQyxFQUFFOzRCQUUzQnZaLFNBQVMsQ0FBQzJsQixNQUFNLEdBQUc3UyxNQUFNalMsU0FBUyxDQUFDNmtCLFNBQVNwbEI7d0JBQzlDO29CQUNGLEVBQUUsT0FBT3JELEtBQUs7d0JBQ1owTCxXQUFXdEosQ0FBQyxDQUFDcEM7b0JBQ2YsU0FBVTt3QkFDUjBMLFdBQVdySixDQUFDO29CQUNkO2dCQUNGO2dCQUVBO1lBQ0Y7UUFFRixLQUFLO1lBQ0g7Z0JBQ0UsSUFBSThKLFNBQVM5SSxHQUFHeUIsSUFBSSxFQUNoQjhhLGFBQWF2YyxHQUFHdWMsVUFBVSxFQUMxQnNCLGdCQUFnQjdkLEdBQUc2ZCxhQUFhO2dCQUVwQyxJQUFJL1UsT0FBT2xQLE1BQU0sS0FBSyxHQUFHO29CQUN2QixNQUFNLElBQUkwUCxNQUFNO2dCQUNsQjtnQkFFQSxJQUFJZ2MsU0FBUzFnQixLQUFLekQsR0FBRyxDQUFDNUIsUUFBUXVKO2dCQUU5QixJQUFLLElBQUl5YyxTQUFTMUgsY0FBZTtvQkFDL0IsSUFBSTBILFVBQVUsY0FBY0EsVUFBVSxRQUFRO3dCQUM1QyxNQUFNLElBQUlqYyxNQUFNLG1CQUFvQnhELE1BQU0sQ0FBQ3lmLE9BQU87b0JBQ3BEO29CQUVBLElBQUk1c0IsUUFBUWtsQixhQUFhLENBQUMwSCxNQUFNO29CQUVoQyxJQUFJNXNCLFNBQVMsTUFBTTt3QkFDakIsT0FBTzJzQixNQUFNLENBQUNDLE1BQU07b0JBQ3RCLE9BQU87d0JBQ0xELE1BQU0sQ0FBQ0MsTUFBTSxHQUFHNXNCO29CQUNsQjtnQkFDRixFQUFFLGdGQUFnRjtnQkFHbEYsSUFBSyxJQUFJNnNCLFNBQVNqSixXQUFZO29CQUM1QixJQUFJLENBQUNzQixjQUFjMWtCLGNBQWMsQ0FBQ3FzQixRQUFRO3dCQUN4QyxPQUFPRixNQUFNLENBQUNFLE1BQU07b0JBQ3RCO2dCQUNGO2dCQUVBO1lBQ0Y7UUFFRixLQUFLO1lBQ0g7Z0JBQ0UsSUFBSXBILGlCQUFpQnBlLEdBQUc2ZCxhQUFhO2dCQUVyQyxJQUFJTyxrQkFBa0IsTUFBTTtvQkFDMUIxZSxZQUFZMGU7Z0JBQ2QsT0FBTztvQkFDTCxJQUFJMWUsYUFBYSxNQUFNO3dCQUNyQixJQUFJLENBQUM4RCxNQUFNcU4sT0FBTyxDQUFDdU4saUJBQWlCOzRCQUNsQyxNQUFNLElBQUk5VSxNQUFNLG1FQUFxRXhELE1BQU0sQ0FBQzhWLFNBQVNDLFNBQVMsQ0FBQ3VDLGlCQUFpQjt3QkFDbEk7d0JBRUExZSxZQUFZK2pCLGdCQUFnQixDQUFDLEdBQUdyRjtvQkFDbEM7b0JBRUEsSUFBSyxJQUFJcUgsU0FBU3JILGVBQWdCO3dCQUNoQyxJQUFJc0gsU0FBU3RILGNBQWMsQ0FBQ3FILE1BQU07d0JBRWxDLElBQUlDLFVBQVUsTUFBTTs0QkFDbEIsSUFBSUQsVUFBVSxZQUFZQSxVQUFVLFNBQVM7Z0NBQzNDLE1BQU0sSUFBSW5jLE1BQU0sc0JBQXVCeEQsTUFBTSxDQUFDMmYsT0FBTzs0QkFDdkQ7NEJBRUEsT0FBTy9sQixTQUFTLENBQUMrbEIsTUFBTTt3QkFDekIsT0FBTzs0QkFDTC9sQixTQUFTLENBQUMrbEIsTUFBTSxHQUFHQzt3QkFDckI7b0JBQ0Y7Z0JBQ0Y7Z0JBRUE7WUFDRjtRQUVGLEtBQUs7WUFDSDtnQkFDRSxJQUFJQyxTQUFTM2xCLEdBQUd5QixJQUFJLEVBQ2hCbWMsV0FBVzVkLEdBQUc0ZCxRQUFRLEVBQ3RCcEIsY0FBY3hjLEdBQUd1YyxVQUFVO2dCQUUvQixJQUFJb0osT0FBTy9yQixNQUFNLEtBQUssR0FBRztvQkFDdkIsTUFBTSxJQUFJMFAsTUFBTSxrREFBb0R4RCxNQUFNLENBQUM2ZixRQUFRO2dCQUNyRjtnQkFFQSxJQUFJQyxTQUFTaGhCLEtBQUt6RCxHQUFHLENBQUM1QixRQUFRb21CO2dCQUU5QixJQUFJRSxXQUFXamhCLEtBQUt4QixNQUFNLENBQUM3RCxRQUFRb21CO2dCQUVuQyxJQUFJRyxVQUFVSCxNQUFNLENBQUNBLE9BQU8vckIsTUFBTSxHQUFHLEVBQUU7Z0JBQ3ZDLElBQUltc0I7Z0JBRUosSUFBSTlpQixLQUFLQyxNQUFNLENBQUMwaUIsU0FBUztvQkFDdkIsSUFBSUksV0FBV0osT0FBT3RnQixJQUFJLENBQUN2SyxLQUFLLENBQUMsR0FBRzZpQjtvQkFFcEMsSUFBSXFJLFVBQVVMLE9BQU90Z0IsSUFBSSxDQUFDdkssS0FBSyxDQUFDNmlCO29CQUVoQ2dJLE9BQU90Z0IsSUFBSSxHQUFHMGdCO29CQUNkRCxVQUFVdEMsZ0JBQWdCQSxnQkFBZ0IsQ0FBQyxHQUFHakgsY0FBYyxDQUFDLEdBQUc7d0JBQzlEbFgsTUFBTTJnQjtvQkFDUjtnQkFDRixPQUFPO29CQUNMLElBQUlDLFdBQVdOLE9BQU9wbUIsUUFBUSxDQUFDekUsS0FBSyxDQUFDLEdBQUc2aUI7b0JBRXhDLElBQUl1SSxVQUFVUCxPQUFPcG1CLFFBQVEsQ0FBQ3pFLEtBQUssQ0FBQzZpQjtvQkFFcENnSSxPQUFPcG1CLFFBQVEsR0FBRzBtQjtvQkFDbEJILFVBQVV0QyxnQkFBZ0JBLGdCQUFnQixDQUFDLEdBQUdqSCxjQUFjLENBQUMsR0FBRzt3QkFDOURoZCxVQUFVMm1CO29CQUNaO2dCQUNGO2dCQUVBTixTQUFTcm1CLFFBQVEsQ0FBQ21kLE1BQU0sQ0FBQ21KLFVBQVUsR0FBRyxHQUFHQztnQkFFekMsSUFBSXJtQixXQUFXO29CQUNiLElBQUl5YSxhQUFhdUosNkJBQTZCbGdCLE1BQU02ZCxNQUFNLENBQUMzaEIsYUFDdkQwYTtvQkFFSixJQUFJO3dCQUNGLElBQUtELFdBQVdyYixDQUFDLElBQUksQ0FBQyxDQUFDc2IsU0FBU0QsV0FBV3RmLENBQUMsRUFBQyxFQUFHNEIsSUFBSSxFQUFHOzRCQUNyRCxJQUFJNGQsZUFBZXRkLGVBQWVxZCxPQUFPemhCLEtBQUssRUFBRSxJQUM1Q3l0QixVQUFVL0wsWUFBWSxDQUFDLEVBQUUsRUFDekJnTSxRQUFRaE0sWUFBWSxDQUFDLEVBQUU7NEJBRTNCM2EsU0FBUyxDQUFDMm1CLE1BQU0sR0FBRzdULE1BQU1qUyxTQUFTLENBQUM2bEIsU0FBU3BtQjt3QkFDOUM7b0JBQ0YsRUFBRSxPQUFPckQsS0FBSzt3QkFDWndkLFdBQVdwYixDQUFDLENBQUNwQztvQkFDZixTQUFVO3dCQUNSd2QsV0FBV25iLENBQUM7b0JBQ2Q7Z0JBQ0Y7Z0JBRUE7WUFDRjtJQUNKO0lBRUEsT0FBT1U7QUFDVCxHQUFHLHdDQUF3QztBQUczQyxJQUFJNG1CLG9CQUFvQjtJQUN0Qjs7R0FFQyxHQUNEL2xCLFdBQVcsU0FBU0EsVUFBVWhCLE1BQU0sRUFBRVMsRUFBRTtRQUN0Q1QsT0FBT0MsUUFBUSxHQUFHMUcsTUFBTXl0QixXQUFXLENBQUNobkIsT0FBT0MsUUFBUTtRQUNuRCxJQUFJRSxZQUFZSCxPQUFPRyxTQUFTLElBQUk1RyxNQUFNeXRCLFdBQVcsQ0FBQ2huQixPQUFPRyxTQUFTO1FBRXRFLElBQUk7WUFDRkEsWUFBWW1rQixhQUFhdGtCLFFBQVFHLFdBQVdNO1FBQzlDLFNBQVU7WUFDUlQsT0FBT0MsUUFBUSxHQUFHMUcsTUFBTTB0QixXQUFXLENBQUNqbkIsT0FBT0MsUUFBUTtZQUVuRCxJQUFJRSxXQUFXO2dCQUNiSCxPQUFPRyxTQUFTLEdBQUc1RyxNQUFNMnRCLE9BQU8sQ0FBQy9tQixhQUFhNUcsTUFBTTB0QixXQUFXLENBQUM5bUIsYUFBYUE7WUFDL0UsT0FBTztnQkFDTEgsT0FBT0csU0FBUyxHQUFHO1lBQ3JCO1FBQ0Y7SUFDRjtBQUNGO0FBRUEsSUFBSWduQixZQUFZO0lBQUM7Q0FBTyxFQUNwQkMsYUFBYTtJQUFDO0NBQVc7QUFFN0IsU0FBU0MsVUFBVW5wQixNQUFNLEVBQUVDLGNBQWM7SUFBSSxJQUFJQyxPQUFPbkYsT0FBT21GLElBQUksQ0FBQ0Y7SUFBUyxJQUFJakYsT0FBT29GLHFCQUFxQixFQUFFO1FBQUUsSUFBSUMsVUFBVXJGLE9BQU9vRixxQkFBcUIsQ0FBQ0g7UUFBUyxJQUFJQyxnQkFBZ0I7WUFBRUcsVUFBVUEsUUFBUUMsTUFBTSxDQUFDLFNBQVVDLEdBQUc7Z0JBQUksT0FBT3ZGLE9BQU93Rix3QkFBd0IsQ0FBQ1AsUUFBUU0sS0FBS3BDLFVBQVU7WUFBRTtRQUFJO1FBQUVnQyxLQUFLakIsSUFBSSxDQUFDdUIsS0FBSyxDQUFDTixNQUFNRTtJQUFVO0lBQUUsT0FBT0Y7QUFBTTtBQUUxVixTQUFTa3BCLGdCQUFnQjFvQixNQUFNO0lBQUksSUFBSyxJQUFJdEUsSUFBSSxHQUFHQSxJQUFJdUUsVUFBVXhFLE1BQU0sRUFBRUMsSUFBSztRQUFFLElBQUl3RSxTQUFTRCxTQUFTLENBQUN2RSxFQUFFLElBQUksT0FBT3VFLFNBQVMsQ0FBQ3ZFLEVBQUUsR0FBRyxDQUFDO1FBQUcsSUFBSUEsSUFBSSxHQUFHO1lBQUUrc0IsVUFBVXB1QixPQUFPNkYsU0FBUyxNQUFNQyxPQUFPLENBQUMsU0FBVTVDLEdBQUc7Z0JBQUlGLGdCQUFnQjJDLFFBQVF6QyxLQUFLMkMsTUFBTSxDQUFDM0MsSUFBSTtZQUFHO1FBQUksT0FBTyxJQUFJbEQsT0FBTytGLHlCQUF5QixFQUFFO1lBQUUvRixPQUFPZ0csZ0JBQWdCLENBQUNMLFFBQVEzRixPQUFPK0YseUJBQXlCLENBQUNGO1FBQVUsT0FBTztZQUFFdW9CLFVBQVVwdUIsT0FBTzZGLFNBQVNDLE9BQU8sQ0FBQyxTQUFVNUMsR0FBRztnQkFBSWxELE9BQU9DLGNBQWMsQ0FBQzBGLFFBQVF6QyxLQUFLbEQsT0FBT3dGLHdCQUF3QixDQUFDSyxRQUFRM0M7WUFBTztRQUFJO0lBQUU7SUFBRSxPQUFPeUM7QUFBUTtBQUUzaEIsU0FBUzJvQiw2QkFBNkJuc0IsQ0FBQyxFQUFFK0QsY0FBYztJQUFJLElBQUlDLEtBQUssT0FBT3JFLFdBQVcsZUFBZUssQ0FBQyxDQUFDTCxPQUFPQyxRQUFRLENBQUMsSUFBSUksQ0FBQyxDQUFDLGFBQWE7SUFBRSxJQUFJLENBQUNnRSxJQUFJO1FBQUUsSUFBSTVFLE1BQU1HLE9BQU8sQ0FBQ1MsTUFBT2dFLENBQUFBLEtBQUtvb0IsOEJBQThCcHNCLEVBQUMsS0FBTStELGtCQUFrQi9ELEtBQUssT0FBT0EsRUFBRWYsTUFBTSxLQUFLLFVBQVU7WUFBRSxJQUFJK0UsSUFBSWhFLElBQUlnRTtZQUFJLElBQUk5RSxJQUFJO1lBQUcsSUFBSWdGLElBQUksU0FBU0EsS0FBSztZQUFHLE9BQU87Z0JBQUVDLEdBQUdEO2dCQUFHaEUsR0FBRyxTQUFTQTtvQkFBTSxJQUFJaEIsS0FBS2MsRUFBRWYsTUFBTSxFQUFFLE9BQU87d0JBQUU2QyxNQUFNO29CQUFLO29CQUFHLE9BQU87d0JBQUVBLE1BQU07d0JBQU85RCxPQUFPZ0MsQ0FBQyxDQUFDZCxJQUFJO29CQUFDO2dCQUFHO2dCQUFHa0YsR0FBRyxTQUFTQSxFQUFFeEMsRUFBRTtvQkFBSSxNQUFNQTtnQkFBSTtnQkFBR3lDLEdBQUdIO1lBQUU7UUFBRztRQUFFLE1BQU0sSUFBSXhELFVBQVU7SUFBMEk7SUFBRSxJQUFJNEQsbUJBQW1CLE1BQU1DLFNBQVMsT0FBT3ZDO0lBQUssT0FBTztRQUFFbUMsR0FBRyxTQUFTQTtZQUFNSCxLQUFLQSxHQUFHdkYsSUFBSSxDQUFDdUI7UUFBSTtRQUFHRSxHQUFHLFNBQVNBO1lBQU0sSUFBSXNFLE9BQU9SLEdBQUduQyxJQUFJO1lBQUl5QyxtQkFBbUJFLEtBQUsxQyxJQUFJO1lBQUUsT0FBTzBDO1FBQU07UUFBR0osR0FBRyxTQUFTQSxFQUFFSyxHQUFHO1lBQUlGLFNBQVM7WUFBTXZDLE1BQU15QztRQUFLO1FBQUdKLEdBQUcsU0FBU0E7WUFBTSxJQUFJO2dCQUFFLElBQUksQ0FBQ0Msb0JBQW9CTixFQUFFLENBQUMsU0FBUyxJQUFJLE1BQU1BLEVBQUUsQ0FBQyxTQUFTO1lBQUksU0FBVTtnQkFBRSxJQUFJTyxRQUFRLE1BQU12QztZQUFLO1FBQUU7SUFBRTtBQUFHO0FBRS8rQixTQUFTb3FCLDhCQUE4QnBzQixDQUFDLEVBQUVDLE1BQU07SUFBSSxJQUFJLENBQUNELEdBQUc7SUFBUSxJQUFJLE9BQU9BLE1BQU0sVUFBVSxPQUFPcXNCLG9CQUFvQnJzQixHQUFHQztJQUFTLElBQUlDLElBQUlyQyxPQUFPVSxTQUFTLENBQUM0QixRQUFRLENBQUMxQixJQUFJLENBQUN1QixHQUFHSSxLQUFLLENBQUMsR0FBRyxDQUFDO0lBQUksSUFBSUYsTUFBTSxZQUFZRixFQUFFSyxXQUFXLEVBQUVILElBQUlGLEVBQUVLLFdBQVcsQ0FBQ0MsSUFBSTtJQUFFLElBQUlKLE1BQU0sU0FBU0EsTUFBTSxPQUFPLE9BQU9kLE1BQU1TLElBQUksQ0FBQ0c7SUFBSSxJQUFJRSxNQUFNLGVBQWUsMkNBQTJDSyxJQUFJLENBQUNMLElBQUksT0FBT21zQixvQkFBb0Jyc0IsR0FBR0M7QUFBUztBQUVyYSxTQUFTb3NCLG9CQUFvQnR0QixHQUFHLEVBQUVDLEdBQUc7SUFBSSxJQUFJQSxPQUFPLFFBQVFBLE1BQU1ELElBQUlFLE1BQU0sRUFBRUQsTUFBTUQsSUFBSUUsTUFBTTtJQUFFLElBQUssSUFBSUMsSUFBSSxHQUFHQyxPQUFPLElBQUlDLE1BQU1KLE1BQU1FLElBQUlGLEtBQUtFLElBQUs7UUFBRUMsSUFBSSxDQUFDRCxFQUFFLEdBQUdILEdBQUcsQ0FBQ0csRUFBRTtJQUFFO0lBQUUsT0FBT0M7QUFBTTtBQUV4TCxJQUFJbXRCLGlCQUFpQjtJQUNuQjs7R0FFQyxHQUNEN2hCLGFBQWEsU0FBU0EsWUFBWTdGLE1BQU0sRUFBRWdJLEtBQUs7UUFDN0MsSUFBSWdKLFVBQVVuUyxVQUFVeEUsTUFBTSxHQUFHLEtBQUt3RSxTQUFTLENBQUMsRUFBRSxLQUFLa00sWUFBWWxNLFNBQVMsQ0FBQyxFQUFFLEdBQUcsQ0FBQztRQUNuRjhCLE9BQU9zVyxrQkFBa0IsQ0FBQ2pYLFFBQVE7WUFDaEMsSUFBSTJuQixtQkFBbUIzVyxRQUFRNFcsT0FBTyxFQUNsQ0EsVUFBVUQscUJBQXFCLEtBQUssSUFBSSxRQUFRQSxrQkFDaEQxVyxpQkFBaUJELFFBQVFwTSxLQUFLLEVBQzlCQSxRQUFRcU0sbUJBQW1CLEtBQUssSUFBSSxRQUFRQSxnQkFDNUNDLGdCQUFnQkYsUUFBUUcsSUFBSSxFQUM1QkEsT0FBT0Qsa0JBQWtCLEtBQUssSUFBSSxXQUFXQTtZQUNqRCxJQUFJNUssS0FBSzBLLFFBQVExSyxFQUFFLEVBQ2Y5QyxRQUFRd04sUUFBUXhOLEtBQUssRUFDckJxa0IsU0FBUzdXLFFBQVE2VyxNQUFNO1lBRTNCLElBQUl4aUIsS0FBS2lZLE1BQU0sQ0FBQ3RWLFFBQVE7Z0JBQ3RCQSxRQUFRO29CQUFDQTtpQkFBTTtZQUNqQjtZQUVBLElBQUlBLE1BQU0zTixNQUFNLEtBQUssR0FBRztnQkFDdEI7WUFDRjtZQUVBLElBQUl5dEIsU0FBUzlmLE9BQ1QrZixVQUFVdnFCLGVBQWVzcUIsUUFBUSxJQUNqQ3JrQixPQUFPc2tCLE9BQU8sQ0FBQyxFQUFFLEVBQUUsd0VBQXdFO1lBQy9GLHVFQUF1RTtZQUN2RSw0REFBNEQ7WUFHNUQsSUFBSSxDQUFDemhCLElBQUk7Z0JBQ1AsSUFBSXRHLE9BQU9HLFNBQVMsRUFBRTtvQkFDcEJtRyxLQUFLdEcsT0FBT0csU0FBUztnQkFDdkIsT0FBTyxJQUFJSCxPQUFPQyxRQUFRLENBQUM1RixNQUFNLEdBQUcsR0FBRztvQkFDckNpTSxLQUFLM0YsT0FBTzZNLEdBQUcsQ0FBQ3hOLFFBQVEsRUFBRTtnQkFDNUIsT0FBTztvQkFDTHNHLEtBQUs7d0JBQUM7cUJBQUU7Z0JBQ1Y7Z0JBRUF1aEIsU0FBUztZQUNYO1lBRUEsSUFBSUEsVUFBVSxNQUFNO2dCQUNsQkEsU0FBUztZQUNYO1lBRUEsSUFBSTVqQixNQUFNcU4sT0FBTyxDQUFDaEwsS0FBSztnQkFDckIsSUFBSSxDQUFDc2hCLFNBQVM7b0JBQ1p0aEIsS0FBSzNGLE9BQU9xYSxXQUFXLENBQUNoYixRQUFRc0csSUFBSTt3QkFDbEMxQixPQUFPQTtvQkFDVDtnQkFDRjtnQkFFQSxJQUFJWCxNQUFNYyxXQUFXLENBQUN1QixLQUFLO29CQUN6QkEsS0FBS0EsR0FBR2lMLE1BQU07Z0JBQ2hCLE9BQU87b0JBQ0wsSUFBSXFILGVBQWUzVSxNQUFNcU8sS0FBSyxDQUFDaE0sS0FDM0J1UyxnQkFBZ0JyYixlQUFlb2IsY0FBYyxJQUM3Q3BMLE1BQU1xTCxhQUFhLENBQUMsRUFBRTtvQkFFMUIsSUFBSUMsV0FBV25ZLE9BQU9tWSxRQUFRLENBQUM5WSxRQUFRd047b0JBQ3ZDeEssVUFBVSxDQUFDLFNBQVMsQ0FBQ2hELFFBQVE7d0JBQzNCc0csSUFBSUE7b0JBQ047b0JBQ0FBLEtBQUt3UyxTQUFTVCxLQUFLO2dCQUNyQjtZQUNGO1lBRUEsSUFBSXBGLE1BQU04RSxPQUFPLENBQUN6UixLQUFLO2dCQUNyQixJQUFJOUMsU0FBUyxNQUFNO29CQUNqQixJQUFJRSxLQUFLQyxNQUFNLENBQUNGLE9BQU87d0JBQ3JCRCxRQUFRLFNBQVNBLE1BQU1sSSxDQUFDOzRCQUN0QixPQUFPb0ksS0FBS0MsTUFBTSxDQUFDckk7d0JBQ3JCO29CQUNGLE9BQU8sSUFBSTBFLE9BQU9LLFFBQVEsQ0FBQ29ELE9BQU87d0JBQ2hDRCxRQUFRLFNBQVNBLE1BQU1sSSxDQUFDOzRCQUN0QixPQUFPb0ksS0FBS0MsTUFBTSxDQUFDckksTUFBTXFGLE9BQU9OLFFBQVEsQ0FBQ0wsUUFBUTFFO3dCQUNuRDtvQkFDRixPQUFPO3dCQUNMa0ksUUFBUSxTQUFTQSxNQUFNbEksQ0FBQzs0QkFDdEIsT0FBTzZLLFFBQVFDLFNBQVMsQ0FBQzlLLE1BQU1xRixPQUFPK1IsT0FBTyxDQUFDMVMsUUFBUTFFO3dCQUN4RDtvQkFDRjtnQkFDRjtnQkFFQSxJQUFJd1ksZ0JBQWdCblQsT0FBT3FILEtBQUssQ0FBQ2hJLFFBQVE7b0JBQ3ZDc0csSUFBSUEsR0FBR3BFLElBQUk7b0JBQ1hzQixPQUFPQTtvQkFDUDJOLE1BQU1BO29CQUNOdk0sT0FBT0E7Z0JBQ1QsSUFDSW1QLGlCQUFpQnZXLGVBQWVzVyxlQUFlLElBQy9DN04sUUFBUThOLGNBQWMsQ0FBQyxFQUFFO2dCQUU3QixJQUFJOU4sT0FBTztvQkFDVCxJQUFJQyxTQUFTMUksZUFBZXlJLE9BQU8sSUFDL0IraEIsYUFBYTloQixNQUFNLENBQUMsRUFBRTtvQkFFMUIsSUFBSStSLFVBQVV0WCxPQUFPc1gsT0FBTyxDQUFDalksUUFBUWdvQjtvQkFDckMsSUFBSUMsVUFBVXRuQixPQUFPcVMsS0FBSyxDQUFDaFQsUUFBUXNHLElBQUkwaEI7b0JBQ3ZDaGxCLFdBQVd3QyxVQUFVLENBQUN4RixRQUFRO3dCQUM1QnNHLElBQUlBO3dCQUNKOUMsT0FBT0E7d0JBQ1AyTixNQUFNQTt3QkFDTnZNLE9BQU9BO29CQUNUO29CQUNBLElBQUkxQyxPQUFPK1YsUUFBUUksS0FBSztvQkFDeEIvUixLQUFLMmhCLFVBQVU1bEIsS0FBS3BGLElBQUksQ0FBQ2lGLFFBQVFBO2dCQUNuQyxPQUFPO29CQUNMO2dCQUNGO1lBQ0Y7WUFFQSxJQUFJb1YsYUFBYWpWLEtBQUt3QixNQUFNLENBQUN5QztZQUM3QixJQUFJaVcsUUFBUWpXLEVBQUUsQ0FBQ0EsR0FBR2pNLE1BQU0sR0FBRyxFQUFFO1lBRTdCLElBQUksQ0FBQ3VLLFNBQVNqRSxNQUFNLENBQUMsT0FBTyxDQUFDWCxRQUFRO2dCQUNuQ3NHLElBQUlnUjtZQUNOLElBQUk7Z0JBQ0Y7WUFDRjtZQUVBLElBQUk1VyxZQUFZNm1CLDZCQUE2QnZmLFFBQ3pDbkg7WUFFSixJQUFJO2dCQUNGLElBQUtILFVBQVVuQixDQUFDLElBQUksQ0FBQyxDQUFDc0IsUUFBUUgsVUFBVXBGLENBQUMsRUFBQyxFQUFHNEIsSUFBSSxFQUFHO29CQUNsRCxJQUFJK1csUUFBUXBULE1BQU16SCxLQUFLO29CQUV2QixJQUFJMEosUUFBUXdVLFdBQVcvUSxNQUFNLENBQUNnVztvQkFFOUJBO29CQUNBdmMsT0FBT3RCLEtBQUssQ0FBQzt3QkFDWHlFLE1BQU07d0JBQ05qQixNQUFNWTt3QkFDTlcsTUFBTXdRO29CQUNSO29CQUNBM04sS0FBS2pFLEtBQUtwRixJQUFJLENBQUNxSjtnQkFDakI7WUFDRixFQUFFLE9BQU9sSixLQUFLO2dCQUNac0QsVUFBVWxCLENBQUMsQ0FBQ3BDO1lBQ2QsU0FBVTtnQkFDUnNELFVBQVVqQixDQUFDO1lBQ2I7WUFFQTZHLEtBQUtqRSxLQUFLa0csUUFBUSxDQUFDakM7WUFFbkIsSUFBSXVoQixRQUFRO2dCQUNWLElBQUluVyxRQUFRL1EsT0FBTzZNLEdBQUcsQ0FBQ3hOLFFBQVFzRztnQkFFL0IsSUFBSW9MLE9BQU87b0JBQ1QxTyxXQUFXNmtCLE1BQU0sQ0FBQzduQixRQUFRMFI7Z0JBQzVCO1lBQ0Y7UUFDRjtJQUNGO0lBRUE7OztHQUdDLEdBQ0R3VyxXQUFXLFNBQVNBLFVBQVVsb0IsTUFBTTtRQUNsQyxJQUFJZ1IsVUFBVW5TLFVBQVV4RSxNQUFNLEdBQUcsS0FBS3dFLFNBQVMsQ0FBQyxFQUFFLEtBQUtrTSxZQUFZbE0sU0FBUyxDQUFDLEVBQUUsR0FBRyxDQUFDO1FBQ25GOEIsT0FBT3NXLGtCQUFrQixDQUFDalgsUUFBUTtZQUNoQyxJQUFJb1IsY0FBY0osUUFBUTFLLEVBQUUsRUFDeEJBLEtBQUs4SyxnQkFBZ0IsS0FBSyxJQUFJcFIsT0FBT0csU0FBUyxHQUFHaVIsYUFDakQwRCxpQkFBaUI5RCxRQUFRRyxJQUFJLEVBQzdCQSxPQUFPMkQsbUJBQW1CLEtBQUssSUFBSSxXQUFXQSxnQkFDOUNsQixrQkFBa0I1QyxRQUFRcE0sS0FBSyxFQUMvQkEsUUFBUWdQLG9CQUFvQixLQUFLLElBQUksUUFBUUE7WUFDakQsSUFBSXBRLFFBQVF3TixRQUFReE4sS0FBSztZQUV6QixJQUFJQSxTQUFTLE1BQU07Z0JBQ2pCQSxRQUFRbkIsS0FBS2lULE1BQU0sQ0FBQ2hQLE1BQU02aEIsVUFBVW5vQixRQUFRc0csTUFBTSxTQUFVaEwsQ0FBQztvQkFDM0QsT0FBTzZLLFFBQVFDLFNBQVMsQ0FBQzlLLE1BQU1xRixPQUFPK1IsT0FBTyxDQUFDMVMsUUFBUTFFO2dCQUN4RDtZQUNGO1lBRUEsSUFBSSxDQUFDZ0wsSUFBSTtnQkFDUDtZQUNGO1lBRUEsSUFBSStKLFVBQVUxUCxPQUFPcUgsS0FBSyxDQUFDaEksUUFBUTtnQkFDakNzRyxJQUFJQTtnQkFDSjlDLE9BQU9BO2dCQUNQMk4sTUFBTUE7Z0JBQ052TSxPQUFPQTtZQUNUO1lBQ0EsSUFBSWhFLFdBQVdwRyxNQUFNUyxJQUFJLENBQUNvVixTQUFTLFNBQVVqUCxJQUFJO2dCQUMvQyxJQUFJSyxRQUFRakUsZUFBZTRELE1BQU0sSUFDN0IrRyxJQUFJMUcsS0FBSyxDQUFDLEVBQUU7Z0JBRWhCLE9BQU9kLE9BQU9zWCxPQUFPLENBQUNqWSxRQUFRbUk7WUFDaEM7WUFFQSxJQUFLLElBQUl4TCxLQUFLLEdBQUd5ckIsWUFBWXhuQixVQUFVakUsS0FBS3lyQixVQUFVL3RCLE1BQU0sRUFBRXNDLEtBQU07Z0JBQ2xFLElBQUlzYixVQUFVbVEsU0FBUyxDQUFDenJCLEdBQUc7Z0JBQzNCLElBQUl1RixPQUFPK1YsUUFBUUksS0FBSztnQkFFeEIsSUFBSW5XLEtBQUs3SCxNQUFNLEdBQUcsR0FBRztvQkFDbkIsTUFBTSxJQUFJMFAsTUFBTSwrQkFBK0J4RCxNQUFNLENBQUNyRSxNQUFNO2dCQUM5RDtnQkFFQSxJQUFJbW1CLGtCQUFrQjFuQixPQUFPOEMsSUFBSSxDQUFDekQsUUFBUXFDLEtBQUt3QixNQUFNLENBQUMzQjtnQkFFdEQsSUFBSW9tQixtQkFBbUI5cUIsZUFBZTZxQixpQkFBaUIsSUFDbkR4a0IsU0FBU3lrQixnQkFBZ0IsQ0FBQyxFQUFFLEVBQzVCaFIsYUFBYWdSLGdCQUFnQixDQUFDLEVBQUU7Z0JBRXBDLElBQUkvTCxRQUFRcmEsSUFBSSxDQUFDQSxLQUFLN0gsTUFBTSxHQUFHLEVBQUU7Z0JBQ2pDLElBQUlBLFNBQVN3SixPQUFPNUQsUUFBUSxDQUFDNUYsTUFBTTtnQkFFbkMsSUFBSUEsV0FBVyxHQUFHO29CQUNoQixJQUFJa3VCLFNBQVNsbUIsS0FBS3BGLElBQUksQ0FBQ3FhO29CQUN2QnRVLFdBQVd3bEIsU0FBUyxDQUFDeG9CLFFBQVE7d0JBQzNCc0csSUFBSXBFO3dCQUNKa1QsSUFBSW1UO3dCQUNKM2pCLE9BQU9BO29CQUNUO29CQUNBNUIsV0FBVytELFdBQVcsQ0FBQy9HLFFBQVE7d0JBQzdCc0csSUFBSWdSO3dCQUNKMVMsT0FBT0E7b0JBQ1Q7Z0JBQ0YsT0FBTyxJQUFJMlgsVUFBVSxHQUFHO29CQUN0QnZaLFdBQVd3bEIsU0FBUyxDQUFDeG9CLFFBQVE7d0JBQzNCc0csSUFBSXBFO3dCQUNKa1QsSUFBSWtDO3dCQUNKMVMsT0FBT0E7b0JBQ1Q7Z0JBQ0YsT0FBTyxJQUFJMlgsVUFBVWxpQixTQUFTLEdBQUc7b0JBQy9CLElBQUlvdUIsVUFBVXBtQixLQUFLcEYsSUFBSSxDQUFDcWE7b0JBRXhCdFUsV0FBV3dsQixTQUFTLENBQUN4b0IsUUFBUTt3QkFDM0JzRyxJQUFJcEU7d0JBQ0prVCxJQUFJcVQ7d0JBQ0o3akIsT0FBT0E7b0JBQ1Q7Z0JBQ0YsT0FBTztvQkFDTCxJQUFJOGpCLFlBQVlybUIsS0FBS3BGLElBQUksQ0FBQ2lGO29CQUUxQixJQUFJeW1CLFdBQVd0bUIsS0FBS3BGLElBQUksQ0FBQ3FhO29CQUV6QnRVLFdBQVd3QyxVQUFVLENBQUN4RixRQUFRO3dCQUM1QnNHLElBQUlvaUI7d0JBQ0o5akIsT0FBT0E7b0JBQ1Q7b0JBQ0E1QixXQUFXd2xCLFNBQVMsQ0FBQ3hvQixRQUFRO3dCQUMzQnNHLElBQUlwRTt3QkFDSmtULElBQUl1VDt3QkFDSi9qQixPQUFPQTtvQkFDVDtnQkFDRjtZQUNGO1FBQ0Y7SUFDRjtJQUVBOzs7R0FHQyxHQUNEd0MsWUFBWSxTQUFTQSxXQUFXcEgsTUFBTTtRQUNwQyxJQUFJZ1IsVUFBVW5TLFVBQVV4RSxNQUFNLEdBQUcsS0FBS3dFLFNBQVMsQ0FBQyxFQUFFLEtBQUtrTSxZQUFZbE0sU0FBUyxDQUFDLEVBQUUsR0FBRyxDQUFDO1FBQ25GOEIsT0FBT3NXLGtCQUFrQixDQUFDalgsUUFBUTtZQUNoQyxJQUFJd0QsUUFBUXdOLFFBQVF4TixLQUFLLEVBQ3JCa1EsZUFBZTFDLFFBQVExSyxFQUFFLEVBQ3pCQSxLQUFLb04saUJBQWlCLEtBQUssSUFBSTFULE9BQU9HLFNBQVMsR0FBR3VUO1lBQ3RELElBQUlrVixvQkFBb0I1WCxRQUFRNFcsT0FBTyxFQUNuQ0EsVUFBVWdCLHNCQUFzQixLQUFLLElBQUksUUFBUUEsbUJBQ2pEN1Qsa0JBQWtCL0QsUUFBUXBNLEtBQUssRUFDL0JBLFFBQVFtUSxvQkFBb0IsS0FBSyxJQUFJLFFBQVFBLGlCQUM3Q1ksaUJBQWlCM0UsUUFBUUcsSUFBSSxFQUM3QkEsT0FBT3dFLG1CQUFtQixLQUFLLElBQUksV0FBV0E7WUFFbEQsSUFBSSxDQUFDclAsSUFBSTtnQkFDUDtZQUNGO1lBRUEsSUFBSTlDLFNBQVMsTUFBTTtnQkFDakIsSUFBSW5CLEtBQUtpVCxNQUFNLENBQUNoUCxLQUFLO29CQUNuQixJQUFJMUMsaUJBQWlCakQsT0FBT2tELE1BQU0sQ0FBQzdELFFBQVFzRyxLQUN2Q3hDLGtCQUFrQnRHLGVBQWVvRyxnQkFBZ0IsSUFDakRDLFNBQVNDLGVBQWUsQ0FBQyxFQUFFO29CQUUvQk4sUUFBUSxTQUFTQSxNQUFNbEksQ0FBQzt3QkFDdEIsT0FBT3VJLE9BQU81RCxRQUFRLENBQUNzVixRQUFRLENBQUNqYTtvQkFDbEM7Z0JBQ0YsT0FBTztvQkFDTGtJLFFBQVEsU0FBU0EsTUFBTWxJLENBQUM7d0JBQ3RCLE9BQU82SyxRQUFRQyxTQUFTLENBQUM5SyxNQUFNcUYsT0FBTytSLE9BQU8sQ0FBQzFTLFFBQVExRTtvQkFDeEQ7Z0JBQ0Y7WUFDRjtZQUVBLElBQUksQ0FBQ3NzQixXQUFXM2pCLE1BQU1xTixPQUFPLENBQUNoTCxLQUFLO2dCQUNqQ0EsS0FBSzNGLE9BQU9xYSxXQUFXLENBQUNoYixRQUFRc0csSUFBSTtvQkFDbEMxQixPQUFPQTtnQkFDVDtZQUNGO1lBRUEsSUFBSVgsTUFBTXFOLE9BQU8sQ0FBQ2hMLEtBQUs7Z0JBQ3JCLElBQUlyQyxNQUFNYyxXQUFXLENBQUN1QixLQUFLO29CQUN6QkEsS0FBS0EsR0FBR2lMLE1BQU07Z0JBQ2hCLE9BQU87b0JBQ0wsSUFBSTZILGdCQUFnQm5WLE1BQU1xTyxLQUFLLENBQUNoTSxLQUM1QitTLGdCQUFnQjdiLGVBQWU0YixlQUFlLElBQzlDNUwsTUFBTTZMLGFBQWEsQ0FBQyxFQUFFO29CQUUxQixJQUFJUCxXQUFXblksT0FBT21ZLFFBQVEsQ0FBQzlZLFFBQVF3TjtvQkFDdkN4SyxVQUFVLENBQUMsU0FBUyxDQUFDaEQsUUFBUTt3QkFDM0JzRyxJQUFJQTtvQkFDTjtvQkFDQUEsS0FBS3dTLFNBQVNULEtBQUs7b0JBRW5CLElBQUlySCxRQUFRMUssRUFBRSxJQUFJLE1BQU07d0JBQ3RCdEQsV0FBVzZrQixNQUFNLENBQUM3bkIsUUFBUXNHO29CQUM1QjtnQkFDRjtZQUNGO1lBRUEsSUFBSWtQLGlCQUFpQjdVLE9BQU9xSCxLQUFLLENBQUNoSSxRQUFRO2dCQUN4Q3NHLElBQUlBO2dCQUNKOUMsT0FBT0E7Z0JBQ1BvQixPQUFPQTtnQkFDUHVNLE1BQU1BO1lBQ1IsSUFDSXNFLGlCQUFpQmpZLGVBQWVnWSxnQkFBZ0IsSUFDaEQ0QyxVQUFVM0MsY0FBYyxDQUFDLEVBQUU7WUFFL0IsSUFBSTdPLE9BQU9qRyxPQUFPNEgsUUFBUSxDQUFDdkksUUFBUTtnQkFDakNzRyxJQUFJQTtnQkFDSjlDLE9BQU9BO2dCQUNQb0IsT0FBT0E7Z0JBQ1B1TSxNQUFNQTtZQUNSO1lBRUEsSUFBSSxDQUFDaUgsV0FBVyxDQUFDeFIsTUFBTTtnQkFDckI7WUFDRjtZQUVBLElBQUlpaUIsV0FBV3JyQixlQUFlNGEsU0FBUyxJQUNuQzNVLE9BQU9vbEIsUUFBUSxDQUFDLEVBQUUsRUFDbEIzbUIsT0FBTzJtQixRQUFRLENBQUMsRUFBRTtZQUV0QixJQUFJdFUsUUFBUS9XLGVBQWVvSixNQUFNLElBQzdCNE4sV0FBV0QsS0FBSyxDQUFDLEVBQUUsRUFDbkJFLFdBQVdGLEtBQUssQ0FBQyxFQUFFO1lBRXZCLElBQUlyUyxLQUFLN0gsTUFBTSxLQUFLLEtBQUtvYSxTQUFTcGEsTUFBTSxLQUFLLEdBQUc7Z0JBQzlDO1lBQ0Y7WUFFQSxJQUFJb0ksVUFBVUosS0FBS3BGLElBQUksQ0FBQ3dYO1lBQ3hCLElBQUlxVSxhQUFhem1CLEtBQUt5VixNQUFNLENBQUM1VixNQUFNdVM7WUFDbkMsSUFBSXNVLG9CQUFvQjFtQixLQUFLcWMsU0FBUyxDQUFDeGMsTUFBTXVTO1lBQzdDLElBQUk1TSxTQUFTck4sTUFBTVMsSUFBSSxDQUFDMEYsT0FBT2tILE1BQU0sQ0FBQzdILFFBQVE7Z0JBQzVDc0csSUFBSXBFO1lBQ04sSUFBSSxTQUFVK0YsS0FBSztnQkFDakIsSUFBSUMsUUFBUTFLLGVBQWV5SyxPQUFPLElBQzlCM00sSUFBSTRNLEtBQUssQ0FBQyxFQUFFO2dCQUVoQixPQUFPNU07WUFDVCxHQUFHRSxLQUFLLENBQUNzdEIsV0FBV3p1QixNQUFNLEVBQUVtQixLQUFLLENBQUMsR0FBRyxDQUFDLElBQUksdUVBQXVFO1lBQ2pILCtEQUErRDtZQUUvRCxJQUFJd3RCLGdCQUFnQnJvQixPQUFPb1EsS0FBSyxDQUFDL1EsUUFBUTtnQkFDdkNzRyxJQUFJcEU7Z0JBQ0ppUCxNQUFNO2dCQUNOM04sT0FBTyxTQUFTQSxNQUFNbEksQ0FBQztvQkFDckIsT0FBT3VNLE9BQU8wTixRQUFRLENBQUNqYSxNQUFNMnRCLG1CQUFtQmpwQixRQUFRMUU7Z0JBQzFEO1lBQ0Y7WUFDQSxJQUFJNHRCLFdBQVdGLGlCQUFpQnJvQixPQUFPc1gsT0FBTyxDQUFDalksUUFBUWdwQixhQUFhLENBQUMsRUFBRTtZQUN2RSxJQUFJaE07WUFDSixJQUFJcUIsVUFBVSx5RUFBeUU7WUFDdkYsNkNBQTZDO1lBRTdDLElBQUkzYSxLQUFLQyxNQUFNLENBQUNGLFNBQVNDLEtBQUtDLE1BQU0sQ0FBQzZRLFdBQVc7Z0JBQzlDL1EsS0FBS3NDLElBQUk7Z0JBQ0wsSUFBSThPLE9BQU92Syx5QkFBeUI3RyxNQUFNMGpCO2dCQUU5QzlJLFdBQVc3SixTQUFTek8sSUFBSSxDQUFDMUwsTUFBTTtnQkFDL0IyaUIsYUFBYW5JO1lBQ2YsT0FBTyxJQUFJMU8sUUFBUUMsU0FBUyxDQUFDM0MsU0FBUzBDLFFBQVFDLFNBQVMsQ0FBQ29PLFdBQVc7Z0JBQ2pFL1EsS0FBS3hELFFBQVE7Z0JBQ1QsSUFBSWlVLFFBQVE1Six5QkFBeUI3RyxNQUFNMmpCO2dCQUUvQy9JLFdBQVc3SixTQUFTdlUsUUFBUSxDQUFDNUYsTUFBTTtnQkFDbkMyaUIsYUFBYTlJO1lBQ2YsT0FBTztnQkFDTCxNQUFNLElBQUluSyxNQUFNLGtDQUFrQ3hELE1BQU0sQ0FBQ3JFLE1BQU0saUVBQWlFcUUsTUFBTSxDQUFDOFYsU0FBU0MsU0FBUyxDQUFDN1ksT0FBTyxLQUFLOEMsTUFBTSxDQUFDOFYsU0FBU0MsU0FBUyxDQUFDOUg7WUFDbE0sRUFBRSx3RUFBd0U7WUFDMUUsbUNBQW1DO1lBR25DLElBQUksQ0FBQ3VVLG1CQUFtQjtnQkFDdEIvbEIsV0FBV3dsQixTQUFTLENBQUN4b0IsUUFBUTtvQkFDM0JzRyxJQUFJcEU7b0JBQ0prVCxJQUFJM1M7b0JBQ0ptQyxPQUFPQTtnQkFDVDtZQUNGLEVBQUUsMEVBQTBFO1lBQzVFLDhCQUE4QjtZQUc5QixJQUFJc2tCLFVBQVU7Z0JBQ1psbUIsV0FBVytELFdBQVcsQ0FBQy9HLFFBQVE7b0JBQzdCc0csSUFBSTRpQixTQUFTOVEsT0FBTztvQkFDcEJ4VCxPQUFPQTtnQkFDVDtZQUNGLEVBQUUseUVBQXlFO1lBQzNFLG9FQUFvRTtZQUNwRSx1RUFBdUU7WUFDdkUscUJBQXFCO1lBQ3JCLHdEQUF3RDtZQUd4RCxJQUFJdUIsUUFBUUMsU0FBUyxDQUFDb08sYUFBYTdULE9BQU95UyxPQUFPLENBQUNwVCxRQUFRd1UsYUFBYTlRLEtBQUtDLE1BQU0sQ0FBQzZRLGFBQWFBLFNBQVN6TyxJQUFJLEtBQUssTUFBTTBPLFFBQVEsQ0FBQ0EsU0FBU3BhLE1BQU0sR0FBRyxFQUFFLEtBQUssR0FBRztnQkFDM0oySSxXQUFXK0QsV0FBVyxDQUFDL0csUUFBUTtvQkFDN0JzRyxJQUFJbU87b0JBQ0o3UCxPQUFPQTtnQkFDVDtZQUNGLE9BQU87Z0JBQ0w1RSxPQUFPdEIsS0FBSyxDQUFDO29CQUNYeUUsTUFBTTtvQkFDTmpCLE1BQU1PO29CQUNONGIsVUFBVUE7b0JBQ1ZyQixZQUFZQTtnQkFDZDtZQUNGO1lBRUEsSUFBSWtNLFVBQVU7Z0JBQ1pBLFNBQVM3USxLQUFLO1lBQ2hCO1FBQ0Y7SUFDRjtJQUVBOztHQUVDLEdBQ0RtUSxXQUFXLFNBQVNBLFVBQVV4b0IsTUFBTSxFQUFFZ1IsT0FBTztRQUMzQ3JRLE9BQU9zVyxrQkFBa0IsQ0FBQ2pYLFFBQVE7WUFDaEMsSUFBSW9WLEtBQUtwRSxRQUFRb0UsRUFBRSxFQUNmSixlQUFlaEUsUUFBUTFLLEVBQUUsRUFDekJBLEtBQUswTyxpQkFBaUIsS0FBSyxJQUFJaFYsT0FBT0csU0FBUyxHQUFHNlUsY0FDbEQ4RSxpQkFBaUI5SSxRQUFRRyxJQUFJLEVBQzdCQSxPQUFPMkksbUJBQW1CLEtBQUssSUFBSSxXQUFXQSxnQkFDOUMvRCxrQkFBa0IvRSxRQUFRcE0sS0FBSyxFQUMvQkEsUUFBUW1SLG9CQUFvQixLQUFLLElBQUksUUFBUUE7WUFDakQsSUFBSXZTLFFBQVF3TixRQUFReE4sS0FBSztZQUV6QixJQUFJLENBQUM4QyxJQUFJO2dCQUNQO1lBQ0Y7WUFFQSxJQUFJOUMsU0FBUyxNQUFNO2dCQUNqQkEsUUFBUW5CLEtBQUtpVCxNQUFNLENBQUNoUCxNQUFNNmhCLFVBQVVub0IsUUFBUXNHLE1BQU0sU0FBVWhMLENBQUM7b0JBQzNELE9BQU82SyxRQUFRQyxTQUFTLENBQUM5SyxNQUFNcUYsT0FBTytSLE9BQU8sQ0FBQzFTLFFBQVExRTtnQkFDeEQ7WUFDRjtZQUVBLElBQUk2dEIsUUFBUXhvQixPQUFPc1gsT0FBTyxDQUFDalksUUFBUW9WO1lBQ25DLElBQUlnVSxVQUFVem9CLE9BQU9xSCxLQUFLLENBQUNoSSxRQUFRO2dCQUNqQ3NHLElBQUlBO2dCQUNKOUMsT0FBT0E7Z0JBQ1AyTixNQUFNQTtnQkFDTnZNLE9BQU9BO1lBQ1Q7WUFDQSxJQUFJaEUsV0FBV3BHLE1BQU1TLElBQUksQ0FBQ211QixTQUFTLFNBQVV6ZixLQUFLO2dCQUNoRCxJQUFJMGYsUUFBUTdyQixlQUFlbU0sT0FBTyxJQUM5QnhCLElBQUlraEIsS0FBSyxDQUFDLEVBQUU7Z0JBRWhCLE9BQU8xb0IsT0FBT3NYLE9BQU8sQ0FBQ2pZLFFBQVFtSTtZQUNoQztZQUVBLElBQUssSUFBSW1oQixNQUFNLEdBQUdDLGFBQWEzb0IsVUFBVTBvQixNQUFNQyxXQUFXbHZCLE1BQU0sRUFBRWl2QixNQUFPO2dCQUN2RSxJQUFJclIsVUFBVXNSLFVBQVUsQ0FBQ0QsSUFBSTtnQkFDN0IsSUFBSXBuQixPQUFPK1YsUUFBUUksS0FBSztnQkFDeEIsSUFBSTVWLFVBQVUwbUIsTUFBTS9RLE9BQU87Z0JBRTNCLElBQUlsVyxLQUFLN0gsTUFBTSxLQUFLLEdBQUc7b0JBQ3JCMkYsT0FBT3RCLEtBQUssQ0FBQzt3QkFDWHlFLE1BQU07d0JBQ05qQixNQUFNQTt3QkFDTk8sU0FBU0E7b0JBQ1g7Z0JBQ0Y7Z0JBRUEsSUFBSTBtQixNQUFNL1EsT0FBTyxJQUFJL1YsS0FBS3FjLFNBQVMsQ0FBQ2pjLFNBQVNQLFNBQVNHLEtBQUtzYixPQUFPLENBQUNsYixTQUFTUCxPQUFPO29CQUNqRiwwRkFBMEY7b0JBQzFGLDRGQUE0RjtvQkFDNUYsOERBQThEO29CQUM5RGluQixNQUFNL1EsT0FBTyxHQUFHL1YsS0FBS3BGLElBQUksQ0FBQ2tzQixNQUFNL1EsT0FBTztnQkFDekM7WUFDRjtZQUVBK1EsTUFBTTlRLEtBQUs7UUFDYjtJQUNGO0lBRUE7O0dBRUMsR0FDRHRSLGFBQWEsU0FBU0EsWUFBWS9HLE1BQU07UUFDdEMsSUFBSWdSLFVBQVVuUyxVQUFVeEUsTUFBTSxHQUFHLEtBQUt3RSxTQUFTLENBQUMsRUFBRSxLQUFLa00sWUFBWWxNLFNBQVMsQ0FBQyxFQUFFLEdBQUcsQ0FBQztRQUNuRjhCLE9BQU9zVyxrQkFBa0IsQ0FBQ2pYLFFBQVE7WUFDaEMsSUFBSXdwQixvQkFBb0J4WSxRQUFRNFcsT0FBTyxFQUNuQ0EsVUFBVTRCLHNCQUFzQixLQUFLLElBQUksUUFBUUEsbUJBQ2pEclEsa0JBQWtCbkksUUFBUXBNLEtBQUssRUFDL0JBLFFBQVF1VSxvQkFBb0IsS0FBSyxJQUFJLFFBQVFBLGlCQUM3Q3NRLGlCQUFpQnpZLFFBQVFHLElBQUksRUFDN0JBLE9BQU9zWSxtQkFBbUIsS0FBSyxJQUFJLFdBQVdBO1lBQ2xELElBQUkvVCxlQUFlMUUsUUFBUTFLLEVBQUUsRUFDekJBLEtBQUtvUCxpQkFBaUIsS0FBSyxJQUFJMVYsT0FBT0csU0FBUyxHQUFHdVYsY0FDbERsUyxRQUFRd04sUUFBUXhOLEtBQUs7WUFFekIsSUFBSSxDQUFDOEMsSUFBSTtnQkFDUDtZQUNGO1lBRUEsSUFBSTlDLFNBQVMsTUFBTTtnQkFDakJBLFFBQVFuQixLQUFLaVQsTUFBTSxDQUFDaFAsTUFBTTZoQixVQUFVbm9CLFFBQVFzRyxNQUFNLFNBQVVoTCxDQUFDO29CQUMzRCxPQUFPNkssUUFBUUMsU0FBUyxDQUFDOUssTUFBTXFGLE9BQU8rUixPQUFPLENBQUMxUyxRQUFRMUU7Z0JBQ3hEO1lBQ0Y7WUFFQSxJQUFJLENBQUNzc0IsV0FBVzNqQixNQUFNcU4sT0FBTyxDQUFDaEwsS0FBSztnQkFDakNBLEtBQUszRixPQUFPcWEsV0FBVyxDQUFDaGIsUUFBUXNHLElBQUk7b0JBQ2xDMUIsT0FBT0E7Z0JBQ1Q7WUFDRjtZQUVBLElBQUk4a0IsU0FBUy9vQixPQUFPcUgsS0FBSyxDQUFDaEksUUFBUTtnQkFDaENzRyxJQUFJQTtnQkFDSjlDLE9BQU9BO2dCQUNQMk4sTUFBTUE7Z0JBQ052TSxPQUFPQTtZQUNUO1lBQ0EsSUFBSWhFLFdBQVdwRyxNQUFNUyxJQUFJLENBQUN5dUIsUUFBUSxTQUFVQyxLQUFLO2dCQUMvQyxJQUFJQyxRQUFRcHNCLGVBQWVtc0IsT0FBTyxJQUM5QnhoQixJQUFJeWhCLEtBQUssQ0FBQyxFQUFFO2dCQUVoQixPQUFPanBCLE9BQU9zWCxPQUFPLENBQUNqWSxRQUFRbUk7WUFDaEM7WUFFQSxJQUFLLElBQUkwaEIsTUFBTSxHQUFHQyxhQUFhbHBCLFVBQVVpcEIsTUFBTUMsV0FBV3p2QixNQUFNLEVBQUV3dkIsTUFBTztnQkFDdkUsSUFBSTVSLFVBQVU2UixVQUFVLENBQUNELElBQUk7Z0JBQzdCLElBQUkzbkIsT0FBTytWLFFBQVFJLEtBQUs7Z0JBRXhCLElBQUluVyxNQUFNO29CQUNSLElBQUlrQyxlQUFlekQsT0FBTzhDLElBQUksQ0FBQ3pELFFBQVFrQyxPQUNuQ21DLGdCQUFnQjdHLGVBQWU0RyxjQUFjLElBQzdDWCxPQUFPWSxhQUFhLENBQUMsRUFBRTtvQkFFM0JyRSxPQUFPdEIsS0FBSyxDQUFDO3dCQUNYeUUsTUFBTTt3QkFDTmpCLE1BQU1BO3dCQUNOdUIsTUFBTUE7b0JBQ1I7Z0JBQ0Y7WUFDRjtRQUNGO0lBQ0Y7SUFFQTs7R0FFQyxHQUNEaUIsVUFBVSxTQUFTQSxTQUFTMUUsTUFBTSxFQUFFaVEsS0FBSztRQUN2QyxJQUFJZSxVQUFVblMsVUFBVXhFLE1BQU0sR0FBRyxLQUFLd0UsU0FBUyxDQUFDLEVBQUUsS0FBS2tNLFlBQVlsTSxTQUFTLENBQUMsRUFBRSxHQUFHLENBQUM7UUFDbkY4QixPQUFPc1csa0JBQWtCLENBQUNqWCxRQUFRO1lBQ2hDLElBQUl3RCxRQUFRd04sUUFBUXhOLEtBQUssRUFDckJ3VixlQUFlaEksUUFBUTFLLEVBQUUsRUFDekJBLEtBQUswUyxpQkFBaUIsS0FBSyxJQUFJaFosT0FBT0csU0FBUyxHQUFHNlksY0FDbER6QyxVQUFVdkYsUUFBUXVGLE9BQU8sRUFDekJ3VCxRQUFRL1ksUUFBUStZLEtBQUs7WUFDekIsSUFBSUMsb0JBQW9CaFosUUFBUTRXLE9BQU8sRUFDbkNBLFVBQVVvQyxzQkFBc0IsS0FBSyxJQUFJLFFBQVFBLG1CQUNqREMsaUJBQWlCalosUUFBUUcsSUFBSSxFQUM3QkEsT0FBTzhZLG1CQUFtQixLQUFLLElBQUksV0FBV0EsZ0JBQzlDQyxpQkFBaUJsWixRQUFRck0sS0FBSyxFQUM5QkEsUUFBUXVsQixtQkFBbUIsS0FBSyxJQUFJLFFBQVFBLGdCQUM1Q25RLGtCQUFrQi9JLFFBQVFwTSxLQUFLLEVBQy9CQSxRQUFRbVYsb0JBQW9CLEtBQUssSUFBSSxRQUFRQTtZQUVqRCxJQUFJLENBQUN6VCxJQUFJO2dCQUNQO1lBQ0Y7WUFFQSxJQUFJOUMsU0FBUyxNQUFNO2dCQUNqQkEsUUFBUW5CLEtBQUtpVCxNQUFNLENBQUNoUCxNQUFNNmhCLFVBQVVub0IsUUFBUXNHLE1BQU0sU0FBVWhMLENBQUM7b0JBQzNELE9BQU82SyxRQUFRQyxTQUFTLENBQUM5SyxNQUFNcUYsT0FBTytSLE9BQU8sQ0FBQzFTLFFBQVExRTtnQkFDeEQ7WUFDRjtZQUVBLElBQUksQ0FBQ3NzQixXQUFXM2pCLE1BQU1xTixPQUFPLENBQUNoTCxLQUFLO2dCQUNqQ0EsS0FBSzNGLE9BQU9xYSxXQUFXLENBQUNoYixRQUFRc0csSUFBSTtvQkFDbEMxQixPQUFPQTtnQkFDVDtZQUNGO1lBRUEsSUFBSUQsU0FBU1YsTUFBTXFOLE9BQU8sQ0FBQ2hMLEtBQUs7Z0JBQzlCLElBQUlyQyxNQUFNYyxXQUFXLENBQUN1QixPQUFPM0YsT0FBTzhTLElBQUksQ0FBQ3pULFFBQVFzRyxHQUFHaUwsTUFBTSxDQUFDLENBQUMsRUFBRSxDQUFDeEwsSUFBSSxDQUFDMUwsTUFBTSxHQUFHLEdBQUc7b0JBQzlFLHdGQUF3RjtvQkFDeEYscUNBQXFDO29CQUNyQztnQkFDRjtnQkFFQSxJQUFJaWdCLFdBQVczWixPQUFPMlosUUFBUSxDQUFDdGEsUUFBUXNHLElBQUk7b0JBQ3pDNlIsVUFBVTtnQkFDWjtnQkFFQSxJQUFJdUMsZ0JBQWdCelcsTUFBTXFPLEtBQUssQ0FBQ2hNLEtBQzVCcVUsZ0JBQWdCbmQsZUFBZWtkLGVBQWUsSUFDOUN6SSxRQUFRMEksYUFBYSxDQUFDLEVBQUUsRUFDeEJuTixNQUFNbU4sYUFBYSxDQUFDLEVBQUU7Z0JBRTFCLElBQUl3UCxZQUFZaFosU0FBUyxXQUFXLFdBQVc7Z0JBQy9DLElBQUlpWixpQkFBaUJ6cEIsT0FBT3FTLEtBQUssQ0FBQ2hULFFBQVF3TixLQUFLQSxJQUFJdEwsSUFBSTtnQkFDdkRjLFdBQVd3QyxVQUFVLENBQUN4RixRQUFRO29CQUM1QnNHLElBQUlrSDtvQkFDSmhLLE9BQU9BO29CQUNQMk4sTUFBTWdaO29CQUNOdmxCLE9BQU9BO29CQUNQYSxRQUFRLENBQUMya0I7Z0JBQ1g7Z0JBQ0EsSUFBSUMscUJBQXFCMXBCLE9BQU93UyxPQUFPLENBQUNuVCxRQUFRaVMsT0FBT0EsTUFBTS9QLElBQUk7Z0JBQ2pFYyxXQUFXd0MsVUFBVSxDQUFDeEYsUUFBUTtvQkFDNUJzRyxJQUFJMkw7b0JBQ0p6TyxPQUFPQTtvQkFDUDJOLE1BQU1nWjtvQkFDTnZsQixPQUFPQTtvQkFDUGEsUUFBUSxDQUFDNGtCO2dCQUNYO2dCQUNBL2pCLEtBQUtnVSxTQUFTakMsS0FBSztnQkFFbkIsSUFBSXJILFFBQVExSyxFQUFFLElBQUksTUFBTTtvQkFDdEJ0RCxXQUFXNmtCLE1BQU0sQ0FBQzduQixRQUFRc0c7Z0JBQzVCO1lBQ0Y7WUFFQSxJQUFJLENBQUNpUSxTQUFTO2dCQUNaQSxVQUFVLFNBQVNBLFFBQVErVCxJQUFJLEVBQUVDLFFBQVE7b0JBQ3ZDLE9BQU9ELFNBQVNDO2dCQUNsQjtZQUNGO1lBRUEsSUFBSXRwQixhQUFhc21CLDZCQUE2QjVtQixPQUFPcUgsS0FBSyxDQUFDaEksUUFBUTtnQkFDakVzRyxJQUFJQTtnQkFDSjlDLE9BQU9BO2dCQUNQMk4sTUFBTUE7Z0JBQ052TSxPQUFPQTtZQUNULEtBQ0l6RDtZQUVKLElBQUk7Z0JBQ0YsSUFBS0YsV0FBVzFCLENBQUMsSUFBSSxDQUFDLENBQUM0QixTQUFTRixXQUFXM0YsQ0FBQyxFQUFDLEVBQUc0QixJQUFJLEVBQUc7b0JBQ3JELElBQUkwZixlQUFlcGYsZUFBZTJELE9BQU8vSCxLQUFLLEVBQUUsSUFDNUNxSyxPQUFPbVosWUFBWSxDQUFDLEVBQUUsRUFDdEIxYSxPQUFPMGEsWUFBWSxDQUFDLEVBQUU7b0JBRTFCLElBQUlJLGFBQWEsQ0FBQztvQkFDbEIsSUFBSXNCLGdCQUFnQixDQUFDLEdBQUcsK0NBQStDO29CQUV2RSxJQUFJcGMsS0FBSzdILE1BQU0sS0FBSyxHQUFHO3dCQUNyQjtvQkFDRjtvQkFFQSxJQUFJbXdCLGFBQWE7b0JBRWpCLElBQUssSUFBSUMsS0FBS3hhLE1BQU87d0JBQ25CLElBQUl3YSxNQUFNLGNBQWNBLE1BQU0sUUFBUTs0QkFDcEM7d0JBQ0Y7d0JBRUEsSUFBSWxVLFFBQVF0RyxLQUFLLENBQUN3YSxFQUFFLEVBQUVobkIsSUFBSSxDQUFDZ25CLEVBQUUsR0FBRzs0QkFDOUJELGFBQWEsTUFBTSxtREFBbUQ7NEJBRXRFLElBQUkvbUIsS0FBSzdKLGNBQWMsQ0FBQzZ3QixJQUFJek4sVUFBVSxDQUFDeU4sRUFBRSxHQUFHaG5CLElBQUksQ0FBQ2duQixFQUFFLEVBQUUsc0VBQXNFOzRCQUUzSCxJQUFJVixPQUFPO2dDQUNULElBQUk5WixLQUFLLENBQUN3YSxFQUFFLElBQUksTUFBTW5NLGFBQWEsQ0FBQ21NLEVBQUUsR0FBR1YsTUFBTXRtQixJQUFJLENBQUNnbkIsRUFBRSxFQUFFeGEsS0FBSyxDQUFDd2EsRUFBRTs0QkFDbEUsT0FBTztnQ0FDTCxJQUFJeGEsS0FBSyxDQUFDd2EsRUFBRSxJQUFJLE1BQU1uTSxhQUFhLENBQUNtTSxFQUFFLEdBQUd4YSxLQUFLLENBQUN3YSxFQUFFOzRCQUNuRDt3QkFDRjtvQkFDRjtvQkFFQSxJQUFJRCxZQUFZO3dCQUNkeHFCLE9BQU90QixLQUFLLENBQUM7NEJBQ1h5RSxNQUFNOzRCQUNOakIsTUFBTUE7NEJBQ044YSxZQUFZQTs0QkFDWnNCLGVBQWVBO3dCQUNqQjtvQkFDRjtnQkFDRjtZQUNGLEVBQUUsT0FBT2xoQixLQUFLO2dCQUNaNkQsV0FBV3pCLENBQUMsQ0FBQ3BDO1lBQ2YsU0FBVTtnQkFDUjZELFdBQVd4QixDQUFDO1lBQ2Q7UUFDRjtJQUNGO0lBRUE7O0dBRUMsR0FDRCtGLFlBQVksU0FBU0EsV0FBV3hGLE1BQU07UUFDcEMsSUFBSWdSLFVBQVVuUyxVQUFVeEUsTUFBTSxHQUFHLEtBQUt3RSxTQUFTLENBQUMsRUFBRSxLQUFLa00sWUFBWWxNLFNBQVMsQ0FBQyxFQUFFLEdBQUcsQ0FBQztRQUNuRjhCLE9BQU9zVyxrQkFBa0IsQ0FBQ2pYLFFBQVE7WUFDaEMsSUFBSTBxQixpQkFBaUIxWixRQUFRRyxJQUFJLEVBQzdCQSxPQUFPdVosbUJBQW1CLEtBQUssSUFBSSxXQUFXQSxnQkFDOUNqUSxrQkFBa0J6SixRQUFRcE0sS0FBSyxFQUMvQkEsUUFBUTZWLG9CQUFvQixLQUFLLElBQUksUUFBUUE7WUFDakQsSUFBSWpYLFFBQVF3TixRQUFReE4sS0FBSyxFQUNyQndXLGVBQWVoSixRQUFRMUssRUFBRSxFQUN6QkEsS0FBSzBULGlCQUFpQixLQUFLLElBQUloYSxPQUFPRyxTQUFTLEdBQUc2WixjQUNsRDJRLGtCQUFrQjNaLFFBQVE0WixNQUFNLEVBQ2hDQSxTQUFTRCxvQkFBb0IsS0FBSyxJQUFJLElBQUlBLGlCQUMxQ0Usa0JBQWtCN1osUUFBUXZMLE1BQU0sRUFDaENBLFNBQVNvbEIsb0JBQW9CLEtBQUssSUFBSSxRQUFRQTtZQUVsRCxJQUFJcm5CLFNBQVMsTUFBTTtnQkFDakJBLFFBQVEsU0FBU0EsTUFBTWxJLENBQUM7b0JBQ3RCLE9BQU82SyxRQUFRQyxTQUFTLENBQUM5SyxNQUFNcUYsT0FBTytSLE9BQU8sQ0FBQzFTLFFBQVExRTtnQkFDeEQ7WUFDRjtZQUVBLElBQUkySSxNQUFNcU4sT0FBTyxDQUFDaEwsS0FBSztnQkFDckJBLEtBQUt3a0IsWUFBWTlxQixRQUFRc0c7WUFDM0IsRUFBRSxvRUFBb0U7WUFDdEUsdUVBQXVFO1lBR3ZFLElBQUlqRSxLQUFLaVQsTUFBTSxDQUFDaFAsS0FBSztnQkFDbkIsSUFBSXBFLE9BQU9vRTtnQkFDWCxJQUFJb0wsUUFBUS9RLE9BQU8rUSxLQUFLLENBQUMxUixRQUFRa0M7Z0JBRWpDLElBQUlzQyxrQkFBa0I3RCxPQUFPa0QsTUFBTSxDQUFDN0QsUUFBUWtDLE9BQ3hDdUMsa0JBQWtCakgsZUFBZWdILGlCQUFpQixJQUNsRFgsU0FBU1ksZUFBZSxDQUFDLEVBQUU7Z0JBRS9CakIsUUFBUSxTQUFTQSxNQUFNbEksQ0FBQztvQkFDdEIsT0FBT0EsTUFBTXVJO2dCQUNmO2dCQUVBK21CLFNBQVNsWixNQUFNeFAsSUFBSSxDQUFDN0gsTUFBTSxHQUFHNkgsS0FBSzdILE1BQU0sR0FBRztnQkFDM0NpTSxLQUFLb0w7Z0JBQ0xqTSxTQUFTO1lBQ1g7WUFFQSxJQUFJLENBQUNhLElBQUk7Z0JBQ1A7WUFDRjtZQUVBLElBQUl5a0IsWUFBWXBxQixPQUFPbVksUUFBUSxDQUFDOVksUUFBUXNHLElBQUk7Z0JBQzFDNlIsVUFBVTtZQUNaO1lBQ0EsSUFBSTZTO1lBRUosSUFBSTtnQkFDRixJQUFJNVEsaUJBQWlCelosT0FBT3FILEtBQUssQ0FBQ2hJLFFBQVE7b0JBQ3hDc0csSUFBSUE7b0JBQ0o5QyxPQUFPQTtvQkFDUDJOLE1BQU1BO29CQUNOdk0sT0FBT0E7Z0JBQ1QsSUFDSXlWLGlCQUFpQjdjLGVBQWU0YyxnQkFBZ0IsSUFDaEQ2USxVQUFVNVEsY0FBYyxDQUFDLEVBQUU7Z0JBRS9CLElBQUksQ0FBQzRRLFNBQVM7b0JBQ1o7Z0JBQ0Y7Z0JBRUEsSUFBSUMsWUFBWXZxQixNQUFNLENBQUMsT0FBTyxDQUFDWCxRQUFRO29CQUNyQ3NHLElBQUlBO29CQUNKNkssTUFBTTtnQkFDUjtnQkFDQSxJQUFJZ2EsUUFBUTtnQkFFWixJQUFJLENBQUN2bUIsU0FBU3NtQixXQUFXO29CQUN2QixJQUFJRSxhQUFhNXRCLGVBQWUwdEIsV0FBVyxJQUN2Q0csV0FBV0QsVUFBVSxDQUFDLEVBQUUsRUFDeEJFLFdBQVdGLFVBQVUsQ0FBQyxFQUFFO29CQUU1QixJQUFJamxCLFFBQVFDLFNBQVMsQ0FBQ2lsQixhQUFhcnJCLE9BQU9LLFFBQVEsQ0FBQ2dyQixXQUFXO3dCQUM1RCxJQUFJNVosUUFBUTlRLE9BQU84USxLQUFLLENBQUN6UixRQUFRc3JCO3dCQUVqQyxJQUFJLENBQUM3WixPQUFPOzRCQUNWLElBQUkxTCxPQUFPO2dDQUNUQSxNQUFNOzRCQUNSOzRCQUNBLElBQUl3bEIsWUFBWWxwQixLQUFLcEYsSUFBSSxDQUFDcXVCOzRCQUMxQnRvQixXQUFXNkMsV0FBVyxDQUFDN0YsUUFBUStGLE1BQU07Z0NBQ25DTyxJQUFJaWxCO2dDQUNKM21CLE9BQU9BOzRCQUNUOzRCQUNBNk0sUUFBUTlRLE9BQU8rUSxLQUFLLENBQUMxUixRQUFRdXJCO3dCQUMvQjt3QkFFQWpsQixLQUFLbUw7d0JBQ0xoTSxTQUFTO29CQUNYO29CQUVBLElBQUkrbEIsZ0JBQWdCbGxCLEdBQUdwRSxJQUFJLENBQUM3SCxNQUFNLEdBQUdpeEIsU0FBU2p4QixNQUFNO29CQUNwRHV3QixTQUFTWSxnQkFBZ0I7b0JBQ3pCL2xCLFNBQVM7Z0JBQ1g7Z0JBRUF1bEIsV0FBV3JxQixPQUFPbVksUUFBUSxDQUFDOVksUUFBUXNHO2dCQUNuQyxJQUFJaVIsUUFBUWpSLEdBQUdwRSxJQUFJLENBQUM3SCxNQUFNLEdBQUd1d0I7Z0JBRTdCLElBQUlhLFdBQVdqdUIsZUFBZXl0QixTQUFTLElBQ25DUyxjQUFjRCxRQUFRLENBQUMsRUFBRTtnQkFFN0IsSUFBSUUsYUFBYXJsQixHQUFHcEUsSUFBSSxDQUFDMUcsS0FBSyxDQUFDLEdBQUcrYjtnQkFDbEMsSUFBSThHLFdBQVd1TSxXQUFXLElBQUl0a0IsR0FBR2lOLE1BQU0sR0FBR2pOLEdBQUdwRSxJQUFJLENBQUNxVixNQUFNLEdBQUc0VDtnQkFFM0QsSUFBSTdwQixhQUFhaW1CLDZCQUE2QjVtQixPQUFPa0gsTUFBTSxDQUFDN0gsUUFBUTtvQkFDbEVzRyxJQUFJcWxCO29CQUNKM21CLFNBQVM7b0JBQ1RKLE9BQU9BO2dCQUNULEtBQ0lwRDtnQkFFSixJQUFJO29CQUNGLElBQUtGLFdBQVcvQixDQUFDLElBQUksQ0FBQyxDQUFDaUMsU0FBU0YsV0FBV2hHLENBQUMsRUFBQyxFQUFHNEIsSUFBSSxFQUFHO3dCQUNyRCxJQUFJNGYsZUFBZXRmLGVBQWVnRSxPQUFPcEksS0FBSyxFQUFFLElBQzVDcUssT0FBT3FaLFlBQVksQ0FBQyxFQUFFLEVBQ3RCaFYsU0FBU2dWLFlBQVksQ0FBQyxFQUFFO3dCQUU1QixJQUFJblksUUFBUTt3QkFFWixJQUFJbUQsT0FBT3pOLE1BQU0sR0FBR3F4QixZQUFZcnhCLE1BQU0sSUFBSXlOLE9BQU96TixNQUFNLEtBQUssS0FBSyxDQUFDdUssU0FBU3VCLFFBQVFDLFNBQVMsQ0FBQzNDLFNBQVM5QyxPQUFPTCxNQUFNLENBQUNOLFFBQVF5RCxPQUFPOzRCQUNqSTt3QkFDRjt3QkFFQSxJQUFJa2hCLFVBQVVvRyxVQUFVM1MsT0FBTzt3QkFDL0IsSUFBSXBGLFFBQVFyUyxPQUFPcVMsS0FBSyxDQUFDaFQsUUFBUTJrQixTQUFTN2M7d0JBRTFDLElBQUlyQyxVQUFVLENBQUNzbEIsYUFBYSxDQUFDcHFCLE9BQU91UyxNQUFNLENBQUNsVCxRQUFRMmtCLFNBQVM3YyxTQUFTOzRCQUNuRW5ELFFBQVE7NEJBQ1IsSUFBSXFZLGFBQWEzWCxLQUFLMFgsWUFBWSxDQUFDdFo7NEJBQ25DekQsT0FBT3RCLEtBQUssQ0FBQztnQ0FDWHlFLE1BQU07Z0NBQ05qQixNQUFNNEY7Z0NBQ051VyxVQUFVQTtnQ0FDVnJCLFlBQVlBOzRCQUNkO3dCQUNGO3dCQUVBcUIsV0FBV3ZXLE1BQU0sQ0FBQ0EsT0FBT3pOLE1BQU0sR0FBRyxFQUFFLEdBQUlzSyxDQUFBQSxTQUFTcU8sUUFBUSxJQUFJO29CQUMvRDtnQkFDRixFQUFFLE9BQU81VixLQUFLO29CQUNaa0UsV0FBVzlCLENBQUMsQ0FBQ3BDO2dCQUNmLFNBQVU7b0JBQ1JrRSxXQUFXN0IsQ0FBQztnQkFDZDtnQkFFQSxJQUFJdVIsUUFBUTFLLEVBQUUsSUFBSSxNQUFNO29CQUN0QixJQUFJaWUsU0FBU3lHLFNBQVM1UyxPQUFPLElBQUl6WCxPQUFPNk0sR0FBRyxDQUFDeE4sUUFBUSxFQUFFO29CQUV0RGdELFdBQVc2a0IsTUFBTSxDQUFDN25CLFFBQVF1a0I7Z0JBQzVCO1lBQ0YsU0FBVTtnQkFDUixJQUFJcUg7Z0JBRUpiLFVBQVUxUyxLQUFLO2dCQUNkdVQsQ0FBQUEsWUFBWVosUUFBTyxNQUFPLFFBQVFZLGNBQWMsS0FBSyxJQUFJLEtBQUssSUFBSUEsVUFBVXZULEtBQUs7WUFDcEY7UUFDRjtJQUNGO0lBRUE7O0dBRUMsR0FDRHpRLFlBQVksU0FBU0EsV0FBVzVILE1BQU0sRUFBRWlRLEtBQUs7UUFDM0MsSUFBSWUsVUFBVW5TLFVBQVV4RSxNQUFNLEdBQUcsS0FBS3dFLFNBQVMsQ0FBQyxFQUFFLEtBQUtrTSxZQUFZbE0sU0FBUyxDQUFDLEVBQUUsR0FBRyxDQUFDO1FBRW5GLElBQUksQ0FBQ3JFLE1BQU1HLE9BQU8sQ0FBQ3NWLFFBQVE7WUFDekJBLFFBQVE7Z0JBQUNBO2FBQU07UUFDakI7UUFFQSxJQUFJL1QsTUFBTSxDQUFDO1FBRVgsSUFBSXFHLGFBQWFnbEIsNkJBQTZCdFgsUUFDMUN6TjtRQUVKLElBQUk7WUFDRixJQUFLRCxXQUFXaEQsQ0FBQyxJQUFJLENBQUMsQ0FBQ2lELFNBQVNELFdBQVdqSCxDQUFDLEVBQUMsRUFBRzRCLElBQUksRUFBRztnQkFDckQsSUFBSWYsTUFBTXFHLE9BQU9wSixLQUFLO2dCQUN0QjhDLEdBQUcsQ0FBQ0MsSUFBSSxHQUFHO1lBQ2I7UUFDRixFQUFFLE9BQU9pQixLQUFLO1lBQ1ptRixXQUFXL0MsQ0FBQyxDQUFDcEM7UUFDZixTQUFVO1lBQ1JtRixXQUFXOUMsQ0FBQztRQUNkO1FBRUF1RCxXQUFXMEIsUUFBUSxDQUFDMUUsUUFBUTlELEtBQUs4VTtJQUNuQztJQUVBOzs7R0FHQyxHQUNENmEsYUFBYSxTQUFTQSxZQUFZN3JCLE1BQU07UUFDdEMsSUFBSWdSLFVBQVVuUyxVQUFVeEUsTUFBTSxHQUFHLEtBQUt3RSxTQUFTLENBQUMsRUFBRSxLQUFLa00sWUFBWWxNLFNBQVMsQ0FBQyxFQUFFLEdBQUcsQ0FBQztRQUNuRjhCLE9BQU9zVyxrQkFBa0IsQ0FBQ2pYLFFBQVE7WUFDaEMsSUFBSThyQixpQkFBaUI5YSxRQUFRRyxJQUFJLEVBQzdCQSxPQUFPMmEsbUJBQW1CLEtBQUssSUFBSSxXQUFXQSxnQkFDOUNDLGtCQUFrQi9hLFFBQVFyTSxLQUFLLEVBQy9CQSxRQUFRb25CLG9CQUFvQixLQUFLLElBQUksUUFBUUEsaUJBQzdDOVEsa0JBQWtCakssUUFBUXBNLEtBQUssRUFDL0JBLFFBQVFxVyxvQkFBb0IsS0FBSyxJQUFJLFFBQVFBO1lBQ2pELElBQUkrUSxlQUFlaGIsUUFBUTFLLEVBQUUsRUFDekJBLEtBQUswbEIsaUJBQWlCLEtBQUssSUFBSWhzQixPQUFPRyxTQUFTLEdBQUc2ckIsY0FDbER4b0IsUUFBUXdOLFFBQVF4TixLQUFLO1lBRXpCLElBQUksQ0FBQzhDLElBQUk7Z0JBQ1A7WUFDRjtZQUVBLElBQUk5QyxTQUFTLE1BQU07Z0JBQ2pCQSxRQUFRbkIsS0FBS2lULE1BQU0sQ0FBQ2hQLE1BQU02aEIsVUFBVW5vQixRQUFRc0csTUFBTSxTQUFVaEwsQ0FBQztvQkFDM0QsT0FBTzZLLFFBQVFDLFNBQVMsQ0FBQzlLLE1BQU1xRixPQUFPK1IsT0FBTyxDQUFDMVMsUUFBUTFFO2dCQUN4RDtZQUNGO1lBRUEsSUFBSStHLEtBQUtpVCxNQUFNLENBQUNoUCxLQUFLO2dCQUNuQkEsS0FBSzNGLE9BQU9pUixLQUFLLENBQUM1UixRQUFRc0c7WUFDNUI7WUFFQSxJQUFJZ1UsV0FBV3JXLE1BQU1xTixPQUFPLENBQUNoTCxNQUFNM0YsT0FBTzJaLFFBQVEsQ0FBQ3RhLFFBQVFzRyxNQUFNO1lBQ2pFLElBQUkrSixVQUFVMVAsT0FBT3FILEtBQUssQ0FBQ2hJLFFBQVE7Z0JBQ2pDc0csSUFBSUE7Z0JBQ0o5QyxPQUFPQTtnQkFDUDJOLE1BQU1BO2dCQUNOdk0sT0FBT0E7WUFDVDtZQUNBLElBQUloRSxXQUFXcEcsTUFBTVMsSUFBSSxDQUFDb1YsU0FBUyxTQUFVNGIsS0FBSztnQkFDaEQsSUFBSUMsU0FBUzF1QixlQUFleXVCLE9BQU8sSUFDL0I5akIsSUFBSStqQixNQUFNLENBQUMsRUFBRTtnQkFFakIsT0FBT3ZyQixPQUFPc1gsT0FBTyxDQUFDalksUUFBUW1JO1lBQ2hDLEVBQUUsdUZBQXVGO2NBR3ZGbkQsT0FBTztZQUVULElBQUlwQyxhQUFhMmtCLDZCQUE2QjNtQixXQUMxQ2lDO1lBRUosSUFBSTtnQkFDRixJQUFJc3BCLFFBQVEsU0FBU0E7b0JBQ25CLElBQUlsVSxVQUFVcFYsT0FBT3pKLEtBQUs7b0JBQzFCLElBQUk4SSxPQUFPK1YsUUFBUUksS0FBSztvQkFFeEIsSUFBSTdRLGdCQUFnQjdHLE9BQU84QyxJQUFJLENBQUN6RCxRQUFRa0MsT0FDcEN1RixnQkFBZ0JqSyxlQUFlZ0ssZUFBZSxJQUM5Qy9ELE9BQU9nRSxhQUFhLENBQUMsRUFBRTtvQkFFM0IsSUFBSW1LLFFBQVFqUixPQUFPaVIsS0FBSyxDQUFDNVIsUUFBUWtDO29CQUVqQyxJQUFJeUMsU0FBUzJWLFVBQVU7d0JBQ3JCMUksUUFBUTNOLE1BQU1tZCxZQUFZLENBQUM5RyxTQUFTbEMsT0FBTyxFQUFFeEc7b0JBQy9DO29CQUVBNU8sV0FBV2tsQixTQUFTLENBQUNsb0IsUUFBUTt3QkFDM0JzRyxJQUFJc0w7d0JBQ0pwTyxPQUFPLFNBQVNBLE1BQU1sSSxDQUFDOzRCQUNyQixPQUFPNkssUUFBUXlKLFVBQVUsQ0FBQ25NLFNBQVNBLEtBQUt4RCxRQUFRLENBQUNzVixRQUFRLENBQUNqYTt3QkFDNUQ7d0JBQ0FzSixPQUFPQTtvQkFDVDtnQkFDRjtnQkFFQSxJQUFLaEMsV0FBV3JELENBQUMsSUFBSSxDQUFDLENBQUNzRCxTQUFTRCxXQUFXdEgsQ0FBQyxFQUFDLEVBQUc0QixJQUFJLEVBQUc7b0JBQ3JEaXZCO2dCQUNGO1lBQ0YsRUFBRSxPQUFPL3VCLEtBQUs7Z0JBQ1p3RixXQUFXcEQsQ0FBQyxDQUFDcEM7WUFDZixTQUFVO2dCQUNSd0YsV0FBV25ELENBQUM7WUFDZDtZQUVBLElBQUk2YSxVQUFVO2dCQUNaQSxTQUFTakMsS0FBSztZQUNoQjtRQUNGO0lBQ0Y7SUFFQTs7O0dBR0MsR0FDRCtULFdBQVcsU0FBU0EsVUFBVXBzQixNQUFNLEVBQUVzUSxPQUFPO1FBQzNDLElBQUlVLFVBQVVuUyxVQUFVeEUsTUFBTSxHQUFHLEtBQUt3RSxTQUFTLENBQUMsRUFBRSxLQUFLa00sWUFBWWxNLFNBQVMsQ0FBQyxFQUFFLEdBQUcsQ0FBQztRQUNuRjhCLE9BQU9zVyxrQkFBa0IsQ0FBQ2pYLFFBQVE7WUFDaEMsSUFBSXFzQixpQkFBaUJyYixRQUFRRyxJQUFJLEVBQzdCQSxPQUFPa2IsbUJBQW1CLEtBQUssSUFBSSxXQUFXQSxnQkFDOUNDLGtCQUFrQnRiLFFBQVFyTSxLQUFLLEVBQy9CQSxRQUFRMm5CLG9CQUFvQixLQUFLLElBQUksUUFBUUEsaUJBQzdDQyxrQkFBa0J2YixRQUFRcE0sS0FBSyxFQUMvQkEsUUFBUTJuQixvQkFBb0IsS0FBSyxJQUFJLFFBQVFBO1lBQ2pELElBQUkvb0IsUUFBUXdOLFFBQVF4TixLQUFLLEVBQ3JCZ3BCLGVBQWV4YixRQUFRMUssRUFBRSxFQUN6QkEsS0FBS2ttQixpQkFBaUIsS0FBSyxJQUFJeHNCLE9BQU9HLFNBQVMsR0FBR3FzQjtZQUV0RCxJQUFJLENBQUNsbUIsSUFBSTtnQkFDUDtZQUNGO1lBRUEsSUFBSTlDLFNBQVMsTUFBTTtnQkFDakIsSUFBSW5CLEtBQUtpVCxNQUFNLENBQUNoUCxLQUFLO29CQUNuQjlDLFFBQVEya0IsVUFBVW5vQixRQUFRc0c7Z0JBQzVCLE9BQU8sSUFBSXRHLE9BQU9LLFFBQVEsQ0FBQ2lRLFVBQVU7b0JBQ25DOU0sUUFBUSxTQUFTQSxNQUFNbEksQ0FBQzt3QkFDdEIsT0FBTzZLLFFBQVFDLFNBQVMsQ0FBQzlLLE1BQU1xRixPQUFPTixRQUFRLENBQUNMLFFBQVExRSxNQUFNb0ksS0FBS0MsTUFBTSxDQUFDckk7b0JBQzNFO2dCQUNGLE9BQU87b0JBQ0xrSSxRQUFRLFNBQVNBLE1BQU1sSSxDQUFDO3dCQUN0QixPQUFPNkssUUFBUUMsU0FBUyxDQUFDOUssTUFBTXFGLE9BQU8rUixPQUFPLENBQUMxUyxRQUFRMUU7b0JBQ3hEO2dCQUNGO1lBQ0Y7WUFFQSxJQUFJcUosU0FBU1YsTUFBTXFOLE9BQU8sQ0FBQ2hMLEtBQUs7Z0JBQzlCLElBQUk0VSxnQkFBZ0JqWCxNQUFNcU8sS0FBSyxDQUFDaE0sS0FDNUI2VSxnQkFBZ0IzZCxlQUFlMGQsZUFBZSxJQUM5Q2pKLFFBQVFrSixhQUFhLENBQUMsRUFBRSxFQUN4QjNOLE1BQU0yTixhQUFhLENBQUMsRUFBRTtnQkFFMUIsSUFBSWIsV0FBVzNaLE9BQU8yWixRQUFRLENBQUN0YSxRQUFRc0csSUFBSTtvQkFDekM2UixVQUFVO2dCQUNaO2dCQUNBblYsV0FBV3dDLFVBQVUsQ0FBQ3hGLFFBQVE7b0JBQzVCc0csSUFBSWtIO29CQUNKaEssT0FBT0E7b0JBQ1BvQixPQUFPQTtnQkFDVDtnQkFDQTVCLFdBQVd3QyxVQUFVLENBQUN4RixRQUFRO29CQUM1QnNHLElBQUkyTDtvQkFDSnpPLE9BQU9BO29CQUNQb0IsT0FBT0E7Z0JBQ1Q7Z0JBQ0EwQixLQUFLZ1UsU0FBU2pDLEtBQUs7Z0JBRW5CLElBQUlySCxRQUFRMUssRUFBRSxJQUFJLE1BQU07b0JBQ3RCdEQsV0FBVzZrQixNQUFNLENBQUM3bkIsUUFBUXNHO2dCQUM1QjtZQUNGO1lBRUEsSUFBSW1tQixRQUFRanlCLE1BQU1TLElBQUksQ0FBQzBGLE9BQU9xSCxLQUFLLENBQUNoSSxRQUFRO2dCQUMxQ3NHLElBQUlBO2dCQUNKOUMsT0FBT3hELE9BQU9LLFFBQVEsQ0FBQ2lRLFdBQVcsU0FBVWhWLENBQUM7b0JBQzNDLE9BQU82SyxRQUFRQyxTQUFTLENBQUM5SyxNQUFNcUYsT0FBTytSLE9BQU8sQ0FBQzFTLFFBQVExRTtnQkFDeEQsSUFBSSxTQUFVQSxDQUFDO29CQUNiLE9BQU9xRixPQUFPOEYsUUFBUSxDQUFDbkw7Z0JBQ3pCO2dCQUNBNlYsTUFBTTtnQkFDTnZNLE9BQU9BO1lBQ1Q7WUFFQSxJQUFLLElBQUk4bkIsTUFBTSxHQUFHQyxTQUFTRixPQUFPQyxNQUFNQyxPQUFPdHlCLE1BQU0sRUFBRXF5QixNQUFPO2dCQUM1RCxJQUFJRSxZQUFZcHZCLGVBQWVtdkIsTUFBTSxDQUFDRCxJQUFJLEVBQUUsSUFDeENHLFdBQVdELFNBQVMsQ0FBQyxFQUFFO2dCQUUzQixJQUFJcEssSUFBSXZlLE1BQU1xTixPQUFPLENBQUNoTCxNQUFNckMsTUFBTW1kLFlBQVksQ0FBQzlhLElBQUkzRixPQUFPaVIsS0FBSyxDQUFDNVIsUUFBUTZzQixhQUFhdm1CO2dCQUVyRixJQUFJLENBQUNrYyxHQUFHO29CQUNOO2dCQUNGO2dCQUVBLElBQUluUyxVQUFVN1YsTUFBTVMsSUFBSSxDQUFDMEYsT0FBT3FILEtBQUssQ0FBQ2hJLFFBQVE7b0JBQzVDc0csSUFBSWtjO29CQUNKaGYsT0FBT0E7b0JBQ1AyTixNQUFNQTtvQkFDTnZNLE9BQU9BO2dCQUNUO2dCQUVBLElBQUl5TCxRQUFRaFcsTUFBTSxHQUFHLEdBQUc7b0JBQ3RCLElBQUl5eUIsT0FBTzt3QkFDVCxJQUFJQyxXQUFXdnZCLGVBQWU2UyxTQUFTLElBQ25Da0MsUUFBUXdhLFFBQVEsQ0FBQyxFQUFFO3dCQUV2QixJQUFJdlosT0FBT25ELE9BQU8sQ0FBQ0EsUUFBUWhXLE1BQU0sR0FBRyxFQUFFO3dCQUV0QyxJQUFJMnlCLFNBQVN4dkIsZUFBZStVLE9BQU8sSUFDL0JtRixZQUFZc1YsTUFBTSxDQUFDLEVBQUU7d0JBRXpCLElBQUlDLFFBQVF6dkIsZUFBZWdXLE1BQU0sSUFDN0JxRSxXQUFXb1YsS0FBSyxDQUFDLEVBQUU7d0JBRXZCLElBQUl2VixVQUFVcmQsTUFBTSxLQUFLLEtBQUt3ZCxTQUFTeGQsTUFBTSxLQUFLLEdBQUc7NEJBQ25ELDBGQUEwRjs0QkFDMUYsT0FBTzt3QkFDVDt3QkFFQSxJQUFJeXVCLGFBQWF6bUIsS0FBSzZFLE1BQU0sQ0FBQ3dRLFdBQVdHLFlBQVl4VixLQUFLd0IsTUFBTSxDQUFDNlQsYUFBYXJWLEtBQUt5VixNQUFNLENBQUNKLFdBQVdHO3dCQUNwRyxJQUFJakcsUUFBUWpSLE9BQU9pUixLQUFLLENBQUM1UixRQUFRMFgsV0FBV0c7d0JBQzVDLElBQUlxVixrQkFBa0J2c0IsT0FBTzhDLElBQUksQ0FBQ3pELFFBQVE4b0I7d0JBRTFDLElBQUlxRSxtQkFBbUIzdkIsZUFBZTB2QixpQkFBaUIsSUFDbkRFLGFBQWFELGdCQUFnQixDQUFDLEVBQUU7d0JBRXBDLElBQUk1VixRQUFRdVIsV0FBV3p1QixNQUFNLEdBQUc7d0JBQ2hDLElBQUlnekIsY0FBY2hyQixLQUFLcEYsSUFBSSxDQUFDNGEsU0FBU3JjLEtBQUssQ0FBQyxHQUFHK2I7d0JBRTlDLElBQUkrVixVQUFVaEcsZ0JBQWdCQSxnQkFBZ0IsQ0FBQyxHQUFHaFgsVUFBVSxDQUFDLEdBQUc7NEJBQzlEclEsVUFBVSxFQUFFO3dCQUNkO3dCQUVBK0MsV0FBVzZDLFdBQVcsQ0FBQzdGLFFBQVFzdEIsU0FBUzs0QkFDdENobkIsSUFBSSttQjs0QkFDSnpvQixPQUFPQTt3QkFDVDt3QkFDQTVCLFdBQVd3bEIsU0FBUyxDQUFDeG9CLFFBQVE7NEJBQzNCc0csSUFBSXNMOzRCQUNKcE8sT0FBTyxTQUFTQSxNQUFNbEksQ0FBQztnQ0FDckIsT0FBTzZLLFFBQVF5SixVQUFVLENBQUN3ZCxlQUFlQSxXQUFXbnRCLFFBQVEsQ0FBQ3NWLFFBQVEsQ0FBQ2phOzRCQUN4RTs0QkFDQThaLElBQUlpWSxZQUFZOW1CLE1BQU0sQ0FBQzs0QkFDdkIzQixPQUFPQTt3QkFDVDtvQkFDRjtvQkFFQSxJQUFJa29CLFNBQVMsWUFBWTtnQkFDM0I7WUFDRjtRQUNGO0lBQ0Y7QUFDRjtBQUVBLElBQUk3RCxxQkFBcUIsU0FBU0EsbUJBQW1CanBCLE1BQU0sRUFBRXlELElBQUk7SUFDL0QsSUFBSTBDLFFBQVFDLFNBQVMsQ0FBQzNDLE9BQU87UUFDM0IsSUFBSTZNLFVBQVU3TTtRQUVkLElBQUk5QyxPQUFPTCxNQUFNLENBQUNOLFFBQVF5RCxPQUFPO1lBQy9CLE9BQU87UUFDVCxPQUFPLElBQUk2TSxRQUFRclEsUUFBUSxDQUFDNUYsTUFBTSxLQUFLLEdBQUc7WUFDeEMsT0FBTzR1QixtQkFBbUJqcEIsUUFBUXNRLFFBQVFyUSxRQUFRLENBQUMsRUFBRTtRQUN2RCxPQUFPO1lBQ0wsT0FBTztRQUNUO0lBQ0YsT0FBTyxJQUFJVSxPQUFPOEYsUUFBUSxDQUFDaEQsT0FBTztRQUNoQyxPQUFPO0lBQ1QsT0FBTztRQUNMLE9BQU87SUFDVDtBQUNGO0FBQ0E7O0NBRUMsR0FHRCxJQUFJcW5CLGNBQWMsU0FBU0EsWUFBWTlxQixNQUFNLEVBQUU0UixLQUFLO0lBQ2xELElBQUkzTixNQUFNYyxXQUFXLENBQUM2TSxRQUFRO1FBQzVCLE9BQU9BLE1BQU1MLE1BQU07SUFDckIsT0FBTztRQUNMLElBQUk4UCxnQkFBZ0JwZCxNQUFNcU8sS0FBSyxDQUFDVixRQUM1QjBQLGlCQUFpQjlqQixlQUFlNmpCLGVBQWUsSUFDL0M3VCxNQUFNOFQsY0FBYyxDQUFDLEVBQUU7UUFFM0IsSUFBSXhJLFdBQVduWSxPQUFPbVksUUFBUSxDQUFDOVksUUFBUXdOO1FBQ3ZDeEssVUFBVSxDQUFDLFNBQVMsQ0FBQ2hELFFBQVE7WUFDM0JzRyxJQUFJc0w7UUFDTjtRQUNBLE9BQU9rSCxTQUFTVCxLQUFLO0lBQ3ZCO0FBQ0Y7QUFFQSxJQUFJOFAsWUFBWSxTQUFTQSxVQUFVbm9CLE1BQU0sRUFBRWtDLElBQUk7SUFDN0MsSUFBSXFyQixnQkFBZ0I1c0IsT0FBTzhDLElBQUksQ0FBQ3pELFFBQVFrQyxPQUNwQ3NyQixnQkFBZ0Jod0IsZUFBZSt2QixlQUFlLElBQzlDOXBCLE9BQU8rcEIsYUFBYSxDQUFDLEVBQUU7SUFFM0IsT0FBTyxTQUFVbHlCLENBQUM7UUFDaEIsT0FBT0EsTUFBTW1JO0lBQ2Y7QUFDRjtBQUVBLFNBQVNncUIsVUFBVXZ2QixNQUFNLEVBQUVDLGNBQWM7SUFBSSxJQUFJQyxPQUFPbkYsT0FBT21GLElBQUksQ0FBQ0Y7SUFBUyxJQUFJakYsT0FBT29GLHFCQUFxQixFQUFFO1FBQUUsSUFBSUMsVUFBVXJGLE9BQU9vRixxQkFBcUIsQ0FBQ0g7UUFBUyxJQUFJQyxnQkFBZ0I7WUFBRUcsVUFBVUEsUUFBUUMsTUFBTSxDQUFDLFNBQVVDLEdBQUc7Z0JBQUksT0FBT3ZGLE9BQU93Rix3QkFBd0IsQ0FBQ1AsUUFBUU0sS0FBS3BDLFVBQVU7WUFBRTtRQUFJO1FBQUVnQyxLQUFLakIsSUFBSSxDQUFDdUIsS0FBSyxDQUFDTixNQUFNRTtJQUFVO0lBQUUsT0FBT0Y7QUFBTTtBQUUxVixTQUFTc3ZCLGdCQUFnQjl1QixNQUFNO0lBQUksSUFBSyxJQUFJdEUsSUFBSSxHQUFHQSxJQUFJdUUsVUFBVXhFLE1BQU0sRUFBRUMsSUFBSztRQUFFLElBQUl3RSxTQUFTRCxTQUFTLENBQUN2RSxFQUFFLElBQUksT0FBT3VFLFNBQVMsQ0FBQ3ZFLEVBQUUsR0FBRyxDQUFDO1FBQUcsSUFBSUEsSUFBSSxHQUFHO1lBQUVtekIsVUFBVXgwQixPQUFPNkYsU0FBUyxNQUFNQyxPQUFPLENBQUMsU0FBVTVDLEdBQUc7Z0JBQUlGLGdCQUFnQjJDLFFBQVF6QyxLQUFLMkMsTUFBTSxDQUFDM0MsSUFBSTtZQUFHO1FBQUksT0FBTyxJQUFJbEQsT0FBTytGLHlCQUF5QixFQUFFO1lBQUUvRixPQUFPZ0csZ0JBQWdCLENBQUNMLFFBQVEzRixPQUFPK0YseUJBQXlCLENBQUNGO1FBQVUsT0FBTztZQUFFMnVCLFVBQVV4MEIsT0FBTzZGLFNBQVNDLE9BQU8sQ0FBQyxTQUFVNUMsR0FBRztnQkFBSWxELE9BQU9DLGNBQWMsQ0FBQzBGLFFBQVF6QyxLQUFLbEQsT0FBT3dGLHdCQUF3QixDQUFDSyxRQUFRM0M7WUFBTztRQUFJO0lBQUU7SUFBRSxPQUFPeUM7QUFBUTtBQUUzaEIsSUFBSSt1QixzQkFBc0I7SUFDeEI7O0dBRUMsR0FDREMsVUFBVSxTQUFTQSxTQUFTNXRCLE1BQU07UUFDaEMsSUFBSWdSLFVBQVVuUyxVQUFVeEUsTUFBTSxHQUFHLEtBQUt3RSxTQUFTLENBQUMsRUFBRSxLQUFLa00sWUFBWWxNLFNBQVMsQ0FBQyxFQUFFLEdBQUcsQ0FBQztRQUNuRixJQUFJMFosZ0JBQWdCdkgsUUFBUVcsSUFBSSxFQUM1QkEsT0FBTzRHLGtCQUFrQixLQUFLLElBQUksV0FBV0E7UUFDakQsSUFBSXBZLFlBQVlILE9BQU9HLFNBQVM7UUFFaEMsSUFBSSxDQUFDQSxXQUFXO1lBQ2Q7UUFDRixPQUFPLElBQUl3UixTQUFTLFVBQVU7WUFDNUIzTyxXQUFXNmtCLE1BQU0sQ0FBQzduQixRQUFRRyxVQUFVb1IsTUFBTTtRQUM1QyxPQUFPLElBQUlJLFNBQVMsU0FBUztZQUMzQjNPLFdBQVc2a0IsTUFBTSxDQUFDN25CLFFBQVFHLFVBQVVxUixLQUFLO1FBQzNDLE9BQU8sSUFBSUcsU0FBUyxTQUFTO1lBQzNCLElBQUlpSCxlQUFlM1UsTUFBTXFPLEtBQUssQ0FBQ25TLFlBQzNCMFksZ0JBQWdCcmIsZUFBZW9iLGNBQWMsSUFDN0MzRyxRQUFRNEcsYUFBYSxDQUFDLEVBQUU7WUFFNUI3VixXQUFXNmtCLE1BQU0sQ0FBQzduQixRQUFRaVM7UUFDNUIsT0FBTyxJQUFJTixTQUFTLE9BQU87WUFDekIsSUFBSXlILGdCQUFnQm5WLE1BQU1xTyxLQUFLLENBQUNuUyxZQUM1QmtaLGdCQUFnQjdiLGVBQWU0YixlQUFlLElBQzlDNUwsTUFBTTZMLGFBQWEsQ0FBQyxFQUFFO1lBRTFCclcsV0FBVzZrQixNQUFNLENBQUM3bkIsUUFBUXdOO1FBQzVCO0lBQ0Y7SUFFQTs7R0FFQyxHQUNEcWdCLFVBQVUsU0FBU0EsU0FBUzd0QixNQUFNO1FBQ2hDLElBQUlHLFlBQVlILE9BQU9HLFNBQVM7UUFFaEMsSUFBSUEsV0FBVztZQUNiSCxPQUFPdEIsS0FBSyxDQUFDO2dCQUNYeUUsTUFBTTtnQkFDTjZaLFlBQVk3YztnQkFDWm1lLGVBQWU7WUFDakI7UUFDRjtJQUNGO0lBRUE7O0dBRUMsR0FDRHdQLE1BQU0sU0FBU0EsS0FBSzl0QixNQUFNO1FBQ3hCLElBQUlnUixVQUFVblMsVUFBVXhFLE1BQU0sR0FBRyxLQUFLd0UsU0FBUyxDQUFDLEVBQUUsS0FBS2tNLFlBQVlsTSxTQUFTLENBQUMsRUFBRSxHQUFHLENBQUM7UUFDbkYsSUFBSXNCLFlBQVlILE9BQU9HLFNBQVM7UUFDaEMsSUFBSTBSLG9CQUFvQmIsUUFBUXpGLFFBQVEsRUFDcENBLFdBQVdzRyxzQkFBc0IsS0FBSyxJQUFJLElBQUlBLG1CQUM5Q00sZ0JBQWdCbkIsUUFBUWxNLElBQUksRUFDNUJBLE9BQU9xTixrQkFBa0IsS0FBSyxJQUFJLGNBQWNBLGVBQ2hEd0IsbUJBQW1CM0MsUUFBUWhNLE9BQU8sRUFDbENBLFVBQVUyTyxxQkFBcUIsS0FBSyxJQUFJLFFBQVFBO1FBQ3BELElBQUlvYSxpQkFBaUIvYyxRQUFRVyxJQUFJLEVBQzdCQSxPQUFPb2MsbUJBQW1CLEtBQUssSUFBSSxPQUFPQTtRQUU5QyxJQUFJLENBQUM1dEIsV0FBVztZQUNkO1FBQ0Y7UUFFQSxJQUFJd1IsU0FBUyxTQUFTO1lBQ3BCQSxPQUFPMU4sTUFBTTRjLFVBQVUsQ0FBQzFnQixhQUFhLFVBQVU7UUFDakQ7UUFFQSxJQUFJd1IsU0FBUyxPQUFPO1lBQ2xCQSxPQUFPMU4sTUFBTTRjLFVBQVUsQ0FBQzFnQixhQUFhLFdBQVc7UUFDbEQ7UUFFQSxJQUFJb1IsU0FBU3BSLFVBQVVvUixNQUFNLEVBQ3pCQyxRQUFRclIsVUFBVXFSLEtBQUs7UUFDM0IsSUFBSXdjLE9BQU87WUFDVHppQixVQUFVQTtZQUNWekcsTUFBTUE7UUFDUjtRQUNBLElBQUltTCxRQUFRLENBQUM7UUFFYixJQUFJMEIsUUFBUSxRQUFRQSxTQUFTLFVBQVU7WUFDckMsSUFBSUQsUUFBUTFNLFVBQVVyRSxPQUFPcVIsTUFBTSxDQUFDaFMsUUFBUXVSLFFBQVF5YyxRQUFRcnRCLE9BQU84USxLQUFLLENBQUN6UixRQUFRdVIsUUFBUXljO1lBRXpGLElBQUl0YyxPQUFPO2dCQUNUekIsTUFBTXNCLE1BQU0sR0FBR0c7WUFDakI7UUFDRjtRQUVBLElBQUlDLFFBQVEsUUFBUUEsU0FBUyxTQUFTO1lBQ3BDLElBQUk0UyxTQUFTdmYsVUFBVXJFLE9BQU9xUixNQUFNLENBQUNoUyxRQUFRd1IsT0FBT3djLFFBQVFydEIsT0FBTzhRLEtBQUssQ0FBQ3pSLFFBQVF3UixPQUFPd2M7WUFFeEYsSUFBSXpKLFFBQVE7Z0JBQ1Z0VSxNQUFNdUIsS0FBSyxHQUFHK1M7WUFDaEI7UUFDRjtRQUVBdmhCLFdBQVdpckIsWUFBWSxDQUFDanVCLFFBQVFpUTtJQUNsQztJQUVBOztHQUVDLEdBQ0Q0WCxRQUFRLFNBQVNBLE9BQU83bkIsTUFBTSxFQUFFcEIsTUFBTTtRQUNwQyxJQUFJdUIsWUFBWUgsT0FBT0csU0FBUztRQUNoQ3ZCLFNBQVMrQixPQUFPaVIsS0FBSyxDQUFDNVIsUUFBUXBCO1FBRTlCLElBQUl1QixXQUFXO1lBQ2I2QyxXQUFXaXJCLFlBQVksQ0FBQ2p1QixRQUFRcEI7WUFDaEM7UUFDRjtRQUVBLElBQUksQ0FBQ3FGLE1BQU1xTixPQUFPLENBQUMxUyxTQUFTO1lBQzFCLE1BQU0sSUFBSW1MLE1BQU0scUlBQXFJeEQsTUFBTSxDQUFDOFYsU0FBU0MsU0FBUyxDQUFDMWQ7UUFDakw7UUFFQW9CLE9BQU90QixLQUFLLENBQUM7WUFDWHlFLE1BQU07WUFDTjZaLFlBQVk3YztZQUNabWUsZUFBZTFmO1FBQ2pCO0lBQ0Y7SUFFQTs7R0FFQyxHQUNEc3ZCLFVBQVUsU0FBU0EsU0FBU2x1QixNQUFNLEVBQUVpUSxLQUFLO1FBQ3ZDLElBQUllLFVBQVVuUyxVQUFVeEUsTUFBTSxHQUFHLEtBQUt3RSxTQUFTLENBQUMsRUFBRSxLQUFLa00sWUFBWWxNLFNBQVMsQ0FBQyxFQUFFLEdBQUcsQ0FBQztRQUNuRixJQUFJc0IsWUFBWUgsT0FBT0csU0FBUztRQUNoQyxJQUFJZ3VCLGlCQUFpQm5kLFFBQVFXLElBQUksRUFDN0JBLE9BQU93YyxtQkFBbUIsS0FBSyxJQUFJLFNBQVNBO1FBRWhELElBQUksQ0FBQ2h1QixXQUFXO1lBQ2Q7UUFDRjtRQUVBLElBQUl3UixTQUFTLFNBQVM7WUFDcEJBLE9BQU8xTixNQUFNNGMsVUFBVSxDQUFDMWdCLGFBQWEsVUFBVTtRQUNqRDtRQUVBLElBQUl3UixTQUFTLE9BQU87WUFDbEJBLE9BQU8xTixNQUFNNGMsVUFBVSxDQUFDMWdCLGFBQWEsV0FBVztRQUNsRDtRQUVBLElBQUlvUixTQUFTcFIsVUFBVW9SLE1BQU0sRUFDekJDLFFBQVFyUixVQUFVcVIsS0FBSztRQUMzQixJQUFJRSxRQUFRQyxTQUFTLFdBQVdKLFNBQVNDO1FBQ3pDeE8sV0FBV2lyQixZQUFZLENBQUNqdUIsUUFBUS9ELGdCQUFnQixDQUFDLEdBQUcwVixTQUFTLFdBQVcsV0FBVyxTQUFTK2IsZ0JBQWdCQSxnQkFBZ0IsQ0FBQyxHQUFHaGMsUUFBUXpCO0lBQzFJO0lBRUE7O0dBRUMsR0FDRGdlLGNBQWMsU0FBU0EsYUFBYWp1QixNQUFNLEVBQUVpUSxLQUFLO1FBQy9DLElBQUk5UCxZQUFZSCxPQUFPRyxTQUFTO1FBQ2hDLElBQUlpdUIsV0FBVyxDQUFDO1FBQ2hCLElBQUlDLFdBQVcsQ0FBQztRQUVoQixJQUFJLENBQUNsdUIsV0FBVztZQUNkO1FBQ0Y7UUFFQSxJQUFLLElBQUlzcUIsS0FBS3hhLE1BQU87WUFDbkIsSUFBSXdhLE1BQU0sWUFBWXhhLE1BQU1zQixNQUFNLElBQUksUUFBUSxDQUFDMEIsTUFBTS9MLE1BQU0sQ0FBQytJLE1BQU1zQixNQUFNLEVBQUVwUixVQUFVb1IsTUFBTSxLQUFLa1osTUFBTSxXQUFXeGEsTUFBTXVCLEtBQUssSUFBSSxRQUFRLENBQUN5QixNQUFNL0wsTUFBTSxDQUFDK0ksTUFBTXVCLEtBQUssRUFBRXJSLFVBQVVxUixLQUFLLEtBQUtpWixNQUFNLFlBQVlBLE1BQU0sV0FBV3hhLEtBQUssQ0FBQ3dhLEVBQUUsS0FBS3RxQixTQUFTLENBQUNzcUIsRUFBRSxFQUFFO2dCQUNsUDJELFFBQVEsQ0FBQzNELEVBQUUsR0FBR3RxQixTQUFTLENBQUNzcUIsRUFBRTtnQkFDMUI0RCxRQUFRLENBQUM1RCxFQUFFLEdBQUd4YSxLQUFLLENBQUN3YSxFQUFFO1lBQ3hCO1FBQ0Y7UUFFQSxJQUFJeHhCLE9BQU9tRixJQUFJLENBQUNnd0IsVUFBVS96QixNQUFNLEdBQUcsR0FBRztZQUNwQzJGLE9BQU90QixLQUFLLENBQUM7Z0JBQ1h5RSxNQUFNO2dCQUNONlosWUFBWW9SO2dCQUNaOVAsZUFBZStQO1lBQ2pCO1FBQ0Y7SUFDRjtBQUNGO0FBRUEsU0FBU0MsMkJBQTJCbHpCLENBQUMsRUFBRStELGNBQWM7SUFBSSxJQUFJQyxLQUFLLE9BQU9yRSxXQUFXLGVBQWVLLENBQUMsQ0FBQ0wsT0FBT0MsUUFBUSxDQUFDLElBQUlJLENBQUMsQ0FBQyxhQUFhO0lBQUUsSUFBSSxDQUFDZ0UsSUFBSTtRQUFFLElBQUk1RSxNQUFNRyxPQUFPLENBQUNTLE1BQU9nRSxDQUFBQSxLQUFLakUsNEJBQTRCQyxFQUFDLEtBQU0rRCxrQkFBa0IvRCxLQUFLLE9BQU9BLEVBQUVmLE1BQU0sS0FBSyxVQUFVO1lBQUUsSUFBSStFLElBQUloRSxJQUFJZ0U7WUFBSSxJQUFJOUUsSUFBSTtZQUFHLElBQUlnRixJQUFJLFNBQVNBLEtBQUs7WUFBRyxPQUFPO2dCQUFFQyxHQUFHRDtnQkFBR2hFLEdBQUcsU0FBU0E7b0JBQU0sSUFBSWhCLEtBQUtjLEVBQUVmLE1BQU0sRUFBRSxPQUFPO3dCQUFFNkMsTUFBTTtvQkFBSztvQkFBRyxPQUFPO3dCQUFFQSxNQUFNO3dCQUFPOUQsT0FBT2dDLENBQUMsQ0FBQ2QsSUFBSTtvQkFBQztnQkFBRztnQkFBR2tGLEdBQUcsU0FBU0EsRUFBRXhDLEVBQUU7b0JBQUksTUFBTUE7Z0JBQUk7Z0JBQUd5QyxHQUFHSDtZQUFFO1FBQUc7UUFBRSxNQUFNLElBQUl4RCxVQUFVO0lBQTBJO0lBQUUsSUFBSTRELG1CQUFtQixNQUFNQyxTQUFTLE9BQU92QztJQUFLLE9BQU87UUFBRW1DLEdBQUcsU0FBU0E7WUFBTUgsS0FBS0EsR0FBR3ZGLElBQUksQ0FBQ3VCO1FBQUk7UUFBR0UsR0FBRyxTQUFTQTtZQUFNLElBQUlzRSxPQUFPUixHQUFHbkMsSUFBSTtZQUFJeUMsbUJBQW1CRSxLQUFLMUMsSUFBSTtZQUFFLE9BQU8wQztRQUFNO1FBQUdKLEdBQUcsU0FBU0EsRUFBRUssR0FBRztZQUFJRixTQUFTO1lBQU12QyxNQUFNeUM7UUFBSztRQUFHSixHQUFHLFNBQVNBO1lBQU0sSUFBSTtnQkFBRSxJQUFJLENBQUNDLG9CQUFvQk4sRUFBRSxDQUFDLFNBQVMsSUFBSSxNQUFNQSxFQUFFLENBQUMsU0FBUztZQUFJLFNBQVU7Z0JBQUUsSUFBSU8sUUFBUSxNQUFNdkM7WUFBSztRQUFFO0lBQUU7QUFBRztBQUUzK0IsU0FBU2pDLDRCQUE0QkMsQ0FBQyxFQUFFQyxNQUFNO0lBQUksSUFBSSxDQUFDRCxHQUFHO0lBQVEsSUFBSSxPQUFPQSxNQUFNLFVBQVUsT0FBT2xCLGtCQUFrQmtCLEdBQUdDO0lBQVMsSUFBSUMsSUFBSXJDLE9BQU9VLFNBQVMsQ0FBQzRCLFFBQVEsQ0FBQzFCLElBQUksQ0FBQ3VCLEdBQUdJLEtBQUssQ0FBQyxHQUFHLENBQUM7SUFBSSxJQUFJRixNQUFNLFlBQVlGLEVBQUVLLFdBQVcsRUFBRUgsSUFBSUYsRUFBRUssV0FBVyxDQUFDQyxJQUFJO0lBQUUsSUFBSUosTUFBTSxTQUFTQSxNQUFNLE9BQU8sT0FBT2QsTUFBTVMsSUFBSSxDQUFDRztJQUFJLElBQUlFLE1BQU0sZUFBZSwyQ0FBMkNLLElBQUksQ0FBQ0wsSUFBSSxPQUFPcEIsa0JBQWtCa0IsR0FBR0M7QUFBUztBQUUvWixTQUFTbkIsa0JBQWtCQyxHQUFHLEVBQUVDLEdBQUc7SUFBSSxJQUFJQSxPQUFPLFFBQVFBLE1BQU1ELElBQUlFLE1BQU0sRUFBRUQsTUFBTUQsSUFBSUUsTUFBTTtJQUFFLElBQUssSUFBSUMsSUFBSSxHQUFHQyxPQUFPLElBQUlDLE1BQU1KLE1BQU1FLElBQUlGLEtBQUtFLElBQUs7UUFBRUMsSUFBSSxDQUFDRCxFQUFFLEdBQUdILEdBQUcsQ0FBQ0csRUFBRTtJQUFFO0lBQUUsT0FBT0M7QUFBTTtBQUV0TCxJQUFJZzBCLGlCQUFpQjtJQUNuQjs7R0FFQyxHQUNELFVBQVUsU0FBU0MsUUFBUXh1QixNQUFNO1FBQy9CLElBQUlnUixVQUFVblMsVUFBVXhFLE1BQU0sR0FBRyxLQUFLd0UsU0FBUyxDQUFDLEVBQUUsS0FBS2tNLFlBQVlsTSxTQUFTLENBQUMsRUFBRSxHQUFHLENBQUM7UUFDbkY4QixPQUFPc1csa0JBQWtCLENBQUNqWCxRQUFRO1lBQ2hDLElBQUkyVCxtQkFBbUIzQyxRQUFRaE0sT0FBTyxFQUNsQ0EsVUFBVTJPLHFCQUFxQixLQUFLLElBQUksUUFBUUEsa0JBQ2hEeEIsZ0JBQWdCbkIsUUFBUWxNLElBQUksRUFDNUJBLE9BQU9xTixrQkFBa0IsS0FBSyxJQUFJLGNBQWNBLGVBQ2hETixvQkFBb0JiLFFBQVF6RixRQUFRLEVBQ3BDQSxXQUFXc0csc0JBQXNCLEtBQUssSUFBSSxJQUFJQSxtQkFDOUNaLGlCQUFpQkQsUUFBUXBNLEtBQUssRUFDOUJBLFFBQVFxTSxtQkFBbUIsS0FBSyxJQUFJLFFBQVFBO1lBQ2hELElBQUlHLGNBQWNKLFFBQVExSyxFQUFFLEVBQ3hCQSxLQUFLOEssZ0JBQWdCLEtBQUssSUFBSXBSLE9BQU9HLFNBQVMsR0FBR2lSLGFBQ2pEdVcsbUJBQW1CM1csUUFBUTRXLE9BQU8sRUFDbENBLFVBQVVELHFCQUFxQixLQUFLLElBQUksUUFBUUE7WUFFcEQsSUFBSSxDQUFDcmhCLElBQUk7Z0JBQ1A7WUFDRjtZQUVBLElBQUl2QixjQUFjO1lBRWxCLElBQUlkLE1BQU1xTixPQUFPLENBQUNoTCxPQUFPckMsTUFBTWMsV0FBVyxDQUFDdUIsS0FBSztnQkFDOUN2QixjQUFjO2dCQUNkdUIsS0FBS0EsR0FBR2lMLE1BQU07WUFDaEI7WUFFQSxJQUFJMEIsTUFBTThFLE9BQU8sQ0FBQ3pSLEtBQUs7Z0JBQ3JCLElBQUltb0IsZUFBZTl0QixNQUFNLENBQUMsT0FBTyxDQUFDWCxRQUFRO29CQUN4Q3NHLElBQUlBO29CQUNKNkssTUFBTTtnQkFDUjtnQkFFQSxJQUFJLENBQUN2TSxTQUFTNnBCLGNBQWM7b0JBQzFCLElBQUlDLGdCQUFnQmx4QixlQUFlaXhCLGNBQWMsSUFDN0NuRCxXQUFXb0QsYUFBYSxDQUFDLEVBQUU7b0JBRS9CcG9CLEtBQUtnbEI7Z0JBQ1AsT0FBTztvQkFDTCxJQUFJMEMsT0FBTzt3QkFDVGxwQixNQUFNQTt3QkFDTnlHLFVBQVVBO29CQUNaO29CQUNBLElBQUkzTSxTQUFTb0csVUFBVXJFLE9BQU9xUixNQUFNLENBQUNoUyxRQUFRc0csSUFBSTBuQixTQUFTcnRCLE9BQU9zUixLQUFLLENBQUNqUyxRQUFRLEVBQUUsSUFBSVcsT0FBTzhRLEtBQUssQ0FBQ3pSLFFBQVFzRyxJQUFJMG5CLFNBQVNydEIsT0FBTzZNLEdBQUcsQ0FBQ3hOLFFBQVEsRUFBRTtvQkFDNUlzRyxLQUFLO3dCQUNIaUwsUUFBUWpMO3dCQUNSa0wsT0FBTzVTO29CQUNUO29CQUNBZ3BCLFVBQVU7Z0JBQ1o7WUFDRjtZQUVBLElBQUl2bEIsS0FBS2lULE1BQU0sQ0FBQ2hQLEtBQUs7Z0JBQ25CdEQsV0FBVytELFdBQVcsQ0FBQy9HLFFBQVE7b0JBQzdCc0csSUFBSUE7b0JBQ0oxQixPQUFPQTtnQkFDVDtnQkFDQTtZQUNGO1lBRUEsSUFBSVgsTUFBTWMsV0FBVyxDQUFDdUIsS0FBSztnQkFDekI7WUFDRjtZQUVBLElBQUksQ0FBQ3NoQixTQUFTO2dCQUNaLElBQUloUCxlQUFlM1UsTUFBTXFPLEtBQUssQ0FBQ2hNLEtBQzNCdVMsZ0JBQWdCcmIsZUFBZW9iLGNBQWMsSUFDN0MrVixPQUFPOVYsYUFBYSxDQUFDLEVBQUU7Z0JBRTNCLElBQUkrVixXQUFXanVCLE9BQU82TSxHQUFHLENBQUN4TixRQUFRLEVBQUU7Z0JBRXBDLElBQUksQ0FBQ2lULE1BQU0vTCxNQUFNLENBQUN5bkIsTUFBTUMsV0FBVztvQkFDakN0b0IsS0FBSzNGLE9BQU9xYSxXQUFXLENBQUNoYixRQUFRc0csSUFBSTt3QkFDbEMxQixPQUFPQTtvQkFDVDtnQkFDRjtZQUNGO1lBRUEsSUFBSXdVLGdCQUFnQm5WLE1BQU1xTyxLQUFLLENBQUNoTSxLQUM1QitTLGdCQUFnQjdiLGVBQWU0YixlQUFlLElBQzlDbkgsUUFBUW9ILGFBQWEsQ0FBQyxFQUFFLEVBQ3hCN0wsTUFBTTZMLGFBQWEsQ0FBQyxFQUFFO1lBRTFCLElBQUl3VixhQUFhbHVCLE9BQU9vUSxLQUFLLENBQUMvUSxRQUFRO2dCQUNwQ3dELE9BQU8sU0FBU0EsTUFBTWxJLENBQUM7b0JBQ3JCLE9BQU82SyxRQUFRQyxTQUFTLENBQUM5SyxNQUFNcUYsT0FBTytSLE9BQU8sQ0FBQzFTLFFBQVExRTtnQkFDeEQ7Z0JBQ0FnTCxJQUFJMkw7Z0JBQ0pyTixPQUFPQTtZQUNUO1lBQ0EsSUFBSXlXLFdBQVcxYSxPQUFPb1EsS0FBSyxDQUFDL1EsUUFBUTtnQkFDbEN3RCxPQUFPLFNBQVNBLE1BQU1sSSxDQUFDO29CQUNyQixPQUFPNkssUUFBUUMsU0FBUyxDQUFDOUssTUFBTXFGLE9BQU8rUixPQUFPLENBQUMxUyxRQUFRMUU7Z0JBQ3hEO2dCQUNBZ0wsSUFBSWtIO2dCQUNKNUksT0FBT0E7WUFDVDtZQUNBLElBQUlrcUIsaUJBQWlCRCxjQUFjeFQsWUFBWSxDQUFDaFosS0FBSzZFLE1BQU0sQ0FBQzJuQixVQUFVLENBQUMsRUFBRSxFQUFFeFQsUUFBUSxDQUFDLEVBQUU7WUFDdEYsSUFBSTBULGVBQWUxc0IsS0FBSzZFLE1BQU0sQ0FBQytLLE1BQU0vUCxJQUFJLEVBQUVzTCxJQUFJdEwsSUFBSTtZQUNuRCxJQUFJOHNCLFlBQVlwcUIsUUFBUSxPQUFPakUsTUFBTSxDQUFDLE9BQU8sQ0FBQ1gsUUFBUTtnQkFDcERzRyxJQUFJMkw7Z0JBQ0pkLE1BQU07WUFDUjtZQUNBLElBQUk4ZCxVQUFVcnFCLFFBQVEsT0FBT2pFLE1BQU0sQ0FBQyxPQUFPLENBQUNYLFFBQVE7Z0JBQ2xEc0csSUFBSWtIO2dCQUNKMkQsTUFBTTtZQUNSLElBQUksd0VBQXdFO1lBRTVFLElBQUk2ZCxXQUFXO2dCQUNiLElBQUloZCxTQUFTclIsT0FBT3FSLE1BQU0sQ0FBQ2hTLFFBQVFpUztnQkFFbkMsSUFBSUQsVUFBVTZjLGNBQWN4c0IsS0FBS3VOLFVBQVUsQ0FBQ2lmLFVBQVUsQ0FBQyxFQUFFLEVBQUU3YyxPQUFPOVAsSUFBSSxHQUFHO29CQUN2RStQLFFBQVFEO2dCQUNWO1lBQ0Y7WUFFQSxJQUFJaWQsU0FBUztnQkFDWCxJQUFJeGQsUUFBUTlRLE9BQU84USxLQUFLLENBQUN6UixRQUFRd047Z0JBRWpDLElBQUlpRSxTQUFTNEosWUFBWWhaLEtBQUt1TixVQUFVLENBQUN5TCxRQUFRLENBQUMsRUFBRSxFQUFFNUosTUFBTXZQLElBQUksR0FBRztvQkFDakVzTCxNQUFNaUU7Z0JBQ1I7WUFDRixFQUFFLHlFQUF5RTtZQUMzRSwyQkFBMkI7WUFHM0IsSUFBSXBCLFVBQVUsRUFBRTtZQUNoQixJQUFJd0g7WUFFSixJQUFJblgsWUFBWTR0QiwyQkFBMkIzdEIsT0FBT3FILEtBQUssQ0FBQ2hJLFFBQVE7Z0JBQzlEc0csSUFBSUE7Z0JBQ0oxQixPQUFPQTtZQUNULEtBQ0kvRDtZQUVKLElBQUk7Z0JBQ0YsSUFBS0gsVUFBVW5CLENBQUMsSUFBSSxDQUFDLENBQUNzQixRQUFRSCxVQUFVcEYsQ0FBQyxFQUFDLEVBQUc0QixJQUFJLEVBQUc7b0JBQ2xELElBQUkrSSxRQUFRcEYsTUFBTXpILEtBQUs7b0JBRXZCLElBQUk4TSxTQUFTMUksZUFBZXlJLE9BQU8sSUFDL0IyTyxTQUFTMU8sTUFBTSxDQUFDLEVBQUUsRUFDbEI0QixTQUFTNUIsTUFBTSxDQUFDLEVBQUU7b0JBRXRCLElBQUkyUixZQUFZeFYsS0FBS2tVLE9BQU8sQ0FBQ3pPLFFBQVErUCxjQUFjLEdBQUc7d0JBQ3BEO29CQUNGO29CQUVBLElBQUksQ0FBQ2pULFNBQVN1QixRQUFRQyxTQUFTLENBQUN3TyxXQUFXalUsT0FBT0wsTUFBTSxDQUFDTixRQUFRNFUsV0FBVyxDQUFDdlMsS0FBS29kLFFBQVEsQ0FBQzNYLFFBQVFtSyxNQUFNL1AsSUFBSSxLQUFLLENBQUNHLEtBQUtvZCxRQUFRLENBQUMzWCxRQUFRMEYsSUFBSXRMLElBQUksR0FBRzt3QkFDbEptTyxRQUFRbFQsSUFBSSxDQUFDOEk7d0JBQ2I0UixXQUFXL1A7b0JBQ2I7Z0JBQ0Y7WUFDRixFQUFFLE9BQU8xSyxLQUFLO2dCQUNac0QsVUFBVWxCLENBQUMsQ0FBQ3BDO1lBQ2QsU0FBVTtnQkFDUnNELFVBQVVqQixDQUFDO1lBQ2I7WUFFQSxJQUFJbUIsV0FBV3BHLE1BQU1TLElBQUksQ0FBQ29WLFNBQVMsU0FBVWpQLElBQUk7Z0JBQy9DLElBQUlLLFFBQVFqRSxlQUFlNEQsTUFBTSxJQUM3QitHLElBQUkxRyxLQUFLLENBQUMsRUFBRTtnQkFFaEIsT0FBT2QsT0FBT3NYLE9BQU8sQ0FBQ2pZLFFBQVFtSTtZQUNoQztZQUNBLElBQUkrbUIsV0FBV3Z1QixPQUFPbVksUUFBUSxDQUFDOVksUUFBUWlTO1lBQ3ZDLElBQUlrZCxTQUFTeHVCLE9BQU9tWSxRQUFRLENBQUM5WSxRQUFRd047WUFDckMsSUFBSTRoQixjQUFjO1lBRWxCLElBQUksQ0FBQ0wsZ0JBQWdCLENBQUNDLFdBQVc7Z0JBQy9CLElBQUl6SyxTQUFTMkssU0FBUzlXLE9BQU87Z0JBRTdCLElBQUlqRSxlQUFleFQsT0FBTzhTLElBQUksQ0FBQ3pULFFBQVF1a0IsU0FDbkNuUSxnQkFBZ0I1VyxlQUFlMlcsY0FBYyxJQUM3QzFRLE9BQU8yUSxhQUFhLENBQUMsRUFBRTtnQkFFM0IsSUFBSWxTLE9BQU9xaUIsT0FBT3JpQixJQUFJO2dCQUN0QixJQUFJbXRCLFNBQVNwZCxPQUNUc0IsU0FBUzhiLE9BQU85YixNQUFNO2dCQUMxQixJQUFJeE4sT0FBT3RDLEtBQUtzQyxJQUFJLENBQUN2SyxLQUFLLENBQUMrWDtnQkFFM0IsSUFBSXhOLEtBQUsxTCxNQUFNLEdBQUcsR0FBRztvQkFDbkIyRixPQUFPdEIsS0FBSyxDQUFDO3dCQUNYeUUsTUFBTTt3QkFDTmpCLE1BQU1BO3dCQUNOcVIsUUFBUUE7d0JBQ1J4TixNQUFNQTtvQkFDUjtvQkFDQXFwQixjQUFjcnBCO2dCQUNoQjtZQUNGO1lBRUFuRixTQUFTb0UsT0FBTyxHQUFHZ1MsR0FBRyxDQUFDLFNBQVV6SCxDQUFDO2dCQUNoQyxPQUFPQSxFQUFFOEksS0FBSztZQUNoQixHQUFHOVosTUFBTSxDQUFDLFNBQVVnUixDQUFDO2dCQUNuQixPQUFPQSxNQUFNO1lBQ2YsR0FBR3hRLE9BQU8sQ0FBQyxTQUFVb0osQ0FBQztnQkFDcEIsT0FBT25GLFdBQVcrRCxXQUFXLENBQUMvRyxRQUFRO29CQUNwQ3NHLElBQUk2QjtvQkFDSnZELE9BQU9BO2dCQUNUO1lBQ0Y7WUFFQSxJQUFJLENBQUNxcUIsU0FBUztnQkFDWixJQUFJdEssVUFBVXdLLE9BQU8vVyxPQUFPO2dCQUU1QixJQUFJa1gsZ0JBQWdCM3VCLE9BQU84UyxJQUFJLENBQUN6VCxRQUFRMmtCLFVBQ3BDNEssZ0JBQWdCL3hCLGVBQWU4eEIsZUFBZSxJQUM5Q3JiLFFBQVFzYixhQUFhLENBQUMsRUFBRTtnQkFFNUIsSUFBSXpzQixRQUFRNmhCLFFBQVF6aUIsSUFBSTtnQkFFeEIsSUFBSXNqQixVQUFVdUosZUFBZTljLE1BQU1zQixNQUFNLEdBQUc7Z0JBRTVDLElBQUlrUyxRQUFReFIsTUFBTWxPLElBQUksQ0FBQ3ZLLEtBQUssQ0FBQ2dxQixTQUFTaFksSUFBSStGLE1BQU07Z0JBRWhELElBQUlrUyxNQUFNcHJCLE1BQU0sR0FBRyxHQUFHO29CQUNwQjJGLE9BQU90QixLQUFLLENBQUM7d0JBQ1h5RSxNQUFNO3dCQUNOakIsTUFBTVk7d0JBQ055USxRQUFRaVM7d0JBQ1J6ZixNQUFNMGY7b0JBQ1I7b0JBQ0EySixjQUFjM0o7Z0JBQ2hCO1lBQ0Y7WUFFQSxJQUFJLENBQUNzSixnQkFBZ0JELGtCQUFrQkssT0FBTy9XLE9BQU8sSUFBSThXLFNBQVM5VyxPQUFPLEVBQUU7Z0JBQ3pFcFYsV0FBV29FLFVBQVUsQ0FBQ3BILFFBQVE7b0JBQzVCc0csSUFBSTZvQixPQUFPL1csT0FBTztvQkFDbEJ3UCxTQUFTO29CQUNUaGpCLE9BQU9BO2dCQUNUO1lBQ0YsRUFBRSxrRUFBa0U7WUFDcEUseURBQXlEO1lBQ3pELGdFQUFnRTtZQUdoRSxJQUFJRyxlQUFlQyxXQUFXRixTQUFTLGVBQWVzcUIsWUFBWS8wQixNQUFNLEdBQUcsS0FBSyswQixZQUFZNXJCLEtBQUssQ0FBQyxxQkFBcUI7Z0JBQ3JIUixXQUFXOEMsVUFBVSxDQUFDOUYsUUFBUW92QixZQUFZNXpCLEtBQUssQ0FBQyxHQUFHNHpCLFlBQVkvMEIsTUFBTSxHQUFHa1I7WUFDMUU7WUFFQSxJQUFJaWtCLGFBQWFOLFNBQVM3VyxLQUFLO1lBQy9CLElBQUlvWCxXQUFXTixPQUFPOVcsS0FBSztZQUMzQixJQUFJM0csUUFBUTFNLFVBQVV3cUIsY0FBY0MsV0FBV0EsWUFBWUQ7WUFFM0QsSUFBSXhlLFFBQVExSyxFQUFFLElBQUksUUFBUW9MLE9BQU87Z0JBQy9CMU8sV0FBVzZrQixNQUFNLENBQUM3bkIsUUFBUTBSO1lBQzVCO1FBQ0Y7SUFDRjtJQUVBOztHQUVDLEdBQ0QvTCxnQkFBZ0IsU0FBU0EsZUFBZTNGLE1BQU0sRUFBRXNGLFFBQVE7UUFDdEQsSUFBSTBMLFVBQVVuUyxVQUFVeEUsTUFBTSxHQUFHLEtBQUt3RSxTQUFTLENBQUMsRUFBRSxLQUFLa00sWUFBWWxNLFNBQVMsQ0FBQyxFQUFFLEdBQUcsQ0FBQztRQUNuRjhCLE9BQU9zVyxrQkFBa0IsQ0FBQ2pYLFFBQVE7WUFDaEMsSUFBSTRvQixvQkFBb0I1WCxRQUFRNFcsT0FBTyxFQUNuQ0EsVUFBVWdCLHNCQUFzQixLQUFLLElBQUksUUFBUUEsbUJBQ2pEaFYsa0JBQWtCNUMsUUFBUXBNLEtBQUssRUFDL0JBLFFBQVFnUCxvQkFBb0IsS0FBSyxJQUFJLFFBQVFBO1lBQ2pELElBQUlGLGVBQWUxQyxRQUFRMUssRUFBRSxFQUN6QkEsS0FBS29OLGlCQUFpQixLQUFLLElBQUkxVCxPQUFPRyxTQUFTLEdBQUd1VDtZQUV0RCxJQUFJLENBQUNwTyxTQUFTakwsTUFBTSxFQUFFO2dCQUNwQjtZQUNGO1lBRUEsSUFBSSxDQUFDaU0sSUFBSTtnQkFDUDtZQUNGLE9BQU8sSUFBSXJDLE1BQU1xTixPQUFPLENBQUNoTCxLQUFLO2dCQUM1QixJQUFJLENBQUNzaEIsU0FBUztvQkFDWnRoQixLQUFLM0YsT0FBT3FhLFdBQVcsQ0FBQ2hiLFFBQVFzRyxJQUFJO3dCQUNsQzFCLE9BQU9BO29CQUNUO2dCQUNGO2dCQUVBLElBQUlYLE1BQU1jLFdBQVcsQ0FBQ3VCLEtBQUs7b0JBQ3pCQSxLQUFLQSxHQUFHaUwsTUFBTTtnQkFDaEIsT0FBTztvQkFDTCxJQUFJbUosZ0JBQWdCelcsTUFBTXFPLEtBQUssQ0FBQ2hNLEtBQzVCcVUsZ0JBQWdCbmQsZUFBZWtkLGVBQWUsSUFDOUNsTixNQUFNbU4sYUFBYSxDQUFDLEVBQUU7b0JBRTFCLElBQUksQ0FBQy9WLFNBQVNqRSxNQUFNLENBQUMsT0FBTyxDQUFDWCxRQUFRO3dCQUNuQ3NHLElBQUlrSDtvQkFDTixJQUFJO3dCQUNGO29CQUNGO29CQUVBLElBQUlzTCxXQUFXblksT0FBT21ZLFFBQVEsQ0FBQzlZLFFBQVF3TjtvQkFDdkN4SyxVQUFVLENBQUMsU0FBUyxDQUFDaEQsUUFBUTt3QkFDM0JzRyxJQUFJQTtvQkFDTjtvQkFDQUEsS0FBS3dTLFNBQVNULEtBQUs7Z0JBQ3JCO1lBQ0YsT0FBTyxJQUFJaFcsS0FBS2lULE1BQU0sQ0FBQ2hQLEtBQUs7Z0JBQzFCQSxLQUFLM0YsT0FBT3NSLEtBQUssQ0FBQ2pTLFFBQVFzRztZQUM1QjtZQUVBLElBQUksQ0FBQzFCLFNBQVNqRSxNQUFNLENBQUMsT0FBTyxDQUFDWCxRQUFRO2dCQUNuQ3NHLElBQUlBO1lBQ04sSUFBSTtnQkFDRjtZQUNGLEVBQUUsd0VBQXdFO1lBQzFFLG9EQUFvRDtZQUdwRCxJQUFJb3BCLHFCQUFxQi91QixPQUFPb1EsS0FBSyxDQUFDL1EsUUFBUTtnQkFDNUNzRyxJQUFJQTtnQkFDSjlDLE9BQU8sU0FBU0EsTUFBTWxJLENBQUM7b0JBQ3JCLE9BQU82SyxRQUFRQyxTQUFTLENBQUM5SyxNQUFNcUYsT0FBT04sUUFBUSxDQUFDTCxRQUFRMUU7Z0JBQ3pEO2dCQUNBNlYsTUFBTTtnQkFDTnZNLE9BQU9BO1lBQ1Q7WUFFQSxJQUFJOHFCLG9CQUFvQjtnQkFDdEIsSUFBSUMsc0JBQXNCbnlCLGVBQWVreUIsb0JBQW9CLElBQ3pERSxjQUFjRCxtQkFBbUIsQ0FBQyxFQUFFO2dCQUV4QyxJQUFJaHZCLE9BQU9xUyxLQUFLLENBQUNoVCxRQUFRc0csSUFBSXNwQixjQUFjO29CQUN6QyxJQUFJbmUsUUFBUTlRLE9BQU84USxLQUFLLENBQUN6UixRQUFRNHZCO29CQUNqQ3RwQixLQUFLbUw7Z0JBQ1AsT0FBTyxJQUFJOVEsT0FBT3dTLE9BQU8sQ0FBQ25ULFFBQVFzRyxJQUFJc3BCLGNBQWM7b0JBQ2xELElBQUk1ZCxTQUFTclIsT0FBT3FSLE1BQU0sQ0FBQ2hTLFFBQVE0dkI7b0JBQ25DdHBCLEtBQUswTDtnQkFDUDtZQUNGO1lBRUEsSUFBSTZkLGFBQWFsdkIsT0FBT29RLEtBQUssQ0FBQy9RLFFBQVE7Z0JBQ3BDd0QsT0FBTyxTQUFTQSxNQUFNbEksQ0FBQztvQkFDckIsT0FBTzZLLFFBQVFDLFNBQVMsQ0FBQzlLLE1BQU1xRixPQUFPK1IsT0FBTyxDQUFDMVMsUUFBUTFFO2dCQUN4RDtnQkFDQWdMLElBQUlBO2dCQUNKMUIsT0FBT0E7WUFDVDtZQUVBLElBQUlrckIsY0FBY3R5QixlQUFlcXlCLFlBQVksSUFDekNsYixZQUFZbWIsV0FBVyxDQUFDLEVBQUU7WUFFOUIsSUFBSUMsZUFBZXB2QixPQUFPd1MsT0FBTyxDQUFDblQsUUFBUXNHLElBQUlxTztZQUM5QyxJQUFJcWIsYUFBYXJ2QixPQUFPcVMsS0FBSyxDQUFDaFQsUUFBUXNHLElBQUlxTztZQUMxQyxJQUFJc2IsZUFBZUYsZ0JBQWdCQztZQUNuQyxJQUFJRSxhQUFhLENBQUNILGdCQUFnQkEsZ0JBQWdCQztZQUNsRCxJQUFJRyxXQUFXLENBQUNIO1lBRWhCLElBQUl4WSxjQUFjblMsS0FBS2tOLEtBQUssQ0FBQztnQkFDM0J0UyxVQUFVcUY7WUFDWixHQUFHLEVBQUUsR0FDRG1TLGVBQWVqYSxlQUFlZ2EsYUFBYSxJQUMzQ0UsWUFBWUQsWUFBWSxDQUFDLEVBQUU7WUFFL0IsSUFBSUUsYUFBYXRTLEtBQUttTyxJQUFJLENBQUM7Z0JBQ3pCdlQsVUFBVXFGO1lBQ1osR0FBRyxFQUFFLEdBQ0RzUyxjQUFjcGEsZUFBZW1hLFlBQVksSUFDekNFLFdBQVdELFdBQVcsQ0FBQyxFQUFFO1lBRTdCLElBQUl2SCxVQUFVLEVBQUU7WUFFaEIsSUFBSStmLFVBQVUsU0FBU0EsUUFBUW5vQixLQUFLO2dCQUNsQyxJQUFJQyxRQUFRMUssZUFBZXlLLE9BQU8sSUFDOUIzTSxJQUFJNE0sS0FBSyxDQUFDLEVBQUUsRUFDWkMsSUFBSUQsS0FBSyxDQUFDLEVBQUU7Z0JBRWhCLElBQUltb0IsU0FBU2xvQixFQUFFOU4sTUFBTSxLQUFLO2dCQUUxQixJQUFJZzJCLFFBQVE7b0JBQ1YsT0FBTztnQkFDVDtnQkFFQSxJQUFJSixjQUFjO29CQUNoQixPQUFPO2dCQUNUO2dCQUVBLElBQUlDLGNBQWM3dEIsS0FBS3VOLFVBQVUsQ0FBQ3pILEdBQUd1UCxjQUFjdlIsUUFBUUMsU0FBUyxDQUFDOUssTUFBTSxDQUFDMEUsT0FBT00sTUFBTSxDQUFDaEYsTUFBTSxDQUFDMEUsT0FBT0ssUUFBUSxDQUFDL0UsSUFBSTtvQkFDbkgsT0FBTztnQkFDVDtnQkFFQSxJQUFJNjBCLFlBQVk5dEIsS0FBS3VOLFVBQVUsQ0FBQ3pILEdBQUcwUCxhQUFhMVIsUUFBUUMsU0FBUyxDQUFDOUssTUFBTSxDQUFDMEUsT0FBT00sTUFBTSxDQUFDaEYsTUFBTSxDQUFDMEUsT0FBT0ssUUFBUSxDQUFDL0UsSUFBSTtvQkFDaEgsT0FBTztnQkFDVDtnQkFFQSxPQUFPO1lBQ1Q7WUFFQSxJQUFJMkYsYUFBYXF0QiwyQkFBMkJqcEIsS0FBSzJDLEtBQUssQ0FBQztnQkFDckQvSCxVQUFVcUY7WUFDWixHQUFHO2dCQUNENlEsTUFBTWlhO1lBQ1IsS0FDSWp2QjtZQUVKLElBQUk7Z0JBQ0YsSUFBS0YsV0FBVzFCLENBQUMsSUFBSSxDQUFDLENBQUM0QixTQUFTRixXQUFXM0YsQ0FBQyxFQUFDLEVBQUc0QixJQUFJLEVBQUc7b0JBQ3JELElBQUkrSSxRQUFROUUsT0FBTy9ILEtBQUs7b0JBRXhCLElBQUlnM0IsUUFBUW5xQixRQUFRO3dCQUNsQm9LLFFBQVFsVCxJQUFJLENBQUM4STtvQkFDZjtnQkFDRjtZQUNGLEVBQUUsT0FBTzdJLEtBQUs7Z0JBQ1o2RCxXQUFXekIsQ0FBQyxDQUFDcEM7WUFDZixTQUFVO2dCQUNSNkQsV0FBV3hCLENBQUM7WUFDZDtZQUVBLElBQUk2d0IsU0FBUyxFQUFFO1lBQ2YsSUFBSUMsVUFBVSxFQUFFO1lBQ2hCLElBQUlDLE9BQU8sRUFBRTtZQUNiLElBQUlDLFdBQVc7WUFDZixJQUFJamUsWUFBWTtZQUVoQixJQUFLLElBQUk3VixLQUFLLEdBQUdvd0IsV0FBVzFjLFNBQVMxVCxLQUFLb3dCLFNBQVMxeUIsTUFBTSxFQUFFc0MsS0FBTTtnQkFDL0QsSUFBSSt6QixjQUFjbHpCLGVBQWV1dkIsUUFBUSxDQUFDcHdCLEdBQUcsRUFBRSxJQUMzQzhHLE9BQU9pdEIsV0FBVyxDQUFDLEVBQUU7Z0JBRXpCLElBQUl2cUIsUUFBUUMsU0FBUyxDQUFDM0MsU0FBUyxDQUFDekQsT0FBT0ssUUFBUSxDQUFDb0QsT0FBTztvQkFDckRndEIsV0FBVztvQkFDWGplLFlBQVk7b0JBQ1orZCxRQUFRcHpCLElBQUksQ0FBQ3NHO2dCQUNmLE9BQU8sSUFBSWd0QixVQUFVO29CQUNuQkgsT0FBT256QixJQUFJLENBQUNzRztnQkFDZCxPQUFPO29CQUNMK3NCLEtBQUtyekIsSUFBSSxDQUFDc0c7Z0JBQ1o7WUFDRjtZQUVBLElBQUlxUSxnQkFBZ0JuVCxPQUFPcUgsS0FBSyxDQUFDaEksUUFBUTtnQkFDdkNzRyxJQUFJQTtnQkFDSjlDLE9BQU8sU0FBU0EsTUFBTWxJLENBQUM7b0JBQ3JCLE9BQU9vSSxLQUFLQyxNQUFNLENBQUNySSxNQUFNcUYsT0FBT04sUUFBUSxDQUFDTCxRQUFRMUU7Z0JBQ25EO2dCQUNBNlYsTUFBTTtnQkFDTnZNLE9BQU9BO1lBQ1QsSUFDSW1QLGlCQUFpQnZXLGVBQWVzVyxlQUFlLElBQy9DNmMsY0FBYzVjLGNBQWMsQ0FBQyxFQUFFO1lBRW5DLElBQUk2YyxlQUFlcHpCLGVBQWVtekIsYUFBYSxJQUMzQ0UsYUFBYUQsWUFBWSxDQUFDLEVBQUU7WUFFaEMsSUFBSUUsZ0JBQWdCbndCLE9BQU93UyxPQUFPLENBQUNuVCxRQUFRc0csSUFBSXVxQjtZQUMvQyxJQUFJRSxjQUFjcHdCLE9BQU9xUyxLQUFLLENBQUNoVCxRQUFRc0csSUFBSXVxQjtZQUMzQyxJQUFJRyxZQUFZcndCLE9BQU9zWCxPQUFPLENBQUNqWSxRQUFRZ3dCLGNBQWMsQ0FBQ1EsS0FBS24yQixNQUFNLEdBQUdnSSxLQUFLcEYsSUFBSSxDQUFDMFgsYUFBYUE7WUFDM0YsSUFBSXdhLFNBQVN4dUIsT0FBT3NYLE9BQU8sQ0FBQ2pZLFFBQVErd0IsY0FBYzF1QixLQUFLcEYsSUFBSSxDQUFDNHpCLGNBQWNBO1lBQzFFN3RCLFdBQVd3QyxVQUFVLENBQUN4RixRQUFRO2dCQUM1QnNHLElBQUlBO2dCQUNKOUMsT0FBTyxTQUFTQSxNQUFNbEksQ0FBQztvQkFDckIsT0FBT2tYLFlBQVlyTSxRQUFRQyxTQUFTLENBQUM5SyxNQUFNcUYsT0FBTytSLE9BQU8sQ0FBQzFTLFFBQVExRSxLQUFLb0ksS0FBS0MsTUFBTSxDQUFDckksTUFBTXFGLE9BQU9OLFFBQVEsQ0FBQ0wsUUFBUTFFO2dCQUNuSDtnQkFDQTZWLE1BQU1xQixZQUFZLFdBQVc7Z0JBQzdCL00sUUFBUStNLGFBQWMsRUFBQ3VkLGdCQUFnQk8sT0FBT2oyQixNQUFNLEdBQUcsTUFBTyxFQUFDMjFCLGNBQWNRLEtBQUtuMkIsTUFBTSxHQUFHO2dCQUMzRnVLLE9BQU9BO1lBQ1Q7WUFDQSxJQUFJc3FCLFdBQVd2dUIsT0FBT3NYLE9BQU8sQ0FBQ2pZLFFBQVEsQ0FBQzh3QixpQkFBaUJBLGlCQUFpQkMsY0FBYzF1QixLQUFLcEYsSUFBSSxDQUFDNHpCLGNBQWNBO1lBQy9HN3RCLFdBQVc2QyxXQUFXLENBQUM3RixRQUFRc3dCLFFBQVE7Z0JBQ3JDaHFCLElBQUk0b0IsU0FBUzlXLE9BQU87Z0JBQ3BCNVUsT0FBTyxTQUFTQSxNQUFNbEksQ0FBQztvQkFDckIsT0FBT29JLEtBQUtDLE1BQU0sQ0FBQ3JJLE1BQU1xRixPQUFPTixRQUFRLENBQUNMLFFBQVExRTtnQkFDbkQ7Z0JBQ0E2VixNQUFNO2dCQUNOdk0sT0FBT0E7WUFDVDtZQUVBLElBQUlxckIsZ0JBQWdCLENBQUNLLE9BQU9qMkIsTUFBTSxJQUFJazJCLFFBQVFsMkIsTUFBTSxJQUFJLENBQUNtMkIsS0FBS24yQixNQUFNLEVBQUU7Z0JBQ3BFMkksVUFBVSxDQUFDLFNBQVMsQ0FBQ2hELFFBQVE7b0JBQzNCc0csSUFBSXFPO29CQUNKL1AsT0FBT0E7Z0JBQ1Q7WUFDRjtZQUVBNUIsV0FBVzZDLFdBQVcsQ0FBQzdGLFFBQVF1d0IsU0FBUztnQkFDdENqcUIsSUFBSTBxQixVQUFVNVksT0FBTztnQkFDckI1VSxPQUFPLFNBQVNBLE1BQU1sSSxDQUFDO29CQUNyQixPQUFPNkssUUFBUUMsU0FBUyxDQUFDOUssTUFBTXFGLE9BQU8rUixPQUFPLENBQUMxUyxRQUFRMUU7Z0JBQ3hEO2dCQUNBNlYsTUFBTTtnQkFDTnZNLE9BQU9BO1lBQ1Q7WUFDQTVCLFdBQVc2QyxXQUFXLENBQUM3RixRQUFRd3dCLE1BQU07Z0JBQ25DbHFCLElBQUk2b0IsT0FBTy9XLE9BQU87Z0JBQ2xCNVUsT0FBTyxTQUFTQSxNQUFNbEksQ0FBQztvQkFDckIsT0FBT29JLEtBQUtDLE1BQU0sQ0FBQ3JJLE1BQU1xRixPQUFPTixRQUFRLENBQUNMLFFBQVExRTtnQkFDbkQ7Z0JBQ0E2VixNQUFNO2dCQUNOdk0sT0FBT0E7WUFDVDtZQUVBLElBQUksQ0FBQ29NLFFBQVExSyxFQUFFLEVBQUU7Z0JBQ2YsSUFBSXBFO2dCQUVKLElBQUlzdUIsS0FBS24yQixNQUFNLEdBQUcsS0FBSzgwQixPQUFPL1csT0FBTyxFQUFFO29CQUNyQ2xXLE9BQU9HLEtBQUtrRyxRQUFRLENBQUM0bUIsT0FBTy9XLE9BQU87Z0JBQ3JDLE9BQU8sSUFBSW1ZLFFBQVFsMkIsTUFBTSxHQUFHLEtBQUsyMkIsVUFBVTVZLE9BQU8sRUFBRTtvQkFDbERsVyxPQUFPRyxLQUFLa0csUUFBUSxDQUFDeW9CLFVBQVU1WSxPQUFPO2dCQUN4QyxPQUFPLElBQUk4VyxTQUFTOVcsT0FBTyxFQUFFO29CQUMzQmxXLE9BQU9HLEtBQUtrRyxRQUFRLENBQUMybUIsU0FBUzlXLE9BQU87Z0JBQ3ZDO2dCQUVBLElBQUlsVyxNQUFNO29CQUNSLElBQUkrdUIsUUFBUXR3QixPQUFPNk0sR0FBRyxDQUFDeE4sUUFBUWtDO29CQUUvQmMsV0FBVzZrQixNQUFNLENBQUM3bkIsUUFBUWl4QjtnQkFDNUI7WUFDRjtZQUVBL0IsU0FBUzdXLEtBQUs7WUFDZDJZLFVBQVUzWSxLQUFLO1lBQ2Y4VyxPQUFPOVcsS0FBSztRQUNkO0lBQ0Y7SUFFQTs7R0FFQyxHQUNEdlMsWUFBWSxTQUFTQSxXQUFXOUYsTUFBTSxFQUFFK0YsSUFBSTtRQUMxQyxJQUFJaUwsVUFBVW5TLFVBQVV4RSxNQUFNLEdBQUcsS0FBS3dFLFNBQVMsQ0FBQyxFQUFFLEtBQUtrTSxZQUFZbE0sU0FBUyxDQUFDLEVBQUUsR0FBRyxDQUFDO1FBQ25GOEIsT0FBT3NXLGtCQUFrQixDQUFDalgsUUFBUTtZQUNoQyxJQUFJK1Usa0JBQWtCL0QsUUFBUXBNLEtBQUssRUFDL0JBLFFBQVFtUSxvQkFBb0IsS0FBSyxJQUFJLFFBQVFBO1lBQ2pELElBQUlDLGVBQWVoRSxRQUFRMUssRUFBRSxFQUN6QkEsS0FBSzBPLGlCQUFpQixLQUFLLElBQUloVixPQUFPRyxTQUFTLEdBQUc2VTtZQUV0RCxJQUFJLENBQUMxTyxJQUFJO2dCQUNQO1lBQ0Y7WUFFQSxJQUFJakUsS0FBS2lULE1BQU0sQ0FBQ2hQLEtBQUs7Z0JBQ25CQSxLQUFLM0YsT0FBT2lSLEtBQUssQ0FBQzVSLFFBQVFzRztZQUM1QjtZQUVBLElBQUlyQyxNQUFNcU4sT0FBTyxDQUFDaEwsS0FBSztnQkFDckIsSUFBSXJDLE1BQU1jLFdBQVcsQ0FBQ3VCLEtBQUs7b0JBQ3pCQSxLQUFLQSxHQUFHaUwsTUFBTTtnQkFDaEIsT0FBTztvQkFDTCxJQUFJL0QsTUFBTXZKLE1BQU11SixHQUFHLENBQUNsSDtvQkFFcEIsSUFBSSxDQUFDMUIsU0FBU2pFLE1BQU0sQ0FBQyxPQUFPLENBQUNYLFFBQVE7d0JBQ25Dc0csSUFBSWtIO29CQUNOLElBQUk7d0JBQ0Y7b0JBQ0Y7b0JBRUEsSUFBSXlFLFFBQVFoTyxNQUFNZ08sS0FBSyxDQUFDM0w7b0JBQ3hCLElBQUk0b0IsV0FBV3Z1QixPQUFPbVksUUFBUSxDQUFDOVksUUFBUWlTO29CQUN2QyxJQUFJa2QsU0FBU3h1QixPQUFPbVksUUFBUSxDQUFDOVksUUFBUXdOO29CQUNyQ3hLLFVBQVUsQ0FBQyxTQUFTLENBQUNoRCxRQUFRO3dCQUMzQnNHLElBQUlBO3dCQUNKMUIsT0FBT0E7b0JBQ1Q7b0JBQ0EsSUFBSXNzQixhQUFhaEMsU0FBUzdXLEtBQUs7b0JBQy9CLElBQUk4WSxXQUFXaEMsT0FBTzlXLEtBQUs7b0JBQzNCL1IsS0FBSzRxQixjQUFjQztvQkFDbkJudUIsV0FBV2lyQixZQUFZLENBQUNqdUIsUUFBUTt3QkFDOUJ1UixRQUFRakw7d0JBQ1JrTCxPQUFPbEw7b0JBQ1Q7Z0JBQ0Y7WUFDRjtZQUVBLElBQUksQ0FBQzFCLFNBQVNqRSxNQUFNLENBQUMsT0FBTyxDQUFDWCxRQUFRO2dCQUNuQ3NHLElBQUlBO1lBQ04sSUFBSTtnQkFDRjtZQUNGO1lBRUEsSUFBSThxQixNQUFNOXFCLElBQ05wRSxPQUFPa3ZCLElBQUlsdkIsSUFBSSxFQUNmcVIsU0FBUzZkLElBQUk3ZCxNQUFNO1lBQ3ZCLElBQUl4TixLQUFLMUwsTUFBTSxHQUFHLEdBQUcyRixPQUFPdEIsS0FBSyxDQUFDO2dCQUNoQ3lFLE1BQU07Z0JBQ05qQixNQUFNQTtnQkFDTnFSLFFBQVFBO2dCQUNSeE4sTUFBTUE7WUFDUjtRQUNGO0lBQ0Y7QUFDRjtBQUVBLFNBQVNzckIsUUFBUW56QixNQUFNLEVBQUVDLGNBQWM7SUFBSSxJQUFJQyxPQUFPbkYsT0FBT21GLElBQUksQ0FBQ0Y7SUFBUyxJQUFJakYsT0FBT29GLHFCQUFxQixFQUFFO1FBQUUsSUFBSUMsVUFBVXJGLE9BQU9vRixxQkFBcUIsQ0FBQ0g7UUFBUyxJQUFJQyxnQkFBZ0I7WUFBRUcsVUFBVUEsUUFBUUMsTUFBTSxDQUFDLFNBQVVDLEdBQUc7Z0JBQUksT0FBT3ZGLE9BQU93Rix3QkFBd0IsQ0FBQ1AsUUFBUU0sS0FBS3BDLFVBQVU7WUFBRTtRQUFJO1FBQUVnQyxLQUFLakIsSUFBSSxDQUFDdUIsS0FBSyxDQUFDTixNQUFNRTtJQUFVO0lBQUUsT0FBT0Y7QUFBTTtBQUV4VixTQUFTa3pCLGNBQWMxeUIsTUFBTTtJQUFJLElBQUssSUFBSXRFLElBQUksR0FBR0EsSUFBSXVFLFVBQVV4RSxNQUFNLEVBQUVDLElBQUs7UUFBRSxJQUFJd0UsU0FBU0QsU0FBUyxDQUFDdkUsRUFBRSxJQUFJLE9BQU91RSxTQUFTLENBQUN2RSxFQUFFLEdBQUcsQ0FBQztRQUFHLElBQUlBLElBQUksR0FBRztZQUFFKzJCLFFBQVFwNEIsT0FBTzZGLFNBQVMsTUFBTUMsT0FBTyxDQUFDLFNBQVU1QyxHQUFHO2dCQUFJRixnQkFBZ0IyQyxRQUFRekMsS0FBSzJDLE1BQU0sQ0FBQzNDLElBQUk7WUFBRztRQUFJLE9BQU8sSUFBSWxELE9BQU8rRix5QkFBeUIsRUFBRTtZQUFFL0YsT0FBT2dHLGdCQUFnQixDQUFDTCxRQUFRM0YsT0FBTytGLHlCQUF5QixDQUFDRjtRQUFVLE9BQU87WUFBRXV5QixRQUFRcDRCLE9BQU82RixTQUFTQyxPQUFPLENBQUMsU0FBVTVDLEdBQUc7Z0JBQUlsRCxPQUFPQyxjQUFjLENBQUMwRixRQUFRekMsS0FBS2xELE9BQU93Rix3QkFBd0IsQ0FBQ0ssUUFBUTNDO1lBQU87UUFBSTtJQUFFO0lBQUUsT0FBT3lDO0FBQVE7QUFDcmhCLElBQUlvRSxhQUFhc3VCLGNBQWNBLGNBQWNBLGNBQWNBLGNBQWMsQ0FBQyxHQUFHdkssb0JBQW9CVyxpQkFBaUJpRyxzQkFBc0JZO0FBRXhJcDFCLGNBQWMsR0FBR3dIO0FBQ2pCeEgsZUFBZSxHQUFHZ047QUFDbEJoTixnQkFBZ0IsR0FBR3lpQjtBQUNuQnppQixZQUFZLEdBQUdrTTtBQUNmbE0saUJBQWlCLEdBQUcyWjtBQUNwQjNaLFlBQVksR0FBR2tKO0FBQ2ZsSixlQUFlLEdBQUc0SDtBQUNsQjVILGFBQWEsR0FBRzhaO0FBQ2hCOVosZ0JBQWdCLEdBQUdrSTtBQUNuQmxJLGFBQWEsR0FBRzhLO0FBQ2hCOUssZ0JBQWdCLEdBQUd1STtBQUNuQnZJLGdCQUFnQixHQUFHa2pCO0FBQ25CbGpCLFlBQVksR0FBRzZjO0FBQ2Y3YyxZQUFZLEdBQUd1SztBQUNmdkssa0JBQWtCLEdBQUc2SjtBQUNyQjdKLG9CQUFvQixHQUFHNEcsY0FDdkIsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGF5bG9hZC8uL25vZGVfbW9kdWxlcy9zbGF0ZS9kaXN0L2luZGV4LmpzP2E2NDkiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgaXNQbGFpbk9iamVjdCA9IHJlcXVpcmUoJ2lzLXBsYWluLW9iamVjdCcpO1xudmFyIGltbWVyID0gcmVxdWlyZSgnaW1tZXInKTtcblxuZnVuY3Rpb24gdW53cmFwRXhwb3J0cyAoeCkge1xuXHRyZXR1cm4geCAmJiB4Ll9fZXNNb2R1bGUgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHgsICdkZWZhdWx0JykgPyB4WydkZWZhdWx0J10gOiB4O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVDb21tb25qc01vZHVsZShmbiwgbW9kdWxlKSB7XG5cdHJldHVybiBtb2R1bGUgPSB7IGV4cG9ydHM6IHt9IH0sIGZuKG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMpLCBtb2R1bGUuZXhwb3J0cztcbn1cblxudmFyIGFycmF5TGlrZVRvQXJyYXkgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlKSB7XG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikge1xuICBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHtcbiAgICBhcnIyW2ldID0gYXJyW2ldO1xuICB9XG5cbiAgcmV0dXJuIGFycjI7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2FycmF5TGlrZVRvQXJyYXk7XG5tb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG59KTtcblxudW53cmFwRXhwb3J0cyhhcnJheUxpa2VUb0FycmF5KTtcblxudmFyIGFycmF5V2l0aG91dEhvbGVzID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSkge1xuZnVuY3Rpb24gX2FycmF5V2l0aG91dEhvbGVzKGFycikge1xuICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gYXJyYXlMaWtlVG9BcnJheShhcnIpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9hcnJheVdpdGhvdXRIb2xlcztcbm1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbn0pO1xuXG51bndyYXBFeHBvcnRzKGFycmF5V2l0aG91dEhvbGVzKTtcblxudmFyIGl0ZXJhYmxlVG9BcnJheSA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUpIHtcbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXkoaXRlcikge1xuICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBpdGVyW1N5bWJvbC5pdGVyYXRvcl0gIT0gbnVsbCB8fCBpdGVyW1wiQEBpdGVyYXRvclwiXSAhPSBudWxsKSByZXR1cm4gQXJyYXkuZnJvbShpdGVyKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfaXRlcmFibGVUb0FycmF5O1xubW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHMsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xufSk7XG5cbnVud3JhcEV4cG9ydHMoaXRlcmFibGVUb0FycmF5KTtcblxudmFyIHVuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5ID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSkge1xuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikge1xuICBpZiAoIW8pIHJldHVybjtcbiAgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xuICB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7XG4gIGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7XG4gIGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pO1xuICBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIGFycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXk7XG5tb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG59KTtcblxudW53cmFwRXhwb3J0cyh1bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSk7XG5cbnZhciBub25JdGVyYWJsZVNwcmVhZCA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUpIHtcbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVNwcmVhZCgpIHtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBzcHJlYWQgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX25vbkl0ZXJhYmxlU3ByZWFkO1xubW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHMsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xufSk7XG5cbnVud3JhcEV4cG9ydHMobm9uSXRlcmFibGVTcHJlYWQpO1xuXG52YXIgdG9Db25zdW1hYmxlQXJyYXkgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlKSB7XG5mdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkoYXJyKSB7XG4gIHJldHVybiBhcnJheVdpdGhvdXRIb2xlcyhhcnIpIHx8IGl0ZXJhYmxlVG9BcnJheShhcnIpIHx8IHVuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFycikgfHwgbm9uSXRlcmFibGVTcHJlYWQoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfdG9Db25zdW1hYmxlQXJyYXk7XG5tb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG59KTtcblxudmFyIF90b0NvbnN1bWFibGVBcnJheSA9IHVud3JhcEV4cG9ydHModG9Db25zdW1hYmxlQXJyYXkpO1xuXG52YXIgZGVmaW5lUHJvcGVydHkgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlKSB7XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7XG4gIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBvYmpba2V5XSA9IHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIG9iajtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfZGVmaW5lUHJvcGVydHk7XG5tb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG59KTtcblxudmFyIF9kZWZpbmVQcm9wZXJ0eSA9IHVud3JhcEV4cG9ydHMoZGVmaW5lUHJvcGVydHkpO1xuXG52YXIgYXJyYXlXaXRoSG9sZXMgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlKSB7XG5mdW5jdGlvbiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBhcnI7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2FycmF5V2l0aEhvbGVzO1xubW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHMsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xufSk7XG5cbnVud3JhcEV4cG9ydHMoYXJyYXlXaXRoSG9sZXMpO1xuXG52YXIgaXRlcmFibGVUb0FycmF5TGltaXQgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlKSB7XG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB7XG4gIHZhciBfaSA9IGFyciA9PSBudWxsID8gbnVsbCA6IHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgYXJyW1N5bWJvbC5pdGVyYXRvcl0gfHwgYXJyW1wiQEBpdGVyYXRvclwiXTtcblxuICBpZiAoX2kgPT0gbnVsbCkgcmV0dXJuO1xuICB2YXIgX2FyciA9IFtdO1xuICB2YXIgX24gPSB0cnVlO1xuICB2YXIgX2QgPSBmYWxzZTtcblxuICB2YXIgX3MsIF9lO1xuXG4gIHRyeSB7XG4gICAgZm9yIChfaSA9IF9pLmNhbGwoYXJyKTsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkge1xuICAgICAgX2Fyci5wdXNoKF9zLnZhbHVlKTtcblxuICAgICAgaWYgKGkgJiYgX2Fyci5sZW5ndGggPT09IGkpIGJyZWFrO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgX2QgPSB0cnVlO1xuICAgIF9lID0gZXJyO1xuICB9IGZpbmFsbHkge1xuICAgIHRyeSB7XG4gICAgICBpZiAoIV9uICYmIF9pW1wicmV0dXJuXCJdICE9IG51bGwpIF9pW1wicmV0dXJuXCJdKCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlmIChfZCkgdGhyb3cgX2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIF9hcnI7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2l0ZXJhYmxlVG9BcnJheUxpbWl0O1xubW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHMsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xufSk7XG5cbnVud3JhcEV4cG9ydHMoaXRlcmFibGVUb0FycmF5TGltaXQpO1xuXG52YXIgbm9uSXRlcmFibGVSZXN0ID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSkge1xuZnVuY3Rpb24gX25vbkl0ZXJhYmxlUmVzdCgpIHtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfbm9uSXRlcmFibGVSZXN0O1xubW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHMsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xufSk7XG5cbnVud3JhcEV4cG9ydHMobm9uSXRlcmFibGVSZXN0KTtcblxudmFyIHNsaWNlZFRvQXJyYXkgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlKSB7XG5mdW5jdGlvbiBfc2xpY2VkVG9BcnJheShhcnIsIGkpIHtcbiAgcmV0dXJuIGFycmF5V2l0aEhvbGVzKGFycikgfHwgaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB8fCB1bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIsIGkpIHx8IG5vbkl0ZXJhYmxlUmVzdCgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9zbGljZWRUb0FycmF5O1xubW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHMsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xufSk7XG5cbnZhciBfc2xpY2VkVG9BcnJheSA9IHVud3JhcEV4cG9ydHMoc2xpY2VkVG9BcnJheSk7XG5cbnZhciBESVJUWV9QQVRIUyA9IG5ldyBXZWFrTWFwKCk7XG52YXIgRElSVFlfUEFUSF9LRVlTID0gbmV3IFdlYWtNYXAoKTtcbnZhciBGTFVTSElORyA9IG5ldyBXZWFrTWFwKCk7XG52YXIgTk9STUFMSVpJTkcgPSBuZXcgV2Vha01hcCgpO1xudmFyIFBBVEhfUkVGUyA9IG5ldyBXZWFrTWFwKCk7XG52YXIgUE9JTlRfUkVGUyA9IG5ldyBXZWFrTWFwKCk7XG52YXIgUkFOR0VfUkVGUyA9IG5ldyBXZWFrTWFwKCk7XG5cbmZ1bmN0aW9uIG93bktleXMkOShvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgeyBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSk7IH0ga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQkOSh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyBvd25LZXlzJDkoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHsgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTsgfSBlbHNlIHsgb3duS2V5cyQ5KE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciQ3KG8sIGFsbG93QXJyYXlMaWtlKSB7IHZhciBpdCA9IHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdIHx8IG9bXCJAQGl0ZXJhdG9yXCJdOyBpZiAoIWl0KSB7IGlmIChBcnJheS5pc0FycmF5KG8pIHx8IChpdCA9IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSQ3KG8pKSB8fCBhbGxvd0FycmF5TGlrZSAmJiBvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgeyBpZiAoaXQpIG8gPSBpdDsgdmFyIGkgPSAwOyB2YXIgRiA9IGZ1bmN0aW9uIEYoKSB7fTsgcmV0dXJuIHsgczogRiwgbjogZnVuY3Rpb24gbigpIHsgaWYgKGkgPj0gby5sZW5ndGgpIHJldHVybiB7IGRvbmU6IHRydWUgfTsgcmV0dXJuIHsgZG9uZTogZmFsc2UsIHZhbHVlOiBvW2krK10gfTsgfSwgZTogZnVuY3Rpb24gZShfZSkgeyB0aHJvdyBfZTsgfSwgZjogRiB9OyB9IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfSB2YXIgbm9ybWFsQ29tcGxldGlvbiA9IHRydWUsIGRpZEVyciA9IGZhbHNlLCBlcnI7IHJldHVybiB7IHM6IGZ1bmN0aW9uIHMoKSB7IGl0ID0gaXQuY2FsbChvKTsgfSwgbjogZnVuY3Rpb24gbigpIHsgdmFyIHN0ZXAgPSBpdC5uZXh0KCk7IG5vcm1hbENvbXBsZXRpb24gPSBzdGVwLmRvbmU7IHJldHVybiBzdGVwOyB9LCBlOiBmdW5jdGlvbiBlKF9lMikgeyBkaWRFcnIgPSB0cnVlOyBlcnIgPSBfZTI7IH0sIGY6IGZ1bmN0aW9uIGYoKSB7IHRyeSB7IGlmICghbm9ybWFsQ29tcGxldGlvbiAmJiBpdFtcInJldHVyblwiXSAhPSBudWxsKSBpdFtcInJldHVyblwiXSgpOyB9IGZpbmFsbHkgeyBpZiAoZGlkRXJyKSB0aHJvdyBlcnI7IH0gfSB9OyB9XG5cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSQ3KG8sIG1pbkxlbikgeyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkkNyhvLCBtaW5MZW4pOyB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5JDcobywgbWluTGVuKTsgfVxuXG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheSQ3KGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfVxuLyoqXHJcbiAqIENyZWF0ZSBhIG5ldyBTbGF0ZSBgRWRpdG9yYCBvYmplY3QuXHJcbiAqL1xuXG52YXIgY3JlYXRlRWRpdG9yID0gZnVuY3Rpb24gY3JlYXRlRWRpdG9yKCkge1xuICB2YXIgZWRpdG9yID0ge1xuICAgIGNoaWxkcmVuOiBbXSxcbiAgICBvcGVyYXRpb25zOiBbXSxcbiAgICBzZWxlY3Rpb246IG51bGwsXG4gICAgbWFya3M6IG51bGwsXG4gICAgaXNJbmxpbmU6IGZ1bmN0aW9uIGlzSW5saW5lKCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG4gICAgaXNWb2lkOiBmdW5jdGlvbiBpc1ZvaWQoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcbiAgICBtYXJrYWJsZVZvaWQ6IGZ1bmN0aW9uIG1hcmthYmxlVm9pZCgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuICAgIG9uQ2hhbmdlOiBmdW5jdGlvbiBvbkNoYW5nZSgpIHt9LFxuICAgIGFwcGx5OiBmdW5jdGlvbiBhcHBseShvcCkge1xuICAgICAgdmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDcoRWRpdG9yLnBhdGhSZWZzKGVkaXRvcikpLFxuICAgICAgICAgIF9zdGVwO1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKF9pdGVyYXRvci5zKCk7ICEoX3N0ZXAgPSBfaXRlcmF0b3IubigpKS5kb25lOykge1xuICAgICAgICAgIHZhciByZWYgPSBfc3RlcC52YWx1ZTtcbiAgICAgICAgICBQYXRoUmVmLnRyYW5zZm9ybShyZWYsIG9wKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9pdGVyYXRvci5lKGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBfaXRlcmF0b3IuZigpO1xuICAgICAgfVxuXG4gICAgICB2YXIgX2l0ZXJhdG9yMiA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDcoRWRpdG9yLnBvaW50UmVmcyhlZGl0b3IpKSxcbiAgICAgICAgICBfc3RlcDI7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoX2l0ZXJhdG9yMi5zKCk7ICEoX3N0ZXAyID0gX2l0ZXJhdG9yMi5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgdmFyIF9yZWYgPSBfc3RlcDIudmFsdWU7XG4gICAgICAgICAgUG9pbnRSZWYudHJhbnNmb3JtKF9yZWYsIG9wKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9pdGVyYXRvcjIuZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yMi5mKCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBfaXRlcmF0b3IzID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkNyhFZGl0b3IucmFuZ2VSZWZzKGVkaXRvcikpLFxuICAgICAgICAgIF9zdGVwMztcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChfaXRlcmF0b3IzLnMoKTsgIShfc3RlcDMgPSBfaXRlcmF0b3IzLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICB2YXIgX3JlZjIgPSBfc3RlcDMudmFsdWU7XG4gICAgICAgICAgUmFuZ2VSZWYudHJhbnNmb3JtKF9yZWYyLCBvcCk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3IzLmUoZXJyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIF9pdGVyYXRvcjMuZigpO1xuICAgICAgfVxuXG4gICAgICB2YXIgb2xkRGlydHlQYXRocyA9IERJUlRZX1BBVEhTLmdldChlZGl0b3IpIHx8IFtdO1xuICAgICAgdmFyIG9sZERpcnR5UGF0aEtleXMgPSBESVJUWV9QQVRIX0tFWVMuZ2V0KGVkaXRvcikgfHwgbmV3IFNldCgpO1xuICAgICAgdmFyIGRpcnR5UGF0aHM7XG4gICAgICB2YXIgZGlydHlQYXRoS2V5cztcblxuICAgICAgdmFyIGFkZCA9IGZ1bmN0aW9uIGFkZChwYXRoKSB7XG4gICAgICAgIGlmIChwYXRoKSB7XG4gICAgICAgICAgdmFyIGtleSA9IHBhdGguam9pbignLCcpO1xuXG4gICAgICAgICAgaWYgKCFkaXJ0eVBhdGhLZXlzLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICBkaXJ0eVBhdGhLZXlzLmFkZChrZXkpO1xuICAgICAgICAgICAgZGlydHlQYXRocy5wdXNoKHBhdGgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgaWYgKFBhdGgub3BlcmF0aW9uQ2FuVHJhbnNmb3JtUGF0aChvcCkpIHtcbiAgICAgICAgZGlydHlQYXRocyA9IFtdO1xuICAgICAgICBkaXJ0eVBhdGhLZXlzID0gbmV3IFNldCgpO1xuXG4gICAgICAgIHZhciBfaXRlcmF0b3I0ID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkNyhvbGREaXJ0eVBhdGhzKSxcbiAgICAgICAgICAgIF9zdGVwNDtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIGZvciAoX2l0ZXJhdG9yNC5zKCk7ICEoX3N0ZXA0ID0gX2l0ZXJhdG9yNC5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgICB2YXIgcGF0aCA9IF9zdGVwNC52YWx1ZTtcbiAgICAgICAgICAgIHZhciBuZXdQYXRoID0gUGF0aC50cmFuc2Zvcm0ocGF0aCwgb3ApO1xuICAgICAgICAgICAgYWRkKG5ld1BhdGgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgX2l0ZXJhdG9yNC5lKGVycik7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgX2l0ZXJhdG9yNC5mKCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRpcnR5UGF0aHMgPSBvbGREaXJ0eVBhdGhzO1xuICAgICAgICBkaXJ0eVBhdGhLZXlzID0gb2xkRGlydHlQYXRoS2V5cztcbiAgICAgIH1cblxuICAgICAgdmFyIG5ld0RpcnR5UGF0aHMgPSBlZGl0b3IuZ2V0RGlydHlQYXRocyhvcCk7XG5cbiAgICAgIHZhciBfaXRlcmF0b3I1ID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkNyhuZXdEaXJ0eVBhdGhzKSxcbiAgICAgICAgICBfc3RlcDU7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoX2l0ZXJhdG9yNS5zKCk7ICEoX3N0ZXA1ID0gX2l0ZXJhdG9yNS5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgdmFyIF9wYXRoID0gX3N0ZXA1LnZhbHVlO1xuICAgICAgICAgIGFkZChfcGF0aCk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3I1LmUoZXJyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIF9pdGVyYXRvcjUuZigpO1xuICAgICAgfVxuXG4gICAgICBESVJUWV9QQVRIUy5zZXQoZWRpdG9yLCBkaXJ0eVBhdGhzKTtcbiAgICAgIERJUlRZX1BBVEhfS0VZUy5zZXQoZWRpdG9yLCBkaXJ0eVBhdGhLZXlzKTtcbiAgICAgIFRyYW5zZm9ybXMudHJhbnNmb3JtKGVkaXRvciwgb3ApO1xuICAgICAgZWRpdG9yLm9wZXJhdGlvbnMucHVzaChvcCk7XG4gICAgICBFZGl0b3Iubm9ybWFsaXplKGVkaXRvciwge1xuICAgICAgICBvcGVyYXRpb246IG9wXG4gICAgICB9KTsgLy8gQ2xlYXIgYW55IGZvcm1hdHMgYXBwbGllZCB0byB0aGUgY3Vyc29yIGlmIHRoZSBzZWxlY3Rpb24gY2hhbmdlcy5cblxuICAgICAgaWYgKG9wLnR5cGUgPT09ICdzZXRfc2VsZWN0aW9uJykge1xuICAgICAgICBlZGl0b3IubWFya3MgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICBpZiAoIUZMVVNISU5HLmdldChlZGl0b3IpKSB7XG4gICAgICAgIEZMVVNISU5HLnNldChlZGl0b3IsIHRydWUpO1xuICAgICAgICBQcm9taXNlLnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBGTFVTSElORy5zZXQoZWRpdG9yLCBmYWxzZSk7XG4gICAgICAgICAgZWRpdG9yLm9uQ2hhbmdlKHtcbiAgICAgICAgICAgIG9wZXJhdGlvbjogb3BcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBlZGl0b3Iub3BlcmF0aW9ucyA9IFtdO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGFkZE1hcms6IGZ1bmN0aW9uIGFkZE1hcmsoa2V5LCB2YWx1ZSkge1xuICAgICAgdmFyIHNlbGVjdGlvbiA9IGVkaXRvci5zZWxlY3Rpb247XG4gICAgICAgICAgZWRpdG9yLm1hcmthYmxlVm9pZDtcblxuICAgICAgaWYgKHNlbGVjdGlvbikge1xuICAgICAgICB2YXIgbWF0Y2ggPSBmdW5jdGlvbiBtYXRjaChub2RlLCBwYXRoKSB7XG4gICAgICAgICAgaWYgKCFUZXh0LmlzVGV4dChub2RlKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBtYXJrcyBjYW4gb25seSBiZSBhcHBsaWVkIHRvIHRleHRcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgX0VkaXRvciRwYXJlbnQgPSBFZGl0b3IucGFyZW50KGVkaXRvciwgcGF0aCksXG4gICAgICAgICAgICAgIF9FZGl0b3IkcGFyZW50MiA9IF9zbGljZWRUb0FycmF5KF9FZGl0b3IkcGFyZW50LCAyKSxcbiAgICAgICAgICAgICAgcGFyZW50Tm9kZSA9IF9FZGl0b3IkcGFyZW50MlswXTtcbiAgICAgICAgICAgICAgX0VkaXRvciRwYXJlbnQyWzFdO1xuXG4gICAgICAgICAgcmV0dXJuICFlZGl0b3IuaXNWb2lkKHBhcmVudE5vZGUpIHx8IGVkaXRvci5tYXJrYWJsZVZvaWQocGFyZW50Tm9kZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGV4cGFuZGVkU2VsZWN0aW9uID0gUmFuZ2UuaXNFeHBhbmRlZChzZWxlY3Rpb24pO1xuICAgICAgICB2YXIgbWFya0FjY2VwdGluZ1ZvaWRTZWxlY3RlZCA9IGZhbHNlO1xuXG4gICAgICAgIGlmICghZXhwYW5kZWRTZWxlY3Rpb24pIHtcbiAgICAgICAgICB2YXIgX0VkaXRvciRub2RlID0gRWRpdG9yLm5vZGUoZWRpdG9yLCBzZWxlY3Rpb24pLFxuICAgICAgICAgICAgICBfRWRpdG9yJG5vZGUyID0gX3NsaWNlZFRvQXJyYXkoX0VkaXRvciRub2RlLCAyKSxcbiAgICAgICAgICAgICAgc2VsZWN0ZWROb2RlID0gX0VkaXRvciRub2RlMlswXSxcbiAgICAgICAgICAgICAgc2VsZWN0ZWRQYXRoID0gX0VkaXRvciRub2RlMlsxXTtcblxuICAgICAgICAgIGlmIChzZWxlY3RlZE5vZGUgJiYgbWF0Y2goc2VsZWN0ZWROb2RlLCBzZWxlY3RlZFBhdGgpKSB7XG4gICAgICAgICAgICB2YXIgX0VkaXRvciRwYXJlbnQzID0gRWRpdG9yLnBhcmVudChlZGl0b3IsIHNlbGVjdGVkUGF0aCksXG4gICAgICAgICAgICAgICAgX0VkaXRvciRwYXJlbnQ0ID0gX3NsaWNlZFRvQXJyYXkoX0VkaXRvciRwYXJlbnQzLCAxKSxcbiAgICAgICAgICAgICAgICBwYXJlbnROb2RlID0gX0VkaXRvciRwYXJlbnQ0WzBdO1xuXG4gICAgICAgICAgICBtYXJrQWNjZXB0aW5nVm9pZFNlbGVjdGVkID0gcGFyZW50Tm9kZSAmJiBlZGl0b3IubWFya2FibGVWb2lkKHBhcmVudE5vZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChleHBhbmRlZFNlbGVjdGlvbiB8fCBtYXJrQWNjZXB0aW5nVm9pZFNlbGVjdGVkKSB7XG4gICAgICAgICAgVHJhbnNmb3Jtcy5zZXROb2RlcyhlZGl0b3IsIF9kZWZpbmVQcm9wZXJ0eSh7fSwga2V5LCB2YWx1ZSksIHtcbiAgICAgICAgICAgIG1hdGNoOiBtYXRjaCxcbiAgICAgICAgICAgIHNwbGl0OiB0cnVlLFxuICAgICAgICAgICAgdm9pZHM6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgbWFya3MgPSBfb2JqZWN0U3ByZWFkJDkoX29iamVjdFNwcmVhZCQ5KHt9LCBFZGl0b3IubWFya3MoZWRpdG9yKSB8fCB7fSksIHt9LCBfZGVmaW5lUHJvcGVydHkoe30sIGtleSwgdmFsdWUpKTtcblxuICAgICAgICAgIGVkaXRvci5tYXJrcyA9IG1hcmtzO1xuXG4gICAgICAgICAgaWYgKCFGTFVTSElORy5nZXQoZWRpdG9yKSkge1xuICAgICAgICAgICAgZWRpdG9yLm9uQ2hhbmdlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBkZWxldGVCYWNrd2FyZDogZnVuY3Rpb24gZGVsZXRlQmFja3dhcmQodW5pdCkge1xuICAgICAgdmFyIHNlbGVjdGlvbiA9IGVkaXRvci5zZWxlY3Rpb247XG5cbiAgICAgIGlmIChzZWxlY3Rpb24gJiYgUmFuZ2UuaXNDb2xsYXBzZWQoc2VsZWN0aW9uKSkge1xuICAgICAgICBUcmFuc2Zvcm1zW1wiZGVsZXRlXCJdKGVkaXRvciwge1xuICAgICAgICAgIHVuaXQ6IHVuaXQsXG4gICAgICAgICAgcmV2ZXJzZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGRlbGV0ZUZvcndhcmQ6IGZ1bmN0aW9uIGRlbGV0ZUZvcndhcmQodW5pdCkge1xuICAgICAgdmFyIHNlbGVjdGlvbiA9IGVkaXRvci5zZWxlY3Rpb247XG5cbiAgICAgIGlmIChzZWxlY3Rpb24gJiYgUmFuZ2UuaXNDb2xsYXBzZWQoc2VsZWN0aW9uKSkge1xuICAgICAgICBUcmFuc2Zvcm1zW1wiZGVsZXRlXCJdKGVkaXRvciwge1xuICAgICAgICAgIHVuaXQ6IHVuaXRcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBkZWxldGVGcmFnbWVudDogZnVuY3Rpb24gZGVsZXRlRnJhZ21lbnQoZGlyZWN0aW9uKSB7XG4gICAgICB2YXIgc2VsZWN0aW9uID0gZWRpdG9yLnNlbGVjdGlvbjtcblxuICAgICAgaWYgKHNlbGVjdGlvbiAmJiBSYW5nZS5pc0V4cGFuZGVkKHNlbGVjdGlvbikpIHtcbiAgICAgICAgVHJhbnNmb3Jtc1tcImRlbGV0ZVwiXShlZGl0b3IsIHtcbiAgICAgICAgICByZXZlcnNlOiBkaXJlY3Rpb24gPT09ICdiYWNrd2FyZCdcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBnZXRGcmFnbWVudDogZnVuY3Rpb24gZ2V0RnJhZ21lbnQoKSB7XG4gICAgICB2YXIgc2VsZWN0aW9uID0gZWRpdG9yLnNlbGVjdGlvbjtcblxuICAgICAgaWYgKHNlbGVjdGlvbikge1xuICAgICAgICByZXR1cm4gTm9kZS5mcmFnbWVudChlZGl0b3IsIHNlbGVjdGlvbik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBbXTtcbiAgICB9LFxuICAgIGluc2VydEJyZWFrOiBmdW5jdGlvbiBpbnNlcnRCcmVhaygpIHtcbiAgICAgIFRyYW5zZm9ybXMuc3BsaXROb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgYWx3YXlzOiB0cnVlXG4gICAgICB9KTtcbiAgICB9LFxuICAgIGluc2VydFNvZnRCcmVhazogZnVuY3Rpb24gaW5zZXJ0U29mdEJyZWFrKCkge1xuICAgICAgVHJhbnNmb3Jtcy5zcGxpdE5vZGVzKGVkaXRvciwge1xuICAgICAgICBhbHdheXM6IHRydWVcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgaW5zZXJ0RnJhZ21lbnQ6IGZ1bmN0aW9uIGluc2VydEZyYWdtZW50KGZyYWdtZW50KSB7XG4gICAgICBUcmFuc2Zvcm1zLmluc2VydEZyYWdtZW50KGVkaXRvciwgZnJhZ21lbnQpO1xuICAgIH0sXG4gICAgaW5zZXJ0Tm9kZTogZnVuY3Rpb24gaW5zZXJ0Tm9kZShub2RlKSB7XG4gICAgICBUcmFuc2Zvcm1zLmluc2VydE5vZGVzKGVkaXRvciwgbm9kZSk7XG4gICAgfSxcbiAgICBpbnNlcnRUZXh0OiBmdW5jdGlvbiBpbnNlcnRUZXh0KHRleHQpIHtcbiAgICAgIHZhciBzZWxlY3Rpb24gPSBlZGl0b3Iuc2VsZWN0aW9uLFxuICAgICAgICAgIG1hcmtzID0gZWRpdG9yLm1hcmtzO1xuXG4gICAgICBpZiAoc2VsZWN0aW9uKSB7XG4gICAgICAgIGlmIChtYXJrcykge1xuICAgICAgICAgIHZhciBub2RlID0gX29iamVjdFNwcmVhZCQ5KHtcbiAgICAgICAgICAgIHRleHQ6IHRleHRcbiAgICAgICAgICB9LCBtYXJrcyk7XG5cbiAgICAgICAgICBUcmFuc2Zvcm1zLmluc2VydE5vZGVzKGVkaXRvciwgbm9kZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgVHJhbnNmb3Jtcy5pbnNlcnRUZXh0KGVkaXRvciwgdGV4dCk7XG4gICAgICAgIH1cblxuICAgICAgICBlZGl0b3IubWFya3MgPSBudWxsO1xuICAgICAgfVxuICAgIH0sXG4gICAgbm9ybWFsaXplTm9kZTogZnVuY3Rpb24gbm9ybWFsaXplTm9kZShlbnRyeSkge1xuICAgICAgdmFyIF9lbnRyeSA9IF9zbGljZWRUb0FycmF5KGVudHJ5LCAyKSxcbiAgICAgICAgICBub2RlID0gX2VudHJ5WzBdLFxuICAgICAgICAgIHBhdGggPSBfZW50cnlbMV07IC8vIFRoZXJlIGFyZSBubyBjb3JlIG5vcm1hbGl6YXRpb25zIGZvciB0ZXh0IG5vZGVzLlxuXG5cbiAgICAgIGlmIChUZXh0LmlzVGV4dChub2RlKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IC8vIEVuc3VyZSB0aGF0IGJsb2NrIGFuZCBpbmxpbmUgbm9kZXMgaGF2ZSBhdCBsZWFzdCBvbmUgdGV4dCBjaGlsZC5cblxuXG4gICAgICBpZiAoRWxlbWVudC5pc0VsZW1lbnQobm9kZSkgJiYgbm9kZS5jaGlsZHJlbi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdmFyIGNoaWxkID0ge1xuICAgICAgICAgIHRleHQ6ICcnXG4gICAgICAgIH07XG4gICAgICAgIFRyYW5zZm9ybXMuaW5zZXJ0Tm9kZXMoZWRpdG9yLCBjaGlsZCwge1xuICAgICAgICAgIGF0OiBwYXRoLmNvbmNhdCgwKSxcbiAgICAgICAgICB2b2lkczogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyBEZXRlcm1pbmUgd2hldGhlciB0aGUgbm9kZSBzaG91bGQgaGF2ZSBibG9jayBvciBpbmxpbmUgY2hpbGRyZW4uXG5cblxuICAgICAgdmFyIHNob3VsZEhhdmVJbmxpbmVzID0gRWRpdG9yLmlzRWRpdG9yKG5vZGUpID8gZmFsc2UgOiBFbGVtZW50LmlzRWxlbWVudChub2RlKSAmJiAoZWRpdG9yLmlzSW5saW5lKG5vZGUpIHx8IG5vZGUuY2hpbGRyZW4ubGVuZ3RoID09PSAwIHx8IFRleHQuaXNUZXh0KG5vZGUuY2hpbGRyZW5bMF0pIHx8IGVkaXRvci5pc0lubGluZShub2RlLmNoaWxkcmVuWzBdKSk7IC8vIFNpbmNlIHdlJ2xsIGJlIGFwcGx5aW5nIG9wZXJhdGlvbnMgd2hpbGUgaXRlcmF0aW5nLCBrZWVwIHRyYWNrIG9mIGFuXG4gICAgICAvLyBpbmRleCB0aGF0IGFjY291bnRzIGZvciBhbnkgYWRkZWQvcmVtb3ZlZCBub2Rlcy5cblxuICAgICAgdmFyIG4gPSAwO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpKyssIG4rKykge1xuICAgICAgICB2YXIgY3VycmVudE5vZGUgPSBOb2RlLmdldChlZGl0b3IsIHBhdGgpO1xuICAgICAgICBpZiAoVGV4dC5pc1RleHQoY3VycmVudE5vZGUpKSBjb250aW51ZTtcbiAgICAgICAgdmFyIF9jaGlsZCA9IG5vZGUuY2hpbGRyZW5baV07XG4gICAgICAgIHZhciBwcmV2ID0gY3VycmVudE5vZGUuY2hpbGRyZW5bbiAtIDFdO1xuICAgICAgICB2YXIgaXNMYXN0ID0gaSA9PT0gbm9kZS5jaGlsZHJlbi5sZW5ndGggLSAxO1xuICAgICAgICB2YXIgaXNJbmxpbmVPclRleHQgPSBUZXh0LmlzVGV4dChfY2hpbGQpIHx8IEVsZW1lbnQuaXNFbGVtZW50KF9jaGlsZCkgJiYgZWRpdG9yLmlzSW5saW5lKF9jaGlsZCk7IC8vIE9ubHkgYWxsb3cgYmxvY2sgbm9kZXMgaW4gdGhlIHRvcC1sZXZlbCBjaGlsZHJlbiBhbmQgcGFyZW50IGJsb2Nrc1xuICAgICAgICAvLyB0aGF0IG9ubHkgY29udGFpbiBibG9jayBub2Rlcy4gU2ltaWxhcmx5LCBvbmx5IGFsbG93IGlubGluZSBub2RlcyBpblxuICAgICAgICAvLyBvdGhlciBpbmxpbmUgbm9kZXMsIG9yIHBhcmVudCBibG9ja3MgdGhhdCBvbmx5IGNvbnRhaW4gaW5saW5lcyBhbmRcbiAgICAgICAgLy8gdGV4dC5cblxuICAgICAgICBpZiAoaXNJbmxpbmVPclRleHQgIT09IHNob3VsZEhhdmVJbmxpbmVzKSB7XG4gICAgICAgICAgVHJhbnNmb3Jtcy5yZW1vdmVOb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAgIGF0OiBwYXRoLmNvbmNhdChuKSxcbiAgICAgICAgICAgIHZvaWRzOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgbi0tO1xuICAgICAgICB9IGVsc2UgaWYgKEVsZW1lbnQuaXNFbGVtZW50KF9jaGlsZCkpIHtcbiAgICAgICAgICAvLyBFbnN1cmUgdGhhdCBpbmxpbmUgbm9kZXMgYXJlIHN1cnJvdW5kZWQgYnkgdGV4dCBub2Rlcy5cbiAgICAgICAgICBpZiAoZWRpdG9yLmlzSW5saW5lKF9jaGlsZCkpIHtcbiAgICAgICAgICAgIGlmIChwcmV2ID09IG51bGwgfHwgIVRleHQuaXNUZXh0KHByZXYpKSB7XG4gICAgICAgICAgICAgIHZhciBuZXdDaGlsZCA9IHtcbiAgICAgICAgICAgICAgICB0ZXh0OiAnJ1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBUcmFuc2Zvcm1zLmluc2VydE5vZGVzKGVkaXRvciwgbmV3Q2hpbGQsIHtcbiAgICAgICAgICAgICAgICBhdDogcGF0aC5jb25jYXQobiksXG4gICAgICAgICAgICAgICAgdm9pZHM6IHRydWVcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIG4rKztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNMYXN0KSB7XG4gICAgICAgICAgICAgIHZhciBfbmV3Q2hpbGQgPSB7XG4gICAgICAgICAgICAgICAgdGV4dDogJydcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgVHJhbnNmb3Jtcy5pbnNlcnROb2RlcyhlZGl0b3IsIF9uZXdDaGlsZCwge1xuICAgICAgICAgICAgICAgIGF0OiBwYXRoLmNvbmNhdChuICsgMSksXG4gICAgICAgICAgICAgICAgdm9pZHM6IHRydWVcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIG4rKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gTWVyZ2UgYWRqYWNlbnQgdGV4dCBub2RlcyB0aGF0IGFyZSBlbXB0eSBvciBtYXRjaC5cbiAgICAgICAgICBpZiAocHJldiAhPSBudWxsICYmIFRleHQuaXNUZXh0KHByZXYpKSB7XG4gICAgICAgICAgICBpZiAoVGV4dC5lcXVhbHMoX2NoaWxkLCBwcmV2LCB7XG4gICAgICAgICAgICAgIGxvb3NlOiB0cnVlXG4gICAgICAgICAgICB9KSkge1xuICAgICAgICAgICAgICBUcmFuc2Zvcm1zLm1lcmdlTm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICAgICAgYXQ6IHBhdGguY29uY2F0KG4pLFxuICAgICAgICAgICAgICAgIHZvaWRzOiB0cnVlXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBuLS07XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHByZXYudGV4dCA9PT0gJycpIHtcbiAgICAgICAgICAgICAgVHJhbnNmb3Jtcy5yZW1vdmVOb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAgICAgICBhdDogcGF0aC5jb25jYXQobiAtIDEpLFxuICAgICAgICAgICAgICAgIHZvaWRzOiB0cnVlXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBuLS07XG4gICAgICAgICAgICB9IGVsc2UgaWYgKF9jaGlsZC50ZXh0ID09PSAnJykge1xuICAgICAgICAgICAgICBUcmFuc2Zvcm1zLnJlbW92ZU5vZGVzKGVkaXRvciwge1xuICAgICAgICAgICAgICAgIGF0OiBwYXRoLmNvbmNhdChuKSxcbiAgICAgICAgICAgICAgICB2b2lkczogdHJ1ZVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgbi0tO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgcmVtb3ZlTWFyazogZnVuY3Rpb24gcmVtb3ZlTWFyayhrZXkpIHtcbiAgICAgIHZhciBzZWxlY3Rpb24gPSBlZGl0b3Iuc2VsZWN0aW9uO1xuXG4gICAgICBpZiAoc2VsZWN0aW9uKSB7XG4gICAgICAgIHZhciBtYXRjaCA9IGZ1bmN0aW9uIG1hdGNoKG5vZGUsIHBhdGgpIHtcbiAgICAgICAgICBpZiAoIVRleHQuaXNUZXh0KG5vZGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7IC8vIG1hcmtzIGNhbiBvbmx5IGJlIGFwcGxpZWQgdG8gdGV4dFxuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBfRWRpdG9yJHBhcmVudDUgPSBFZGl0b3IucGFyZW50KGVkaXRvciwgcGF0aCksXG4gICAgICAgICAgICAgIF9FZGl0b3IkcGFyZW50NiA9IF9zbGljZWRUb0FycmF5KF9FZGl0b3IkcGFyZW50NSwgMiksXG4gICAgICAgICAgICAgIHBhcmVudE5vZGUgPSBfRWRpdG9yJHBhcmVudDZbMF07XG4gICAgICAgICAgICAgIF9FZGl0b3IkcGFyZW50NlsxXTtcblxuICAgICAgICAgIHJldHVybiAhZWRpdG9yLmlzVm9pZChwYXJlbnROb2RlKSB8fCBlZGl0b3IubWFya2FibGVWb2lkKHBhcmVudE5vZGUpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBleHBhbmRlZFNlbGVjdGlvbiA9IFJhbmdlLmlzRXhwYW5kZWQoc2VsZWN0aW9uKTtcbiAgICAgICAgdmFyIG1hcmtBY2NlcHRpbmdWb2lkU2VsZWN0ZWQgPSBmYWxzZTtcblxuICAgICAgICBpZiAoIWV4cGFuZGVkU2VsZWN0aW9uKSB7XG4gICAgICAgICAgdmFyIF9FZGl0b3Ikbm9kZTMgPSBFZGl0b3Iubm9kZShlZGl0b3IsIHNlbGVjdGlvbiksXG4gICAgICAgICAgICAgIF9FZGl0b3Ikbm9kZTQgPSBfc2xpY2VkVG9BcnJheShfRWRpdG9yJG5vZGUzLCAyKSxcbiAgICAgICAgICAgICAgc2VsZWN0ZWROb2RlID0gX0VkaXRvciRub2RlNFswXSxcbiAgICAgICAgICAgICAgc2VsZWN0ZWRQYXRoID0gX0VkaXRvciRub2RlNFsxXTtcblxuICAgICAgICAgIGlmIChzZWxlY3RlZE5vZGUgJiYgbWF0Y2goc2VsZWN0ZWROb2RlLCBzZWxlY3RlZFBhdGgpKSB7XG4gICAgICAgICAgICB2YXIgX0VkaXRvciRwYXJlbnQ3ID0gRWRpdG9yLnBhcmVudChlZGl0b3IsIHNlbGVjdGVkUGF0aCksXG4gICAgICAgICAgICAgICAgX0VkaXRvciRwYXJlbnQ4ID0gX3NsaWNlZFRvQXJyYXkoX0VkaXRvciRwYXJlbnQ3LCAxKSxcbiAgICAgICAgICAgICAgICBwYXJlbnROb2RlID0gX0VkaXRvciRwYXJlbnQ4WzBdO1xuXG4gICAgICAgICAgICBtYXJrQWNjZXB0aW5nVm9pZFNlbGVjdGVkID0gcGFyZW50Tm9kZSAmJiBlZGl0b3IubWFya2FibGVWb2lkKHBhcmVudE5vZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChleHBhbmRlZFNlbGVjdGlvbiB8fCBtYXJrQWNjZXB0aW5nVm9pZFNlbGVjdGVkKSB7XG4gICAgICAgICAgVHJhbnNmb3Jtcy51bnNldE5vZGVzKGVkaXRvciwga2V5LCB7XG4gICAgICAgICAgICBtYXRjaDogbWF0Y2gsXG4gICAgICAgICAgICBzcGxpdDogdHJ1ZSxcbiAgICAgICAgICAgIHZvaWRzOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIG1hcmtzID0gX29iamVjdFNwcmVhZCQ5KHt9LCBFZGl0b3IubWFya3MoZWRpdG9yKSB8fCB7fSk7XG5cbiAgICAgICAgICBkZWxldGUgbWFya3Nba2V5XTtcbiAgICAgICAgICBlZGl0b3IubWFya3MgPSBtYXJrcztcblxuICAgICAgICAgIGlmICghRkxVU0hJTkcuZ2V0KGVkaXRvcikpIHtcbiAgICAgICAgICAgIGVkaXRvci5vbkNoYW5nZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgXCJkaXJ0eVwiIHBhdGhzIGdlbmVyYXRlZCBmcm9tIGFuIG9wZXJhdGlvbi5cclxuICAgICAqL1xuICAgIGdldERpcnR5UGF0aHM6IGZ1bmN0aW9uIGdldERpcnR5UGF0aHMob3ApIHtcbiAgICAgIHN3aXRjaCAob3AudHlwZSkge1xuICAgICAgICBjYXNlICdpbnNlcnRfdGV4dCc6XG4gICAgICAgIGNhc2UgJ3JlbW92ZV90ZXh0JzpcbiAgICAgICAgY2FzZSAnc2V0X25vZGUnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBwYXRoID0gb3AucGF0aDtcbiAgICAgICAgICAgIHJldHVybiBQYXRoLmxldmVscyhwYXRoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSAnaW5zZXJ0X25vZGUnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBub2RlID0gb3Aubm9kZSxcbiAgICAgICAgICAgICAgICBfcGF0aDIgPSBvcC5wYXRoO1xuICAgICAgICAgICAgdmFyIGxldmVscyA9IFBhdGgubGV2ZWxzKF9wYXRoMik7XG4gICAgICAgICAgICB2YXIgZGVzY2VuZGFudHMgPSBUZXh0LmlzVGV4dChub2RlKSA/IFtdIDogQXJyYXkuZnJvbShOb2RlLm5vZGVzKG5vZGUpLCBmdW5jdGlvbiAoX3JlZjMpIHtcbiAgICAgICAgICAgICAgdmFyIF9yZWY0ID0gX3NsaWNlZFRvQXJyYXkoX3JlZjMsIDIpLFxuICAgICAgICAgICAgICAgICAgcCA9IF9yZWY0WzFdO1xuXG4gICAgICAgICAgICAgIHJldHVybiBfcGF0aDIuY29uY2F0KHApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gW10uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShsZXZlbHMpLCBfdG9Db25zdW1hYmxlQXJyYXkoZGVzY2VuZGFudHMpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSAnbWVyZ2Vfbm9kZSc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIF9wYXRoMyA9IG9wLnBhdGg7XG4gICAgICAgICAgICB2YXIgYW5jZXN0b3JzID0gUGF0aC5hbmNlc3RvcnMoX3BhdGgzKTtcbiAgICAgICAgICAgIHZhciBwcmV2aW91c1BhdGggPSBQYXRoLnByZXZpb3VzKF9wYXRoMyk7XG4gICAgICAgICAgICByZXR1cm4gW10uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShhbmNlc3RvcnMpLCBbcHJldmlvdXNQYXRoXSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgJ21vdmVfbm9kZSc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIF9wYXRoNCA9IG9wLnBhdGgsXG4gICAgICAgICAgICAgICAgbmV3UGF0aCA9IG9wLm5ld1BhdGg7XG5cbiAgICAgICAgICAgIGlmIChQYXRoLmVxdWFscyhfcGF0aDQsIG5ld1BhdGgpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIG9sZEFuY2VzdG9ycyA9IFtdO1xuICAgICAgICAgICAgdmFyIG5ld0FuY2VzdG9ycyA9IFtdO1xuXG4gICAgICAgICAgICB2YXIgX2l0ZXJhdG9yNiA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDcoUGF0aC5hbmNlc3RvcnMoX3BhdGg0KSksXG4gICAgICAgICAgICAgICAgX3N0ZXA2O1xuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBmb3IgKF9pdGVyYXRvcjYucygpOyAhKF9zdGVwNiA9IF9pdGVyYXRvcjYubigpKS5kb25lOykge1xuICAgICAgICAgICAgICAgIHZhciBhbmNlc3RvciA9IF9zdGVwNi52YWx1ZTtcbiAgICAgICAgICAgICAgICB2YXIgcCA9IFBhdGgudHJhbnNmb3JtKGFuY2VzdG9yLCBvcCk7XG4gICAgICAgICAgICAgICAgb2xkQW5jZXN0b3JzLnB1c2gocCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICBfaXRlcmF0b3I2LmUoZXJyKTtcbiAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgIF9pdGVyYXRvcjYuZigpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgX2l0ZXJhdG9yNyA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDcoUGF0aC5hbmNlc3RvcnMobmV3UGF0aCkpLFxuICAgICAgICAgICAgICAgIF9zdGVwNztcblxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgZm9yIChfaXRlcmF0b3I3LnMoKTsgIShfc3RlcDcgPSBfaXRlcmF0b3I3Lm4oKSkuZG9uZTspIHtcbiAgICAgICAgICAgICAgICB2YXIgX2FuY2VzdG9yID0gX3N0ZXA3LnZhbHVlO1xuXG4gICAgICAgICAgICAgICAgdmFyIF9wID0gUGF0aC50cmFuc2Zvcm0oX2FuY2VzdG9yLCBvcCk7XG5cbiAgICAgICAgICAgICAgICBuZXdBbmNlc3RvcnMucHVzaChfcCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICBfaXRlcmF0b3I3LmUoZXJyKTtcbiAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgIF9pdGVyYXRvcjcuZigpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgbmV3UGFyZW50ID0gbmV3QW5jZXN0b3JzW25ld0FuY2VzdG9ycy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIHZhciBuZXdJbmRleCA9IG5ld1BhdGhbbmV3UGF0aC5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIHZhciByZXN1bHRQYXRoID0gbmV3UGFyZW50LmNvbmNhdChuZXdJbmRleCk7XG4gICAgICAgICAgICByZXR1cm4gW10uY29uY2F0KG9sZEFuY2VzdG9ycywgbmV3QW5jZXN0b3JzLCBbcmVzdWx0UGF0aF0pO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlICdyZW1vdmVfbm9kZSc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIF9wYXRoNSA9IG9wLnBhdGg7XG5cbiAgICAgICAgICAgIHZhciBfYW5jZXN0b3JzID0gUGF0aC5hbmNlc3RvcnMoX3BhdGg1KTtcblxuICAgICAgICAgICAgcmV0dXJuIF90b0NvbnN1bWFibGVBcnJheShfYW5jZXN0b3JzKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSAnc3BsaXRfbm9kZSc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIF9wYXRoNiA9IG9wLnBhdGg7XG5cbiAgICAgICAgICAgIHZhciBfbGV2ZWxzID0gUGF0aC5sZXZlbHMoX3BhdGg2KTtcblxuICAgICAgICAgICAgdmFyIG5leHRQYXRoID0gUGF0aC5uZXh0KF9wYXRoNik7XG4gICAgICAgICAgICByZXR1cm4gW10uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShfbGV2ZWxzKSwgW25leHRQYXRoXSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIHNob3VsZE5vcm1hbGl6ZTogZnVuY3Rpb24gc2hvdWxkTm9ybWFsaXplKF9yZWY1KSB7XG4gICAgICB2YXIgaXRlcmF0aW9uID0gX3JlZjUuaXRlcmF0aW9uLFxuICAgICAgICAgIGluaXRpYWxEaXJ0eVBhdGhzTGVuZ3RoID0gX3JlZjUuaW5pdGlhbERpcnR5UGF0aHNMZW5ndGg7XG4gICAgICB2YXIgbWF4SXRlcmF0aW9ucyA9IGluaXRpYWxEaXJ0eVBhdGhzTGVuZ3RoICogNDI7IC8vIEhBQ0s6IGJldHRlciB3YXk/XG5cbiAgICAgIGlmIChpdGVyYXRpb24gPiBtYXhJdGVyYXRpb25zKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBjb21wbGV0ZWx5IG5vcm1hbGl6ZSB0aGUgZWRpdG9yIGFmdGVyIFwiLmNvbmNhdChtYXhJdGVyYXRpb25zLCBcIiBpdGVyYXRpb25zISBUaGlzIGlzIHVzdWFsbHkgZHVlIHRvIGluY29ycmVjdCBub3JtYWxpemF0aW9uIGxvZ2ljIHRoYXQgbGVhdmVzIGEgbm9kZSBpbiBhbiBpbnZhbGlkIHN0YXRlLlwiKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIGVkaXRvcjtcbn07XG5cbnZhciBvYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSkge1xuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCkge1xuICBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTtcbiAgdmFyIHRhcmdldCA9IHt9O1xuICB2YXIgc291cmNlS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XG4gIHZhciBrZXksIGk7XG5cbiAgZm9yIChpID0gMDsgaSA8IHNvdXJjZUtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBrZXkgPSBzb3VyY2VLZXlzW2ldO1xuICAgIGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7XG4gICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2U7XG5tb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG59KTtcblxudW53cmFwRXhwb3J0cyhvYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKTtcblxudmFyIG9iamVjdFdpdGhvdXRQcm9wZXJ0aWVzID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSkge1xuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHNvdXJjZSwgZXhjbHVkZWQpIHtcbiAgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307XG4gIHZhciB0YXJnZXQgPSBvYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpO1xuICB2YXIga2V5LCBpO1xuXG4gIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgdmFyIHNvdXJjZVN5bWJvbEtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgc291cmNlU3ltYm9sS2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAga2V5ID0gc291cmNlU3ltYm9sS2V5c1tpXTtcbiAgICAgIGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7XG4gICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzb3VyY2UsIGtleSkpIGNvbnRpbnVlO1xuICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcztcbm1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbn0pO1xuXG52YXIgX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzID0gdW53cmFwRXhwb3J0cyhvYmplY3RXaXRob3V0UHJvcGVydGllcyk7XG5cbmZ1bmN0aW9uIF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDYobywgYWxsb3dBcnJheUxpa2UpIHsgdmFyIGl0ID0gdHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl0gfHwgb1tcIkBAaXRlcmF0b3JcIl07IGlmICghaXQpIHsgaWYgKEFycmF5LmlzQXJyYXkobykgfHwgKGl0ID0gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5JDYobykpIHx8IGFsbG93QXJyYXlMaWtlICYmIG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSB7IGlmIChpdCkgbyA9IGl0OyB2YXIgaSA9IDA7IHZhciBGID0gZnVuY3Rpb24gRigpIHt9OyByZXR1cm4geyBzOiBGLCBuOiBmdW5jdGlvbiBuKCkgeyBpZiAoaSA+PSBvLmxlbmd0aCkgcmV0dXJuIHsgZG9uZTogdHJ1ZSB9OyByZXR1cm4geyBkb25lOiBmYWxzZSwgdmFsdWU6IG9baSsrXSB9OyB9LCBlOiBmdW5jdGlvbiBlKF9lKSB7IHRocm93IF9lOyB9LCBmOiBGIH07IH0gdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9IHZhciBub3JtYWxDb21wbGV0aW9uID0gdHJ1ZSwgZGlkRXJyID0gZmFsc2UsIGVycjsgcmV0dXJuIHsgczogZnVuY3Rpb24gcygpIHsgaXQgPSBpdC5jYWxsKG8pOyB9LCBuOiBmdW5jdGlvbiBuKCkgeyB2YXIgc3RlcCA9IGl0Lm5leHQoKTsgbm9ybWFsQ29tcGxldGlvbiA9IHN0ZXAuZG9uZTsgcmV0dXJuIHN0ZXA7IH0sIGU6IGZ1bmN0aW9uIGUoX2UyKSB7IGRpZEVyciA9IHRydWU7IGVyciA9IF9lMjsgfSwgZjogZnVuY3Rpb24gZigpIHsgdHJ5IHsgaWYgKCFub3JtYWxDb21wbGV0aW9uICYmIGl0W1wicmV0dXJuXCJdICE9IG51bGwpIGl0W1wicmV0dXJuXCJdKCk7IH0gZmluYWxseSB7IGlmIChkaWRFcnIpIHRocm93IGVycjsgfSB9IH07IH1cblxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5JDYobywgbWluTGVuKSB7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheSQ2KG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkkNihvLCBtaW5MZW4pOyB9XG5cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5JDYoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgeyBhcnIyW2ldID0gYXJyW2ldOyB9IHJldHVybiBhcnIyOyB9XG5cbi8vIENoYXJhY3RlciAoZ3JhcGhlbWUgY2x1c3RlcikgYm91bmRhcmllcyBhcmUgZGV0ZXJtaW5lZCBhY2NvcmRpbmcgdG9cbi8vIHRoZSBkZWZhdWx0IGdyYXBoZW1lIGNsdXN0ZXIgYm91bmRhcnkgc3BlY2lmaWNhdGlvbiwgZXh0ZW5kZWQgZ3JhcGhlbWUgY2x1c3RlcnMgdmFyaWFudFsxXS5cbi8vXG4vLyBSZWZlcmVuY2VzOlxuLy9cbi8vIFsxXSBodHRwczovL3d3dy51bmljb2RlLm9yZy9yZXBvcnRzL3RyMjkvI0RlZmF1bHRfR3JhcGhlbWVfQ2x1c3Rlcl9UYWJsZVxuLy8gWzJdIGh0dHBzOi8vd3d3LnVuaWNvZGUub3JnL1B1YmxpYy9VQ0QvbGF0ZXN0L3VjZC9hdXhpbGlhcnkvR3JhcGhlbWVCcmVha1Byb3BlcnR5LnR4dFxuLy8gWzNdIGh0dHBzOi8vd3d3LnVuaWNvZGUub3JnL1B1YmxpYy9VQ0QvbGF0ZXN0L3VjZC9hdXhpbGlhcnkvR3JhcGhlbWVCcmVha1Rlc3QuaHRtbFxuLy8gWzRdIGh0dHBzOi8vd3d3LnVuaWNvZGUub3JnL1B1YmxpYy9VQ0QvbGF0ZXN0L3VjZC9hdXhpbGlhcnkvR3JhcGhlbWVCcmVha1Rlc3QudHh0XG5cbi8qKlxyXG4gKiBHZXQgdGhlIGRpc3RhbmNlIHRvIHRoZSBlbmQgb2YgdGhlIGZpcnN0IGNoYXJhY3RlciBpbiBhIHN0cmluZyBvZiB0ZXh0LlxyXG4gKi9cbnZhciBnZXRDaGFyYWN0ZXJEaXN0YW5jZSA9IGZ1bmN0aW9uIGdldENoYXJhY3RlckRpc3RhbmNlKHN0cikge1xuICB2YXIgaXNSVEwgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuICB2YXIgaXNMVFIgPSAhaXNSVEw7XG4gIHZhciBjb2RlcG9pbnRzID0gaXNSVEwgPyBjb2RlcG9pbnRzSXRlcmF0b3JSVEwoc3RyKSA6IHN0cjtcbiAgdmFyIGxlZnQgPSBDb2RlcG9pbnRUeXBlLk5vbmU7XG4gIHZhciByaWdodCA9IENvZGVwb2ludFR5cGUuTm9uZTtcbiAgdmFyIGRpc3RhbmNlID0gMDsgLy8gRXZhbHVhdGlvbiBvZiB0aGVzZSBjb25kaXRpb25zIGFyZSBkZWZlcnJlZC5cblxuICB2YXIgZ2IxMSA9IG51bGw7IC8vIElzIEdCMTEgYXBwbGljYWJsZT9cblxuICB2YXIgZ2IxMk9yMTMgPSBudWxsOyAvLyBJcyBHQjEyIG9yIEdCMTMgYXBwbGljYWJsZT9cblxuICB2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkNihjb2RlcG9pbnRzKSxcbiAgICAgIF9zdGVwO1xuXG4gIHRyeSB7XG4gICAgZm9yIChfaXRlcmF0b3IucygpOyAhKF9zdGVwID0gX2l0ZXJhdG9yLm4oKSkuZG9uZTspIHtcbiAgICAgIHZhciBfY2hhciA9IF9zdGVwLnZhbHVlO1xuXG4gICAgICB2YXIgY29kZSA9IF9jaGFyLmNvZGVQb2ludEF0KDApO1xuXG4gICAgICBpZiAoIWNvZGUpIGJyZWFrO1xuICAgICAgdmFyIHR5cGUgPSBnZXRDb2RlcG9pbnRUeXBlKF9jaGFyLCBjb2RlKTtcblxuICAgICAgdmFyIF9yZWYgPSBpc0xUUiA/IFtyaWdodCwgdHlwZV0gOiBbdHlwZSwgbGVmdF07XG5cbiAgICAgIHZhciBfcmVmMiA9IF9zbGljZWRUb0FycmF5KF9yZWYsIDIpO1xuXG4gICAgICBsZWZ0ID0gX3JlZjJbMF07XG4gICAgICByaWdodCA9IF9yZWYyWzFdO1xuXG4gICAgICBpZiAoaW50ZXJzZWN0cyhsZWZ0LCBDb2RlcG9pbnRUeXBlLlpXSikgJiYgaW50ZXJzZWN0cyhyaWdodCwgQ29kZXBvaW50VHlwZS5FeHRQaWN0KSkge1xuICAgICAgICBpZiAoaXNMVFIpIHtcbiAgICAgICAgICBnYjExID0gZW5kc1dpdGhFbW9qaVpXSihzdHIuc3Vic3RyaW5nKDAsIGRpc3RhbmNlKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZ2IxMSA9IGVuZHNXaXRoRW1vamlaV0ooc3RyLnN1YnN0cmluZygwLCBzdHIubGVuZ3RoIC0gZGlzdGFuY2UpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghZ2IxMSkgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGlmIChpbnRlcnNlY3RzKGxlZnQsIENvZGVwb2ludFR5cGUuUkkpICYmIGludGVyc2VjdHMocmlnaHQsIENvZGVwb2ludFR5cGUuUkkpKSB7XG4gICAgICAgIGlmIChnYjEyT3IxMyAhPT0gbnVsbCkge1xuICAgICAgICAgIGdiMTJPcjEzID0gIWdiMTJPcjEzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChpc0xUUikge1xuICAgICAgICAgICAgZ2IxMk9yMTMgPSB0cnVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnYjEyT3IxMyA9IGVuZHNXaXRoT2RkTnVtYmVyT2ZSSXMoc3RyLnN1YnN0cmluZygwLCBzdHIubGVuZ3RoIC0gZGlzdGFuY2UpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWdiMTJPcjEzKSBicmVhaztcbiAgICAgIH1cblxuICAgICAgaWYgKGxlZnQgIT09IENvZGVwb2ludFR5cGUuTm9uZSAmJiByaWdodCAhPT0gQ29kZXBvaW50VHlwZS5Ob25lICYmIGlzQm91bmRhcnlQYWlyKGxlZnQsIHJpZ2h0KSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgZGlzdGFuY2UgKz0gX2NoYXIubGVuZ3RoO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgX2l0ZXJhdG9yLmUoZXJyKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBfaXRlcmF0b3IuZigpO1xuICB9XG5cbiAgcmV0dXJuIGRpc3RhbmNlIHx8IDE7XG59O1xudmFyIFNQQUNFID0gL1xccy87XG52YXIgUFVOQ1RVQVRJT04gPSAvW1xcdTAwMjEtXFx1MDAyM1xcdTAwMjUtXFx1MDAyQVxcdTAwMkMtXFx1MDAyRlxcdTAwM0FcXHUwMDNCXFx1MDAzRlxcdTAwNDBcXHUwMDVCLVxcdTAwNURcXHUwMDVGXFx1MDA3QlxcdTAwN0RcXHUwMEExXFx1MDBBN1xcdTAwQUJcXHUwMEI2XFx1MDBCN1xcdTAwQkJcXHUwMEJGXFx1MDM3RVxcdTAzODdcXHUwNTVBLVxcdTA1NUZcXHUwNTg5XFx1MDU4QVxcdTA1QkVcXHUwNUMwXFx1MDVDM1xcdTA1QzZcXHUwNUYzXFx1MDVGNFxcdTA2MDlcXHUwNjBBXFx1MDYwQ1xcdTA2MERcXHUwNjFCXFx1MDYxRVxcdTA2MUZcXHUwNjZBLVxcdTA2NkRcXHUwNkQ0XFx1MDcwMC1cXHUwNzBEXFx1MDdGNy1cXHUwN0Y5XFx1MDgzMC1cXHUwODNFXFx1MDg1RVxcdTA5NjRcXHUwOTY1XFx1MDk3MFxcdTBBRjBcXHUwREY0XFx1MEU0RlxcdTBFNUFcXHUwRTVCXFx1MEYwNC1cXHUwRjEyXFx1MEYxNFxcdTBGM0EtXFx1MEYzRFxcdTBGODVcXHUwRkQwLVxcdTBGRDRcXHUwRkQ5XFx1MEZEQVxcdTEwNEEtXFx1MTA0RlxcdTEwRkJcXHUxMzYwLVxcdTEzNjhcXHUxNDAwXFx1MTY2RFxcdTE2NkVcXHUxNjlCXFx1MTY5Q1xcdTE2RUItXFx1MTZFRFxcdTE3MzVcXHUxNzM2XFx1MTdENC1cXHUxN0Q2XFx1MTdEOC1cXHUxN0RBXFx1MTgwMC1cXHUxODBBXFx1MTk0NFxcdTE5NDVcXHUxQTFFXFx1MUExRlxcdTFBQTAtXFx1MUFBNlxcdTFBQTgtXFx1MUFBRFxcdTFCNUEtXFx1MUI2MFxcdTFCRkMtXFx1MUJGRlxcdTFDM0ItXFx1MUMzRlxcdTFDN0VcXHUxQzdGXFx1MUNDMC1cXHUxQ0M3XFx1MUNEM1xcdTIwMTAtXFx1MjAyN1xcdTIwMzAtXFx1MjA0M1xcdTIwNDUtXFx1MjA1MVxcdTIwNTMtXFx1MjA1RVxcdTIwN0RcXHUyMDdFXFx1MjA4RFxcdTIwOEVcXHUyMzI5XFx1MjMyQVxcdTI3NjgtXFx1Mjc3NVxcdTI3QzVcXHUyN0M2XFx1MjdFNi1cXHUyN0VGXFx1Mjk4My1cXHUyOTk4XFx1MjlEOC1cXHUyOURCXFx1MjlGQ1xcdTI5RkRcXHUyQ0Y5LVxcdTJDRkNcXHUyQ0ZFXFx1MkNGRlxcdTJENzBcXHUyRTAwLVxcdTJFMkVcXHUyRTMwLVxcdTJFM0JcXHUzMDAxLVxcdTMwMDNcXHUzMDA4LVxcdTMwMTFcXHUzMDE0LVxcdTMwMUZcXHUzMDMwXFx1MzAzRFxcdTMwQTBcXHUzMEZCXFx1QTRGRVxcdUE0RkZcXHVBNjBELVxcdUE2MEZcXHVBNjczXFx1QTY3RVxcdUE2RjItXFx1QTZGN1xcdUE4NzQtXFx1QTg3N1xcdUE4Q0VcXHVBOENGXFx1QThGOC1cXHVBOEZBXFx1QTkyRVxcdUE5MkZcXHVBOTVGXFx1QTlDMS1cXHVBOUNEXFx1QTlERVxcdUE5REZcXHVBQTVDLVxcdUFBNUZcXHVBQURFXFx1QUFERlxcdUFBRjBcXHVBQUYxXFx1QUJFQlxcdUZEM0VcXHVGRDNGXFx1RkUxMC1cXHVGRTE5XFx1RkUzMC1cXHVGRTUyXFx1RkU1NC1cXHVGRTYxXFx1RkU2M1xcdUZFNjhcXHVGRTZBXFx1RkU2QlxcdUZGMDEtXFx1RkYwM1xcdUZGMDUtXFx1RkYwQVxcdUZGMEMtXFx1RkYwRlxcdUZGMUFcXHVGRjFCXFx1RkYxRlxcdUZGMjBcXHVGRjNCLVxcdUZGM0RcXHVGRjNGXFx1RkY1QlxcdUZGNURcXHVGRjVGLVxcdUZGNjVdLztcbnZhciBDSEFNRUxFT04gPSAvWydcXHUyMDE4XFx1MjAxOV0vO1xuLyoqXHJcbiAqIEdldCB0aGUgZGlzdGFuY2UgdG8gdGhlIGVuZCBvZiB0aGUgZmlyc3Qgd29yZCBpbiBhIHN0cmluZyBvZiB0ZXh0LlxyXG4gKi9cblxudmFyIGdldFdvcmREaXN0YW5jZSA9IGZ1bmN0aW9uIGdldFdvcmREaXN0YW5jZSh0ZXh0KSB7XG4gIHZhciBpc1JUTCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZmFsc2U7XG4gIHZhciBkaXN0ID0gMDtcbiAgdmFyIHN0YXJ0ZWQgPSBmYWxzZTtcblxuICB3aGlsZSAodGV4dC5sZW5ndGggPiAwKSB7XG4gICAgdmFyIGNoYXJEaXN0ID0gZ2V0Q2hhcmFjdGVyRGlzdGFuY2UodGV4dCwgaXNSVEwpO1xuXG4gICAgdmFyIF9zcGxpdEJ5Q2hhcmFjdGVyRGlzdCA9IHNwbGl0QnlDaGFyYWN0ZXJEaXN0YW5jZSh0ZXh0LCBjaGFyRGlzdCwgaXNSVEwpLFxuICAgICAgICBfc3BsaXRCeUNoYXJhY3RlckRpc3QyID0gX3NsaWNlZFRvQXJyYXkoX3NwbGl0QnlDaGFyYWN0ZXJEaXN0LCAyKSxcbiAgICAgICAgX2NoYXIyID0gX3NwbGl0QnlDaGFyYWN0ZXJEaXN0MlswXSxcbiAgICAgICAgcmVtYWluaW5nID0gX3NwbGl0QnlDaGFyYWN0ZXJEaXN0MlsxXTtcblxuICAgIGlmIChpc1dvcmRDaGFyYWN0ZXIoX2NoYXIyLCByZW1haW5pbmcsIGlzUlRMKSkge1xuICAgICAgc3RhcnRlZCA9IHRydWU7XG4gICAgICBkaXN0ICs9IGNoYXJEaXN0O1xuICAgIH0gZWxzZSBpZiAoIXN0YXJ0ZWQpIHtcbiAgICAgIGRpc3QgKz0gY2hhckRpc3Q7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHRleHQgPSByZW1haW5pbmc7XG4gIH1cblxuICByZXR1cm4gZGlzdDtcbn07XG4vKipcclxuICogU3BsaXQgYSBzdHJpbmcgaW4gdHdvIHBhcnRzIGF0IGEgZ2l2ZW4gZGlzdGFuY2Ugc3RhcnRpbmcgZnJvbSB0aGUgZW5kIHdoZW5cclxuICogYGlzUlRMYCBpcyBzZXQgdG8gYHRydWVgLlxyXG4gKi9cblxudmFyIHNwbGl0QnlDaGFyYWN0ZXJEaXN0YW5jZSA9IGZ1bmN0aW9uIHNwbGl0QnlDaGFyYWN0ZXJEaXN0YW5jZShzdHIsIGRpc3QsIGlzUlRMKSB7XG4gIGlmIChpc1JUTCkge1xuICAgIHZhciBhdCA9IHN0ci5sZW5ndGggLSBkaXN0O1xuICAgIHJldHVybiBbc3RyLnNsaWNlKGF0LCBzdHIubGVuZ3RoKSwgc3RyLnNsaWNlKDAsIGF0KV07XG4gIH1cblxuICByZXR1cm4gW3N0ci5zbGljZSgwLCBkaXN0KSwgc3RyLnNsaWNlKGRpc3QpXTtcbn07XG4vKipcclxuICogQ2hlY2sgaWYgYSBjaGFyYWN0ZXIgaXMgYSB3b3JkIGNoYXJhY3Rlci4gVGhlIGByZW1haW5pbmdgIGFyZ3VtZW50IGlzIHVzZWRcclxuICogYmVjYXVzZSBzb21ldGltZXMgeW91IG11c3QgcmVhZCBzdWJzZXF1ZW50IGNoYXJhY3RlcnMgdG8gdHJ1bHkgZGV0ZXJtaW5lIGl0LlxyXG4gKi9cblxudmFyIGlzV29yZENoYXJhY3RlciA9IGZ1bmN0aW9uIGlzV29yZENoYXJhY3RlcihfY2hhcjMsIHJlbWFpbmluZykge1xuICB2YXIgaXNSVEwgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGZhbHNlO1xuXG4gIGlmIChTUEFDRS50ZXN0KF9jaGFyMykpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gLy8gQ2hhbWVsZW9ucyBjb3VudCBhcyB3b3JkIGNoYXJhY3RlcnMgYXMgbG9uZyBhcyB0aGV5J3JlIGluIGEgd29yZCwgc29cbiAgLy8gcmVjdXJzZSB0byBzZWUgaWYgdGhlIG5leHQgb25lIGlzIGEgd29yZCBjaGFyYWN0ZXIgb3Igbm90LlxuXG5cbiAgaWYgKENIQU1FTEVPTi50ZXN0KF9jaGFyMykpIHtcbiAgICB2YXIgY2hhckRpc3QgPSBnZXRDaGFyYWN0ZXJEaXN0YW5jZShyZW1haW5pbmcsIGlzUlRMKTtcblxuICAgIHZhciBfc3BsaXRCeUNoYXJhY3RlckRpc3QzID0gc3BsaXRCeUNoYXJhY3RlckRpc3RhbmNlKHJlbWFpbmluZywgY2hhckRpc3QsIGlzUlRMKSxcbiAgICAgICAgX3NwbGl0QnlDaGFyYWN0ZXJEaXN0NCA9IF9zbGljZWRUb0FycmF5KF9zcGxpdEJ5Q2hhcmFjdGVyRGlzdDMsIDIpLFxuICAgICAgICBuZXh0Q2hhciA9IF9zcGxpdEJ5Q2hhcmFjdGVyRGlzdDRbMF0sXG4gICAgICAgIG5leHRSZW1haW5pbmcgPSBfc3BsaXRCeUNoYXJhY3RlckRpc3Q0WzFdO1xuXG4gICAgaWYgKGlzV29yZENoYXJhY3RlcihuZXh0Q2hhciwgbmV4dFJlbWFpbmluZywgaXNSVEwpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBpZiAoUFVOQ1RVQVRJT04udGVzdChfY2hhcjMpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuLyoqXHJcbiAqIEl0ZXJhdGUgb24gY29kZXBvaW50cyBmcm9tIHJpZ2h0IHRvIGxlZnQuXHJcbiAqL1xuXG5cbnZhciBjb2RlcG9pbnRzSXRlcmF0b3JSVEwgPSBmdW5jdGlvbiogY29kZXBvaW50c0l0ZXJhdG9yUlRMKHN0cikge1xuICB2YXIgZW5kID0gc3RyLmxlbmd0aCAtIDE7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgY2hhcjEgPSBzdHIuY2hhckF0KGVuZCAtIGkpO1xuXG4gICAgaWYgKGlzTG93U3Vycm9nYXRlKGNoYXIxLmNoYXJDb2RlQXQoMCkpKSB7XG4gICAgICB2YXIgY2hhcjIgPSBzdHIuY2hhckF0KGVuZCAtIGkgLSAxKTtcblxuICAgICAgaWYgKGlzSGlnaFN1cnJvZ2F0ZShjaGFyMi5jaGFyQ29kZUF0KDApKSkge1xuICAgICAgICB5aWVsZCBjaGFyMiArIGNoYXIxO1xuICAgICAgICBpKys7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHlpZWxkIGNoYXIxO1xuICB9XG59O1xuLyoqXHJcbiAqIElzIGBjaGFyQ29kZWAgYSBoaWdoIHN1cnJvZ2F0ZS5cclxuICpcclxuICogaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVW5pdmVyc2FsX0NoYXJhY3Rlcl9TZXRfY2hhcmFjdGVycyNTdXJyb2dhdGVzXHJcbiAqL1xuXG52YXIgaXNIaWdoU3Vycm9nYXRlID0gZnVuY3Rpb24gaXNIaWdoU3Vycm9nYXRlKGNoYXJDb2RlKSB7XG4gIHJldHVybiBjaGFyQ29kZSA+PSAweGQ4MDAgJiYgY2hhckNvZGUgPD0gMHhkYmZmO1xufTtcbi8qKlxyXG4gKiBJcyBgY2hhckNvZGVgIGEgbG93IHN1cnJvZ2F0ZS5cclxuICpcclxuICogaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVW5pdmVyc2FsX0NoYXJhY3Rlcl9TZXRfY2hhcmFjdGVycyNTdXJyb2dhdGVzXHJcbiAqL1xuXG5cbnZhciBpc0xvd1N1cnJvZ2F0ZSA9IGZ1bmN0aW9uIGlzTG93U3Vycm9nYXRlKGNoYXJDb2RlKSB7XG4gIHJldHVybiBjaGFyQ29kZSA+PSAweGRjMDAgJiYgY2hhckNvZGUgPD0gMHhkZmZmO1xufTtcblxudmFyIENvZGVwb2ludFR5cGU7XG5cbihmdW5jdGlvbiAoQ29kZXBvaW50VHlwZSkge1xuICBDb2RlcG9pbnRUeXBlW0NvZGVwb2ludFR5cGVbXCJOb25lXCJdID0gMF0gPSBcIk5vbmVcIjtcbiAgQ29kZXBvaW50VHlwZVtDb2RlcG9pbnRUeXBlW1wiRXh0ZW5kXCJdID0gMV0gPSBcIkV4dGVuZFwiO1xuICBDb2RlcG9pbnRUeXBlW0NvZGVwb2ludFR5cGVbXCJaV0pcIl0gPSAyXSA9IFwiWldKXCI7XG4gIENvZGVwb2ludFR5cGVbQ29kZXBvaW50VHlwZVtcIlJJXCJdID0gNF0gPSBcIlJJXCI7XG4gIENvZGVwb2ludFR5cGVbQ29kZXBvaW50VHlwZVtcIlByZXBlbmRcIl0gPSA4XSA9IFwiUHJlcGVuZFwiO1xuICBDb2RlcG9pbnRUeXBlW0NvZGVwb2ludFR5cGVbXCJTcGFjaW5nTWFya1wiXSA9IDE2XSA9IFwiU3BhY2luZ01hcmtcIjtcbiAgQ29kZXBvaW50VHlwZVtDb2RlcG9pbnRUeXBlW1wiTFwiXSA9IDMyXSA9IFwiTFwiO1xuICBDb2RlcG9pbnRUeXBlW0NvZGVwb2ludFR5cGVbXCJWXCJdID0gNjRdID0gXCJWXCI7XG4gIENvZGVwb2ludFR5cGVbQ29kZXBvaW50VHlwZVtcIlRcIl0gPSAxMjhdID0gXCJUXCI7XG4gIENvZGVwb2ludFR5cGVbQ29kZXBvaW50VHlwZVtcIkxWXCJdID0gMjU2XSA9IFwiTFZcIjtcbiAgQ29kZXBvaW50VHlwZVtDb2RlcG9pbnRUeXBlW1wiTFZUXCJdID0gNTEyXSA9IFwiTFZUXCI7XG4gIENvZGVwb2ludFR5cGVbQ29kZXBvaW50VHlwZVtcIkV4dFBpY3RcIl0gPSAxMDI0XSA9IFwiRXh0UGljdFwiO1xuICBDb2RlcG9pbnRUeXBlW0NvZGVwb2ludFR5cGVbXCJBbnlcIl0gPSAyMDQ4XSA9IFwiQW55XCI7XG59KShDb2RlcG9pbnRUeXBlIHx8IChDb2RlcG9pbnRUeXBlID0ge30pKTtcblxudmFyIHJlRXh0ZW5kID0gL14oPzpbXFx1MDMwMC1cXHUwMzZGXFx1MDQ4My1cXHUwNDg5XFx1MDU5MS1cXHUwNUJEXFx1MDVCRlxcdTA1QzFcXHUwNUMyXFx1MDVDNFxcdTA1QzVcXHUwNUM3XFx1MDYxMC1cXHUwNjFBXFx1MDY0Qi1cXHUwNjVGXFx1MDY3MFxcdTA2RDYtXFx1MDZEQ1xcdTA2REYtXFx1MDZFNFxcdTA2RTdcXHUwNkU4XFx1MDZFQS1cXHUwNkVEXFx1MDcxMVxcdTA3MzAtXFx1MDc0QVxcdTA3QTYtXFx1MDdCMFxcdTA3RUItXFx1MDdGM1xcdTA3RkRcXHUwODE2LVxcdTA4MTlcXHUwODFCLVxcdTA4MjNcXHUwODI1LVxcdTA4MjdcXHUwODI5LVxcdTA4MkRcXHUwODU5LVxcdTA4NUJcXHUwOEQzLVxcdTA4RTFcXHUwOEUzLVxcdTA5MDJcXHUwOTNBXFx1MDkzQ1xcdTA5NDEtXFx1MDk0OFxcdTA5NERcXHUwOTUxLVxcdTA5NTdcXHUwOTYyXFx1MDk2M1xcdTA5ODFcXHUwOUJDXFx1MDlCRVxcdTA5QzEtXFx1MDlDNFxcdTA5Q0RcXHUwOUQ3XFx1MDlFMlxcdTA5RTNcXHUwOUZFXFx1MEEwMVxcdTBBMDJcXHUwQTNDXFx1MEE0MVxcdTBBNDJcXHUwQTQ3XFx1MEE0OFxcdTBBNEItXFx1MEE0RFxcdTBBNTFcXHUwQTcwXFx1MEE3MVxcdTBBNzVcXHUwQTgxXFx1MEE4MlxcdTBBQkNcXHUwQUMxLVxcdTBBQzVcXHUwQUM3XFx1MEFDOFxcdTBBQ0RcXHUwQUUyXFx1MEFFM1xcdTBBRkEtXFx1MEFGRlxcdTBCMDFcXHUwQjNDXFx1MEIzRVxcdTBCM0ZcXHUwQjQxLVxcdTBCNDRcXHUwQjREXFx1MEI1NS1cXHUwQjU3XFx1MEI2MlxcdTBCNjNcXHUwQjgyXFx1MEJCRVxcdTBCQzBcXHUwQkNEXFx1MEJEN1xcdTBDMDBcXHUwQzA0XFx1MEMzRS1cXHUwQzQwXFx1MEM0Ni1cXHUwQzQ4XFx1MEM0QS1cXHUwQzREXFx1MEM1NVxcdTBDNTZcXHUwQzYyXFx1MEM2M1xcdTBDODFcXHUwQ0JDXFx1MENCRlxcdTBDQzJcXHUwQ0M2XFx1MENDQ1xcdTBDQ0RcXHUwQ0Q1XFx1MENENlxcdTBDRTJcXHUwQ0UzXFx1MEQwMFxcdTBEMDFcXHUwRDNCXFx1MEQzQ1xcdTBEM0VcXHUwRDQxLVxcdTBENDRcXHUwRDREXFx1MEQ1N1xcdTBENjJcXHUwRDYzXFx1MEQ4MVxcdTBEQ0FcXHUwRENGXFx1MEREMi1cXHUwREQ0XFx1MERENlxcdTBEREZcXHUwRTMxXFx1MEUzNC1cXHUwRTNBXFx1MEU0Ny1cXHUwRTRFXFx1MEVCMVxcdTBFQjQtXFx1MEVCQ1xcdTBFQzgtXFx1MEVDRFxcdTBGMThcXHUwRjE5XFx1MEYzNVxcdTBGMzdcXHUwRjM5XFx1MEY3MS1cXHUwRjdFXFx1MEY4MC1cXHUwRjg0XFx1MEY4NlxcdTBGODdcXHUwRjhELVxcdTBGOTdcXHUwRjk5LVxcdTBGQkNcXHUwRkM2XFx1MTAyRC1cXHUxMDMwXFx1MTAzMi1cXHUxMDM3XFx1MTAzOVxcdTEwM0FcXHUxMDNEXFx1MTAzRVxcdTEwNThcXHUxMDU5XFx1MTA1RS1cXHUxMDYwXFx1MTA3MS1cXHUxMDc0XFx1MTA4MlxcdTEwODVcXHUxMDg2XFx1MTA4RFxcdTEwOURcXHUxMzVELVxcdTEzNUZcXHUxNzEyLVxcdTE3MTRcXHUxNzMyLVxcdTE3MzRcXHUxNzUyXFx1MTc1M1xcdTE3NzJcXHUxNzczXFx1MTdCNFxcdTE3QjVcXHUxN0I3LVxcdTE3QkRcXHUxN0M2XFx1MTdDOS1cXHUxN0QzXFx1MTdERFxcdTE4MEItXFx1MTgwRFxcdTE4ODVcXHUxODg2XFx1MThBOVxcdTE5MjAtXFx1MTkyMlxcdTE5MjdcXHUxOTI4XFx1MTkzMlxcdTE5MzktXFx1MTkzQlxcdTFBMTdcXHUxQTE4XFx1MUExQlxcdTFBNTZcXHUxQTU4LVxcdTFBNUVcXHUxQTYwXFx1MUE2MlxcdTFBNjUtXFx1MUE2Q1xcdTFBNzMtXFx1MUE3Q1xcdTFBN0ZcXHUxQUIwLVxcdTFBQzBcXHUxQjAwLVxcdTFCMDNcXHUxQjM0LVxcdTFCM0FcXHUxQjNDXFx1MUI0MlxcdTFCNkItXFx1MUI3M1xcdTFCODBcXHUxQjgxXFx1MUJBMi1cXHUxQkE1XFx1MUJBOFxcdTFCQTlcXHUxQkFCLVxcdTFCQURcXHUxQkU2XFx1MUJFOFxcdTFCRTlcXHUxQkVEXFx1MUJFRi1cXHUxQkYxXFx1MUMyQy1cXHUxQzMzXFx1MUMzNlxcdTFDMzdcXHUxQ0QwLVxcdTFDRDJcXHUxQ0Q0LVxcdTFDRTBcXHUxQ0UyLVxcdTFDRThcXHUxQ0VEXFx1MUNGNFxcdTFDRjhcXHUxQ0Y5XFx1MURDMC1cXHUxREY5XFx1MURGQi1cXHUxREZGXFx1MjAwQ1xcdTIwRDAtXFx1MjBGMFxcdTJDRUYtXFx1MkNGMVxcdTJEN0ZcXHUyREUwLVxcdTJERkZcXHUzMDJBLVxcdTMwMkZcXHUzMDk5XFx1MzA5QVxcdUE2NkYtXFx1QTY3MlxcdUE2NzQtXFx1QTY3RFxcdUE2OUVcXHVBNjlGXFx1QTZGMFxcdUE2RjFcXHVBODAyXFx1QTgwNlxcdUE4MEJcXHVBODI1XFx1QTgyNlxcdUE4MkNcXHVBOEM0XFx1QThDNVxcdUE4RTAtXFx1QThGMVxcdUE4RkZcXHVBOTI2LVxcdUE5MkRcXHVBOTQ3LVxcdUE5NTFcXHVBOTgwLVxcdUE5ODJcXHVBOUIzXFx1QTlCNi1cXHVBOUI5XFx1QTlCQ1xcdUE5QkRcXHVBOUU1XFx1QUEyOS1cXHVBQTJFXFx1QUEzMVxcdUFBMzJcXHVBQTM1XFx1QUEzNlxcdUFBNDNcXHVBQTRDXFx1QUE3Q1xcdUFBQjBcXHVBQUIyLVxcdUFBQjRcXHVBQUI3XFx1QUFCOFxcdUFBQkVcXHVBQUJGXFx1QUFDMVxcdUFBRUNcXHVBQUVEXFx1QUFGNlxcdUFCRTVcXHVBQkU4XFx1QUJFRFxcdUZCMUVcXHVGRTAwLVxcdUZFMEZcXHVGRTIwLVxcdUZFMkZcXHVGRjlFXFx1RkY5Rl18XFx1RDgwMFtcXHVEREZEXFx1REVFMFxcdURGNzYtXFx1REY3QV18XFx1RDgwMltcXHVERTAxLVxcdURFMDNcXHVERTA1XFx1REUwNlxcdURFMEMtXFx1REUwRlxcdURFMzgtXFx1REUzQVxcdURFM0ZcXHVERUU1XFx1REVFNl18XFx1RDgwM1tcXHVERDI0LVxcdUREMjdcXHVERUFCXFx1REVBQ1xcdURGNDYtXFx1REY1MF18XFx1RDgwNFtcXHVEQzAxXFx1REMzOC1cXHVEQzQ2XFx1REM3Ri1cXHVEQzgxXFx1RENCMy1cXHVEQ0I2XFx1RENCOVxcdURDQkFcXHVERDAwLVxcdUREMDJcXHVERDI3LVxcdUREMkJcXHVERDJELVxcdUREMzRcXHVERDczXFx1REQ4MFxcdUREODFcXHVEREI2LVxcdUREQkVcXHVEREM5LVxcdUREQ0NcXHVERENGXFx1REUyRi1cXHVERTMxXFx1REUzNFxcdURFMzZcXHVERTM3XFx1REUzRVxcdURFREZcXHVERUUzLVxcdURFRUFcXHVERjAwXFx1REYwMVxcdURGM0JcXHVERjNDXFx1REYzRVxcdURGNDBcXHVERjU3XFx1REY2Ni1cXHVERjZDXFx1REY3MC1cXHVERjc0XXxcXHVEODA1W1xcdURDMzgtXFx1REMzRlxcdURDNDItXFx1REM0NFxcdURDNDZcXHVEQzVFXFx1RENCMFxcdURDQjMtXFx1RENCOFxcdURDQkFcXHVEQ0JEXFx1RENCRlxcdURDQzBcXHVEQ0MyXFx1RENDM1xcdUREQUZcXHVEREIyLVxcdUREQjVcXHVEREJDXFx1RERCRFxcdUREQkZcXHVEREMwXFx1REREQ1xcdURERERcXHVERTMzLVxcdURFM0FcXHVERTNEXFx1REUzRlxcdURFNDBcXHVERUFCXFx1REVBRFxcdURFQjAtXFx1REVCNVxcdURFQjdcXHVERjFELVxcdURGMUZcXHVERjIyLVxcdURGMjVcXHVERjI3LVxcdURGMkJdfFxcdUQ4MDZbXFx1REMyRi1cXHVEQzM3XFx1REMzOVxcdURDM0FcXHVERDMwXFx1REQzQlxcdUREM0NcXHVERDNFXFx1REQ0M1xcdURERDQtXFx1REREN1xcdUREREFcXHVERERCXFx1RERFMFxcdURFMDEtXFx1REUwQVxcdURFMzMtXFx1REUzOFxcdURFM0ItXFx1REUzRVxcdURFNDdcXHVERTUxLVxcdURFNTZcXHVERTU5LVxcdURFNUJcXHVERThBLVxcdURFOTZcXHVERTk4XFx1REU5OV18XFx1RDgwN1tcXHVEQzMwLVxcdURDMzZcXHVEQzM4LVxcdURDM0RcXHVEQzNGXFx1REM5Mi1cXHVEQ0E3XFx1RENBQS1cXHVEQ0IwXFx1RENCMlxcdURDQjNcXHVEQ0I1XFx1RENCNlxcdUREMzEtXFx1REQzNlxcdUREM0FcXHVERDNDXFx1REQzRFxcdUREM0YtXFx1REQ0NVxcdURENDdcXHVERDkwXFx1REQ5MVxcdUREOTVcXHVERDk3XFx1REVGM1xcdURFRjRdfFxcdUQ4MUFbXFx1REVGMC1cXHVERUY0XFx1REYzMC1cXHVERjM2XXxcXHVEODFCW1xcdURGNEZcXHVERjhGLVxcdURGOTJcXHVERkU0XXxcXHVEODJGW1xcdURDOURcXHVEQzlFXXxcXHVEODM0W1xcdURENjVcXHVERDY3LVxcdURENjlcXHVERDZFLVxcdURENzJcXHVERDdCLVxcdUREODJcXHVERDg1LVxcdUREOEJcXHVEREFBLVxcdUREQURcXHVERTQyLVxcdURFNDRdfFxcdUQ4MzZbXFx1REUwMC1cXHVERTM2XFx1REUzQi1cXHVERTZDXFx1REU3NVxcdURFODRcXHVERTlCLVxcdURFOUZcXHVERUExLVxcdURFQUZdfFxcdUQ4MzhbXFx1REMwMC1cXHVEQzA2XFx1REMwOC1cXHVEQzE4XFx1REMxQi1cXHVEQzIxXFx1REMyM1xcdURDMjRcXHVEQzI2LVxcdURDMkFcXHVERDMwLVxcdUREMzZcXHVERUVDLVxcdURFRUZdfFxcdUQ4M0FbXFx1RENEMC1cXHVEQ0Q2XFx1REQ0NC1cXHVERDRBXXxcXHVEODNDW1xcdURGRkItXFx1REZGRl18XFx1REI0MFtcXHVEQzIwLVxcdURDN0ZcXHVERDAwLVxcdURERUZdKSQvO1xudmFyIHJlUHJlcGVuZCA9IC9eKD86W1xcdTA2MDAtXFx1MDYwNVxcdTA2RERcXHUwNzBGXFx1MDg5MFxcdTA4OTFcXHUwOEUyXFx1MEQ0RV18XFx1RDgwNFtcXHVEQ0JEXFx1RENDRFxcdUREQzJcXHVEREMzXXxcXHVEODA2W1xcdUREM0ZcXHVERDQxXFx1REUzQVxcdURFODQtXFx1REU4OV18XFx1RDgwN1xcdURENDYpJC87XG52YXIgcmVTcGFjaW5nTWFyayA9IC9eKD86W1xcdTA5MDNcXHUwOTNCXFx1MDkzRS1cXHUwOTQwXFx1MDk0OS1cXHUwOTRDXFx1MDk0RVxcdTA5NEZcXHUwOTgyXFx1MDk4M1xcdTA5QkZcXHUwOUMwXFx1MDlDN1xcdTA5QzhcXHUwOUNCXFx1MDlDQ1xcdTBBMDNcXHUwQTNFLVxcdTBBNDBcXHUwQTgzXFx1MEFCRS1cXHUwQUMwXFx1MEFDOVxcdTBBQ0JcXHUwQUNDXFx1MEIwMlxcdTBCMDNcXHUwQjQwXFx1MEI0N1xcdTBCNDhcXHUwQjRCXFx1MEI0Q1xcdTBCQkZcXHUwQkMxXFx1MEJDMlxcdTBCQzYtXFx1MEJDOFxcdTBCQ0EtXFx1MEJDQ1xcdTBDMDEtXFx1MEMwM1xcdTBDNDEtXFx1MEM0NFxcdTBDODJcXHUwQzgzXFx1MENCRVxcdTBDQzBcXHUwQ0MxXFx1MENDM1xcdTBDQzRcXHUwQ0M3XFx1MENDOFxcdTBDQ0FcXHUwQ0NCXFx1MEQwMlxcdTBEMDNcXHUwRDNGXFx1MEQ0MFxcdTBENDYtXFx1MEQ0OFxcdTBENEEtXFx1MEQ0Q1xcdTBEODJcXHUwRDgzXFx1MEREMFxcdTBERDFcXHUwREQ4LVxcdTBEREVcXHUwREYyXFx1MERGM1xcdTBFMzNcXHUwRUIzXFx1MEYzRVxcdTBGM0ZcXHUwRjdGXFx1MTAzMVxcdTEwM0JcXHUxMDNDXFx1MTA1NlxcdTEwNTdcXHUxMDg0XFx1MTcxNVxcdTE3MzRcXHUxN0I2XFx1MTdCRS1cXHUxN0M1XFx1MTdDN1xcdTE3QzhcXHUxOTIzLVxcdTE5MjZcXHUxOTI5LVxcdTE5MkJcXHUxOTMwXFx1MTkzMVxcdTE5MzMtXFx1MTkzOFxcdTFBMTlcXHUxQTFBXFx1MUE1NVxcdTFBNTdcXHUxQTZELVxcdTFBNzJcXHUxQjA0XFx1MUIzQlxcdTFCM0QtXFx1MUI0MVxcdTFCNDNcXHUxQjQ0XFx1MUI4MlxcdTFCQTFcXHUxQkE2XFx1MUJBN1xcdTFCQUFcXHUxQkU3XFx1MUJFQS1cXHUxQkVDXFx1MUJFRVxcdTFCRjJcXHUxQkYzXFx1MUMyNC1cXHUxQzJCXFx1MUMzNFxcdTFDMzVcXHUxQ0UxXFx1MUNGN1xcdUE4MjNcXHVBODI0XFx1QTgyN1xcdUE4ODBcXHVBODgxXFx1QThCNC1cXHVBOEMzXFx1QTk1MlxcdUE5NTNcXHVBOTgzXFx1QTlCNFxcdUE5QjVcXHVBOUJBXFx1QTlCQlxcdUE5QkUtXFx1QTlDMFxcdUFBMkZcXHVBQTMwXFx1QUEzM1xcdUFBMzRcXHVBQTREXFx1QUFFQlxcdUFBRUVcXHVBQUVGXFx1QUFGNVxcdUFCRTNcXHVBQkU0XFx1QUJFNlxcdUFCRTdcXHVBQkU5XFx1QUJFQVxcdUFCRUNdfFxcdUQ4MDRbXFx1REMwMFxcdURDMDJcXHVEQzgyXFx1RENCMC1cXHVEQ0IyXFx1RENCN1xcdURDQjhcXHVERDJDXFx1REQ0NVxcdURENDZcXHVERDgyXFx1RERCMy1cXHVEREI1XFx1RERCRlxcdUREQzBcXHVERENFXFx1REUyQy1cXHVERTJFXFx1REUzMlxcdURFMzNcXHVERTM1XFx1REVFMC1cXHVERUUyXFx1REYwMlxcdURGMDNcXHVERjNGXFx1REY0MS1cXHVERjQ0XFx1REY0N1xcdURGNDhcXHVERjRCLVxcdURGNERcXHVERjYyXFx1REY2M118XFx1RDgwNVtcXHVEQzM1LVxcdURDMzdcXHVEQzQwXFx1REM0MVxcdURDNDVcXHVEQ0IxXFx1RENCMlxcdURDQjlcXHVEQ0JCXFx1RENCQ1xcdURDQkVcXHVEQ0MxXFx1RERCMFxcdUREQjFcXHVEREI4LVxcdUREQkJcXHVEREJFXFx1REUzMC1cXHVERTMyXFx1REUzQlxcdURFM0NcXHVERTNFXFx1REVBQ1xcdURFQUVcXHVERUFGXFx1REVCNlxcdURGMjZdfFxcdUQ4MDZbXFx1REMyQy1cXHVEQzJFXFx1REMzOFxcdUREMzEtXFx1REQzNVxcdUREMzdcXHVERDM4XFx1REQzRFxcdURENDBcXHVERDQyXFx1REREMS1cXHVEREQzXFx1REREQy1cXHVERERGXFx1RERFNFxcdURFMzlcXHVERTU3XFx1REU1OFxcdURFOTddfFxcdUQ4MDdbXFx1REMyRlxcdURDM0VcXHVEQ0E5XFx1RENCMVxcdURDQjRcXHVERDhBLVxcdUREOEVcXHVERDkzXFx1REQ5NFxcdUREOTZcXHVERUY1XFx1REVGNl18XFx1RDgxQltcXHVERjUxLVxcdURGODdcXHVERkYwXFx1REZGMV18XFx1RDgzNFtcXHVERDY2XFx1REQ2RF0pJC87XG52YXIgcmVMID0gL15bXFx1MTEwMC1cXHUxMTVGXFx1QTk2MC1cXHVBOTdDXSQvO1xudmFyIHJlViA9IC9eW1xcdTExNjAtXFx1MTFBN1xcdUQ3QjAtXFx1RDdDNl0kLztcbnZhciByZVQgPSAvXltcXHUxMUE4LVxcdTExRkZcXHVEN0NCLVxcdUQ3RkJdJC87XG52YXIgcmVMViA9IC9eW1xcdUFDMDBcXHVBQzFDXFx1QUMzOFxcdUFDNTRcXHVBQzcwXFx1QUM4Q1xcdUFDQThcXHVBQ0M0XFx1QUNFMFxcdUFDRkNcXHVBRDE4XFx1QUQzNFxcdUFENTBcXHVBRDZDXFx1QUQ4OFxcdUFEQTRcXHVBREMwXFx1QUREQ1xcdUFERjhcXHVBRTE0XFx1QUUzMFxcdUFFNENcXHVBRTY4XFx1QUU4NFxcdUFFQTBcXHVBRUJDXFx1QUVEOFxcdUFFRjRcXHVBRjEwXFx1QUYyQ1xcdUFGNDhcXHVBRjY0XFx1QUY4MFxcdUFGOUNcXHVBRkI4XFx1QUZENFxcdUFGRjBcXHVCMDBDXFx1QjAyOFxcdUIwNDRcXHVCMDYwXFx1QjA3Q1xcdUIwOThcXHVCMEI0XFx1QjBEMFxcdUIwRUNcXHVCMTA4XFx1QjEyNFxcdUIxNDBcXHVCMTVDXFx1QjE3OFxcdUIxOTRcXHVCMUIwXFx1QjFDQ1xcdUIxRThcXHVCMjA0XFx1QjIyMFxcdUIyM0NcXHVCMjU4XFx1QjI3NFxcdUIyOTBcXHVCMkFDXFx1QjJDOFxcdUIyRTRcXHVCMzAwXFx1QjMxQ1xcdUIzMzhcXHVCMzU0XFx1QjM3MFxcdUIzOENcXHVCM0E4XFx1QjNDNFxcdUIzRTBcXHVCM0ZDXFx1QjQxOFxcdUI0MzRcXHVCNDUwXFx1QjQ2Q1xcdUI0ODhcXHVCNEE0XFx1QjRDMFxcdUI0RENcXHVCNEY4XFx1QjUxNFxcdUI1MzBcXHVCNTRDXFx1QjU2OFxcdUI1ODRcXHVCNUEwXFx1QjVCQ1xcdUI1RDhcXHVCNUY0XFx1QjYxMFxcdUI2MkNcXHVCNjQ4XFx1QjY2NFxcdUI2ODBcXHVCNjlDXFx1QjZCOFxcdUI2RDRcXHVCNkYwXFx1QjcwQ1xcdUI3MjhcXHVCNzQ0XFx1Qjc2MFxcdUI3N0NcXHVCNzk4XFx1QjdCNFxcdUI3RDBcXHVCN0VDXFx1QjgwOFxcdUI4MjRcXHVCODQwXFx1Qjg1Q1xcdUI4NzhcXHVCODk0XFx1QjhCMFxcdUI4Q0NcXHVCOEU4XFx1QjkwNFxcdUI5MjBcXHVCOTNDXFx1Qjk1OFxcdUI5NzRcXHVCOTkwXFx1QjlBQ1xcdUI5QzhcXHVCOUU0XFx1QkEwMFxcdUJBMUNcXHVCQTM4XFx1QkE1NFxcdUJBNzBcXHVCQThDXFx1QkFBOFxcdUJBQzRcXHVCQUUwXFx1QkFGQ1xcdUJCMThcXHVCQjM0XFx1QkI1MFxcdUJCNkNcXHVCQjg4XFx1QkJBNFxcdUJCQzBcXHVCQkRDXFx1QkJGOFxcdUJDMTRcXHVCQzMwXFx1QkM0Q1xcdUJDNjhcXHVCQzg0XFx1QkNBMFxcdUJDQkNcXHVCQ0Q4XFx1QkNGNFxcdUJEMTBcXHVCRDJDXFx1QkQ0OFxcdUJENjRcXHVCRDgwXFx1QkQ5Q1xcdUJEQjhcXHVCREQ0XFx1QkRGMFxcdUJFMENcXHVCRTI4XFx1QkU0NFxcdUJFNjBcXHVCRTdDXFx1QkU5OFxcdUJFQjRcXHVCRUQwXFx1QkVFQ1xcdUJGMDhcXHVCRjI0XFx1QkY0MFxcdUJGNUNcXHVCRjc4XFx1QkY5NFxcdUJGQjBcXHVCRkNDXFx1QkZFOFxcdUMwMDRcXHVDMDIwXFx1QzAzQ1xcdUMwNThcXHVDMDc0XFx1QzA5MFxcdUMwQUNcXHVDMEM4XFx1QzBFNFxcdUMxMDBcXHVDMTFDXFx1QzEzOFxcdUMxNTRcXHVDMTcwXFx1QzE4Q1xcdUMxQThcXHVDMUM0XFx1QzFFMFxcdUMxRkNcXHVDMjE4XFx1QzIzNFxcdUMyNTBcXHVDMjZDXFx1QzI4OFxcdUMyQTRcXHVDMkMwXFx1QzJEQ1xcdUMyRjhcXHVDMzE0XFx1QzMzMFxcdUMzNENcXHVDMzY4XFx1QzM4NFxcdUMzQTBcXHVDM0JDXFx1QzNEOFxcdUMzRjRcXHVDNDEwXFx1QzQyQ1xcdUM0NDhcXHVDNDY0XFx1QzQ4MFxcdUM0OUNcXHVDNEI4XFx1QzRENFxcdUM0RjBcXHVDNTBDXFx1QzUyOFxcdUM1NDRcXHVDNTYwXFx1QzU3Q1xcdUM1OThcXHVDNUI0XFx1QzVEMFxcdUM1RUNcXHVDNjA4XFx1QzYyNFxcdUM2NDBcXHVDNjVDXFx1QzY3OFxcdUM2OTRcXHVDNkIwXFx1QzZDQ1xcdUM2RThcXHVDNzA0XFx1QzcyMFxcdUM3M0NcXHVDNzU4XFx1Qzc3NFxcdUM3OTBcXHVDN0FDXFx1QzdDOFxcdUM3RTRcXHVDODAwXFx1QzgxQ1xcdUM4MzhcXHVDODU0XFx1Qzg3MFxcdUM4OENcXHVDOEE4XFx1QzhDNFxcdUM4RTBcXHVDOEZDXFx1QzkxOFxcdUM5MzRcXHVDOTUwXFx1Qzk2Q1xcdUM5ODhcXHVDOUE0XFx1QzlDMFxcdUM5RENcXHVDOUY4XFx1Q0ExNFxcdUNBMzBcXHVDQTRDXFx1Q0E2OFxcdUNBODRcXHVDQUEwXFx1Q0FCQ1xcdUNBRDhcXHVDQUY0XFx1Q0IxMFxcdUNCMkNcXHVDQjQ4XFx1Q0I2NFxcdUNCODBcXHVDQjlDXFx1Q0JCOFxcdUNCRDRcXHVDQkYwXFx1Q0MwQ1xcdUNDMjhcXHVDQzQ0XFx1Q0M2MFxcdUNDN0NcXHVDQzk4XFx1Q0NCNFxcdUNDRDBcXHVDQ0VDXFx1Q0QwOFxcdUNEMjRcXHVDRDQwXFx1Q0Q1Q1xcdUNENzhcXHVDRDk0XFx1Q0RCMFxcdUNEQ0NcXHVDREU4XFx1Q0UwNFxcdUNFMjBcXHVDRTNDXFx1Q0U1OFxcdUNFNzRcXHVDRTkwXFx1Q0VBQ1xcdUNFQzhcXHVDRUU0XFx1Q0YwMFxcdUNGMUNcXHVDRjM4XFx1Q0Y1NFxcdUNGNzBcXHVDRjhDXFx1Q0ZBOFxcdUNGQzRcXHVDRkUwXFx1Q0ZGQ1xcdUQwMThcXHVEMDM0XFx1RDA1MFxcdUQwNkNcXHVEMDg4XFx1RDBBNFxcdUQwQzBcXHVEMERDXFx1RDBGOFxcdUQxMTRcXHVEMTMwXFx1RDE0Q1xcdUQxNjhcXHVEMTg0XFx1RDFBMFxcdUQxQkNcXHVEMUQ4XFx1RDFGNFxcdUQyMTBcXHVEMjJDXFx1RDI0OFxcdUQyNjRcXHVEMjgwXFx1RDI5Q1xcdUQyQjhcXHVEMkQ0XFx1RDJGMFxcdUQzMENcXHVEMzI4XFx1RDM0NFxcdUQzNjBcXHVEMzdDXFx1RDM5OFxcdUQzQjRcXHVEM0QwXFx1RDNFQ1xcdUQ0MDhcXHVENDI0XFx1RDQ0MFxcdUQ0NUNcXHVENDc4XFx1RDQ5NFxcdUQ0QjBcXHVENENDXFx1RDRFOFxcdUQ1MDRcXHVENTIwXFx1RDUzQ1xcdUQ1NThcXHVENTc0XFx1RDU5MFxcdUQ1QUNcXHVENUM4XFx1RDVFNFxcdUQ2MDBcXHVENjFDXFx1RDYzOFxcdUQ2NTRcXHVENjcwXFx1RDY4Q1xcdUQ2QThcXHVENkM0XFx1RDZFMFxcdUQ2RkNcXHVENzE4XFx1RDczNFxcdUQ3NTBcXHVENzZDXFx1RDc4OF0kLztcbnZhciByZUxWVCA9IC9eW1xcdUFDMDEtXFx1QUMxQlxcdUFDMUQtXFx1QUMzN1xcdUFDMzktXFx1QUM1M1xcdUFDNTUtXFx1QUM2RlxcdUFDNzEtXFx1QUM4QlxcdUFDOEQtXFx1QUNBN1xcdUFDQTktXFx1QUNDM1xcdUFDQzUtXFx1QUNERlxcdUFDRTEtXFx1QUNGQlxcdUFDRkQtXFx1QUQxN1xcdUFEMTktXFx1QUQzM1xcdUFEMzUtXFx1QUQ0RlxcdUFENTEtXFx1QUQ2QlxcdUFENkQtXFx1QUQ4N1xcdUFEODktXFx1QURBM1xcdUFEQTUtXFx1QURCRlxcdUFEQzEtXFx1QUREQlxcdUFEREQtXFx1QURGN1xcdUFERjktXFx1QUUxM1xcdUFFMTUtXFx1QUUyRlxcdUFFMzEtXFx1QUU0QlxcdUFFNEQtXFx1QUU2N1xcdUFFNjktXFx1QUU4M1xcdUFFODUtXFx1QUU5RlxcdUFFQTEtXFx1QUVCQlxcdUFFQkQtXFx1QUVEN1xcdUFFRDktXFx1QUVGM1xcdUFFRjUtXFx1QUYwRlxcdUFGMTEtXFx1QUYyQlxcdUFGMkQtXFx1QUY0N1xcdUFGNDktXFx1QUY2M1xcdUFGNjUtXFx1QUY3RlxcdUFGODEtXFx1QUY5QlxcdUFGOUQtXFx1QUZCN1xcdUFGQjktXFx1QUZEM1xcdUFGRDUtXFx1QUZFRlxcdUFGRjEtXFx1QjAwQlxcdUIwMEQtXFx1QjAyN1xcdUIwMjktXFx1QjA0M1xcdUIwNDUtXFx1QjA1RlxcdUIwNjEtXFx1QjA3QlxcdUIwN0QtXFx1QjA5N1xcdUIwOTktXFx1QjBCM1xcdUIwQjUtXFx1QjBDRlxcdUIwRDEtXFx1QjBFQlxcdUIwRUQtXFx1QjEwN1xcdUIxMDktXFx1QjEyM1xcdUIxMjUtXFx1QjEzRlxcdUIxNDEtXFx1QjE1QlxcdUIxNUQtXFx1QjE3N1xcdUIxNzktXFx1QjE5M1xcdUIxOTUtXFx1QjFBRlxcdUIxQjEtXFx1QjFDQlxcdUIxQ0QtXFx1QjFFN1xcdUIxRTktXFx1QjIwM1xcdUIyMDUtXFx1QjIxRlxcdUIyMjEtXFx1QjIzQlxcdUIyM0QtXFx1QjI1N1xcdUIyNTktXFx1QjI3M1xcdUIyNzUtXFx1QjI4RlxcdUIyOTEtXFx1QjJBQlxcdUIyQUQtXFx1QjJDN1xcdUIyQzktXFx1QjJFM1xcdUIyRTUtXFx1QjJGRlxcdUIzMDEtXFx1QjMxQlxcdUIzMUQtXFx1QjMzN1xcdUIzMzktXFx1QjM1M1xcdUIzNTUtXFx1QjM2RlxcdUIzNzEtXFx1QjM4QlxcdUIzOEQtXFx1QjNBN1xcdUIzQTktXFx1QjNDM1xcdUIzQzUtXFx1QjNERlxcdUIzRTEtXFx1QjNGQlxcdUIzRkQtXFx1QjQxN1xcdUI0MTktXFx1QjQzM1xcdUI0MzUtXFx1QjQ0RlxcdUI0NTEtXFx1QjQ2QlxcdUI0NkQtXFx1QjQ4N1xcdUI0ODktXFx1QjRBM1xcdUI0QTUtXFx1QjRCRlxcdUI0QzEtXFx1QjREQlxcdUI0REQtXFx1QjRGN1xcdUI0RjktXFx1QjUxM1xcdUI1MTUtXFx1QjUyRlxcdUI1MzEtXFx1QjU0QlxcdUI1NEQtXFx1QjU2N1xcdUI1NjktXFx1QjU4M1xcdUI1ODUtXFx1QjU5RlxcdUI1QTEtXFx1QjVCQlxcdUI1QkQtXFx1QjVEN1xcdUI1RDktXFx1QjVGM1xcdUI1RjUtXFx1QjYwRlxcdUI2MTEtXFx1QjYyQlxcdUI2MkQtXFx1QjY0N1xcdUI2NDktXFx1QjY2M1xcdUI2NjUtXFx1QjY3RlxcdUI2ODEtXFx1QjY5QlxcdUI2OUQtXFx1QjZCN1xcdUI2QjktXFx1QjZEM1xcdUI2RDUtXFx1QjZFRlxcdUI2RjEtXFx1QjcwQlxcdUI3MEQtXFx1QjcyN1xcdUI3MjktXFx1Qjc0M1xcdUI3NDUtXFx1Qjc1RlxcdUI3NjEtXFx1Qjc3QlxcdUI3N0QtXFx1Qjc5N1xcdUI3OTktXFx1QjdCM1xcdUI3QjUtXFx1QjdDRlxcdUI3RDEtXFx1QjdFQlxcdUI3RUQtXFx1QjgwN1xcdUI4MDktXFx1QjgyM1xcdUI4MjUtXFx1QjgzRlxcdUI4NDEtXFx1Qjg1QlxcdUI4NUQtXFx1Qjg3N1xcdUI4NzktXFx1Qjg5M1xcdUI4OTUtXFx1QjhBRlxcdUI4QjEtXFx1QjhDQlxcdUI4Q0QtXFx1QjhFN1xcdUI4RTktXFx1QjkwM1xcdUI5MDUtXFx1QjkxRlxcdUI5MjEtXFx1QjkzQlxcdUI5M0QtXFx1Qjk1N1xcdUI5NTktXFx1Qjk3M1xcdUI5NzUtXFx1Qjk4RlxcdUI5OTEtXFx1QjlBQlxcdUI5QUQtXFx1QjlDN1xcdUI5QzktXFx1QjlFM1xcdUI5RTUtXFx1QjlGRlxcdUJBMDEtXFx1QkExQlxcdUJBMUQtXFx1QkEzN1xcdUJBMzktXFx1QkE1M1xcdUJBNTUtXFx1QkE2RlxcdUJBNzEtXFx1QkE4QlxcdUJBOEQtXFx1QkFBN1xcdUJBQTktXFx1QkFDM1xcdUJBQzUtXFx1QkFERlxcdUJBRTEtXFx1QkFGQlxcdUJBRkQtXFx1QkIxN1xcdUJCMTktXFx1QkIzM1xcdUJCMzUtXFx1QkI0RlxcdUJCNTEtXFx1QkI2QlxcdUJCNkQtXFx1QkI4N1xcdUJCODktXFx1QkJBM1xcdUJCQTUtXFx1QkJCRlxcdUJCQzEtXFx1QkJEQlxcdUJCREQtXFx1QkJGN1xcdUJCRjktXFx1QkMxM1xcdUJDMTUtXFx1QkMyRlxcdUJDMzEtXFx1QkM0QlxcdUJDNEQtXFx1QkM2N1xcdUJDNjktXFx1QkM4M1xcdUJDODUtXFx1QkM5RlxcdUJDQTEtXFx1QkNCQlxcdUJDQkQtXFx1QkNEN1xcdUJDRDktXFx1QkNGM1xcdUJDRjUtXFx1QkQwRlxcdUJEMTEtXFx1QkQyQlxcdUJEMkQtXFx1QkQ0N1xcdUJENDktXFx1QkQ2M1xcdUJENjUtXFx1QkQ3RlxcdUJEODEtXFx1QkQ5QlxcdUJEOUQtXFx1QkRCN1xcdUJEQjktXFx1QkREM1xcdUJERDUtXFx1QkRFRlxcdUJERjEtXFx1QkUwQlxcdUJFMEQtXFx1QkUyN1xcdUJFMjktXFx1QkU0M1xcdUJFNDUtXFx1QkU1RlxcdUJFNjEtXFx1QkU3QlxcdUJFN0QtXFx1QkU5N1xcdUJFOTktXFx1QkVCM1xcdUJFQjUtXFx1QkVDRlxcdUJFRDEtXFx1QkVFQlxcdUJFRUQtXFx1QkYwN1xcdUJGMDktXFx1QkYyM1xcdUJGMjUtXFx1QkYzRlxcdUJGNDEtXFx1QkY1QlxcdUJGNUQtXFx1QkY3N1xcdUJGNzktXFx1QkY5M1xcdUJGOTUtXFx1QkZBRlxcdUJGQjEtXFx1QkZDQlxcdUJGQ0QtXFx1QkZFN1xcdUJGRTktXFx1QzAwM1xcdUMwMDUtXFx1QzAxRlxcdUMwMjEtXFx1QzAzQlxcdUMwM0QtXFx1QzA1N1xcdUMwNTktXFx1QzA3M1xcdUMwNzUtXFx1QzA4RlxcdUMwOTEtXFx1QzBBQlxcdUMwQUQtXFx1QzBDN1xcdUMwQzktXFx1QzBFM1xcdUMwRTUtXFx1QzBGRlxcdUMxMDEtXFx1QzExQlxcdUMxMUQtXFx1QzEzN1xcdUMxMzktXFx1QzE1M1xcdUMxNTUtXFx1QzE2RlxcdUMxNzEtXFx1QzE4QlxcdUMxOEQtXFx1QzFBN1xcdUMxQTktXFx1QzFDM1xcdUMxQzUtXFx1QzFERlxcdUMxRTEtXFx1QzFGQlxcdUMxRkQtXFx1QzIxN1xcdUMyMTktXFx1QzIzM1xcdUMyMzUtXFx1QzI0RlxcdUMyNTEtXFx1QzI2QlxcdUMyNkQtXFx1QzI4N1xcdUMyODktXFx1QzJBM1xcdUMyQTUtXFx1QzJCRlxcdUMyQzEtXFx1QzJEQlxcdUMyREQtXFx1QzJGN1xcdUMyRjktXFx1QzMxM1xcdUMzMTUtXFx1QzMyRlxcdUMzMzEtXFx1QzM0QlxcdUMzNEQtXFx1QzM2N1xcdUMzNjktXFx1QzM4M1xcdUMzODUtXFx1QzM5RlxcdUMzQTEtXFx1QzNCQlxcdUMzQkQtXFx1QzNEN1xcdUMzRDktXFx1QzNGM1xcdUMzRjUtXFx1QzQwRlxcdUM0MTEtXFx1QzQyQlxcdUM0MkQtXFx1QzQ0N1xcdUM0NDktXFx1QzQ2M1xcdUM0NjUtXFx1QzQ3RlxcdUM0ODEtXFx1QzQ5QlxcdUM0OUQtXFx1QzRCN1xcdUM0QjktXFx1QzREM1xcdUM0RDUtXFx1QzRFRlxcdUM0RjEtXFx1QzUwQlxcdUM1MEQtXFx1QzUyN1xcdUM1MjktXFx1QzU0M1xcdUM1NDUtXFx1QzU1RlxcdUM1NjEtXFx1QzU3QlxcdUM1N0QtXFx1QzU5N1xcdUM1OTktXFx1QzVCM1xcdUM1QjUtXFx1QzVDRlxcdUM1RDEtXFx1QzVFQlxcdUM1RUQtXFx1QzYwN1xcdUM2MDktXFx1QzYyM1xcdUM2MjUtXFx1QzYzRlxcdUM2NDEtXFx1QzY1QlxcdUM2NUQtXFx1QzY3N1xcdUM2NzktXFx1QzY5M1xcdUM2OTUtXFx1QzZBRlxcdUM2QjEtXFx1QzZDQlxcdUM2Q0QtXFx1QzZFN1xcdUM2RTktXFx1QzcwM1xcdUM3MDUtXFx1QzcxRlxcdUM3MjEtXFx1QzczQlxcdUM3M0QtXFx1Qzc1N1xcdUM3NTktXFx1Qzc3M1xcdUM3NzUtXFx1Qzc4RlxcdUM3OTEtXFx1QzdBQlxcdUM3QUQtXFx1QzdDN1xcdUM3QzktXFx1QzdFM1xcdUM3RTUtXFx1QzdGRlxcdUM4MDEtXFx1QzgxQlxcdUM4MUQtXFx1QzgzN1xcdUM4MzktXFx1Qzg1M1xcdUM4NTUtXFx1Qzg2RlxcdUM4NzEtXFx1Qzg4QlxcdUM4OEQtXFx1QzhBN1xcdUM4QTktXFx1QzhDM1xcdUM4QzUtXFx1QzhERlxcdUM4RTEtXFx1QzhGQlxcdUM4RkQtXFx1QzkxN1xcdUM5MTktXFx1QzkzM1xcdUM5MzUtXFx1Qzk0RlxcdUM5NTEtXFx1Qzk2QlxcdUM5NkQtXFx1Qzk4N1xcdUM5ODktXFx1QzlBM1xcdUM5QTUtXFx1QzlCRlxcdUM5QzEtXFx1QzlEQlxcdUM5REQtXFx1QzlGN1xcdUM5RjktXFx1Q0ExM1xcdUNBMTUtXFx1Q0EyRlxcdUNBMzEtXFx1Q0E0QlxcdUNBNEQtXFx1Q0E2N1xcdUNBNjktXFx1Q0E4M1xcdUNBODUtXFx1Q0E5RlxcdUNBQTEtXFx1Q0FCQlxcdUNBQkQtXFx1Q0FEN1xcdUNBRDktXFx1Q0FGM1xcdUNBRjUtXFx1Q0IwRlxcdUNCMTEtXFx1Q0IyQlxcdUNCMkQtXFx1Q0I0N1xcdUNCNDktXFx1Q0I2M1xcdUNCNjUtXFx1Q0I3RlxcdUNCODEtXFx1Q0I5QlxcdUNCOUQtXFx1Q0JCN1xcdUNCQjktXFx1Q0JEM1xcdUNCRDUtXFx1Q0JFRlxcdUNCRjEtXFx1Q0MwQlxcdUNDMEQtXFx1Q0MyN1xcdUNDMjktXFx1Q0M0M1xcdUNDNDUtXFx1Q0M1RlxcdUNDNjEtXFx1Q0M3QlxcdUNDN0QtXFx1Q0M5N1xcdUNDOTktXFx1Q0NCM1xcdUNDQjUtXFx1Q0NDRlxcdUNDRDEtXFx1Q0NFQlxcdUNDRUQtXFx1Q0QwN1xcdUNEMDktXFx1Q0QyM1xcdUNEMjUtXFx1Q0QzRlxcdUNENDEtXFx1Q0Q1QlxcdUNENUQtXFx1Q0Q3N1xcdUNENzktXFx1Q0Q5M1xcdUNEOTUtXFx1Q0RBRlxcdUNEQjEtXFx1Q0RDQlxcdUNEQ0QtXFx1Q0RFN1xcdUNERTktXFx1Q0UwM1xcdUNFMDUtXFx1Q0UxRlxcdUNFMjEtXFx1Q0UzQlxcdUNFM0QtXFx1Q0U1N1xcdUNFNTktXFx1Q0U3M1xcdUNFNzUtXFx1Q0U4RlxcdUNFOTEtXFx1Q0VBQlxcdUNFQUQtXFx1Q0VDN1xcdUNFQzktXFx1Q0VFM1xcdUNFRTUtXFx1Q0VGRlxcdUNGMDEtXFx1Q0YxQlxcdUNGMUQtXFx1Q0YzN1xcdUNGMzktXFx1Q0Y1M1xcdUNGNTUtXFx1Q0Y2RlxcdUNGNzEtXFx1Q0Y4QlxcdUNGOEQtXFx1Q0ZBN1xcdUNGQTktXFx1Q0ZDM1xcdUNGQzUtXFx1Q0ZERlxcdUNGRTEtXFx1Q0ZGQlxcdUNGRkQtXFx1RDAxN1xcdUQwMTktXFx1RDAzM1xcdUQwMzUtXFx1RDA0RlxcdUQwNTEtXFx1RDA2QlxcdUQwNkQtXFx1RDA4N1xcdUQwODktXFx1RDBBM1xcdUQwQTUtXFx1RDBCRlxcdUQwQzEtXFx1RDBEQlxcdUQwREQtXFx1RDBGN1xcdUQwRjktXFx1RDExM1xcdUQxMTUtXFx1RDEyRlxcdUQxMzEtXFx1RDE0QlxcdUQxNEQtXFx1RDE2N1xcdUQxNjktXFx1RDE4M1xcdUQxODUtXFx1RDE5RlxcdUQxQTEtXFx1RDFCQlxcdUQxQkQtXFx1RDFEN1xcdUQxRDktXFx1RDFGM1xcdUQxRjUtXFx1RDIwRlxcdUQyMTEtXFx1RDIyQlxcdUQyMkQtXFx1RDI0N1xcdUQyNDktXFx1RDI2M1xcdUQyNjUtXFx1RDI3RlxcdUQyODEtXFx1RDI5QlxcdUQyOUQtXFx1RDJCN1xcdUQyQjktXFx1RDJEM1xcdUQyRDUtXFx1RDJFRlxcdUQyRjEtXFx1RDMwQlxcdUQzMEQtXFx1RDMyN1xcdUQzMjktXFx1RDM0M1xcdUQzNDUtXFx1RDM1RlxcdUQzNjEtXFx1RDM3QlxcdUQzN0QtXFx1RDM5N1xcdUQzOTktXFx1RDNCM1xcdUQzQjUtXFx1RDNDRlxcdUQzRDEtXFx1RDNFQlxcdUQzRUQtXFx1RDQwN1xcdUQ0MDktXFx1RDQyM1xcdUQ0MjUtXFx1RDQzRlxcdUQ0NDEtXFx1RDQ1QlxcdUQ0NUQtXFx1RDQ3N1xcdUQ0NzktXFx1RDQ5M1xcdUQ0OTUtXFx1RDRBRlxcdUQ0QjEtXFx1RDRDQlxcdUQ0Q0QtXFx1RDRFN1xcdUQ0RTktXFx1RDUwM1xcdUQ1MDUtXFx1RDUxRlxcdUQ1MjEtXFx1RDUzQlxcdUQ1M0QtXFx1RDU1N1xcdUQ1NTktXFx1RDU3M1xcdUQ1NzUtXFx1RDU4RlxcdUQ1OTEtXFx1RDVBQlxcdUQ1QUQtXFx1RDVDN1xcdUQ1QzktXFx1RDVFM1xcdUQ1RTUtXFx1RDVGRlxcdUQ2MDEtXFx1RDYxQlxcdUQ2MUQtXFx1RDYzN1xcdUQ2MzktXFx1RDY1M1xcdUQ2NTUtXFx1RDY2RlxcdUQ2NzEtXFx1RDY4QlxcdUQ2OEQtXFx1RDZBN1xcdUQ2QTktXFx1RDZDM1xcdUQ2QzUtXFx1RDZERlxcdUQ2RTEtXFx1RDZGQlxcdUQ2RkQtXFx1RDcxN1xcdUQ3MTktXFx1RDczM1xcdUQ3MzUtXFx1RDc0RlxcdUQ3NTEtXFx1RDc2QlxcdUQ3NkQtXFx1RDc4N1xcdUQ3ODktXFx1RDdBM10kLztcbnZhciByZUV4dFBpY3QgPSAvXig/OltcXHhBOVxceEFFXFx1MjAzQ1xcdTIwNDlcXHUyMTIyXFx1MjEzOVxcdTIxOTQtXFx1MjE5OVxcdTIxQTlcXHUyMUFBXFx1MjMxQVxcdTIzMUJcXHUyMzI4XFx1MjM4OFxcdTIzQ0ZcXHUyM0U5LVxcdTIzRjNcXHUyM0Y4LVxcdTIzRkFcXHUyNEMyXFx1MjVBQVxcdTI1QUJcXHUyNUI2XFx1MjVDMFxcdTI1RkItXFx1MjVGRVxcdTI2MDAtXFx1MjYwNVxcdTI2MDctXFx1MjYxMlxcdTI2MTQtXFx1MjY4NVxcdTI2OTAtXFx1MjcwNVxcdTI3MDgtXFx1MjcxMlxcdTI3MTRcXHUyNzE2XFx1MjcxRFxcdTI3MjFcXHUyNzI4XFx1MjczM1xcdTI3MzRcXHUyNzQ0XFx1Mjc0N1xcdTI3NENcXHUyNzRFXFx1Mjc1My1cXHUyNzU1XFx1Mjc1N1xcdTI3NjMtXFx1Mjc2N1xcdTI3OTUtXFx1Mjc5N1xcdTI3QTFcXHUyN0IwXFx1MjdCRlxcdTI5MzRcXHUyOTM1XFx1MkIwNS1cXHUyQjA3XFx1MkIxQlxcdTJCMUNcXHUyQjUwXFx1MkI1NVxcdTMwMzBcXHUzMDNEXFx1MzI5N1xcdTMyOTldfFxcdUQ4M0NbXFx1REMwMC1cXHVEQ0ZGXFx1REQwRC1cXHVERDBGXFx1REQyRlxcdURENkMtXFx1REQ3MVxcdUREN0VcXHVERDdGXFx1REQ4RVxcdUREOTEtXFx1REQ5QVxcdUREQUQtXFx1RERFNVxcdURFMDEtXFx1REUwRlxcdURFMUFcXHVERTJGXFx1REUzMi1cXHVERTNBXFx1REUzQy1cXHVERTNGXFx1REU0OS1cXHVERkZBXXxcXHVEODNEW1xcdURDMDAtXFx1REQzRFxcdURENDYtXFx1REU0RlxcdURFODAtXFx1REVGRlxcdURGNzQtXFx1REY3RlxcdURGRDUtXFx1REZGRl18XFx1RDgzRVtcXHVEQzBDLVxcdURDMEZcXHVEQzQ4LVxcdURDNEZcXHVEQzVBLVxcdURDNUZcXHVEQzg4LVxcdURDOEZcXHVEQ0FFLVxcdURDRkZcXHVERDBDLVxcdUREM0FcXHVERDNDLVxcdURENDVcXHVERDQ3LVxcdURFRkZdfFxcdUQ4M0ZbXFx1REMwMC1cXHVERkZEXSkkLztcblxudmFyIGdldENvZGVwb2ludFR5cGUgPSBmdW5jdGlvbiBnZXRDb2RlcG9pbnRUeXBlKF9jaGFyNCwgY29kZSkge1xuICB2YXIgdHlwZSA9IENvZGVwb2ludFR5cGUuQW55O1xuXG4gIGlmIChfY2hhcjQuc2VhcmNoKHJlRXh0ZW5kKSAhPT0gLTEpIHtcbiAgICB0eXBlIHw9IENvZGVwb2ludFR5cGUuRXh0ZW5kO1xuICB9XG5cbiAgaWYgKGNvZGUgPT09IDB4MjAwZCkge1xuICAgIHR5cGUgfD0gQ29kZXBvaW50VHlwZS5aV0o7XG4gIH1cblxuICBpZiAoY29kZSA+PSAweDFmMWU2ICYmIGNvZGUgPD0gMHgxZjFmZikge1xuICAgIHR5cGUgfD0gQ29kZXBvaW50VHlwZS5SSTtcbiAgfVxuXG4gIGlmIChfY2hhcjQuc2VhcmNoKHJlUHJlcGVuZCkgIT09IC0xKSB7XG4gICAgdHlwZSB8PSBDb2RlcG9pbnRUeXBlLlByZXBlbmQ7XG4gIH1cblxuICBpZiAoX2NoYXI0LnNlYXJjaChyZVNwYWNpbmdNYXJrKSAhPT0gLTEpIHtcbiAgICB0eXBlIHw9IENvZGVwb2ludFR5cGUuU3BhY2luZ01hcms7XG4gIH1cblxuICBpZiAoX2NoYXI0LnNlYXJjaChyZUwpICE9PSAtMSkge1xuICAgIHR5cGUgfD0gQ29kZXBvaW50VHlwZS5MO1xuICB9XG5cbiAgaWYgKF9jaGFyNC5zZWFyY2gocmVWKSAhPT0gLTEpIHtcbiAgICB0eXBlIHw9IENvZGVwb2ludFR5cGUuVjtcbiAgfVxuXG4gIGlmIChfY2hhcjQuc2VhcmNoKHJlVCkgIT09IC0xKSB7XG4gICAgdHlwZSB8PSBDb2RlcG9pbnRUeXBlLlQ7XG4gIH1cblxuICBpZiAoX2NoYXI0LnNlYXJjaChyZUxWKSAhPT0gLTEpIHtcbiAgICB0eXBlIHw9IENvZGVwb2ludFR5cGUuTFY7XG4gIH1cblxuICBpZiAoX2NoYXI0LnNlYXJjaChyZUxWVCkgIT09IC0xKSB7XG4gICAgdHlwZSB8PSBDb2RlcG9pbnRUeXBlLkxWVDtcbiAgfVxuXG4gIGlmIChfY2hhcjQuc2VhcmNoKHJlRXh0UGljdCkgIT09IC0xKSB7XG4gICAgdHlwZSB8PSBDb2RlcG9pbnRUeXBlLkV4dFBpY3Q7XG4gIH1cblxuICByZXR1cm4gdHlwZTtcbn07XG5cbmZ1bmN0aW9uIGludGVyc2VjdHMoeCwgeSkge1xuICByZXR1cm4gKHggJiB5KSAhPT0gMDtcbn1cblxudmFyIE5vbkJvdW5kYXJ5UGFpcnMgPSBbLy8gR0I2XG5bQ29kZXBvaW50VHlwZS5MLCBDb2RlcG9pbnRUeXBlLkwgfCBDb2RlcG9pbnRUeXBlLlYgfCBDb2RlcG9pbnRUeXBlLkxWIHwgQ29kZXBvaW50VHlwZS5MVlRdLCAvLyBHQjdcbltDb2RlcG9pbnRUeXBlLkxWIHwgQ29kZXBvaW50VHlwZS5WLCBDb2RlcG9pbnRUeXBlLlYgfCBDb2RlcG9pbnRUeXBlLlRdLCAvLyBHQjhcbltDb2RlcG9pbnRUeXBlLkxWVCB8IENvZGVwb2ludFR5cGUuVCwgQ29kZXBvaW50VHlwZS5UXSwgLy8gR0I5XG5bQ29kZXBvaW50VHlwZS5BbnksIENvZGVwb2ludFR5cGUuRXh0ZW5kIHwgQ29kZXBvaW50VHlwZS5aV0pdLCAvLyBHQjlhXG5bQ29kZXBvaW50VHlwZS5BbnksIENvZGVwb2ludFR5cGUuU3BhY2luZ01hcmtdLCAvLyBHQjliXG5bQ29kZXBvaW50VHlwZS5QcmVwZW5kLCBDb2RlcG9pbnRUeXBlLkFueV0sIC8vIEdCMTFcbltDb2RlcG9pbnRUeXBlLlpXSiwgQ29kZXBvaW50VHlwZS5FeHRQaWN0XSwgLy8gR0IxMiBhbmQgR0IxM1xuW0NvZGVwb2ludFR5cGUuUkksIENvZGVwb2ludFR5cGUuUkldXTtcblxuZnVuY3Rpb24gaXNCb3VuZGFyeVBhaXIobGVmdCwgcmlnaHQpIHtcbiAgcmV0dXJuIE5vbkJvdW5kYXJ5UGFpcnMuZmluZEluZGV4KGZ1bmN0aW9uIChyKSB7XG4gICAgcmV0dXJuIGludGVyc2VjdHMobGVmdCwgclswXSkgJiYgaW50ZXJzZWN0cyhyaWdodCwgclsxXSk7XG4gIH0pID09PSAtMTtcbn1cblxudmFyIGVuZGluZ0Vtb2ppWldKID0gLyg/OltcXHhBOVxceEFFXFx1MjAzQ1xcdTIwNDlcXHUyMTIyXFx1MjEzOVxcdTIxOTQtXFx1MjE5OVxcdTIxQTlcXHUyMUFBXFx1MjMxQVxcdTIzMUJcXHUyMzI4XFx1MjM4OFxcdTIzQ0ZcXHUyM0U5LVxcdTIzRjNcXHUyM0Y4LVxcdTIzRkFcXHUyNEMyXFx1MjVBQVxcdTI1QUJcXHUyNUI2XFx1MjVDMFxcdTI1RkItXFx1MjVGRVxcdTI2MDAtXFx1MjYwNVxcdTI2MDctXFx1MjYxMlxcdTI2MTQtXFx1MjY4NVxcdTI2OTAtXFx1MjcwNVxcdTI3MDgtXFx1MjcxMlxcdTI3MTRcXHUyNzE2XFx1MjcxRFxcdTI3MjFcXHUyNzI4XFx1MjczM1xcdTI3MzRcXHUyNzQ0XFx1Mjc0N1xcdTI3NENcXHUyNzRFXFx1Mjc1My1cXHUyNzU1XFx1Mjc1N1xcdTI3NjMtXFx1Mjc2N1xcdTI3OTUtXFx1Mjc5N1xcdTI3QTFcXHUyN0IwXFx1MjdCRlxcdTI5MzRcXHUyOTM1XFx1MkIwNS1cXHUyQjA3XFx1MkIxQlxcdTJCMUNcXHUyQjUwXFx1MkI1NVxcdTMwMzBcXHUzMDNEXFx1MzI5N1xcdTMyOTldfFxcdUQ4M0NbXFx1REMwMC1cXHVEQ0ZGXFx1REQwRC1cXHVERDBGXFx1REQyRlxcdURENkMtXFx1REQ3MVxcdUREN0VcXHVERDdGXFx1REQ4RVxcdUREOTEtXFx1REQ5QVxcdUREQUQtXFx1RERFNVxcdURFMDEtXFx1REUwRlxcdURFMUFcXHVERTJGXFx1REUzMi1cXHVERTNBXFx1REUzQy1cXHVERTNGXFx1REU0OS1cXHVERkZBXXxcXHVEODNEW1xcdURDMDAtXFx1REQzRFxcdURENDYtXFx1REU0RlxcdURFODAtXFx1REVGRlxcdURGNzQtXFx1REY3RlxcdURGRDUtXFx1REZGRl18XFx1RDgzRVtcXHVEQzBDLVxcdURDMEZcXHVEQzQ4LVxcdURDNEZcXHVEQzVBLVxcdURDNUZcXHVEQzg4LVxcdURDOEZcXHVEQ0FFLVxcdURDRkZcXHVERDBDLVxcdUREM0FcXHVERDNDLVxcdURENDVcXHVERDQ3LVxcdURFRkZdfFxcdUQ4M0ZbXFx1REMwMC1cXHVERkZEXSkoPzpbXFx1MDMwMC1cXHUwMzZGXFx1MDQ4My1cXHUwNDg5XFx1MDU5MS1cXHUwNUJEXFx1MDVCRlxcdTA1QzFcXHUwNUMyXFx1MDVDNFxcdTA1QzVcXHUwNUM3XFx1MDYxMC1cXHUwNjFBXFx1MDY0Qi1cXHUwNjVGXFx1MDY3MFxcdTA2RDYtXFx1MDZEQ1xcdTA2REYtXFx1MDZFNFxcdTA2RTdcXHUwNkU4XFx1MDZFQS1cXHUwNkVEXFx1MDcxMVxcdTA3MzAtXFx1MDc0QVxcdTA3QTYtXFx1MDdCMFxcdTA3RUItXFx1MDdGM1xcdTA3RkRcXHUwODE2LVxcdTA4MTlcXHUwODFCLVxcdTA4MjNcXHUwODI1LVxcdTA4MjdcXHUwODI5LVxcdTA4MkRcXHUwODU5LVxcdTA4NUJcXHUwOEQzLVxcdTA4RTFcXHUwOEUzLVxcdTA5MDJcXHUwOTNBXFx1MDkzQ1xcdTA5NDEtXFx1MDk0OFxcdTA5NERcXHUwOTUxLVxcdTA5NTdcXHUwOTYyXFx1MDk2M1xcdTA5ODFcXHUwOUJDXFx1MDlCRVxcdTA5QzEtXFx1MDlDNFxcdTA5Q0RcXHUwOUQ3XFx1MDlFMlxcdTA5RTNcXHUwOUZFXFx1MEEwMVxcdTBBMDJcXHUwQTNDXFx1MEE0MVxcdTBBNDJcXHUwQTQ3XFx1MEE0OFxcdTBBNEItXFx1MEE0RFxcdTBBNTFcXHUwQTcwXFx1MEE3MVxcdTBBNzVcXHUwQTgxXFx1MEE4MlxcdTBBQkNcXHUwQUMxLVxcdTBBQzVcXHUwQUM3XFx1MEFDOFxcdTBBQ0RcXHUwQUUyXFx1MEFFM1xcdTBBRkEtXFx1MEFGRlxcdTBCMDFcXHUwQjNDXFx1MEIzRVxcdTBCM0ZcXHUwQjQxLVxcdTBCNDRcXHUwQjREXFx1MEI1NS1cXHUwQjU3XFx1MEI2MlxcdTBCNjNcXHUwQjgyXFx1MEJCRVxcdTBCQzBcXHUwQkNEXFx1MEJEN1xcdTBDMDBcXHUwQzA0XFx1MEMzRS1cXHUwQzQwXFx1MEM0Ni1cXHUwQzQ4XFx1MEM0QS1cXHUwQzREXFx1MEM1NVxcdTBDNTZcXHUwQzYyXFx1MEM2M1xcdTBDODFcXHUwQ0JDXFx1MENCRlxcdTBDQzJcXHUwQ0M2XFx1MENDQ1xcdTBDQ0RcXHUwQ0Q1XFx1MENENlxcdTBDRTJcXHUwQ0UzXFx1MEQwMFxcdTBEMDFcXHUwRDNCXFx1MEQzQ1xcdTBEM0VcXHUwRDQxLVxcdTBENDRcXHUwRDREXFx1MEQ1N1xcdTBENjJcXHUwRDYzXFx1MEQ4MVxcdTBEQ0FcXHUwRENGXFx1MEREMi1cXHUwREQ0XFx1MERENlxcdTBEREZcXHUwRTMxXFx1MEUzNC1cXHUwRTNBXFx1MEU0Ny1cXHUwRTRFXFx1MEVCMVxcdTBFQjQtXFx1MEVCQ1xcdTBFQzgtXFx1MEVDRFxcdTBGMThcXHUwRjE5XFx1MEYzNVxcdTBGMzdcXHUwRjM5XFx1MEY3MS1cXHUwRjdFXFx1MEY4MC1cXHUwRjg0XFx1MEY4NlxcdTBGODdcXHUwRjhELVxcdTBGOTdcXHUwRjk5LVxcdTBGQkNcXHUwRkM2XFx1MTAyRC1cXHUxMDMwXFx1MTAzMi1cXHUxMDM3XFx1MTAzOVxcdTEwM0FcXHUxMDNEXFx1MTAzRVxcdTEwNThcXHUxMDU5XFx1MTA1RS1cXHUxMDYwXFx1MTA3MS1cXHUxMDc0XFx1MTA4MlxcdTEwODVcXHUxMDg2XFx1MTA4RFxcdTEwOURcXHUxMzVELVxcdTEzNUZcXHUxNzEyLVxcdTE3MTRcXHUxNzMyLVxcdTE3MzRcXHUxNzUyXFx1MTc1M1xcdTE3NzJcXHUxNzczXFx1MTdCNFxcdTE3QjVcXHUxN0I3LVxcdTE3QkRcXHUxN0M2XFx1MTdDOS1cXHUxN0QzXFx1MTdERFxcdTE4MEItXFx1MTgwRFxcdTE4ODVcXHUxODg2XFx1MThBOVxcdTE5MjAtXFx1MTkyMlxcdTE5MjdcXHUxOTI4XFx1MTkzMlxcdTE5MzktXFx1MTkzQlxcdTFBMTdcXHUxQTE4XFx1MUExQlxcdTFBNTZcXHUxQTU4LVxcdTFBNUVcXHUxQTYwXFx1MUE2MlxcdTFBNjUtXFx1MUE2Q1xcdTFBNzMtXFx1MUE3Q1xcdTFBN0ZcXHUxQUIwLVxcdTFBQzBcXHUxQjAwLVxcdTFCMDNcXHUxQjM0LVxcdTFCM0FcXHUxQjNDXFx1MUI0MlxcdTFCNkItXFx1MUI3M1xcdTFCODBcXHUxQjgxXFx1MUJBMi1cXHUxQkE1XFx1MUJBOFxcdTFCQTlcXHUxQkFCLVxcdTFCQURcXHUxQkU2XFx1MUJFOFxcdTFCRTlcXHUxQkVEXFx1MUJFRi1cXHUxQkYxXFx1MUMyQy1cXHUxQzMzXFx1MUMzNlxcdTFDMzdcXHUxQ0QwLVxcdTFDRDJcXHUxQ0Q0LVxcdTFDRTBcXHUxQ0UyLVxcdTFDRThcXHUxQ0VEXFx1MUNGNFxcdTFDRjhcXHUxQ0Y5XFx1MURDMC1cXHUxREY5XFx1MURGQi1cXHUxREZGXFx1MjAwQ1xcdTIwRDAtXFx1MjBGMFxcdTJDRUYtXFx1MkNGMVxcdTJEN0ZcXHUyREUwLVxcdTJERkZcXHUzMDJBLVxcdTMwMkZcXHUzMDk5XFx1MzA5QVxcdUE2NkYtXFx1QTY3MlxcdUE2NzQtXFx1QTY3RFxcdUE2OUVcXHVBNjlGXFx1QTZGMFxcdUE2RjFcXHVBODAyXFx1QTgwNlxcdUE4MEJcXHVBODI1XFx1QTgyNlxcdUE4MkNcXHVBOEM0XFx1QThDNVxcdUE4RTAtXFx1QThGMVxcdUE4RkZcXHVBOTI2LVxcdUE5MkRcXHVBOTQ3LVxcdUE5NTFcXHVBOTgwLVxcdUE5ODJcXHVBOUIzXFx1QTlCNi1cXHVBOUI5XFx1QTlCQ1xcdUE5QkRcXHVBOUU1XFx1QUEyOS1cXHVBQTJFXFx1QUEzMVxcdUFBMzJcXHVBQTM1XFx1QUEzNlxcdUFBNDNcXHVBQTRDXFx1QUE3Q1xcdUFBQjBcXHVBQUIyLVxcdUFBQjRcXHVBQUI3XFx1QUFCOFxcdUFBQkVcXHVBQUJGXFx1QUFDMVxcdUFBRUNcXHVBQUVEXFx1QUFGNlxcdUFCRTVcXHVBQkU4XFx1QUJFRFxcdUZCMUVcXHVGRTAwLVxcdUZFMEZcXHVGRTIwLVxcdUZFMkZcXHVGRjlFXFx1RkY5Rl18XFx1RDgwMFtcXHVEREZEXFx1REVFMFxcdURGNzYtXFx1REY3QV18XFx1RDgwMltcXHVERTAxLVxcdURFMDNcXHVERTA1XFx1REUwNlxcdURFMEMtXFx1REUwRlxcdURFMzgtXFx1REUzQVxcdURFM0ZcXHVERUU1XFx1REVFNl18XFx1RDgwM1tcXHVERDI0LVxcdUREMjdcXHVERUFCXFx1REVBQ1xcdURGNDYtXFx1REY1MF18XFx1RDgwNFtcXHVEQzAxXFx1REMzOC1cXHVEQzQ2XFx1REM3Ri1cXHVEQzgxXFx1RENCMy1cXHVEQ0I2XFx1RENCOVxcdURDQkFcXHVERDAwLVxcdUREMDJcXHVERDI3LVxcdUREMkJcXHVERDJELVxcdUREMzRcXHVERDczXFx1REQ4MFxcdUREODFcXHVEREI2LVxcdUREQkVcXHVEREM5LVxcdUREQ0NcXHVERENGXFx1REUyRi1cXHVERTMxXFx1REUzNFxcdURFMzZcXHVERTM3XFx1REUzRVxcdURFREZcXHVERUUzLVxcdURFRUFcXHVERjAwXFx1REYwMVxcdURGM0JcXHVERjNDXFx1REYzRVxcdURGNDBcXHVERjU3XFx1REY2Ni1cXHVERjZDXFx1REY3MC1cXHVERjc0XXxcXHVEODA1W1xcdURDMzgtXFx1REMzRlxcdURDNDItXFx1REM0NFxcdURDNDZcXHVEQzVFXFx1RENCMFxcdURDQjMtXFx1RENCOFxcdURDQkFcXHVEQ0JEXFx1RENCRlxcdURDQzBcXHVEQ0MyXFx1RENDM1xcdUREQUZcXHVEREIyLVxcdUREQjVcXHVEREJDXFx1RERCRFxcdUREQkZcXHVEREMwXFx1REREQ1xcdURERERcXHVERTMzLVxcdURFM0FcXHVERTNEXFx1REUzRlxcdURFNDBcXHVERUFCXFx1REVBRFxcdURFQjAtXFx1REVCNVxcdURFQjdcXHVERjFELVxcdURGMUZcXHVERjIyLVxcdURGMjVcXHVERjI3LVxcdURGMkJdfFxcdUQ4MDZbXFx1REMyRi1cXHVEQzM3XFx1REMzOVxcdURDM0FcXHVERDMwXFx1REQzQlxcdUREM0NcXHVERDNFXFx1REQ0M1xcdURERDQtXFx1REREN1xcdUREREFcXHVERERCXFx1RERFMFxcdURFMDEtXFx1REUwQVxcdURFMzMtXFx1REUzOFxcdURFM0ItXFx1REUzRVxcdURFNDdcXHVERTUxLVxcdURFNTZcXHVERTU5LVxcdURFNUJcXHVERThBLVxcdURFOTZcXHVERTk4XFx1REU5OV18XFx1RDgwN1tcXHVEQzMwLVxcdURDMzZcXHVEQzM4LVxcdURDM0RcXHVEQzNGXFx1REM5Mi1cXHVEQ0E3XFx1RENBQS1cXHVEQ0IwXFx1RENCMlxcdURDQjNcXHVEQ0I1XFx1RENCNlxcdUREMzEtXFx1REQzNlxcdUREM0FcXHVERDNDXFx1REQzRFxcdUREM0YtXFx1REQ0NVxcdURENDdcXHVERDkwXFx1REQ5MVxcdUREOTVcXHVERDk3XFx1REVGM1xcdURFRjRdfFxcdUQ4MUFbXFx1REVGMC1cXHVERUY0XFx1REYzMC1cXHVERjM2XXxcXHVEODFCW1xcdURGNEZcXHVERjhGLVxcdURGOTJcXHVERkU0XXxcXHVEODJGW1xcdURDOURcXHVEQzlFXXxcXHVEODM0W1xcdURENjVcXHVERDY3LVxcdURENjlcXHVERDZFLVxcdURENzJcXHVERDdCLVxcdUREODJcXHVERDg1LVxcdUREOEJcXHVEREFBLVxcdUREQURcXHVERTQyLVxcdURFNDRdfFxcdUQ4MzZbXFx1REUwMC1cXHVERTM2XFx1REUzQi1cXHVERTZDXFx1REU3NVxcdURFODRcXHVERTlCLVxcdURFOUZcXHVERUExLVxcdURFQUZdfFxcdUQ4MzhbXFx1REMwMC1cXHVEQzA2XFx1REMwOC1cXHVEQzE4XFx1REMxQi1cXHVEQzIxXFx1REMyM1xcdURDMjRcXHVEQzI2LVxcdURDMkFcXHVERDMwLVxcdUREMzZcXHVERUVDLVxcdURFRUZdfFxcdUQ4M0FbXFx1RENEMC1cXHVEQ0Q2XFx1REQ0NC1cXHVERDRBXXxcXHVEODNDW1xcdURGRkItXFx1REZGRl18XFx1REI0MFtcXHVEQzIwLVxcdURDN0ZcXHVERDAwLVxcdURERUZdKSpcXHUyMDBEJC87XG5cbnZhciBlbmRzV2l0aEVtb2ppWldKID0gZnVuY3Rpb24gZW5kc1dpdGhFbW9qaVpXSihzdHIpIHtcbiAgcmV0dXJuIHN0ci5zZWFyY2goZW5kaW5nRW1vamlaV0opICE9PSAtMTtcbn07XG5cbnZhciBlbmRpbmdSSXMgPSAvKD86XFx1RDgzQ1tcXHVEREU2LVxcdURERkZdKSskL2c7XG5cbnZhciBlbmRzV2l0aE9kZE51bWJlck9mUklzID0gZnVuY3Rpb24gZW5kc1dpdGhPZGROdW1iZXJPZlJJcyhzdHIpIHtcbiAgdmFyIG1hdGNoID0gc3RyLm1hdGNoKGVuZGluZ1JJcyk7XG5cbiAgaWYgKG1hdGNoID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IGVsc2Uge1xuICAgIC8vIEEgUkkgaXMgcmVwcmVzZW50ZWQgYnkgYSBzdXJyb2dhdGUgcGFpci5cbiAgICB2YXIgbnVtUklzID0gbWF0Y2hbMF0ubGVuZ3RoIC8gMjtcbiAgICByZXR1cm4gbnVtUklzICUgMiA9PT0gMTtcbiAgfVxufTtcblxuLyoqXHJcbiAqIFNoYXJlZCB0aGUgZnVuY3Rpb24gd2l0aCBpc0VsZW1lbnRUeXBlIHV0aWxpdHlcclxuICovXG5cbnZhciBpc0VsZW1lbnQgPSBmdW5jdGlvbiBpc0VsZW1lbnQodmFsdWUpIHtcbiAgcmV0dXJuIGlzUGxhaW5PYmplY3QuaXNQbGFpbk9iamVjdCh2YWx1ZSkgJiYgTm9kZS5pc05vZGVMaXN0KHZhbHVlLmNoaWxkcmVuKSAmJiAhRWRpdG9yLmlzRWRpdG9yKHZhbHVlKTtcbn07IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZWRlY2xhcmVcblxuXG52YXIgRWxlbWVudCA9IHtcbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSB2YWx1ZSBpbXBsZW1lbnRzIHRoZSAnQW5jZXN0b3InIGludGVyZmFjZS5cclxuICAgKi9cbiAgaXNBbmNlc3RvcjogZnVuY3Rpb24gaXNBbmNlc3Rvcih2YWx1ZSkge1xuICAgIHJldHVybiBpc1BsYWluT2JqZWN0LmlzUGxhaW5PYmplY3QodmFsdWUpICYmIE5vZGUuaXNOb2RlTGlzdCh2YWx1ZS5jaGlsZHJlbik7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSB2YWx1ZSBpbXBsZW1lbnRzIHRoZSBgRWxlbWVudGAgaW50ZXJmYWNlLlxyXG4gICAqL1xuICBpc0VsZW1lbnQ6IGlzRWxlbWVudCxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhIHZhbHVlIGlzIGFuIGFycmF5IG9mIGBFbGVtZW50YCBvYmplY3RzLlxyXG4gICAqL1xuICBpc0VsZW1lbnRMaXN0OiBmdW5jdGlvbiBpc0VsZW1lbnRMaXN0KHZhbHVlKSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsdWUpICYmIHZhbHVlLmV2ZXJ5KGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgIHJldHVybiBFbGVtZW50LmlzRWxlbWVudCh2YWwpO1xuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgc2V0IG9mIHByb3BzIGlzIGEgcGFydGlhbCBvZiBFbGVtZW50LlxyXG4gICAqL1xuICBpc0VsZW1lbnRQcm9wczogZnVuY3Rpb24gaXNFbGVtZW50UHJvcHMocHJvcHMpIHtcbiAgICByZXR1cm4gcHJvcHMuY2hpbGRyZW4gIT09IHVuZGVmaW5lZDtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhIHZhbHVlIGltcGxlbWVudHMgdGhlIGBFbGVtZW50YCBpbnRlcmZhY2UgYW5kIGhhcyBlbGVtZW50S2V5IHdpdGggc2VsZWN0ZWQgdmFsdWUuXHJcbiAgICogRGVmYXVsdCBpdCBjaGVjayB0byBgdHlwZWAga2V5IHZhbHVlXHJcbiAgICovXG4gIGlzRWxlbWVudFR5cGU6IGZ1bmN0aW9uIGlzRWxlbWVudFR5cGUodmFsdWUsIGVsZW1lbnRWYWwpIHtcbiAgICB2YXIgZWxlbWVudEtleSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogJ3R5cGUnO1xuICAgIHJldHVybiBpc0VsZW1lbnQodmFsdWUpICYmIHZhbHVlW2VsZW1lbnRLZXldID09PSBlbGVtZW50VmFsO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGFuIGVsZW1lbnQgbWF0Y2hlcyBzZXQgb2YgcHJvcGVydGllcy5cclxuICAgKlxyXG4gICAqIE5vdGU6IHRoaXMgY2hlY2tzIGN1c3RvbSBwcm9wZXJ0aWVzLCBhbmQgaXQgZG9lcyBub3QgZW5zdXJlIHRoYXQgYW55XHJcbiAgICogY2hpbGRyZW4gYXJlIGVxdWl2YWxlbnQuXHJcbiAgICovXG4gIG1hdGNoZXM6IGZ1bmN0aW9uIG1hdGNoZXMoZWxlbWVudCwgcHJvcHMpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gcHJvcHMpIHtcbiAgICAgIGlmIChrZXkgPT09ICdjaGlsZHJlbicpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChlbGVtZW50W2tleV0gIT09IHByb3BzW2tleV0pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG59O1xuXG52YXIgX2V4Y2x1ZGVkJDQgPSBbXCJ0ZXh0XCJdLFxuICAgIF9leGNsdWRlZDIkMyA9IFtcInRleHRcIl07XG5cbmZ1bmN0aW9uIG93bktleXMkOChvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgeyBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSk7IH0ga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQkOCh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyBvd25LZXlzJDgoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHsgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTsgfSBlbHNlIHsgb3duS2V5cyQ4KE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciQ1KG8sIGFsbG93QXJyYXlMaWtlKSB7IHZhciBpdCA9IHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdIHx8IG9bXCJAQGl0ZXJhdG9yXCJdOyBpZiAoIWl0KSB7IGlmIChBcnJheS5pc0FycmF5KG8pIHx8IChpdCA9IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSQ1KG8pKSB8fCBhbGxvd0FycmF5TGlrZSAmJiBvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgeyBpZiAoaXQpIG8gPSBpdDsgdmFyIGkgPSAwOyB2YXIgRiA9IGZ1bmN0aW9uIEYoKSB7fTsgcmV0dXJuIHsgczogRiwgbjogZnVuY3Rpb24gbigpIHsgaWYgKGkgPj0gby5sZW5ndGgpIHJldHVybiB7IGRvbmU6IHRydWUgfTsgcmV0dXJuIHsgZG9uZTogZmFsc2UsIHZhbHVlOiBvW2krK10gfTsgfSwgZTogZnVuY3Rpb24gZShfZSkgeyB0aHJvdyBfZTsgfSwgZjogRiB9OyB9IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfSB2YXIgbm9ybWFsQ29tcGxldGlvbiA9IHRydWUsIGRpZEVyciA9IGZhbHNlLCBlcnI7IHJldHVybiB7IHM6IGZ1bmN0aW9uIHMoKSB7IGl0ID0gaXQuY2FsbChvKTsgfSwgbjogZnVuY3Rpb24gbigpIHsgdmFyIHN0ZXAgPSBpdC5uZXh0KCk7IG5vcm1hbENvbXBsZXRpb24gPSBzdGVwLmRvbmU7IHJldHVybiBzdGVwOyB9LCBlOiBmdW5jdGlvbiBlKF9lMikgeyBkaWRFcnIgPSB0cnVlOyBlcnIgPSBfZTI7IH0sIGY6IGZ1bmN0aW9uIGYoKSB7IHRyeSB7IGlmICghbm9ybWFsQ29tcGxldGlvbiAmJiBpdFtcInJldHVyblwiXSAhPSBudWxsKSBpdFtcInJldHVyblwiXSgpOyB9IGZpbmFsbHkgeyBpZiAoZGlkRXJyKSB0aHJvdyBlcnI7IH0gfSB9OyB9XG5cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSQ1KG8sIG1pbkxlbikgeyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkkNShvLCBtaW5MZW4pOyB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5JDUobywgbWluTGVuKTsgfVxuXG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheSQ1KGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfVxudmFyIElTX0VESVRPUl9DQUNIRSA9IG5ldyBXZWFrTWFwKCk7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZWRlY2xhcmVcblxudmFyIEVkaXRvciA9IHtcbiAgLyoqXHJcbiAgICogR2V0IHRoZSBhbmNlc3RvciBhYm92ZSBhIGxvY2F0aW9uIGluIHRoZSBkb2N1bWVudC5cclxuICAgKi9cbiAgYWJvdmU6IGZ1bmN0aW9uIGFib3ZlKGVkaXRvcikge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICB2YXIgX29wdGlvbnMkdm9pZHMgPSBvcHRpb25zLnZvaWRzLFxuICAgICAgICB2b2lkcyA9IF9vcHRpb25zJHZvaWRzID09PSB2b2lkIDAgPyBmYWxzZSA6IF9vcHRpb25zJHZvaWRzLFxuICAgICAgICBfb3B0aW9ucyRtb2RlID0gb3B0aW9ucy5tb2RlLFxuICAgICAgICBtb2RlID0gX29wdGlvbnMkbW9kZSA9PT0gdm9pZCAwID8gJ2xvd2VzdCcgOiBfb3B0aW9ucyRtb2RlLFxuICAgICAgICBfb3B0aW9ucyRhdCA9IG9wdGlvbnMuYXQsXG4gICAgICAgIGF0ID0gX29wdGlvbnMkYXQgPT09IHZvaWQgMCA/IGVkaXRvci5zZWxlY3Rpb24gOiBfb3B0aW9ucyRhdCxcbiAgICAgICAgbWF0Y2ggPSBvcHRpb25zLm1hdGNoO1xuXG4gICAgaWYgKCFhdCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBwYXRoID0gRWRpdG9yLnBhdGgoZWRpdG9yLCBhdCk7XG4gICAgdmFyIHJldmVyc2UgPSBtb2RlID09PSAnbG93ZXN0JztcblxuICAgIHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciQ1KEVkaXRvci5sZXZlbHMoZWRpdG9yLCB7XG4gICAgICBhdDogcGF0aCxcbiAgICAgIHZvaWRzOiB2b2lkcyxcbiAgICAgIG1hdGNoOiBtYXRjaCxcbiAgICAgIHJldmVyc2U6IHJldmVyc2VcbiAgICB9KSksXG4gICAgICAgIF9zdGVwO1xuXG4gICAgdHJ5IHtcbiAgICAgIGZvciAoX2l0ZXJhdG9yLnMoKTsgIShfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmU7KSB7XG4gICAgICAgIHZhciBfc3RlcCR2YWx1ZSA9IF9zbGljZWRUb0FycmF5KF9zdGVwLnZhbHVlLCAyKSxcbiAgICAgICAgICAgIG4gPSBfc3RlcCR2YWx1ZVswXSxcbiAgICAgICAgICAgIHAgPSBfc3RlcCR2YWx1ZVsxXTtcblxuICAgICAgICBpZiAoVGV4dC5pc1RleHQobikpIGNvbnRpbnVlO1xuXG4gICAgICAgIGlmIChSYW5nZS5pc1JhbmdlKGF0KSkge1xuICAgICAgICAgIGlmIChQYXRoLmlzQW5jZXN0b3IocCwgYXQuYW5jaG9yLnBhdGgpICYmIFBhdGguaXNBbmNlc3RvcihwLCBhdC5mb2N1cy5wYXRoKSkge1xuICAgICAgICAgICAgcmV0dXJuIFtuLCBwXTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKCFQYXRoLmVxdWFscyhwYXRoLCBwKSkge1xuICAgICAgICAgICAgcmV0dXJuIFtuLCBwXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIF9pdGVyYXRvci5lKGVycik7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIF9pdGVyYXRvci5mKCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxyXG4gICAqIEFkZCBhIGN1c3RvbSBwcm9wZXJ0eSB0byB0aGUgbGVhZiB0ZXh0IG5vZGVzIGluIHRoZSBjdXJyZW50IHNlbGVjdGlvbi5cclxuICAgKlxyXG4gICAqIElmIHRoZSBzZWxlY3Rpb24gaXMgY3VycmVudGx5IGNvbGxhcHNlZCwgdGhlIG1hcmtzIHdpbGwgYmUgYWRkZWQgdG8gdGhlXHJcbiAgICogYGVkaXRvci5tYXJrc2AgcHJvcGVydHkgaW5zdGVhZCwgYW5kIGFwcGxpZWQgd2hlbiB0ZXh0IGlzIGluc2VydGVkIG5leHQuXHJcbiAgICovXG4gIGFkZE1hcms6IGZ1bmN0aW9uIGFkZE1hcmsoZWRpdG9yLCBrZXksIHZhbHVlKSB7XG4gICAgZWRpdG9yLmFkZE1hcmsoa2V5LCB2YWx1ZSk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogR2V0IHRoZSBwb2ludCBhZnRlciBhIGxvY2F0aW9uLlxyXG4gICAqL1xuICBhZnRlcjogZnVuY3Rpb24gYWZ0ZXIoZWRpdG9yLCBhdCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICB2YXIgYW5jaG9yID0gRWRpdG9yLnBvaW50KGVkaXRvciwgYXQsIHtcbiAgICAgIGVkZ2U6ICdlbmQnXG4gICAgfSk7XG4gICAgdmFyIGZvY3VzID0gRWRpdG9yLmVuZChlZGl0b3IsIFtdKTtcbiAgICB2YXIgcmFuZ2UgPSB7XG4gICAgICBhbmNob3I6IGFuY2hvcixcbiAgICAgIGZvY3VzOiBmb2N1c1xuICAgIH07XG4gICAgdmFyIF9vcHRpb25zJGRpc3RhbmNlID0gb3B0aW9ucy5kaXN0YW5jZSxcbiAgICAgICAgZGlzdGFuY2UgPSBfb3B0aW9ucyRkaXN0YW5jZSA9PT0gdm9pZCAwID8gMSA6IF9vcHRpb25zJGRpc3RhbmNlO1xuICAgIHZhciBkID0gMDtcbiAgICB2YXIgdGFyZ2V0O1xuXG4gICAgdmFyIF9pdGVyYXRvcjIgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciQ1KEVkaXRvci5wb3NpdGlvbnMoZWRpdG9yLCBfb2JqZWN0U3ByZWFkJDgoX29iamVjdFNwcmVhZCQ4KHt9LCBvcHRpb25zKSwge30sIHtcbiAgICAgIGF0OiByYW5nZVxuICAgIH0pKSksXG4gICAgICAgIF9zdGVwMjtcblxuICAgIHRyeSB7XG4gICAgICBmb3IgKF9pdGVyYXRvcjIucygpOyAhKF9zdGVwMiA9IF9pdGVyYXRvcjIubigpKS5kb25lOykge1xuICAgICAgICB2YXIgcCA9IF9zdGVwMi52YWx1ZTtcblxuICAgICAgICBpZiAoZCA+IGRpc3RhbmNlKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZCAhPT0gMCkge1xuICAgICAgICAgIHRhcmdldCA9IHA7XG4gICAgICAgIH1cblxuICAgICAgICBkKys7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBfaXRlcmF0b3IyLmUoZXJyKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgX2l0ZXJhdG9yMi5mKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfSxcblxuICAvKipcclxuICAgKiBHZXQgdGhlIHBvaW50IGJlZm9yZSBhIGxvY2F0aW9uLlxyXG4gICAqL1xuICBiZWZvcmU6IGZ1bmN0aW9uIGJlZm9yZShlZGl0b3IsIGF0KSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIHZhciBhbmNob3IgPSBFZGl0b3Iuc3RhcnQoZWRpdG9yLCBbXSk7XG4gICAgdmFyIGZvY3VzID0gRWRpdG9yLnBvaW50KGVkaXRvciwgYXQsIHtcbiAgICAgIGVkZ2U6ICdzdGFydCdcbiAgICB9KTtcbiAgICB2YXIgcmFuZ2UgPSB7XG4gICAgICBhbmNob3I6IGFuY2hvcixcbiAgICAgIGZvY3VzOiBmb2N1c1xuICAgIH07XG4gICAgdmFyIF9vcHRpb25zJGRpc3RhbmNlMiA9IG9wdGlvbnMuZGlzdGFuY2UsXG4gICAgICAgIGRpc3RhbmNlID0gX29wdGlvbnMkZGlzdGFuY2UyID09PSB2b2lkIDAgPyAxIDogX29wdGlvbnMkZGlzdGFuY2UyO1xuICAgIHZhciBkID0gMDtcbiAgICB2YXIgdGFyZ2V0O1xuXG4gICAgdmFyIF9pdGVyYXRvcjMgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciQ1KEVkaXRvci5wb3NpdGlvbnMoZWRpdG9yLCBfb2JqZWN0U3ByZWFkJDgoX29iamVjdFNwcmVhZCQ4KHt9LCBvcHRpb25zKSwge30sIHtcbiAgICAgIGF0OiByYW5nZSxcbiAgICAgIHJldmVyc2U6IHRydWVcbiAgICB9KSkpLFxuICAgICAgICBfc3RlcDM7XG5cbiAgICB0cnkge1xuICAgICAgZm9yIChfaXRlcmF0b3IzLnMoKTsgIShfc3RlcDMgPSBfaXRlcmF0b3IzLm4oKSkuZG9uZTspIHtcbiAgICAgICAgdmFyIHAgPSBfc3RlcDMudmFsdWU7XG5cbiAgICAgICAgaWYgKGQgPiBkaXN0YW5jZSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGQgIT09IDApIHtcbiAgICAgICAgICB0YXJnZXQgPSBwO1xuICAgICAgICB9XG5cbiAgICAgICAgZCsrO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgX2l0ZXJhdG9yMy5lKGVycik7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIF9pdGVyYXRvcjMuZigpO1xuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXQ7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogRGVsZXRlIGNvbnRlbnQgaW4gdGhlIGVkaXRvciBiYWNrd2FyZCBmcm9tIHRoZSBjdXJyZW50IHNlbGVjdGlvbi5cclxuICAgKi9cbiAgZGVsZXRlQmFja3dhcmQ6IGZ1bmN0aW9uIGRlbGV0ZUJhY2t3YXJkKGVkaXRvcikge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICB2YXIgX29wdGlvbnMkdW5pdCA9IG9wdGlvbnMudW5pdCxcbiAgICAgICAgdW5pdCA9IF9vcHRpb25zJHVuaXQgPT09IHZvaWQgMCA/ICdjaGFyYWN0ZXInIDogX29wdGlvbnMkdW5pdDtcbiAgICBlZGl0b3IuZGVsZXRlQmFja3dhcmQodW5pdCk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogRGVsZXRlIGNvbnRlbnQgaW4gdGhlIGVkaXRvciBmb3J3YXJkIGZyb20gdGhlIGN1cnJlbnQgc2VsZWN0aW9uLlxyXG4gICAqL1xuICBkZWxldGVGb3J3YXJkOiBmdW5jdGlvbiBkZWxldGVGb3J3YXJkKGVkaXRvcikge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICB2YXIgX29wdGlvbnMkdW5pdDIgPSBvcHRpb25zLnVuaXQsXG4gICAgICAgIHVuaXQgPSBfb3B0aW9ucyR1bml0MiA9PT0gdm9pZCAwID8gJ2NoYXJhY3RlcicgOiBfb3B0aW9ucyR1bml0MjtcbiAgICBlZGl0b3IuZGVsZXRlRm9yd2FyZCh1bml0KTtcbiAgfSxcblxuICAvKipcclxuICAgKiBEZWxldGUgdGhlIGNvbnRlbnQgaW4gdGhlIGN1cnJlbnQgc2VsZWN0aW9uLlxyXG4gICAqL1xuICBkZWxldGVGcmFnbWVudDogZnVuY3Rpb24gZGVsZXRlRnJhZ21lbnQoZWRpdG9yKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIHZhciBfb3B0aW9ucyRkaXJlY3Rpb24gPSBvcHRpb25zLmRpcmVjdGlvbixcbiAgICAgICAgZGlyZWN0aW9uID0gX29wdGlvbnMkZGlyZWN0aW9uID09PSB2b2lkIDAgPyAnZm9yd2FyZCcgOiBfb3B0aW9ucyRkaXJlY3Rpb247XG4gICAgZWRpdG9yLmRlbGV0ZUZyYWdtZW50KGRpcmVjdGlvbik7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogR2V0IHRoZSBzdGFydCBhbmQgZW5kIHBvaW50cyBvZiBhIGxvY2F0aW9uLlxyXG4gICAqL1xuICBlZGdlczogZnVuY3Rpb24gZWRnZXMoZWRpdG9yLCBhdCkge1xuICAgIHJldHVybiBbRWRpdG9yLnN0YXJ0KGVkaXRvciwgYXQpLCBFZGl0b3IuZW5kKGVkaXRvciwgYXQpXTtcbiAgfSxcblxuICAvKipcclxuICAgKiBHZXQgdGhlIGVuZCBwb2ludCBvZiBhIGxvY2F0aW9uLlxyXG4gICAqL1xuICBlbmQ6IGZ1bmN0aW9uIGVuZChlZGl0b3IsIGF0KSB7XG4gICAgcmV0dXJuIEVkaXRvci5wb2ludChlZGl0b3IsIGF0LCB7XG4gICAgICBlZGdlOiAnZW5kJ1xuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgZmlyc3Qgbm9kZSBhdCBhIGxvY2F0aW9uLlxyXG4gICAqL1xuICBmaXJzdDogZnVuY3Rpb24gZmlyc3QoZWRpdG9yLCBhdCkge1xuICAgIHZhciBwYXRoID0gRWRpdG9yLnBhdGgoZWRpdG9yLCBhdCwge1xuICAgICAgZWRnZTogJ3N0YXJ0J1xuICAgIH0pO1xuICAgIHJldHVybiBFZGl0b3Iubm9kZShlZGl0b3IsIHBhdGgpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgZnJhZ21lbnQgYXQgYSBsb2NhdGlvbi5cclxuICAgKi9cbiAgZnJhZ21lbnQ6IGZ1bmN0aW9uIGZyYWdtZW50KGVkaXRvciwgYXQpIHtcbiAgICB2YXIgcmFuZ2UgPSBFZGl0b3IucmFuZ2UoZWRpdG9yLCBhdCk7XG4gICAgdmFyIGZyYWdtZW50ID0gTm9kZS5mcmFnbWVudChlZGl0b3IsIHJhbmdlKTtcbiAgICByZXR1cm4gZnJhZ21lbnQ7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSBub2RlIGhhcyBibG9jayBjaGlsZHJlbi5cclxuICAgKi9cbiAgaGFzQmxvY2tzOiBmdW5jdGlvbiBoYXNCbG9ja3MoZWRpdG9yLCBlbGVtZW50KSB7XG4gICAgcmV0dXJuIGVsZW1lbnQuY2hpbGRyZW4uc29tZShmdW5jdGlvbiAobikge1xuICAgICAgcmV0dXJuIEVsZW1lbnQuaXNFbGVtZW50KG4pICYmIEVkaXRvci5pc0Jsb2NrKGVkaXRvciwgbik7XG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSBub2RlIGhhcyBpbmxpbmUgYW5kIHRleHQgY2hpbGRyZW4uXHJcbiAgICovXG4gIGhhc0lubGluZXM6IGZ1bmN0aW9uIGhhc0lubGluZXMoZWRpdG9yLCBlbGVtZW50KSB7XG4gICAgcmV0dXJuIGVsZW1lbnQuY2hpbGRyZW4uc29tZShmdW5jdGlvbiAobikge1xuICAgICAgcmV0dXJuIFRleHQuaXNUZXh0KG4pIHx8IEVkaXRvci5pc0lubGluZShlZGl0b3IsIG4pO1xuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgbm9kZSBoYXMgdGV4dCBjaGlsZHJlbi5cclxuICAgKi9cbiAgaGFzVGV4dHM6IGZ1bmN0aW9uIGhhc1RleHRzKGVkaXRvciwgZWxlbWVudCkge1xuICAgIHJldHVybiBlbGVtZW50LmNoaWxkcmVuLmV2ZXJ5KGZ1bmN0aW9uIChuKSB7XG4gICAgICByZXR1cm4gVGV4dC5pc1RleHQobik7XG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogSW5zZXJ0IGEgYmxvY2sgYnJlYWsgYXQgdGhlIGN1cnJlbnQgc2VsZWN0aW9uLlxyXG4gICAqXHJcbiAgICogSWYgdGhlIHNlbGVjdGlvbiBpcyBjdXJyZW50bHkgZXhwYW5kZWQsIGl0IHdpbGwgYmUgZGVsZXRlZCBmaXJzdC5cclxuICAgKi9cbiAgaW5zZXJ0QnJlYWs6IGZ1bmN0aW9uIGluc2VydEJyZWFrKGVkaXRvcikge1xuICAgIGVkaXRvci5pbnNlcnRCcmVhaygpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEluc2VydCBhIHNvZnQgYnJlYWsgYXQgdGhlIGN1cnJlbnQgc2VsZWN0aW9uLlxyXG4gICAqXHJcbiAgICogSWYgdGhlIHNlbGVjdGlvbiBpcyBjdXJyZW50bHkgZXhwYW5kZWQsIGl0IHdpbGwgYmUgZGVsZXRlZCBmaXJzdC5cclxuICAgKi9cbiAgaW5zZXJ0U29mdEJyZWFrOiBmdW5jdGlvbiBpbnNlcnRTb2Z0QnJlYWsoZWRpdG9yKSB7XG4gICAgZWRpdG9yLmluc2VydFNvZnRCcmVhaygpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEluc2VydCBhIGZyYWdtZW50IGF0IHRoZSBjdXJyZW50IHNlbGVjdGlvbi5cclxuICAgKlxyXG4gICAqIElmIHRoZSBzZWxlY3Rpb24gaXMgY3VycmVudGx5IGV4cGFuZGVkLCBpdCB3aWxsIGJlIGRlbGV0ZWQgZmlyc3QuXHJcbiAgICovXG4gIGluc2VydEZyYWdtZW50OiBmdW5jdGlvbiBpbnNlcnRGcmFnbWVudChlZGl0b3IsIGZyYWdtZW50KSB7XG4gICAgZWRpdG9yLmluc2VydEZyYWdtZW50KGZyYWdtZW50KTtcbiAgfSxcblxuICAvKipcclxuICAgKiBJbnNlcnQgYSBub2RlIGF0IHRoZSBjdXJyZW50IHNlbGVjdGlvbi5cclxuICAgKlxyXG4gICAqIElmIHRoZSBzZWxlY3Rpb24gaXMgY3VycmVudGx5IGV4cGFuZGVkLCBpdCB3aWxsIGJlIGRlbGV0ZWQgZmlyc3QuXHJcbiAgICovXG4gIGluc2VydE5vZGU6IGZ1bmN0aW9uIGluc2VydE5vZGUoZWRpdG9yLCBub2RlKSB7XG4gICAgZWRpdG9yLmluc2VydE5vZGUobm9kZSk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogSW5zZXJ0IHRleHQgYXQgdGhlIGN1cnJlbnQgc2VsZWN0aW9uLlxyXG4gICAqXHJcbiAgICogSWYgdGhlIHNlbGVjdGlvbiBpcyBjdXJyZW50bHkgZXhwYW5kZWQsIGl0IHdpbGwgYmUgZGVsZXRlZCBmaXJzdC5cclxuICAgKi9cbiAgaW5zZXJ0VGV4dDogZnVuY3Rpb24gaW5zZXJ0VGV4dChlZGl0b3IsIHRleHQpIHtcbiAgICBlZGl0b3IuaW5zZXJ0VGV4dCh0ZXh0KTtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhIHZhbHVlIGlzIGEgYmxvY2sgYEVsZW1lbnRgIG9iamVjdC5cclxuICAgKi9cbiAgaXNCbG9jazogZnVuY3Rpb24gaXNCbG9jayhlZGl0b3IsIHZhbHVlKSB7XG4gICAgcmV0dXJuICFlZGl0b3IuaXNJbmxpbmUodmFsdWUpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgdmFsdWUgaXMgYW4gYEVkaXRvcmAgb2JqZWN0LlxyXG4gICAqL1xuICBpc0VkaXRvcjogZnVuY3Rpb24gaXNFZGl0b3IodmFsdWUpIHtcbiAgICB2YXIgY2FjaGVkSXNFZGl0b3IgPSBJU19FRElUT1JfQ0FDSEUuZ2V0KHZhbHVlKTtcblxuICAgIGlmIChjYWNoZWRJc0VkaXRvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gY2FjaGVkSXNFZGl0b3I7XG4gICAgfVxuXG4gICAgaWYgKCFpc1BsYWluT2JqZWN0LmlzUGxhaW5PYmplY3QodmFsdWUpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIGlzRWRpdG9yID0gdHlwZW9mIHZhbHVlLmFkZE1hcmsgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlLmFwcGx5ID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB2YWx1ZS5kZWxldGVCYWNrd2FyZCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdmFsdWUuZGVsZXRlRm9yd2FyZCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdmFsdWUuZGVsZXRlRnJhZ21lbnQgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlLmluc2VydEJyZWFrID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB2YWx1ZS5pbnNlcnRTb2Z0QnJlYWsgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlLmluc2VydEZyYWdtZW50ID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB2YWx1ZS5pbnNlcnROb2RlID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB2YWx1ZS5pbnNlcnRUZXh0ID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB2YWx1ZS5pc0lubGluZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdmFsdWUuaXNWb2lkID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB2YWx1ZS5ub3JtYWxpemVOb2RlID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB2YWx1ZS5vbkNoYW5nZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdmFsdWUucmVtb3ZlTWFyayA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdmFsdWUuZ2V0RGlydHlQYXRocyA9PT0gJ2Z1bmN0aW9uJyAmJiAodmFsdWUubWFya3MgPT09IG51bGwgfHwgaXNQbGFpbk9iamVjdC5pc1BsYWluT2JqZWN0KHZhbHVlLm1hcmtzKSkgJiYgKHZhbHVlLnNlbGVjdGlvbiA9PT0gbnVsbCB8fCBSYW5nZS5pc1JhbmdlKHZhbHVlLnNlbGVjdGlvbikpICYmIE5vZGUuaXNOb2RlTGlzdCh2YWx1ZS5jaGlsZHJlbikgJiYgT3BlcmF0aW9uLmlzT3BlcmF0aW9uTGlzdCh2YWx1ZS5vcGVyYXRpb25zKTtcbiAgICBJU19FRElUT1JfQ0FDSEUuc2V0KHZhbHVlLCBpc0VkaXRvcik7XG4gICAgcmV0dXJuIGlzRWRpdG9yO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgcG9pbnQgaXMgdGhlIGVuZCBwb2ludCBvZiBhIGxvY2F0aW9uLlxyXG4gICAqL1xuICBpc0VuZDogZnVuY3Rpb24gaXNFbmQoZWRpdG9yLCBwb2ludCwgYXQpIHtcbiAgICB2YXIgZW5kID0gRWRpdG9yLmVuZChlZGl0b3IsIGF0KTtcbiAgICByZXR1cm4gUG9pbnQuZXF1YWxzKHBvaW50LCBlbmQpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgcG9pbnQgaXMgYW4gZWRnZSBvZiBhIGxvY2F0aW9uLlxyXG4gICAqL1xuICBpc0VkZ2U6IGZ1bmN0aW9uIGlzRWRnZShlZGl0b3IsIHBvaW50LCBhdCkge1xuICAgIHJldHVybiBFZGl0b3IuaXNTdGFydChlZGl0b3IsIHBvaW50LCBhdCkgfHwgRWRpdG9yLmlzRW5kKGVkaXRvciwgcG9pbnQsIGF0KTtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhbiBlbGVtZW50IGlzIGVtcHR5LCBhY2NvdW50aW5nIGZvciB2b2lkIG5vZGVzLlxyXG4gICAqL1xuICBpc0VtcHR5OiBmdW5jdGlvbiBpc0VtcHR5KGVkaXRvciwgZWxlbWVudCkge1xuICAgIHZhciBjaGlsZHJlbiA9IGVsZW1lbnQuY2hpbGRyZW47XG5cbiAgICB2YXIgX2NoaWxkcmVuID0gX3NsaWNlZFRvQXJyYXkoY2hpbGRyZW4sIDEpLFxuICAgICAgICBmaXJzdCA9IF9jaGlsZHJlblswXTtcblxuICAgIHJldHVybiBjaGlsZHJlbi5sZW5ndGggPT09IDAgfHwgY2hpbGRyZW4ubGVuZ3RoID09PSAxICYmIFRleHQuaXNUZXh0KGZpcnN0KSAmJiBmaXJzdC50ZXh0ID09PSAnJyAmJiAhZWRpdG9yLmlzVm9pZChlbGVtZW50KTtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhIHZhbHVlIGlzIGFuIGlubGluZSBgRWxlbWVudGAgb2JqZWN0LlxyXG4gICAqL1xuICBpc0lubGluZTogZnVuY3Rpb24gaXNJbmxpbmUoZWRpdG9yLCB2YWx1ZSkge1xuICAgIHJldHVybiBlZGl0b3IuaXNJbmxpbmUodmFsdWUpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIHRoZSBlZGl0b3IgaXMgY3VycmVudGx5IG5vcm1hbGl6aW5nIGFmdGVyIGVhY2ggb3BlcmF0aW9uLlxyXG4gICAqL1xuICBpc05vcm1hbGl6aW5nOiBmdW5jdGlvbiBpc05vcm1hbGl6aW5nKGVkaXRvcikge1xuICAgIHZhciBpc05vcm1hbGl6aW5nID0gTk9STUFMSVpJTkcuZ2V0KGVkaXRvcik7XG4gICAgcmV0dXJuIGlzTm9ybWFsaXppbmcgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBpc05vcm1hbGl6aW5nO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgcG9pbnQgaXMgdGhlIHN0YXJ0IHBvaW50IG9mIGEgbG9jYXRpb24uXHJcbiAgICovXG4gIGlzU3RhcnQ6IGZ1bmN0aW9uIGlzU3RhcnQoZWRpdG9yLCBwb2ludCwgYXQpIHtcbiAgICAvLyBQRVJGOiBJZiB0aGUgb2Zmc2V0IGlzbid0IGAwYCB3ZSBrbm93IGl0J3Mgbm90IHRoZSBzdGFydC5cbiAgICBpZiAocG9pbnQub2Zmc2V0ICE9PSAwKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIHN0YXJ0ID0gRWRpdG9yLnN0YXJ0KGVkaXRvciwgYXQpO1xuICAgIHJldHVybiBQb2ludC5lcXVhbHMocG9pbnQsIHN0YXJ0KTtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhIHZhbHVlIGlzIGEgdm9pZCBgRWxlbWVudGAgb2JqZWN0LlxyXG4gICAqL1xuICBpc1ZvaWQ6IGZ1bmN0aW9uIGlzVm9pZChlZGl0b3IsIHZhbHVlKSB7XG4gICAgcmV0dXJuIGVkaXRvci5pc1ZvaWQodmFsdWUpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgbGFzdCBub2RlIGF0IGEgbG9jYXRpb24uXHJcbiAgICovXG4gIGxhc3Q6IGZ1bmN0aW9uIGxhc3QoZWRpdG9yLCBhdCkge1xuICAgIHZhciBwYXRoID0gRWRpdG9yLnBhdGgoZWRpdG9yLCBhdCwge1xuICAgICAgZWRnZTogJ2VuZCdcbiAgICB9KTtcbiAgICByZXR1cm4gRWRpdG9yLm5vZGUoZWRpdG9yLCBwYXRoKTtcbiAgfSxcblxuICAvKipcclxuICAgKiBHZXQgdGhlIGxlYWYgdGV4dCBub2RlIGF0IGEgbG9jYXRpb24uXHJcbiAgICovXG4gIGxlYWY6IGZ1bmN0aW9uIGxlYWYoZWRpdG9yLCBhdCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICB2YXIgcGF0aCA9IEVkaXRvci5wYXRoKGVkaXRvciwgYXQsIG9wdGlvbnMpO1xuICAgIHZhciBub2RlID0gTm9kZS5sZWFmKGVkaXRvciwgcGF0aCk7XG4gICAgcmV0dXJuIFtub2RlLCBwYXRoXTtcbiAgfSxcblxuICAvKipcclxuICAgKiBJdGVyYXRlIHRocm91Z2ggYWxsIG9mIHRoZSBsZXZlbHMgYXQgYSBsb2NhdGlvbi5cclxuICAgKi9cbiAgbGV2ZWxzOiBmdW5jdGlvbiogbGV2ZWxzKGVkaXRvcikge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICB2YXIgX29wdGlvbnMkYXQyID0gb3B0aW9ucy5hdCxcbiAgICAgICAgYXQgPSBfb3B0aW9ucyRhdDIgPT09IHZvaWQgMCA/IGVkaXRvci5zZWxlY3Rpb24gOiBfb3B0aW9ucyRhdDIsXG4gICAgICAgIF9vcHRpb25zJHJldmVyc2UgPSBvcHRpb25zLnJldmVyc2UsXG4gICAgICAgIHJldmVyc2UgPSBfb3B0aW9ucyRyZXZlcnNlID09PSB2b2lkIDAgPyBmYWxzZSA6IF9vcHRpb25zJHJldmVyc2UsXG4gICAgICAgIF9vcHRpb25zJHZvaWRzMiA9IG9wdGlvbnMudm9pZHMsXG4gICAgICAgIHZvaWRzID0gX29wdGlvbnMkdm9pZHMyID09PSB2b2lkIDAgPyBmYWxzZSA6IF9vcHRpb25zJHZvaWRzMjtcbiAgICB2YXIgbWF0Y2ggPSBvcHRpb25zLm1hdGNoO1xuXG4gICAgaWYgKG1hdGNoID09IG51bGwpIHtcbiAgICAgIG1hdGNoID0gZnVuY3Rpb24gbWF0Y2goKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAoIWF0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGxldmVscyA9IFtdO1xuICAgIHZhciBwYXRoID0gRWRpdG9yLnBhdGgoZWRpdG9yLCBhdCk7XG5cbiAgICB2YXIgX2l0ZXJhdG9yNCA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDUoTm9kZS5sZXZlbHMoZWRpdG9yLCBwYXRoKSksXG4gICAgICAgIF9zdGVwNDtcblxuICAgIHRyeSB7XG4gICAgICBmb3IgKF9pdGVyYXRvcjQucygpOyAhKF9zdGVwNCA9IF9pdGVyYXRvcjQubigpKS5kb25lOykge1xuICAgICAgICB2YXIgX3N0ZXA0JHZhbHVlID0gX3NsaWNlZFRvQXJyYXkoX3N0ZXA0LnZhbHVlLCAyKSxcbiAgICAgICAgICAgIG4gPSBfc3RlcDQkdmFsdWVbMF0sXG4gICAgICAgICAgICBwID0gX3N0ZXA0JHZhbHVlWzFdO1xuXG4gICAgICAgIGlmICghbWF0Y2gobiwgcCkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldmVscy5wdXNoKFtuLCBwXSk7XG5cbiAgICAgICAgaWYgKCF2b2lkcyAmJiBFbGVtZW50LmlzRWxlbWVudChuKSAmJiBFZGl0b3IuaXNWb2lkKGVkaXRvciwgbikpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgX2l0ZXJhdG9yNC5lKGVycik7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIF9pdGVyYXRvcjQuZigpO1xuICAgIH1cblxuICAgIGlmIChyZXZlcnNlKSB7XG4gICAgICBsZXZlbHMucmV2ZXJzZSgpO1xuICAgIH1cblxuICAgIHlpZWxkKiBsZXZlbHM7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogR2V0IHRoZSBtYXJrcyB0aGF0IHdvdWxkIGJlIGFkZGVkIHRvIHRleHQgYXQgdGhlIGN1cnJlbnQgc2VsZWN0aW9uLlxyXG4gICAqL1xuICBtYXJrczogZnVuY3Rpb24gbWFya3MoZWRpdG9yKSB7XG4gICAgdmFyIG1hcmtzID0gZWRpdG9yLm1hcmtzLFxuICAgICAgICBzZWxlY3Rpb24gPSBlZGl0b3Iuc2VsZWN0aW9uO1xuXG4gICAgaWYgKCFzZWxlY3Rpb24pIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGlmIChtYXJrcykge1xuICAgICAgcmV0dXJuIG1hcmtzO1xuICAgIH1cblxuICAgIGlmIChSYW5nZS5pc0V4cGFuZGVkKHNlbGVjdGlvbikpIHtcbiAgICAgIHZhciBfRWRpdG9yJG5vZGVzID0gRWRpdG9yLm5vZGVzKGVkaXRvciwge1xuICAgICAgICBtYXRjaDogVGV4dC5pc1RleHRcbiAgICAgIH0pLFxuICAgICAgICAgIF9FZGl0b3Ikbm9kZXMyID0gX3NsaWNlZFRvQXJyYXkoX0VkaXRvciRub2RlcywgMSksXG4gICAgICAgICAgbWF0Y2ggPSBfRWRpdG9yJG5vZGVzMlswXTtcblxuICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgIHZhciBfbWF0Y2ggPSBfc2xpY2VkVG9BcnJheShtYXRjaCwgMSksXG4gICAgICAgICAgICBfbm9kZSA9IF9tYXRjaFswXTtcblxuICAgICAgICBfbm9kZS50ZXh0O1xuICAgICAgICAgICAgdmFyIF9yZXN0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9ub2RlLCBfZXhjbHVkZWQkNCk7XG5cbiAgICAgICAgcmV0dXJuIF9yZXN0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBhbmNob3IgPSBzZWxlY3Rpb24uYW5jaG9yO1xuICAgIHZhciBwYXRoID0gYW5jaG9yLnBhdGg7XG5cbiAgICB2YXIgX0VkaXRvciRsZWFmID0gRWRpdG9yLmxlYWYoZWRpdG9yLCBwYXRoKSxcbiAgICAgICAgX0VkaXRvciRsZWFmMiA9IF9zbGljZWRUb0FycmF5KF9FZGl0b3IkbGVhZiwgMSksXG4gICAgICAgIG5vZGUgPSBfRWRpdG9yJGxlYWYyWzBdO1xuXG4gICAgaWYgKGFuY2hvci5vZmZzZXQgPT09IDApIHtcbiAgICAgIHZhciBwcmV2ID0gRWRpdG9yLnByZXZpb3VzKGVkaXRvciwge1xuICAgICAgICBhdDogcGF0aCxcbiAgICAgICAgbWF0Y2g6IFRleHQuaXNUZXh0XG4gICAgICB9KTtcbiAgICAgIHZhciBtYXJrZWRWb2lkID0gRWRpdG9yLmFib3ZlKGVkaXRvciwge1xuICAgICAgICBtYXRjaDogZnVuY3Rpb24gbWF0Y2gobikge1xuICAgICAgICAgIHJldHVybiBFbGVtZW50LmlzRWxlbWVudChuKSAmJiBFZGl0b3IuaXNWb2lkKGVkaXRvciwgbikgJiYgZWRpdG9yLm1hcmthYmxlVm9pZChuKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGlmICghbWFya2VkVm9pZCkge1xuICAgICAgICB2YXIgYmxvY2sgPSBFZGl0b3IuYWJvdmUoZWRpdG9yLCB7XG4gICAgICAgICAgbWF0Y2g6IGZ1bmN0aW9uIG1hdGNoKG4pIHtcbiAgICAgICAgICAgIHJldHVybiBFbGVtZW50LmlzRWxlbWVudChuKSAmJiBFZGl0b3IuaXNCbG9jayhlZGl0b3IsIG4pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHByZXYgJiYgYmxvY2spIHtcbiAgICAgICAgICB2YXIgX3ByZXYgPSBfc2xpY2VkVG9BcnJheShwcmV2LCAyKSxcbiAgICAgICAgICAgICAgcHJldk5vZGUgPSBfcHJldlswXSxcbiAgICAgICAgICAgICAgcHJldlBhdGggPSBfcHJldlsxXTtcblxuICAgICAgICAgIHZhciBfYmxvY2sgPSBfc2xpY2VkVG9BcnJheShibG9jaywgMiksXG4gICAgICAgICAgICAgIGJsb2NrUGF0aCA9IF9ibG9ja1sxXTtcblxuICAgICAgICAgIGlmIChQYXRoLmlzQW5jZXN0b3IoYmxvY2tQYXRoLCBwcmV2UGF0aCkpIHtcbiAgICAgICAgICAgIG5vZGUgPSBwcmV2Tm9kZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgX25vZGUyID0gbm9kZTtcbiAgICAgICAgX25vZGUyLnRleHQ7XG4gICAgICAgIHZhciByZXN0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9ub2RlMiwgX2V4Y2x1ZGVkMiQzKTtcblxuICAgIHJldHVybiByZXN0O1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgbWF0Y2hpbmcgbm9kZSBpbiB0aGUgYnJhbmNoIG9mIHRoZSBkb2N1bWVudCBhZnRlciBhIGxvY2F0aW9uLlxyXG4gICAqL1xuICBuZXh0OiBmdW5jdGlvbiBuZXh0KGVkaXRvcikge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICB2YXIgX29wdGlvbnMkbW9kZTIgPSBvcHRpb25zLm1vZGUsXG4gICAgICAgIG1vZGUgPSBfb3B0aW9ucyRtb2RlMiA9PT0gdm9pZCAwID8gJ2xvd2VzdCcgOiBfb3B0aW9ucyRtb2RlMixcbiAgICAgICAgX29wdGlvbnMkdm9pZHMzID0gb3B0aW9ucy52b2lkcyxcbiAgICAgICAgdm9pZHMgPSBfb3B0aW9ucyR2b2lkczMgPT09IHZvaWQgMCA/IGZhbHNlIDogX29wdGlvbnMkdm9pZHMzO1xuICAgIHZhciBtYXRjaCA9IG9wdGlvbnMubWF0Y2gsXG4gICAgICAgIF9vcHRpb25zJGF0MyA9IG9wdGlvbnMuYXQsXG4gICAgICAgIGF0ID0gX29wdGlvbnMkYXQzID09PSB2b2lkIDAgPyBlZGl0b3Iuc2VsZWN0aW9uIDogX29wdGlvbnMkYXQzO1xuXG4gICAgaWYgKCFhdCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBwb2ludEFmdGVyTG9jYXRpb24gPSBFZGl0b3IuYWZ0ZXIoZWRpdG9yLCBhdCwge1xuICAgICAgdm9pZHM6IHZvaWRzXG4gICAgfSk7XG4gICAgaWYgKCFwb2ludEFmdGVyTG9jYXRpb24pIHJldHVybjtcblxuICAgIHZhciBfRWRpdG9yJGxhc3QgPSBFZGl0b3IubGFzdChlZGl0b3IsIFtdKSxcbiAgICAgICAgX0VkaXRvciRsYXN0MiA9IF9zbGljZWRUb0FycmF5KF9FZGl0b3IkbGFzdCwgMiksXG4gICAgICAgIHRvID0gX0VkaXRvciRsYXN0MlsxXTtcblxuICAgIHZhciBzcGFuID0gW3BvaW50QWZ0ZXJMb2NhdGlvbi5wYXRoLCB0b107XG5cbiAgICBpZiAoUGF0aC5pc1BhdGgoYXQpICYmIGF0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGdldCB0aGUgbmV4dCBub2RlIGZyb20gdGhlIHJvb3Qgbm9kZSFcIik7XG4gICAgfVxuXG4gICAgaWYgKG1hdGNoID09IG51bGwpIHtcbiAgICAgIGlmIChQYXRoLmlzUGF0aChhdCkpIHtcbiAgICAgICAgdmFyIF9FZGl0b3IkcGFyZW50ID0gRWRpdG9yLnBhcmVudChlZGl0b3IsIGF0KSxcbiAgICAgICAgICAgIF9FZGl0b3IkcGFyZW50MiA9IF9zbGljZWRUb0FycmF5KF9FZGl0b3IkcGFyZW50LCAxKSxcbiAgICAgICAgICAgIHBhcmVudCA9IF9FZGl0b3IkcGFyZW50MlswXTtcblxuICAgICAgICBtYXRjaCA9IGZ1bmN0aW9uIG1hdGNoKG4pIHtcbiAgICAgICAgICByZXR1cm4gcGFyZW50LmNoaWxkcmVuLmluY2x1ZGVzKG4pO1xuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWF0Y2ggPSBmdW5jdGlvbiBtYXRjaCgpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgX0VkaXRvciRub2RlczMgPSBFZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgICBhdDogc3BhbixcbiAgICAgIG1hdGNoOiBtYXRjaCxcbiAgICAgIG1vZGU6IG1vZGUsXG4gICAgICB2b2lkczogdm9pZHNcbiAgICB9KSxcbiAgICAgICAgX0VkaXRvciRub2RlczQgPSBfc2xpY2VkVG9BcnJheShfRWRpdG9yJG5vZGVzMywgMSksXG4gICAgICAgIG5leHQgPSBfRWRpdG9yJG5vZGVzNFswXTtcblxuICAgIHJldHVybiBuZXh0O1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgbm9kZSBhdCBhIGxvY2F0aW9uLlxyXG4gICAqL1xuICBub2RlOiBmdW5jdGlvbiBub2RlKGVkaXRvciwgYXQpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgdmFyIHBhdGggPSBFZGl0b3IucGF0aChlZGl0b3IsIGF0LCBvcHRpb25zKTtcbiAgICB2YXIgbm9kZSA9IE5vZGUuZ2V0KGVkaXRvciwgcGF0aCk7XG4gICAgcmV0dXJuIFtub2RlLCBwYXRoXTtcbiAgfSxcblxuICAvKipcclxuICAgKiBJdGVyYXRlIHRocm91Z2ggYWxsIG9mIHRoZSBub2RlcyBpbiB0aGUgRWRpdG9yLlxyXG4gICAqL1xuICBub2RlczogZnVuY3Rpb24qIG5vZGVzKGVkaXRvcikge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICB2YXIgX29wdGlvbnMkYXQ0ID0gb3B0aW9ucy5hdCxcbiAgICAgICAgYXQgPSBfb3B0aW9ucyRhdDQgPT09IHZvaWQgMCA/IGVkaXRvci5zZWxlY3Rpb24gOiBfb3B0aW9ucyRhdDQsXG4gICAgICAgIF9vcHRpb25zJG1vZGUzID0gb3B0aW9ucy5tb2RlLFxuICAgICAgICBtb2RlID0gX29wdGlvbnMkbW9kZTMgPT09IHZvaWQgMCA/ICdhbGwnIDogX29wdGlvbnMkbW9kZTMsXG4gICAgICAgIF9vcHRpb25zJHVuaXZlcnNhbCA9IG9wdGlvbnMudW5pdmVyc2FsLFxuICAgICAgICB1bml2ZXJzYWwgPSBfb3B0aW9ucyR1bml2ZXJzYWwgPT09IHZvaWQgMCA/IGZhbHNlIDogX29wdGlvbnMkdW5pdmVyc2FsLFxuICAgICAgICBfb3B0aW9ucyRyZXZlcnNlMiA9IG9wdGlvbnMucmV2ZXJzZSxcbiAgICAgICAgcmV2ZXJzZSA9IF9vcHRpb25zJHJldmVyc2UyID09PSB2b2lkIDAgPyBmYWxzZSA6IF9vcHRpb25zJHJldmVyc2UyLFxuICAgICAgICBfb3B0aW9ucyR2b2lkczQgPSBvcHRpb25zLnZvaWRzLFxuICAgICAgICB2b2lkcyA9IF9vcHRpb25zJHZvaWRzNCA9PT0gdm9pZCAwID8gZmFsc2UgOiBfb3B0aW9ucyR2b2lkczQ7XG4gICAgdmFyIG1hdGNoID0gb3B0aW9ucy5tYXRjaDtcblxuICAgIGlmICghbWF0Y2gpIHtcbiAgICAgIG1hdGNoID0gZnVuY3Rpb24gbWF0Y2goKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAoIWF0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGZyb207XG4gICAgdmFyIHRvO1xuXG4gICAgaWYgKFNwYW4uaXNTcGFuKGF0KSkge1xuICAgICAgZnJvbSA9IGF0WzBdO1xuICAgICAgdG8gPSBhdFsxXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGZpcnN0ID0gRWRpdG9yLnBhdGgoZWRpdG9yLCBhdCwge1xuICAgICAgICBlZGdlOiAnc3RhcnQnXG4gICAgICB9KTtcbiAgICAgIHZhciBsYXN0ID0gRWRpdG9yLnBhdGgoZWRpdG9yLCBhdCwge1xuICAgICAgICBlZGdlOiAnZW5kJ1xuICAgICAgfSk7XG4gICAgICBmcm9tID0gcmV2ZXJzZSA/IGxhc3QgOiBmaXJzdDtcbiAgICAgIHRvID0gcmV2ZXJzZSA/IGZpcnN0IDogbGFzdDtcbiAgICB9XG5cbiAgICB2YXIgbm9kZUVudHJpZXMgPSBOb2RlLm5vZGVzKGVkaXRvciwge1xuICAgICAgcmV2ZXJzZTogcmV2ZXJzZSxcbiAgICAgIGZyb206IGZyb20sXG4gICAgICB0bzogdG8sXG4gICAgICBwYXNzOiBmdW5jdGlvbiBwYXNzKF9yZWYpIHtcbiAgICAgICAgdmFyIF9yZWYyID0gX3NsaWNlZFRvQXJyYXkoX3JlZiwgMSksXG4gICAgICAgICAgICBuID0gX3JlZjJbMF07XG5cbiAgICAgICAgcmV0dXJuIHZvaWRzID8gZmFsc2UgOiBFbGVtZW50LmlzRWxlbWVudChuKSAmJiBFZGl0b3IuaXNWb2lkKGVkaXRvciwgbik7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdmFyIG1hdGNoZXMgPSBbXTtcbiAgICB2YXIgaGl0O1xuXG4gICAgdmFyIF9pdGVyYXRvcjUgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciQ1KG5vZGVFbnRyaWVzKSxcbiAgICAgICAgX3N0ZXA1O1xuXG4gICAgdHJ5IHtcbiAgICAgIGZvciAoX2l0ZXJhdG9yNS5zKCk7ICEoX3N0ZXA1ID0gX2l0ZXJhdG9yNS5uKCkpLmRvbmU7KSB7XG4gICAgICAgIHZhciBfc3RlcDUkdmFsdWUgPSBfc2xpY2VkVG9BcnJheShfc3RlcDUudmFsdWUsIDIpLFxuICAgICAgICAgICAgbm9kZSA9IF9zdGVwNSR2YWx1ZVswXSxcbiAgICAgICAgICAgIHBhdGggPSBfc3RlcDUkdmFsdWVbMV07XG5cbiAgICAgICAgdmFyIGlzTG93ZXIgPSBoaXQgJiYgUGF0aC5jb21wYXJlKHBhdGgsIGhpdFsxXSkgPT09IDA7IC8vIEluIGhpZ2hlc3QgbW9kZSBhbnkgbm9kZSBsb3dlciB0aGFuIHRoZSBsYXN0IGhpdCBpcyBub3QgYSBtYXRjaC5cblxuICAgICAgICBpZiAobW9kZSA9PT0gJ2hpZ2hlc3QnICYmIGlzTG93ZXIpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghbWF0Y2gobm9kZSwgcGF0aCkpIHtcbiAgICAgICAgICAvLyBJZiB3ZSd2ZSBhcnJpdmVkIGF0IGEgbGVhZiB0ZXh0IG5vZGUgdGhhdCBpcyBub3QgbG93ZXIgdGhhbiB0aGUgbGFzdFxuICAgICAgICAgIC8vIGhpdCwgdGhlbiB3ZSd2ZSBmb3VuZCBhIGJyYW5jaCB0aGF0IGRvZXNuJ3QgaW5jbHVkZSBhIG1hdGNoLCB3aGljaFxuICAgICAgICAgIC8vIG1lYW5zIHRoZSBtYXRjaCBpcyBub3QgdW5pdmVyc2FsLlxuICAgICAgICAgIGlmICh1bml2ZXJzYWwgJiYgIWlzTG93ZXIgJiYgVGV4dC5pc1RleHQobm9kZSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIElmIHRoZXJlJ3MgYSBtYXRjaCBhbmQgaXQncyBsb3dlciB0aGFuIHRoZSBsYXN0LCB1cGRhdGUgdGhlIGhpdC5cblxuXG4gICAgICAgIGlmIChtb2RlID09PSAnbG93ZXN0JyAmJiBpc0xvd2VyKSB7XG4gICAgICAgICAgaGl0ID0gW25vZGUsIHBhdGhdO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IC8vIEluIGxvd2VzdCBtb2RlIHdlIGVtaXQgdGhlIGxhc3QgaGl0LCBvbmNlIGl0J3MgZ3VhcmFudGVlZCBsb3dlc3QuXG5cblxuICAgICAgICB2YXIgZW1pdCA9IG1vZGUgPT09ICdsb3dlc3QnID8gaGl0IDogW25vZGUsIHBhdGhdO1xuXG4gICAgICAgIGlmIChlbWl0KSB7XG4gICAgICAgICAgaWYgKHVuaXZlcnNhbCkge1xuICAgICAgICAgICAgbWF0Y2hlcy5wdXNoKGVtaXQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB5aWVsZCBlbWl0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGhpdCA9IFtub2RlLCBwYXRoXTtcbiAgICAgIH0gLy8gU2luY2UgbG93ZXN0IGlzIGFsd2F5cyBlbWl0dGluZyBvbmUgYmVoaW5kLCBjYXRjaCB1cCBhdCB0aGUgZW5kLlxuXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBfaXRlcmF0b3I1LmUoZXJyKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgX2l0ZXJhdG9yNS5mKCk7XG4gICAgfVxuXG4gICAgaWYgKG1vZGUgPT09ICdsb3dlc3QnICYmIGhpdCkge1xuICAgICAgaWYgKHVuaXZlcnNhbCkge1xuICAgICAgICBtYXRjaGVzLnB1c2goaGl0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHlpZWxkIGhpdDtcbiAgICAgIH1cbiAgICB9IC8vIFVuaXZlcnNhbCBkZWZlcnMgdG8gZW5zdXJlIHRoYXQgdGhlIG1hdGNoIG9jY3VycyBpbiBldmVyeSBicmFuY2gsIHNvIHdlXG4gICAgLy8geWllbGQgYWxsIG9mIHRoZSBtYXRjaGVzIGFmdGVyIGl0ZXJhdGluZy5cblxuXG4gICAgaWYgKHVuaXZlcnNhbCkge1xuICAgICAgeWllbGQqIG1hdGNoZXM7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxyXG4gICAqIE5vcm1hbGl6ZSBhbnkgZGlydHkgb2JqZWN0cyBpbiB0aGUgZWRpdG9yLlxyXG4gICAqL1xuICBub3JtYWxpemU6IGZ1bmN0aW9uIG5vcm1hbGl6ZShlZGl0b3IpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgdmFyIF9vcHRpb25zJGZvcmNlID0gb3B0aW9ucy5mb3JjZSxcbiAgICAgICAgZm9yY2UgPSBfb3B0aW9ucyRmb3JjZSA9PT0gdm9pZCAwID8gZmFsc2UgOiBfb3B0aW9ucyRmb3JjZSxcbiAgICAgICAgb3BlcmF0aW9uID0gb3B0aW9ucy5vcGVyYXRpb247XG5cbiAgICB2YXIgZ2V0RGlydHlQYXRocyA9IGZ1bmN0aW9uIGdldERpcnR5UGF0aHMoZWRpdG9yKSB7XG4gICAgICByZXR1cm4gRElSVFlfUEFUSFMuZ2V0KGVkaXRvcikgfHwgW107XG4gICAgfTtcblxuICAgIHZhciBnZXREaXJ0eVBhdGhLZXlzID0gZnVuY3Rpb24gZ2V0RGlydHlQYXRoS2V5cyhlZGl0b3IpIHtcbiAgICAgIHJldHVybiBESVJUWV9QQVRIX0tFWVMuZ2V0KGVkaXRvcikgfHwgbmV3IFNldCgpO1xuICAgIH07XG5cbiAgICB2YXIgcG9wRGlydHlQYXRoID0gZnVuY3Rpb24gcG9wRGlydHlQYXRoKGVkaXRvcikge1xuICAgICAgdmFyIHBhdGggPSBnZXREaXJ0eVBhdGhzKGVkaXRvcikucG9wKCk7XG4gICAgICB2YXIga2V5ID0gcGF0aC5qb2luKCcsJyk7XG4gICAgICBnZXREaXJ0eVBhdGhLZXlzKGVkaXRvcilbXCJkZWxldGVcIl0oa2V5KTtcbiAgICAgIHJldHVybiBwYXRoO1xuICAgIH07XG5cbiAgICBpZiAoIUVkaXRvci5pc05vcm1hbGl6aW5nKGVkaXRvcikpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZm9yY2UpIHtcbiAgICAgIHZhciBhbGxQYXRocyA9IEFycmF5LmZyb20oTm9kZS5ub2RlcyhlZGl0b3IpLCBmdW5jdGlvbiAoX3JlZjMpIHtcbiAgICAgICAgdmFyIF9yZWY0ID0gX3NsaWNlZFRvQXJyYXkoX3JlZjMsIDIpLFxuICAgICAgICAgICAgcCA9IF9yZWY0WzFdO1xuXG4gICAgICAgIHJldHVybiBwO1xuICAgICAgfSk7XG4gICAgICB2YXIgYWxsUGF0aEtleXMgPSBuZXcgU2V0KGFsbFBhdGhzLm1hcChmdW5jdGlvbiAocCkge1xuICAgICAgICByZXR1cm4gcC5qb2luKCcsJyk7XG4gICAgICB9KSk7XG4gICAgICBESVJUWV9QQVRIUy5zZXQoZWRpdG9yLCBhbGxQYXRocyk7XG4gICAgICBESVJUWV9QQVRIX0tFWVMuc2V0KGVkaXRvciwgYWxsUGF0aEtleXMpO1xuICAgIH1cblxuICAgIGlmIChnZXREaXJ0eVBhdGhzKGVkaXRvcikubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgRWRpdG9yLndpdGhvdXROb3JtYWxpemluZyhlZGl0b3IsIGZ1bmN0aW9uICgpIHtcbiAgICAgIC8qXHJcbiAgICAgICAgRml4IGRpcnR5IGVsZW1lbnRzIHdpdGggbm8gY2hpbGRyZW4uXHJcbiAgICAgICAgZWRpdG9yLm5vcm1hbGl6ZU5vZGUoKSBkb2VzIGZpeCB0aGlzLCBidXQgc29tZSBub3JtYWxpemF0aW9uIGZpeGVzIGFsc28gcmVxdWlyZSBpdCB0byB3b3JrLlxyXG4gICAgICAgIFJ1bm5pbmcgYW4gaW5pdGlhbCBwYXNzIGF2b2lkcyB0aGUgY2F0Y2gtMjIgcmFjZSBjb25kaXRpb24uXHJcbiAgICAgICovXG4gICAgICB2YXIgX2l0ZXJhdG9yNiA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDUoZ2V0RGlydHlQYXRocyhlZGl0b3IpKSxcbiAgICAgICAgICBfc3RlcDY7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoX2l0ZXJhdG9yNi5zKCk7ICEoX3N0ZXA2ID0gX2l0ZXJhdG9yNi5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgdmFyIF9kaXJ0eVBhdGggPSBfc3RlcDYudmFsdWU7XG5cbiAgICAgICAgICBpZiAoTm9kZS5oYXMoZWRpdG9yLCBfZGlydHlQYXRoKSkge1xuICAgICAgICAgICAgdmFyIF9lbnRyeSA9IEVkaXRvci5ub2RlKGVkaXRvciwgX2RpcnR5UGF0aCk7XG5cbiAgICAgICAgICAgIHZhciBfZW50cnkyID0gX3NsaWNlZFRvQXJyYXkoX2VudHJ5LCAyKSxcbiAgICAgICAgICAgICAgICBub2RlID0gX2VudHJ5MlswXSxcbiAgICAgICAgICAgICAgICBfID0gX2VudHJ5MlsxXTtcbiAgICAgICAgICAgIC8qXHJcbiAgICAgICAgICAgICAgVGhlIGRlZmF1bHQgbm9ybWFsaXplciBpbnNlcnRzIGFuIGVtcHR5IHRleHQgbm9kZSBpbiB0aGlzIHNjZW5hcmlvLCBidXQgaXQgY2FuIGJlIGN1c3RvbWlzZWQuXHJcbiAgICAgICAgICAgICAgU28gdGhlcmUgaXMgc29tZSByaXNrIGhlcmUuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICBBcyBsb25nIGFzIHRoZSBub3JtYWxpemVyIG9ubHkgaW5zZXJ0cyBjaGlsZCBub2RlcyBmb3IgdGhpcyBjYXNlIGl0IGlzIHNhZmUgdG8gZG8gaW4gYW55IG9yZGVyO1xyXG4gICAgICAgICAgICAgIGJ5IGRlZmluaXRpb24gYWRkaW5nIGNoaWxkcmVuIHRvIGFuIGVtcHR5IG5vZGUgY2FuJ3QgY2F1c2Ugb3RoZXIgcGF0aHMgdG8gY2hhbmdlLlxyXG4gICAgICAgICAgICAqL1xuXG5cbiAgICAgICAgICAgIGlmIChFbGVtZW50LmlzRWxlbWVudChub2RlKSAmJiBub2RlLmNoaWxkcmVuLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICBlZGl0b3Iubm9ybWFsaXplTm9kZShfZW50cnksIHtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb246IG9wZXJhdGlvblxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3I2LmUoZXJyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIF9pdGVyYXRvcjYuZigpO1xuICAgICAgfVxuXG4gICAgICB2YXIgZGlydHlQYXRocyA9IGdldERpcnR5UGF0aHMoZWRpdG9yKTtcbiAgICAgIHZhciBpbml0aWFsRGlydHlQYXRoc0xlbmd0aCA9IGRpcnR5UGF0aHMubGVuZ3RoO1xuICAgICAgdmFyIGl0ZXJhdGlvbiA9IDA7XG5cbiAgICAgIHdoaWxlIChkaXJ0eVBhdGhzLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICBpZiAoIWVkaXRvci5zaG91bGROb3JtYWxpemUoe1xuICAgICAgICAgIGRpcnR5UGF0aHM6IGRpcnR5UGF0aHMsXG4gICAgICAgICAgaXRlcmF0aW9uOiBpdGVyYXRpb24sXG4gICAgICAgICAgaW5pdGlhbERpcnR5UGF0aHNMZW5ndGg6IGluaXRpYWxEaXJ0eVBhdGhzTGVuZ3RoLFxuICAgICAgICAgIG9wZXJhdGlvbjogb3BlcmF0aW9uXG4gICAgICAgIH0pKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGRpcnR5UGF0aCA9IHBvcERpcnR5UGF0aChlZGl0b3IpOyAvLyBJZiB0aGUgbm9kZSBkb2Vzbid0IGV4aXN0IGluIHRoZSB0cmVlLCBpdCBkb2VzIG5vdCBuZWVkIHRvIGJlIG5vcm1hbGl6ZWQuXG5cbiAgICAgICAgaWYgKE5vZGUuaGFzKGVkaXRvciwgZGlydHlQYXRoKSkge1xuICAgICAgICAgIHZhciBlbnRyeSA9IEVkaXRvci5ub2RlKGVkaXRvciwgZGlydHlQYXRoKTtcbiAgICAgICAgICBlZGl0b3Iubm9ybWFsaXplTm9kZShlbnRyeSwge1xuICAgICAgICAgICAgb3BlcmF0aW9uOiBvcGVyYXRpb25cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGl0ZXJhdGlvbisrO1xuICAgICAgICBkaXJ0eVBhdGhzID0gZ2V0RGlydHlQYXRocyhlZGl0b3IpO1xuICAgICAgfVxuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgcGFyZW50IG5vZGUgb2YgYSBsb2NhdGlvbi5cclxuICAgKi9cbiAgcGFyZW50OiBmdW5jdGlvbiBwYXJlbnQoZWRpdG9yLCBhdCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICB2YXIgcGF0aCA9IEVkaXRvci5wYXRoKGVkaXRvciwgYXQsIG9wdGlvbnMpO1xuICAgIHZhciBwYXJlbnRQYXRoID0gUGF0aC5wYXJlbnQocGF0aCk7XG4gICAgdmFyIGVudHJ5ID0gRWRpdG9yLm5vZGUoZWRpdG9yLCBwYXJlbnRQYXRoKTtcbiAgICByZXR1cm4gZW50cnk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogR2V0IHRoZSBwYXRoIG9mIGEgbG9jYXRpb24uXHJcbiAgICovXG4gIHBhdGg6IGZ1bmN0aW9uIHBhdGgoZWRpdG9yLCBhdCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICB2YXIgZGVwdGggPSBvcHRpb25zLmRlcHRoLFxuICAgICAgICBlZGdlID0gb3B0aW9ucy5lZGdlO1xuXG4gICAgaWYgKFBhdGguaXNQYXRoKGF0KSkge1xuICAgICAgaWYgKGVkZ2UgPT09ICdzdGFydCcpIHtcbiAgICAgICAgdmFyIF9Ob2RlJGZpcnN0ID0gTm9kZS5maXJzdChlZGl0b3IsIGF0KSxcbiAgICAgICAgICAgIF9Ob2RlJGZpcnN0MiA9IF9zbGljZWRUb0FycmF5KF9Ob2RlJGZpcnN0LCAyKSxcbiAgICAgICAgICAgIGZpcnN0UGF0aCA9IF9Ob2RlJGZpcnN0MlsxXTtcblxuICAgICAgICBhdCA9IGZpcnN0UGF0aDtcbiAgICAgIH0gZWxzZSBpZiAoZWRnZSA9PT0gJ2VuZCcpIHtcbiAgICAgICAgdmFyIF9Ob2RlJGxhc3QgPSBOb2RlLmxhc3QoZWRpdG9yLCBhdCksXG4gICAgICAgICAgICBfTm9kZSRsYXN0MiA9IF9zbGljZWRUb0FycmF5KF9Ob2RlJGxhc3QsIDIpLFxuICAgICAgICAgICAgbGFzdFBhdGggPSBfTm9kZSRsYXN0MlsxXTtcblxuICAgICAgICBhdCA9IGxhc3RQYXRoO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChSYW5nZS5pc1JhbmdlKGF0KSkge1xuICAgICAgaWYgKGVkZ2UgPT09ICdzdGFydCcpIHtcbiAgICAgICAgYXQgPSBSYW5nZS5zdGFydChhdCk7XG4gICAgICB9IGVsc2UgaWYgKGVkZ2UgPT09ICdlbmQnKSB7XG4gICAgICAgIGF0ID0gUmFuZ2UuZW5kKGF0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGF0ID0gUGF0aC5jb21tb24oYXQuYW5jaG9yLnBhdGgsIGF0LmZvY3VzLnBhdGgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChQb2ludC5pc1BvaW50KGF0KSkge1xuICAgICAgYXQgPSBhdC5wYXRoO1xuICAgIH1cblxuICAgIGlmIChkZXB0aCAhPSBudWxsKSB7XG4gICAgICBhdCA9IGF0LnNsaWNlKDAsIGRlcHRoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXQ7XG4gIH0sXG4gIGhhc1BhdGg6IGZ1bmN0aW9uIGhhc1BhdGgoZWRpdG9yLCBwYXRoKSB7XG4gICAgcmV0dXJuIE5vZGUuaGFzKGVkaXRvciwgcGF0aCk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ3JlYXRlIGEgbXV0YWJsZSByZWYgZm9yIGEgYFBhdGhgIG9iamVjdCwgd2hpY2ggd2lsbCBzdGF5IGluIHN5bmMgYXMgbmV3XHJcbiAgICogb3BlcmF0aW9ucyBhcmUgYXBwbGllZCB0byB0aGUgZWRpdG9yLlxyXG4gICAqL1xuICBwYXRoUmVmOiBmdW5jdGlvbiBwYXRoUmVmKGVkaXRvciwgcGF0aCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICB2YXIgX29wdGlvbnMkYWZmaW5pdHkgPSBvcHRpb25zLmFmZmluaXR5LFxuICAgICAgICBhZmZpbml0eSA9IF9vcHRpb25zJGFmZmluaXR5ID09PSB2b2lkIDAgPyAnZm9yd2FyZCcgOiBfb3B0aW9ucyRhZmZpbml0eTtcbiAgICB2YXIgcmVmID0ge1xuICAgICAgY3VycmVudDogcGF0aCxcbiAgICAgIGFmZmluaXR5OiBhZmZpbml0eSxcbiAgICAgIHVucmVmOiBmdW5jdGlvbiB1bnJlZigpIHtcbiAgICAgICAgdmFyIGN1cnJlbnQgPSByZWYuY3VycmVudDtcbiAgICAgICAgdmFyIHBhdGhSZWZzID0gRWRpdG9yLnBhdGhSZWZzKGVkaXRvcik7XG4gICAgICAgIHBhdGhSZWZzW1wiZGVsZXRlXCJdKHJlZik7XG4gICAgICAgIHJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIGN1cnJlbnQ7XG4gICAgICB9XG4gICAgfTtcbiAgICB2YXIgcmVmcyA9IEVkaXRvci5wYXRoUmVmcyhlZGl0b3IpO1xuICAgIHJlZnMuYWRkKHJlZik7XG4gICAgcmV0dXJuIHJlZjtcbiAgfSxcblxuICAvKipcclxuICAgKiBHZXQgdGhlIHNldCBvZiBjdXJyZW50bHkgdHJhY2tlZCBwYXRoIHJlZnMgb2YgdGhlIGVkaXRvci5cclxuICAgKi9cbiAgcGF0aFJlZnM6IGZ1bmN0aW9uIHBhdGhSZWZzKGVkaXRvcikge1xuICAgIHZhciByZWZzID0gUEFUSF9SRUZTLmdldChlZGl0b3IpO1xuXG4gICAgaWYgKCFyZWZzKSB7XG4gICAgICByZWZzID0gbmV3IFNldCgpO1xuICAgICAgUEFUSF9SRUZTLnNldChlZGl0b3IsIHJlZnMpO1xuICAgIH1cblxuICAgIHJldHVybiByZWZzO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgc3RhcnQgb3IgZW5kIHBvaW50IG9mIGEgbG9jYXRpb24uXHJcbiAgICovXG4gIHBvaW50OiBmdW5jdGlvbiBwb2ludChlZGl0b3IsIGF0KSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIHZhciBfb3B0aW9ucyRlZGdlID0gb3B0aW9ucy5lZGdlLFxuICAgICAgICBlZGdlID0gX29wdGlvbnMkZWRnZSA9PT0gdm9pZCAwID8gJ3N0YXJ0JyA6IF9vcHRpb25zJGVkZ2U7XG5cbiAgICBpZiAoUGF0aC5pc1BhdGgoYXQpKSB7XG4gICAgICB2YXIgcGF0aDtcblxuICAgICAgaWYgKGVkZ2UgPT09ICdlbmQnKSB7XG4gICAgICAgIHZhciBfTm9kZSRsYXN0MyA9IE5vZGUubGFzdChlZGl0b3IsIGF0KSxcbiAgICAgICAgICAgIF9Ob2RlJGxhc3Q0ID0gX3NsaWNlZFRvQXJyYXkoX05vZGUkbGFzdDMsIDIpLFxuICAgICAgICAgICAgbGFzdFBhdGggPSBfTm9kZSRsYXN0NFsxXTtcblxuICAgICAgICBwYXRoID0gbGFzdFBhdGg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgX05vZGUkZmlyc3QzID0gTm9kZS5maXJzdChlZGl0b3IsIGF0KSxcbiAgICAgICAgICAgIF9Ob2RlJGZpcnN0NCA9IF9zbGljZWRUb0FycmF5KF9Ob2RlJGZpcnN0MywgMiksXG4gICAgICAgICAgICBmaXJzdFBhdGggPSBfTm9kZSRmaXJzdDRbMV07XG5cbiAgICAgICAgcGF0aCA9IGZpcnN0UGF0aDtcbiAgICAgIH1cblxuICAgICAgdmFyIG5vZGUgPSBOb2RlLmdldChlZGl0b3IsIHBhdGgpO1xuXG4gICAgICBpZiAoIVRleHQuaXNUZXh0KG5vZGUpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBnZXQgdGhlIFwiLmNvbmNhdChlZGdlLCBcIiBwb2ludCBpbiB0aGUgbm9kZSBhdCBwYXRoIFtcIikuY29uY2F0KGF0LCBcIl0gYmVjYXVzZSBpdCBoYXMgbm8gXCIpLmNvbmNhdChlZGdlLCBcIiB0ZXh0IG5vZGUuXCIpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgb2Zmc2V0OiBlZGdlID09PSAnZW5kJyA/IG5vZGUudGV4dC5sZW5ndGggOiAwXG4gICAgICB9O1xuICAgIH1cblxuICAgIGlmIChSYW5nZS5pc1JhbmdlKGF0KSkge1xuICAgICAgdmFyIF9SYW5nZSRlZGdlcyA9IFJhbmdlLmVkZ2VzKGF0KSxcbiAgICAgICAgICBfUmFuZ2UkZWRnZXMyID0gX3NsaWNlZFRvQXJyYXkoX1JhbmdlJGVkZ2VzLCAyKSxcbiAgICAgICAgICBzdGFydCA9IF9SYW5nZSRlZGdlczJbMF0sXG4gICAgICAgICAgZW5kID0gX1JhbmdlJGVkZ2VzMlsxXTtcblxuICAgICAgcmV0dXJuIGVkZ2UgPT09ICdzdGFydCcgPyBzdGFydCA6IGVuZDtcbiAgICB9XG5cbiAgICByZXR1cm4gYXQ7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ3JlYXRlIGEgbXV0YWJsZSByZWYgZm9yIGEgYFBvaW50YCBvYmplY3QsIHdoaWNoIHdpbGwgc3RheSBpbiBzeW5jIGFzIG5ld1xyXG4gICAqIG9wZXJhdGlvbnMgYXJlIGFwcGxpZWQgdG8gdGhlIGVkaXRvci5cclxuICAgKi9cbiAgcG9pbnRSZWY6IGZ1bmN0aW9uIHBvaW50UmVmKGVkaXRvciwgcG9pbnQpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgdmFyIF9vcHRpb25zJGFmZmluaXR5MiA9IG9wdGlvbnMuYWZmaW5pdHksXG4gICAgICAgIGFmZmluaXR5ID0gX29wdGlvbnMkYWZmaW5pdHkyID09PSB2b2lkIDAgPyAnZm9yd2FyZCcgOiBfb3B0aW9ucyRhZmZpbml0eTI7XG4gICAgdmFyIHJlZiA9IHtcbiAgICAgIGN1cnJlbnQ6IHBvaW50LFxuICAgICAgYWZmaW5pdHk6IGFmZmluaXR5LFxuICAgICAgdW5yZWY6IGZ1bmN0aW9uIHVucmVmKCkge1xuICAgICAgICB2YXIgY3VycmVudCA9IHJlZi5jdXJyZW50O1xuICAgICAgICB2YXIgcG9pbnRSZWZzID0gRWRpdG9yLnBvaW50UmVmcyhlZGl0b3IpO1xuICAgICAgICBwb2ludFJlZnNbXCJkZWxldGVcIl0ocmVmKTtcbiAgICAgICAgcmVmLmN1cnJlbnQgPSBudWxsO1xuICAgICAgICByZXR1cm4gY3VycmVudDtcbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciByZWZzID0gRWRpdG9yLnBvaW50UmVmcyhlZGl0b3IpO1xuICAgIHJlZnMuYWRkKHJlZik7XG4gICAgcmV0dXJuIHJlZjtcbiAgfSxcblxuICAvKipcclxuICAgKiBHZXQgdGhlIHNldCBvZiBjdXJyZW50bHkgdHJhY2tlZCBwb2ludCByZWZzIG9mIHRoZSBlZGl0b3IuXHJcbiAgICovXG4gIHBvaW50UmVmczogZnVuY3Rpb24gcG9pbnRSZWZzKGVkaXRvcikge1xuICAgIHZhciByZWZzID0gUE9JTlRfUkVGUy5nZXQoZWRpdG9yKTtcblxuICAgIGlmICghcmVmcykge1xuICAgICAgcmVmcyA9IG5ldyBTZXQoKTtcbiAgICAgIFBPSU5UX1JFRlMuc2V0KGVkaXRvciwgcmVmcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlZnM7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogUmV0dXJuIGFsbCB0aGUgcG9zaXRpb25zIGluIGBhdGAgcmFuZ2Ugd2hlcmUgYSBgUG9pbnRgIGNhbiBiZSBwbGFjZWQuXHJcbiAgICpcclxuICAgKiBCeSBkZWZhdWx0LCBtb3ZlcyBmb3J3YXJkIGJ5IGluZGl2aWR1YWwgb2Zmc2V0cyBhdCBhIHRpbWUsIGJ1dFxyXG4gICAqIHRoZSBgdW5pdGAgb3B0aW9uIGNhbiBiZSB1c2VkIHRvIHRvIG1vdmUgYnkgY2hhcmFjdGVyLCB3b3JkLCBsaW5lLCBvciBibG9jay5cclxuICAgKlxyXG4gICAqIFRoZSBgcmV2ZXJzZWAgb3B0aW9uIGNhbiBiZSB1c2VkIHRvIGNoYW5nZSBpdGVyYXRpb24gZGlyZWN0aW9uLlxyXG4gICAqXHJcbiAgICogTm90ZTogQnkgZGVmYXVsdCB2b2lkIG5vZGVzIGFyZSB0cmVhdGVkIGFzIGEgc2luZ2xlIHBvaW50IGFuZCBpdGVyYXRpb25cclxuICAgKiB3aWxsIG5vdCBoYXBwZW4gaW5zaWRlIHRoZWlyIGNvbnRlbnQgdW5sZXNzIHlvdSBwYXNzIGluIHRydWUgZm9yIHRoZVxyXG4gICAqIGB2b2lkc2Agb3B0aW9uLCB0aGVuIGl0ZXJhdGlvbiB3aWxsIG9jY3VyLlxyXG4gICAqL1xuICBwb3NpdGlvbnM6IGZ1bmN0aW9uKiBwb3NpdGlvbnMoZWRpdG9yKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIHZhciBfb3B0aW9ucyRhdDUgPSBvcHRpb25zLmF0LFxuICAgICAgICBhdCA9IF9vcHRpb25zJGF0NSA9PT0gdm9pZCAwID8gZWRpdG9yLnNlbGVjdGlvbiA6IF9vcHRpb25zJGF0NSxcbiAgICAgICAgX29wdGlvbnMkdW5pdDMgPSBvcHRpb25zLnVuaXQsXG4gICAgICAgIHVuaXQgPSBfb3B0aW9ucyR1bml0MyA9PT0gdm9pZCAwID8gJ29mZnNldCcgOiBfb3B0aW9ucyR1bml0MyxcbiAgICAgICAgX29wdGlvbnMkcmV2ZXJzZTMgPSBvcHRpb25zLnJldmVyc2UsXG4gICAgICAgIHJldmVyc2UgPSBfb3B0aW9ucyRyZXZlcnNlMyA9PT0gdm9pZCAwID8gZmFsc2UgOiBfb3B0aW9ucyRyZXZlcnNlMyxcbiAgICAgICAgX29wdGlvbnMkdm9pZHM1ID0gb3B0aW9ucy52b2lkcyxcbiAgICAgICAgdm9pZHMgPSBfb3B0aW9ucyR2b2lkczUgPT09IHZvaWQgMCA/IGZhbHNlIDogX29wdGlvbnMkdm9pZHM1O1xuXG4gICAgaWYgKCFhdCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvKipcclxuICAgICAqIEFsZ29yaXRobSBub3RlczpcclxuICAgICAqXHJcbiAgICAgKiBFYWNoIHN0ZXAgYGRpc3RhbmNlYCBpcyBkeW5hbWljIGRlcGVuZGluZyBvbiB0aGUgdW5kZXJseWluZyB0ZXh0XHJcbiAgICAgKiBhbmQgdGhlIGB1bml0YCBzcGVjaWZpZWQuICBFYWNoIHN0ZXAsIGUuZy4sIGEgbGluZSBvciB3b3JkLCBtYXlcclxuICAgICAqIHNwYW4gbXVsdGlwbGUgdGV4dCBub2Rlcywgc28gd2UgaXRlcmF0ZSB0aHJvdWdoIHRoZSB0ZXh0IGJvdGggb25cclxuICAgICAqIHR3byBsZXZlbHMgaW4gc3RlcC1zeW5jOlxyXG4gICAgICpcclxuICAgICAqIGBsZWFmVGV4dGAgc3RvcmVzIHRoZSB0ZXh0IG9uIGEgdGV4dCBsZWFmIGxldmVsLCBhbmQgaXMgYWR2YW5jZWRcclxuICAgICAqIHRocm91Z2ggdXNpbmcgdGhlIGNvdW50ZXJzIGBsZWFmVGV4dE9mZnNldGAgYW5kIGBsZWFmVGV4dFJlbWFpbmluZ2AuXHJcbiAgICAgKlxyXG4gICAgICogYGJsb2NrVGV4dGAgc3RvcmVzIHRoZSB0ZXh0IG9uIGEgYmxvY2sgbGV2ZWwsIGFuZCBpcyBzaG9ydGVuZWRcclxuICAgICAqIGJ5IGBkaXN0YW5jZWAgZXZlcnkgdGltZSBpdCBpcyBhZHZhbmNlZC5cclxuICAgICAqXHJcbiAgICAgKiBXZSBvbmx5IG1haW50YWluIGEgd2luZG93IG9mIG9uZSBibG9ja1RleHQgYW5kIG9uZSBsZWFmVGV4dCBiZWNhdXNlXHJcbiAgICAgKiBhIGJsb2NrIG5vZGUgYWx3YXlzIGFwcGVhcnMgYmVmb3JlIGFsbCBvZiBpdHMgbGVhZiBub2Rlcy5cclxuICAgICAqL1xuXG5cbiAgICB2YXIgcmFuZ2UgPSBFZGl0b3IucmFuZ2UoZWRpdG9yLCBhdCk7XG5cbiAgICB2YXIgX1JhbmdlJGVkZ2VzMyA9IFJhbmdlLmVkZ2VzKHJhbmdlKSxcbiAgICAgICAgX1JhbmdlJGVkZ2VzNCA9IF9zbGljZWRUb0FycmF5KF9SYW5nZSRlZGdlczMsIDIpLFxuICAgICAgICBzdGFydCA9IF9SYW5nZSRlZGdlczRbMF0sXG4gICAgICAgIGVuZCA9IF9SYW5nZSRlZGdlczRbMV07XG5cbiAgICB2YXIgZmlyc3QgPSByZXZlcnNlID8gZW5kIDogc3RhcnQ7XG4gICAgdmFyIGlzTmV3QmxvY2sgPSBmYWxzZTtcbiAgICB2YXIgYmxvY2tUZXh0ID0gJyc7XG4gICAgdmFyIGRpc3RhbmNlID0gMDsgLy8gRGlzdGFuY2UgZm9yIGxlYWZUZXh0IHRvIGNhdGNoIHVwIHRvIGJsb2NrVGV4dC5cblxuICAgIHZhciBsZWFmVGV4dFJlbWFpbmluZyA9IDA7XG4gICAgdmFyIGxlYWZUZXh0T2Zmc2V0ID0gMDsgLy8gSXRlcmF0ZSB0aHJvdWdoIGFsbCBub2RlcyBpbiByYW5nZSwgZ3JhYmJpbmcgZW50aXJlIHRleHR1YWwgY29udGVudFxuICAgIC8vIG9mIGJsb2NrIG5vZGVzIGluIGJsb2NrVGV4dCwgYW5kIHRleHQgbm9kZXMgaW4gbGVhZlRleHQuXG4gICAgLy8gRXhwbG9pdHMgdGhlIGZhY3QgdGhhdCBub2RlcyBhcmUgc2VxdWVuY2VkIGluIHN1Y2ggYSB3YXkgdGhhdCB3ZSBmaXJzdFxuICAgIC8vIGVuY291bnRlciB0aGUgYmxvY2sgbm9kZSwgdGhlbiBhbGwgb2YgaXRzIHRleHQgbm9kZXMsIHNvIHdoZW4gaXRlcmF0aW5nXG4gICAgLy8gdGhyb3VnaCB0aGUgYmxvY2tUZXh0IGFuZCBsZWFmVGV4dCB3ZSBqdXN0IG5lZWQgdG8gcmVtZW1iZXIgYSB3aW5kb3cgb2ZcbiAgICAvLyBvbmUgYmxvY2sgbm9kZSBhbmQgbGVhZiBub2RlLCByZXNwZWN0aXZlbHkuXG5cbiAgICB2YXIgX2l0ZXJhdG9yNyA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDUoRWRpdG9yLm5vZGVzKGVkaXRvciwge1xuICAgICAgYXQ6IGF0LFxuICAgICAgcmV2ZXJzZTogcmV2ZXJzZSxcbiAgICAgIHZvaWRzOiB2b2lkc1xuICAgIH0pKSxcbiAgICAgICAgX3N0ZXA3O1xuXG4gICAgdHJ5IHtcbiAgICAgIGZvciAoX2l0ZXJhdG9yNy5zKCk7ICEoX3N0ZXA3ID0gX2l0ZXJhdG9yNy5uKCkpLmRvbmU7KSB7XG4gICAgICAgIHZhciBfc3RlcDckdmFsdWUgPSBfc2xpY2VkVG9BcnJheShfc3RlcDcudmFsdWUsIDIpLFxuICAgICAgICAgICAgbm9kZSA9IF9zdGVwNyR2YWx1ZVswXSxcbiAgICAgICAgICAgIHBhdGggPSBfc3RlcDckdmFsdWVbMV07XG5cbiAgICAgICAgLypcclxuICAgICAgICAgKiBFTEVNRU5UIE5PREUgLSBZaWVsZCBwb3NpdGlvbihzKSBmb3Igdm9pZHMsIGNvbGxlY3QgYmxvY2tUZXh0IGZvciBibG9ja3NcclxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKEVsZW1lbnQuaXNFbGVtZW50KG5vZGUpKSB7XG4gICAgICAgICAgLy8gVm9pZCBub2RlcyBhcmUgYSBzcGVjaWFsIGNhc2UsIHNvIGJ5IGRlZmF1bHQgd2Ugd2lsbCBhbHdheXNcbiAgICAgICAgICAvLyB5aWVsZCB0aGVpciBmaXJzdCBwb2ludC4gSWYgdGhlIGB2b2lkc2Agb3B0aW9uIGlzIHNldCB0byB0cnVlLFxuICAgICAgICAgIC8vIHRoZW4gd2Ugd2lsbCBpdGVyYXRlIG92ZXIgdGhlaXIgY29udGVudC5cbiAgICAgICAgICBpZiAoIXZvaWRzICYmIGVkaXRvci5pc1ZvaWQobm9kZSkpIHtcbiAgICAgICAgICAgIHlpZWxkIEVkaXRvci5zdGFydChlZGl0b3IsIHBhdGgpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfSAvLyBJbmxpbmUgZWxlbWVudCBub2RlcyBhcmUgaWdub3JlZCBhcyB0aGV5IGRvbid0IHRoZW1zZWx2ZXNcbiAgICAgICAgICAvLyBjb250cmlidXRlIHRvIGBibG9ja1RleHRgIG9yIGBsZWFmVGV4dGAgLSB0aGVpciBwYXJlbnQgYW5kXG4gICAgICAgICAgLy8gY2hpbGRyZW4gZG8uXG5cblxuICAgICAgICAgIGlmIChlZGl0b3IuaXNJbmxpbmUobm9kZSkpIGNvbnRpbnVlOyAvLyBCbG9jayBlbGVtZW50IG5vZGUgLSBzZXQgYGJsb2NrVGV4dGAgdG8gaXRzIHRleHQgY29udGVudC5cblxuICAgICAgICAgIGlmIChFZGl0b3IuaGFzSW5saW5lcyhlZGl0b3IsIG5vZGUpKSB7XG4gICAgICAgICAgICAvLyBXZSBhbHdheXMgZXhoYXVzdCBibG9jayBub2RlcyBiZWZvcmUgZW5jb3VudGVyaW5nIGEgbmV3IG9uZTpcbiAgICAgICAgICAgIC8vICAgY29uc29sZS5hc3NlcnQoYmxvY2tUZXh0ID09PSAnJyxcbiAgICAgICAgICAgIC8vICAgICBgYmxvY2tUZXh0PScke2Jsb2NrVGV4dH0nIC0gYCtcbiAgICAgICAgICAgIC8vICAgICBgbm90IGV4aGF1c3RlZCBiZWZvcmUgbmV3IGJsb2NrIG5vZGVgLCBwYXRoKVxuICAgICAgICAgICAgLy8gRW5zdXJlIHJhbmdlIGNvbnNpZGVyZWQgaXMgY2FwcGVkIHRvIGByYW5nZWAsIGluIHRoZVxuICAgICAgICAgICAgLy8gc3RhcnQvZW5kIGVkZ2UgY2FzZXMgd2hlcmUgYmxvY2sgZXh0ZW5kcyBiZXlvbmQgcmFuZ2UuXG4gICAgICAgICAgICAvLyBFcXVpdmFsZW50IHRvIHRoaXMsIGJ1dCBwcmVzdW1hYmx5IG1vcmUgcGVyZm9ybWFudDpcbiAgICAgICAgICAgIC8vICAgYmxvY2tSYW5nZSA9IEVkaXRvci5yYW5nZShlZGl0b3IsIC4uLkVkaXRvci5lZGdlcyhlZGl0b3IsIHBhdGgpKVxuICAgICAgICAgICAgLy8gICBibG9ja1JhbmdlID0gUmFuZ2UuaW50ZXJzZWN0aW9uKHJhbmdlLCBibG9ja1JhbmdlKSAvLyBpbnRlcnNlY3RcbiAgICAgICAgICAgIC8vICAgYmxvY2tUZXh0ID0gRWRpdG9yLnN0cmluZyhlZGl0b3IsIGJsb2NrUmFuZ2UsIHsgdm9pZHMgfSlcbiAgICAgICAgICAgIHZhciBlID0gUGF0aC5pc0FuY2VzdG9yKHBhdGgsIGVuZC5wYXRoKSA/IGVuZCA6IEVkaXRvci5lbmQoZWRpdG9yLCBwYXRoKTtcbiAgICAgICAgICAgIHZhciBzID0gUGF0aC5pc0FuY2VzdG9yKHBhdGgsIHN0YXJ0LnBhdGgpID8gc3RhcnQgOiBFZGl0b3Iuc3RhcnQoZWRpdG9yLCBwYXRoKTtcbiAgICAgICAgICAgIGJsb2NrVGV4dCA9IEVkaXRvci5zdHJpbmcoZWRpdG9yLCB7XG4gICAgICAgICAgICAgIGFuY2hvcjogcyxcbiAgICAgICAgICAgICAgZm9jdXM6IGVcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgdm9pZHM6IHZvaWRzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlzTmV3QmxvY2sgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvKlxyXG4gICAgICAgICAqIFRFWFQgTEVBRiBOT0RFIC0gSXRlcmF0ZSB0aHJvdWdoIHRleHQgY29udGVudCwgeWllbGRpbmdcclxuICAgICAgICAgKiBwb3NpdGlvbnMgZXZlcnkgYGRpc3RhbmNlYCBvZmZzZXQgYWNjb3JkaW5nIHRvIGB1bml0YC5cclxuICAgICAgICAgKi9cblxuXG4gICAgICAgIGlmIChUZXh0LmlzVGV4dChub2RlKSkge1xuICAgICAgICAgIHZhciBpc0ZpcnN0ID0gUGF0aC5lcXVhbHMocGF0aCwgZmlyc3QucGF0aCk7IC8vIFByb29mIHRoYXQgd2UgYWx3YXlzIGV4aGF1c3QgdGV4dCBub2RlcyBiZWZvcmUgZW5jb3VudGVyaW5nIGEgbmV3IG9uZTpcbiAgICAgICAgICAvLyAgIGNvbnNvbGUuYXNzZXJ0KGxlYWZUZXh0UmVtYWluaW5nIDw9IDAsXG4gICAgICAgICAgLy8gICAgIGBsZWFmVGV4dFJlbWFpbmluZz0ke2xlYWZUZXh0UmVtYWluaW5nfSAtIGArXG4gICAgICAgICAgLy8gICAgIGBub3QgZXhoYXVzdGVkIGJlZm9yZSBuZXcgbGVhZiB0ZXh0IG5vZGVgLCBwYXRoKVxuICAgICAgICAgIC8vIFJlc2V0IGBsZWFmVGV4dGAgY291bnRlcnMgZm9yIG5ldyB0ZXh0IG5vZGUuXG5cbiAgICAgICAgICBpZiAoaXNGaXJzdCkge1xuICAgICAgICAgICAgbGVhZlRleHRSZW1haW5pbmcgPSByZXZlcnNlID8gZmlyc3Qub2Zmc2V0IDogbm9kZS50ZXh0Lmxlbmd0aCAtIGZpcnN0Lm9mZnNldDtcbiAgICAgICAgICAgIGxlYWZUZXh0T2Zmc2V0ID0gZmlyc3Qub2Zmc2V0OyAvLyBXb3JrcyBmb3IgcmV2ZXJzZSB0b28uXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxlYWZUZXh0UmVtYWluaW5nID0gbm9kZS50ZXh0Lmxlbmd0aDtcbiAgICAgICAgICAgIGxlYWZUZXh0T2Zmc2V0ID0gcmV2ZXJzZSA/IGxlYWZUZXh0UmVtYWluaW5nIDogMDtcbiAgICAgICAgICB9IC8vIFlpZWxkIHBvc2l0aW9uIGF0IHRoZSBzdGFydCBvZiBub2RlIChwb3RlbnRpYWxseSkuXG5cblxuICAgICAgICAgIGlmIChpc0ZpcnN0IHx8IGlzTmV3QmxvY2sgfHwgdW5pdCA9PT0gJ29mZnNldCcpIHtcbiAgICAgICAgICAgIHlpZWxkIHtcbiAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgb2Zmc2V0OiBsZWFmVGV4dE9mZnNldFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlzTmV3QmxvY2sgPSBmYWxzZTtcbiAgICAgICAgICB9IC8vIFlpZWxkIHBvc2l0aW9ucyBldmVyeSAoZHluYW1pY2FsbHkgY2FsY3VsYXRlZCkgYGRpc3RhbmNlYCBvZmZzZXQuXG5cblxuICAgICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICAvLyBJZiBgbGVhZlRleHRgIGhhcyBjYXVnaHQgdXAgd2l0aCBgYmxvY2tUZXh0YCAoZGlzdGFuY2U9MCksXG4gICAgICAgICAgICAvLyBhbmQgaWYgYmxvY2tUZXh0IGlzIGV4aGF1c3RlZCwgYnJlYWsgdG8gZ2V0IGFub3RoZXIgYmxvY2sgbm9kZSxcbiAgICAgICAgICAgIC8vIG90aGVyd2lzZSBhZHZhbmNlIGJsb2NrVGV4dCBmb3J3YXJkIGJ5IHRoZSBuZXcgYGRpc3RhbmNlYC5cbiAgICAgICAgICAgIGlmIChkaXN0YW5jZSA9PT0gMCkge1xuICAgICAgICAgICAgICBpZiAoYmxvY2tUZXh0ID09PSAnJykgYnJlYWs7XG4gICAgICAgICAgICAgIGRpc3RhbmNlID0gY2FsY0Rpc3RhbmNlKGJsb2NrVGV4dCwgdW5pdCwgcmV2ZXJzZSk7IC8vIFNwbGl0IHRoZSBzdHJpbmcgYXQgdGhlIHByZXZpb3VzbHkgZm91bmQgZGlzdGFuY2UgYW5kIHVzZSB0aGVcbiAgICAgICAgICAgICAgLy8gcmVtYWluaW5nIHN0cmluZyBmb3IgdGhlIG5leHQgaXRlcmF0aW9uLlxuXG4gICAgICAgICAgICAgIGJsb2NrVGV4dCA9IHNwbGl0QnlDaGFyYWN0ZXJEaXN0YW5jZShibG9ja1RleHQsIGRpc3RhbmNlLCByZXZlcnNlKVsxXTtcbiAgICAgICAgICAgIH0gLy8gQWR2YW5jZSBgbGVhZlRleHRgIGJ5IHRoZSBjdXJyZW50IGBkaXN0YW5jZWAuXG5cblxuICAgICAgICAgICAgbGVhZlRleHRPZmZzZXQgPSByZXZlcnNlID8gbGVhZlRleHRPZmZzZXQgLSBkaXN0YW5jZSA6IGxlYWZUZXh0T2Zmc2V0ICsgZGlzdGFuY2U7XG4gICAgICAgICAgICBsZWFmVGV4dFJlbWFpbmluZyA9IGxlYWZUZXh0UmVtYWluaW5nIC0gZGlzdGFuY2U7IC8vIElmIGBsZWFmVGV4dGAgaXMgZXhoYXVzdGVkLCBicmVhayB0byBnZXQgYSBuZXcgbGVhZiBub2RlXG4gICAgICAgICAgICAvLyBhbmQgc2V0IGRpc3RhbmNlIHRvIHRoZSBvdmVyZmxvdyBhbW91bnQsIHNvIHdlJ2xsIChtYXliZSlcbiAgICAgICAgICAgIC8vIGNhdGNoIHVwIHRvIGJsb2NrVGV4dCBpbiB0aGUgbmV4dCBsZWFmIHRleHQgbm9kZS5cblxuICAgICAgICAgICAgaWYgKGxlYWZUZXh0UmVtYWluaW5nIDwgMCkge1xuICAgICAgICAgICAgICBkaXN0YW5jZSA9IC1sZWFmVGV4dFJlbWFpbmluZztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9IC8vIFN1Y2Nlc3NmdWxseSB3YWxrZWQgYGRpc3RhbmNlYCBvZmZzZXRzIHRocm91Z2ggYGxlYWZUZXh0YFxuICAgICAgICAgICAgLy8gdG8gY2F0Y2ggdXAgd2l0aCBgYmxvY2tUZXh0YCwgc28gd2UgY2FuIHJlc2V0IGBkaXN0YW5jZWBcbiAgICAgICAgICAgIC8vIGFuZCB5aWVsZCB0aGlzIHBvc2l0aW9uIGluIHRoaXMgbm9kZS5cblxuXG4gICAgICAgICAgICBkaXN0YW5jZSA9IDA7XG4gICAgICAgICAgICB5aWVsZCB7XG4gICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgIG9mZnNldDogbGVhZlRleHRPZmZzZXRcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IC8vIFByb29mIHRoYXQgdXBvbiBjb21wbGV0aW9uLCB3ZSd2ZSBleGFodXN0ZWQgYm90aCBsZWFmIGFuZCBibG9jayB0ZXh0OlxuICAgICAgLy8gICBjb25zb2xlLmFzc2VydChsZWFmVGV4dFJlbWFpbmluZyA8PSAwLCBcImxlYWZUZXh0IHdhc24ndCBleGhhdXN0ZWRcIilcbiAgICAgIC8vICAgY29uc29sZS5hc3NlcnQoYmxvY2tUZXh0ID09PSAnJywgXCJibG9ja1RleHQgd2Fzbid0IGV4aGF1c3RlZFwiKVxuICAgICAgLy8gSGVscGVyOlxuICAgICAgLy8gUmV0dXJuIHRoZSBkaXN0YW5jZSBpbiBvZmZzZXRzIGZvciBhIHN0ZXAgb2Ygc2l6ZSBgdW5pdGAgb24gZ2l2ZW4gc3RyaW5nLlxuXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBfaXRlcmF0b3I3LmUoZXJyKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgX2l0ZXJhdG9yNy5mKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2FsY0Rpc3RhbmNlKHRleHQsIHVuaXQsIHJldmVyc2UpIHtcbiAgICAgIGlmICh1bml0ID09PSAnY2hhcmFjdGVyJykge1xuICAgICAgICByZXR1cm4gZ2V0Q2hhcmFjdGVyRGlzdGFuY2UodGV4dCwgcmV2ZXJzZSk7XG4gICAgICB9IGVsc2UgaWYgKHVuaXQgPT09ICd3b3JkJykge1xuICAgICAgICByZXR1cm4gZ2V0V29yZERpc3RhbmNlKHRleHQsIHJldmVyc2UpO1xuICAgICAgfSBlbHNlIGlmICh1bml0ID09PSAnbGluZScgfHwgdW5pdCA9PT0gJ2Jsb2NrJykge1xuICAgICAgICByZXR1cm4gdGV4dC5sZW5ndGg7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgfSxcblxuICAvKipcclxuICAgKiBHZXQgdGhlIG1hdGNoaW5nIG5vZGUgaW4gdGhlIGJyYW5jaCBvZiB0aGUgZG9jdW1lbnQgYmVmb3JlIGEgbG9jYXRpb24uXHJcbiAgICovXG4gIHByZXZpb3VzOiBmdW5jdGlvbiBwcmV2aW91cyhlZGl0b3IpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgdmFyIF9vcHRpb25zJG1vZGU0ID0gb3B0aW9ucy5tb2RlLFxuICAgICAgICBtb2RlID0gX29wdGlvbnMkbW9kZTQgPT09IHZvaWQgMCA/ICdsb3dlc3QnIDogX29wdGlvbnMkbW9kZTQsXG4gICAgICAgIF9vcHRpb25zJHZvaWRzNiA9IG9wdGlvbnMudm9pZHMsXG4gICAgICAgIHZvaWRzID0gX29wdGlvbnMkdm9pZHM2ID09PSB2b2lkIDAgPyBmYWxzZSA6IF9vcHRpb25zJHZvaWRzNjtcbiAgICB2YXIgbWF0Y2ggPSBvcHRpb25zLm1hdGNoLFxuICAgICAgICBfb3B0aW9ucyRhdDYgPSBvcHRpb25zLmF0LFxuICAgICAgICBhdCA9IF9vcHRpb25zJGF0NiA9PT0gdm9pZCAwID8gZWRpdG9yLnNlbGVjdGlvbiA6IF9vcHRpb25zJGF0NjtcblxuICAgIGlmICghYXQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgcG9pbnRCZWZvcmVMb2NhdGlvbiA9IEVkaXRvci5iZWZvcmUoZWRpdG9yLCBhdCwge1xuICAgICAgdm9pZHM6IHZvaWRzXG4gICAgfSk7XG5cbiAgICBpZiAoIXBvaW50QmVmb3JlTG9jYXRpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgX0VkaXRvciRmaXJzdCA9IEVkaXRvci5maXJzdChlZGl0b3IsIFtdKSxcbiAgICAgICAgX0VkaXRvciRmaXJzdDIgPSBfc2xpY2VkVG9BcnJheShfRWRpdG9yJGZpcnN0LCAyKSxcbiAgICAgICAgdG8gPSBfRWRpdG9yJGZpcnN0MlsxXTsgLy8gVGhlIHNlYXJjaCBsb2NhdGlvbiBpcyBmcm9tIHRoZSBzdGFydCBvZiB0aGUgZG9jdW1lbnQgdG8gdGhlIHBhdGggb2ZcbiAgICAvLyB0aGUgcG9pbnQgYmVmb3JlIHRoZSBsb2NhdGlvbiBwYXNzZWQgaW5cblxuXG4gICAgdmFyIHNwYW4gPSBbcG9pbnRCZWZvcmVMb2NhdGlvbi5wYXRoLCB0b107XG5cbiAgICBpZiAoUGF0aC5pc1BhdGgoYXQpICYmIGF0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGdldCB0aGUgcHJldmlvdXMgbm9kZSBmcm9tIHRoZSByb290IG5vZGUhXCIpO1xuICAgIH1cblxuICAgIGlmIChtYXRjaCA9PSBudWxsKSB7XG4gICAgICBpZiAoUGF0aC5pc1BhdGgoYXQpKSB7XG4gICAgICAgIHZhciBfRWRpdG9yJHBhcmVudDMgPSBFZGl0b3IucGFyZW50KGVkaXRvciwgYXQpLFxuICAgICAgICAgICAgX0VkaXRvciRwYXJlbnQ0ID0gX3NsaWNlZFRvQXJyYXkoX0VkaXRvciRwYXJlbnQzLCAxKSxcbiAgICAgICAgICAgIHBhcmVudCA9IF9FZGl0b3IkcGFyZW50NFswXTtcblxuICAgICAgICBtYXRjaCA9IGZ1bmN0aW9uIG1hdGNoKG4pIHtcbiAgICAgICAgICByZXR1cm4gcGFyZW50LmNoaWxkcmVuLmluY2x1ZGVzKG4pO1xuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWF0Y2ggPSBmdW5jdGlvbiBtYXRjaCgpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgX0VkaXRvciRub2RlczUgPSBFZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgICByZXZlcnNlOiB0cnVlLFxuICAgICAgYXQ6IHNwYW4sXG4gICAgICBtYXRjaDogbWF0Y2gsXG4gICAgICBtb2RlOiBtb2RlLFxuICAgICAgdm9pZHM6IHZvaWRzXG4gICAgfSksXG4gICAgICAgIF9FZGl0b3Ikbm9kZXM2ID0gX3NsaWNlZFRvQXJyYXkoX0VkaXRvciRub2RlczUsIDEpLFxuICAgICAgICBwcmV2aW91cyA9IF9FZGl0b3Ikbm9kZXM2WzBdO1xuXG4gICAgcmV0dXJuIHByZXZpb3VzO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEdldCBhIHJhbmdlIG9mIGEgbG9jYXRpb24uXHJcbiAgICovXG4gIHJhbmdlOiBmdW5jdGlvbiByYW5nZShlZGl0b3IsIGF0LCB0bykge1xuICAgIGlmIChSYW5nZS5pc1JhbmdlKGF0KSAmJiAhdG8pIHtcbiAgICAgIHJldHVybiBhdDtcbiAgICB9XG5cbiAgICB2YXIgc3RhcnQgPSBFZGl0b3Iuc3RhcnQoZWRpdG9yLCBhdCk7XG4gICAgdmFyIGVuZCA9IEVkaXRvci5lbmQoZWRpdG9yLCB0byB8fCBhdCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFuY2hvcjogc3RhcnQsXG4gICAgICBmb2N1czogZW5kXG4gICAgfTtcbiAgfSxcblxuICAvKipcclxuICAgKiBDcmVhdGUgYSBtdXRhYmxlIHJlZiBmb3IgYSBgUmFuZ2VgIG9iamVjdCwgd2hpY2ggd2lsbCBzdGF5IGluIHN5bmMgYXMgbmV3XHJcbiAgICogb3BlcmF0aW9ucyBhcmUgYXBwbGllZCB0byB0aGUgZWRpdG9yLlxyXG4gICAqL1xuICByYW5nZVJlZjogZnVuY3Rpb24gcmFuZ2VSZWYoZWRpdG9yLCByYW5nZSkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICB2YXIgX29wdGlvbnMkYWZmaW5pdHkzID0gb3B0aW9ucy5hZmZpbml0eSxcbiAgICAgICAgYWZmaW5pdHkgPSBfb3B0aW9ucyRhZmZpbml0eTMgPT09IHZvaWQgMCA/ICdmb3J3YXJkJyA6IF9vcHRpb25zJGFmZmluaXR5MztcbiAgICB2YXIgcmVmID0ge1xuICAgICAgY3VycmVudDogcmFuZ2UsXG4gICAgICBhZmZpbml0eTogYWZmaW5pdHksXG4gICAgICB1bnJlZjogZnVuY3Rpb24gdW5yZWYoKSB7XG4gICAgICAgIHZhciBjdXJyZW50ID0gcmVmLmN1cnJlbnQ7XG4gICAgICAgIHZhciByYW5nZVJlZnMgPSBFZGl0b3IucmFuZ2VSZWZzKGVkaXRvcik7XG4gICAgICAgIHJhbmdlUmVmc1tcImRlbGV0ZVwiXShyZWYpO1xuICAgICAgICByZWYuY3VycmVudCA9IG51bGw7XG4gICAgICAgIHJldHVybiBjdXJyZW50O1xuICAgICAgfVxuICAgIH07XG4gICAgdmFyIHJlZnMgPSBFZGl0b3IucmFuZ2VSZWZzKGVkaXRvcik7XG4gICAgcmVmcy5hZGQocmVmKTtcbiAgICByZXR1cm4gcmVmO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgc2V0IG9mIGN1cnJlbnRseSB0cmFja2VkIHJhbmdlIHJlZnMgb2YgdGhlIGVkaXRvci5cclxuICAgKi9cbiAgcmFuZ2VSZWZzOiBmdW5jdGlvbiByYW5nZVJlZnMoZWRpdG9yKSB7XG4gICAgdmFyIHJlZnMgPSBSQU5HRV9SRUZTLmdldChlZGl0b3IpO1xuXG4gICAgaWYgKCFyZWZzKSB7XG4gICAgICByZWZzID0gbmV3IFNldCgpO1xuICAgICAgUkFOR0VfUkVGUy5zZXQoZWRpdG9yLCByZWZzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVmcztcbiAgfSxcblxuICAvKipcclxuICAgKiBSZW1vdmUgYSBjdXN0b20gcHJvcGVydHkgZnJvbSBhbGwgb2YgdGhlIGxlYWYgdGV4dCBub2RlcyBpbiB0aGUgY3VycmVudFxyXG4gICAqIHNlbGVjdGlvbi5cclxuICAgKlxyXG4gICAqIElmIHRoZSBzZWxlY3Rpb24gaXMgY3VycmVudGx5IGNvbGxhcHNlZCwgdGhlIHJlbW92YWwgd2lsbCBiZSBzdG9yZWQgb25cclxuICAgKiBgZWRpdG9yLm1hcmtzYCBhbmQgYXBwbGllZCB0byB0aGUgdGV4dCBpbnNlcnRlZCBuZXh0LlxyXG4gICAqL1xuICByZW1vdmVNYXJrOiBmdW5jdGlvbiByZW1vdmVNYXJrKGVkaXRvciwga2V5KSB7XG4gICAgZWRpdG9yLnJlbW92ZU1hcmsoa2V5KTtcbiAgfSxcblxuICAvKipcclxuICAgKiBNYW51YWxseSBzZXQgaWYgdGhlIGVkaXRvciBzaG91bGQgY3VycmVudGx5IGJlIG5vcm1hbGl6aW5nLlxyXG4gICAqXHJcbiAgICogTm90ZTogVXNpbmcgdGhpcyBpbmNvcnJlY3RseSBjYW4gbGVhdmUgdGhlIGVkaXRvciBpbiBhbiBpbnZhbGlkIHN0YXRlLlxyXG4gICAqXHJcbiAgICovXG4gIHNldE5vcm1hbGl6aW5nOiBmdW5jdGlvbiBzZXROb3JtYWxpemluZyhlZGl0b3IsIGlzTm9ybWFsaXppbmcpIHtcbiAgICBOT1JNQUxJWklORy5zZXQoZWRpdG9yLCBpc05vcm1hbGl6aW5nKTtcbiAgfSxcblxuICAvKipcclxuICAgKiBHZXQgdGhlIHN0YXJ0IHBvaW50IG9mIGEgbG9jYXRpb24uXHJcbiAgICovXG4gIHN0YXJ0OiBmdW5jdGlvbiBzdGFydChlZGl0b3IsIGF0KSB7XG4gICAgcmV0dXJuIEVkaXRvci5wb2ludChlZGl0b3IsIGF0LCB7XG4gICAgICBlZGdlOiAnc3RhcnQnXG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogR2V0IHRoZSB0ZXh0IHN0cmluZyBjb250ZW50IG9mIGEgbG9jYXRpb24uXHJcbiAgICpcclxuICAgKiBOb3RlOiBieSBkZWZhdWx0IHRoZSB0ZXh0IG9mIHZvaWQgbm9kZXMgaXMgY29uc2lkZXJlZCB0byBiZSBhbiBlbXB0eVxyXG4gICAqIHN0cmluZywgcmVnYXJkbGVzcyBvZiBjb250ZW50LCB1bmxlc3MgeW91IHBhc3MgaW4gdHJ1ZSBmb3IgdGhlIHZvaWRzIG9wdGlvblxyXG4gICAqL1xuICBzdHJpbmc6IGZ1bmN0aW9uIHN0cmluZyhlZGl0b3IsIGF0KSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIHZhciBfb3B0aW9ucyR2b2lkczcgPSBvcHRpb25zLnZvaWRzLFxuICAgICAgICB2b2lkcyA9IF9vcHRpb25zJHZvaWRzNyA9PT0gdm9pZCAwID8gZmFsc2UgOiBfb3B0aW9ucyR2b2lkczc7XG4gICAgdmFyIHJhbmdlID0gRWRpdG9yLnJhbmdlKGVkaXRvciwgYXQpO1xuXG4gICAgdmFyIF9SYW5nZSRlZGdlczUgPSBSYW5nZS5lZGdlcyhyYW5nZSksXG4gICAgICAgIF9SYW5nZSRlZGdlczYgPSBfc2xpY2VkVG9BcnJheShfUmFuZ2UkZWRnZXM1LCAyKSxcbiAgICAgICAgc3RhcnQgPSBfUmFuZ2UkZWRnZXM2WzBdLFxuICAgICAgICBlbmQgPSBfUmFuZ2UkZWRnZXM2WzFdO1xuXG4gICAgdmFyIHRleHQgPSAnJztcblxuICAgIHZhciBfaXRlcmF0b3I4ID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkNShFZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgICBhdDogcmFuZ2UsXG4gICAgICBtYXRjaDogVGV4dC5pc1RleHQsXG4gICAgICB2b2lkczogdm9pZHNcbiAgICB9KSksXG4gICAgICAgIF9zdGVwODtcblxuICAgIHRyeSB7XG4gICAgICBmb3IgKF9pdGVyYXRvcjgucygpOyAhKF9zdGVwOCA9IF9pdGVyYXRvcjgubigpKS5kb25lOykge1xuICAgICAgICB2YXIgX3N0ZXA4JHZhbHVlID0gX3NsaWNlZFRvQXJyYXkoX3N0ZXA4LnZhbHVlLCAyKSxcbiAgICAgICAgICAgIG5vZGUgPSBfc3RlcDgkdmFsdWVbMF0sXG4gICAgICAgICAgICBwYXRoID0gX3N0ZXA4JHZhbHVlWzFdO1xuXG4gICAgICAgIHZhciB0ID0gbm9kZS50ZXh0O1xuXG4gICAgICAgIGlmIChQYXRoLmVxdWFscyhwYXRoLCBlbmQucGF0aCkpIHtcbiAgICAgICAgICB0ID0gdC5zbGljZSgwLCBlbmQub2Zmc2V0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChQYXRoLmVxdWFscyhwYXRoLCBzdGFydC5wYXRoKSkge1xuICAgICAgICAgIHQgPSB0LnNsaWNlKHN0YXJ0Lm9mZnNldCk7XG4gICAgICAgIH1cblxuICAgICAgICB0ZXh0ICs9IHQ7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBfaXRlcmF0b3I4LmUoZXJyKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgX2l0ZXJhdG9yOC5mKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRleHQ7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ29udmVydCBhIHJhbmdlIGludG8gYSBub24taGFuZ2luZyBvbmUuXHJcbiAgICovXG4gIHVuaGFuZ1JhbmdlOiBmdW5jdGlvbiB1bmhhbmdSYW5nZShlZGl0b3IsIHJhbmdlKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIHZhciBfb3B0aW9ucyR2b2lkczggPSBvcHRpb25zLnZvaWRzLFxuICAgICAgICB2b2lkcyA9IF9vcHRpb25zJHZvaWRzOCA9PT0gdm9pZCAwID8gZmFsc2UgOiBfb3B0aW9ucyR2b2lkczg7XG5cbiAgICB2YXIgX1JhbmdlJGVkZ2VzNyA9IFJhbmdlLmVkZ2VzKHJhbmdlKSxcbiAgICAgICAgX1JhbmdlJGVkZ2VzOCA9IF9zbGljZWRUb0FycmF5KF9SYW5nZSRlZGdlczcsIDIpLFxuICAgICAgICBzdGFydCA9IF9SYW5nZSRlZGdlczhbMF0sXG4gICAgICAgIGVuZCA9IF9SYW5nZSRlZGdlczhbMV07IC8vIFBFUkY6IGV4aXQgZWFybHkgaWYgd2UgY2FuIGd1YXJhbnRlZSB0aGF0IHRoZSByYW5nZSBpc24ndCBoYW5naW5nLlxuXG5cbiAgICBpZiAoc3RhcnQub2Zmc2V0ICE9PSAwIHx8IGVuZC5vZmZzZXQgIT09IDAgfHwgUmFuZ2UuaXNDb2xsYXBzZWQocmFuZ2UpIHx8IFBhdGguaGFzUHJldmlvdXMoZW5kLnBhdGgpKSB7XG4gICAgICByZXR1cm4gcmFuZ2U7XG4gICAgfVxuXG4gICAgdmFyIGVuZEJsb2NrID0gRWRpdG9yLmFib3ZlKGVkaXRvciwge1xuICAgICAgYXQ6IGVuZCxcbiAgICAgIG1hdGNoOiBmdW5jdGlvbiBtYXRjaChuKSB7XG4gICAgICAgIHJldHVybiBFbGVtZW50LmlzRWxlbWVudChuKSAmJiBFZGl0b3IuaXNCbG9jayhlZGl0b3IsIG4pO1xuICAgICAgfSxcbiAgICAgIHZvaWRzOiB2b2lkc1xuICAgIH0pO1xuICAgIHZhciBibG9ja1BhdGggPSBlbmRCbG9jayA/IGVuZEJsb2NrWzFdIDogW107XG4gICAgdmFyIGZpcnN0ID0gRWRpdG9yLnN0YXJ0KGVkaXRvciwgc3RhcnQpO1xuICAgIHZhciBiZWZvcmUgPSB7XG4gICAgICBhbmNob3I6IGZpcnN0LFxuICAgICAgZm9jdXM6IGVuZFxuICAgIH07XG4gICAgdmFyIHNraXAgPSB0cnVlO1xuXG4gICAgdmFyIF9pdGVyYXRvcjkgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciQ1KEVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICAgIGF0OiBiZWZvcmUsXG4gICAgICBtYXRjaDogVGV4dC5pc1RleHQsXG4gICAgICByZXZlcnNlOiB0cnVlLFxuICAgICAgdm9pZHM6IHZvaWRzXG4gICAgfSkpLFxuICAgICAgICBfc3RlcDk7XG5cbiAgICB0cnkge1xuICAgICAgZm9yIChfaXRlcmF0b3I5LnMoKTsgIShfc3RlcDkgPSBfaXRlcmF0b3I5Lm4oKSkuZG9uZTspIHtcbiAgICAgICAgdmFyIF9zdGVwOSR2YWx1ZSA9IF9zbGljZWRUb0FycmF5KF9zdGVwOS52YWx1ZSwgMiksXG4gICAgICAgICAgICBub2RlID0gX3N0ZXA5JHZhbHVlWzBdLFxuICAgICAgICAgICAgcGF0aCA9IF9zdGVwOSR2YWx1ZVsxXTtcblxuICAgICAgICBpZiAoc2tpcCkge1xuICAgICAgICAgIHNraXAgPSBmYWxzZTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChub2RlLnRleHQgIT09ICcnIHx8IFBhdGguaXNCZWZvcmUocGF0aCwgYmxvY2tQYXRoKSkge1xuICAgICAgICAgIGVuZCA9IHtcbiAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICBvZmZzZXQ6IG5vZGUudGV4dC5sZW5ndGhcbiAgICAgICAgICB9O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBfaXRlcmF0b3I5LmUoZXJyKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgX2l0ZXJhdG9yOS5mKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGFuY2hvcjogc3RhcnQsXG4gICAgICBmb2N1czogZW5kXG4gICAgfTtcbiAgfSxcblxuICAvKipcclxuICAgKiBNYXRjaCBhIHZvaWQgbm9kZSBpbiB0aGUgY3VycmVudCBicmFuY2ggb2YgdGhlIGVkaXRvci5cclxuICAgKi9cbiAgXCJ2b2lkXCI6IGZ1bmN0aW9uIF92b2lkKGVkaXRvcikge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICByZXR1cm4gRWRpdG9yLmFib3ZlKGVkaXRvciwgX29iamVjdFNwcmVhZCQ4KF9vYmplY3RTcHJlYWQkOCh7fSwgb3B0aW9ucyksIHt9LCB7XG4gICAgICBtYXRjaDogZnVuY3Rpb24gbWF0Y2gobikge1xuICAgICAgICByZXR1cm4gRWxlbWVudC5pc0VsZW1lbnQobikgJiYgRWRpdG9yLmlzVm9pZChlZGl0b3IsIG4pO1xuICAgICAgfVxuICAgIH0pKTtcbiAgfSxcblxuICAvKipcclxuICAgKiBDYWxsIGEgZnVuY3Rpb24sIGRlZmVycmluZyBub3JtYWxpemF0aW9uIHVudGlsIGFmdGVyIGl0IGNvbXBsZXRlcy5cclxuICAgKi9cbiAgd2l0aG91dE5vcm1hbGl6aW5nOiBmdW5jdGlvbiB3aXRob3V0Tm9ybWFsaXppbmcoZWRpdG9yLCBmbikge1xuICAgIHZhciB2YWx1ZSA9IEVkaXRvci5pc05vcm1hbGl6aW5nKGVkaXRvcik7XG4gICAgRWRpdG9yLnNldE5vcm1hbGl6aW5nKGVkaXRvciwgZmFsc2UpO1xuXG4gICAgdHJ5IHtcbiAgICAgIGZuKCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIEVkaXRvci5zZXROb3JtYWxpemluZyhlZGl0b3IsIHZhbHVlKTtcbiAgICB9XG5cbiAgICBFZGl0b3Iubm9ybWFsaXplKGVkaXRvcik7XG4gIH1cbn07XG5cbnZhciBMb2NhdGlvbiA9IHtcbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSB2YWx1ZSBpbXBsZW1lbnRzIHRoZSBgTG9jYXRpb25gIGludGVyZmFjZS5cclxuICAgKi9cbiAgaXNMb2NhdGlvbjogZnVuY3Rpb24gaXNMb2NhdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiBQYXRoLmlzUGF0aCh2YWx1ZSkgfHwgUG9pbnQuaXNQb2ludCh2YWx1ZSkgfHwgUmFuZ2UuaXNSYW5nZSh2YWx1ZSk7XG4gIH1cbn07IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZWRlY2xhcmVcblxudmFyIFNwYW4gPSB7XG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgdmFsdWUgaW1wbGVtZW50cyB0aGUgYFNwYW5gIGludGVyZmFjZS5cclxuICAgKi9cbiAgaXNTcGFuOiBmdW5jdGlvbiBpc1NwYW4odmFsdWUpIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiYgdmFsdWUubGVuZ3RoID09PSAyICYmIHZhbHVlLmV2ZXJ5KFBhdGguaXNQYXRoKTtcbiAgfVxufTtcblxudmFyIF9leGNsdWRlZCQzID0gW1wiY2hpbGRyZW5cIl0sXG4gICAgX2V4Y2x1ZGVkMiQyID0gW1widGV4dFwiXTtcblxuZnVuY3Rpb24gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkNChvLCBhbGxvd0FycmF5TGlrZSkgeyB2YXIgaXQgPSB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXSB8fCBvW1wiQEBpdGVyYXRvclwiXTsgaWYgKCFpdCkgeyBpZiAoQXJyYXkuaXNBcnJheShvKSB8fCAoaXQgPSBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkkNChvKSkgfHwgYWxsb3dBcnJheUxpa2UgJiYgbyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHsgaWYgKGl0KSBvID0gaXQ7IHZhciBpID0gMDsgdmFyIEYgPSBmdW5jdGlvbiBGKCkge307IHJldHVybiB7IHM6IEYsIG46IGZ1bmN0aW9uIG4oKSB7IGlmIChpID49IG8ubGVuZ3RoKSByZXR1cm4geyBkb25lOiB0cnVlIH07IHJldHVybiB7IGRvbmU6IGZhbHNlLCB2YWx1ZTogb1tpKytdIH07IH0sIGU6IGZ1bmN0aW9uIGUoX2UpIHsgdGhyb3cgX2U7IH0sIGY6IEYgfTsgfSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGl0ZXJhdGUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH0gdmFyIG5vcm1hbENvbXBsZXRpb24gPSB0cnVlLCBkaWRFcnIgPSBmYWxzZSwgZXJyOyByZXR1cm4geyBzOiBmdW5jdGlvbiBzKCkgeyBpdCA9IGl0LmNhbGwobyk7IH0sIG46IGZ1bmN0aW9uIG4oKSB7IHZhciBzdGVwID0gaXQubmV4dCgpOyBub3JtYWxDb21wbGV0aW9uID0gc3RlcC5kb25lOyByZXR1cm4gc3RlcDsgfSwgZTogZnVuY3Rpb24gZShfZTIpIHsgZGlkRXJyID0gdHJ1ZTsgZXJyID0gX2UyOyB9LCBmOiBmdW5jdGlvbiBmKCkgeyB0cnkgeyBpZiAoIW5vcm1hbENvbXBsZXRpb24gJiYgaXRbXCJyZXR1cm5cIl0gIT0gbnVsbCkgaXRbXCJyZXR1cm5cIl0oKTsgfSBmaW5hbGx5IHsgaWYgKGRpZEVycikgdGhyb3cgZXJyOyB9IH0gfTsgfVxuXG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkkNChvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5JDQobywgbWluTGVuKTsgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheSQ0KG8sIG1pbkxlbik7IH1cblxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkkNChhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH1cbnZhciBJU19OT0RFX0xJU1RfQ0FDSEUgPSBuZXcgV2Vha01hcCgpOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVkZWNsYXJlXG5cbnZhciBOb2RlID0ge1xuICAvKipcclxuICAgKiBHZXQgdGhlIG5vZGUgYXQgYSBzcGVjaWZpYyBwYXRoLCBhc3NlcnRpbmcgdGhhdCBpdCdzIGFuIGFuY2VzdG9yIG5vZGUuXHJcbiAgICovXG4gIGFuY2VzdG9yOiBmdW5jdGlvbiBhbmNlc3Rvcihyb290LCBwYXRoKSB7XG4gICAgdmFyIG5vZGUgPSBOb2RlLmdldChyb290LCBwYXRoKTtcblxuICAgIGlmIChUZXh0LmlzVGV4dChub2RlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGdldCB0aGUgYW5jZXN0b3Igbm9kZSBhdCBwYXRoIFtcIi5jb25jYXQocGF0aCwgXCJdIGJlY2F1c2UgaXQgcmVmZXJzIHRvIGEgdGV4dCBub2RlIGluc3RlYWQ6IFwiKS5jb25jYXQoU2NydWJiZXIuc3RyaW5naWZ5KG5vZGUpKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGU7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogUmV0dXJuIGEgZ2VuZXJhdG9yIG9mIGFsbCB0aGUgYW5jZXN0b3Igbm9kZXMgYWJvdmUgYSBzcGVjaWZpYyBwYXRoLlxyXG4gICAqXHJcbiAgICogQnkgZGVmYXVsdCB0aGUgb3JkZXIgaXMgdG9wLWRvd24sIGZyb20gaGlnaGVzdCB0byBsb3dlc3QgYW5jZXN0b3IgaW5cclxuICAgKiB0aGUgdHJlZSwgYnV0IHlvdSBjYW4gcGFzcyB0aGUgYHJldmVyc2U6IHRydWVgIG9wdGlvbiB0byBnbyBib3R0b20tdXAuXHJcbiAgICovXG4gIGFuY2VzdG9yczogZnVuY3Rpb24qIGFuY2VzdG9ycyhyb290LCBwYXRoKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuXG4gICAgdmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDQoUGF0aC5hbmNlc3RvcnMocGF0aCwgb3B0aW9ucykpLFxuICAgICAgICBfc3RlcDtcblxuICAgIHRyeSB7XG4gICAgICBmb3IgKF9pdGVyYXRvci5zKCk7ICEoX3N0ZXAgPSBfaXRlcmF0b3IubigpKS5kb25lOykge1xuICAgICAgICB2YXIgcCA9IF9zdGVwLnZhbHVlO1xuICAgICAgICB2YXIgbiA9IE5vZGUuYW5jZXN0b3Iocm9vdCwgcCk7XG4gICAgICAgIHZhciBlbnRyeSA9IFtuLCBwXTtcbiAgICAgICAgeWllbGQgZW50cnk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBfaXRlcmF0b3IuZShlcnIpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBfaXRlcmF0b3IuZigpO1xuICAgIH1cbiAgfSxcblxuICAvKipcclxuICAgKiBHZXQgdGhlIGNoaWxkIG9mIGEgbm9kZSBhdCBhIHNwZWNpZmljIGluZGV4LlxyXG4gICAqL1xuICBjaGlsZDogZnVuY3Rpb24gY2hpbGQocm9vdCwgaW5kZXgpIHtcbiAgICBpZiAoVGV4dC5pc1RleHQocm9vdCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBnZXQgdGhlIGNoaWxkIG9mIGEgdGV4dCBub2RlOiBcIi5jb25jYXQoU2NydWJiZXIuc3RyaW5naWZ5KHJvb3QpKSk7XG4gICAgfVxuXG4gICAgdmFyIGMgPSByb290LmNoaWxkcmVuW2luZGV4XTtcblxuICAgIGlmIChjID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBnZXQgY2hpbGQgYXQgaW5kZXggYFwiLmNvbmNhdChpbmRleCwgXCJgIGluIG5vZGU6IFwiKS5jb25jYXQoU2NydWJiZXIuc3RyaW5naWZ5KHJvb3QpKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGM7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogSXRlcmF0ZSBvdmVyIHRoZSBjaGlsZHJlbiBvZiBhIG5vZGUgYXQgYSBzcGVjaWZpYyBwYXRoLlxyXG4gICAqL1xuICBjaGlsZHJlbjogZnVuY3Rpb24qIGNoaWxkcmVuKHJvb3QsIHBhdGgpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgdmFyIF9vcHRpb25zJHJldmVyc2UgPSBvcHRpb25zLnJldmVyc2UsXG4gICAgICAgIHJldmVyc2UgPSBfb3B0aW9ucyRyZXZlcnNlID09PSB2b2lkIDAgPyBmYWxzZSA6IF9vcHRpb25zJHJldmVyc2U7XG4gICAgdmFyIGFuY2VzdG9yID0gTm9kZS5hbmNlc3Rvcihyb290LCBwYXRoKTtcbiAgICB2YXIgY2hpbGRyZW4gPSBhbmNlc3Rvci5jaGlsZHJlbjtcbiAgICB2YXIgaW5kZXggPSByZXZlcnNlID8gY2hpbGRyZW4ubGVuZ3RoIC0gMSA6IDA7XG5cbiAgICB3aGlsZSAocmV2ZXJzZSA/IGluZGV4ID49IDAgOiBpbmRleCA8IGNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgdmFyIGNoaWxkID0gTm9kZS5jaGlsZChhbmNlc3RvciwgaW5kZXgpO1xuICAgICAgdmFyIGNoaWxkUGF0aCA9IHBhdGguY29uY2F0KGluZGV4KTtcbiAgICAgIHlpZWxkIFtjaGlsZCwgY2hpbGRQYXRoXTtcbiAgICAgIGluZGV4ID0gcmV2ZXJzZSA/IGluZGV4IC0gMSA6IGluZGV4ICsgMTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogR2V0IGFuIGVudHJ5IGZvciB0aGUgY29tbW9uIGFuY2VzZXRvciBub2RlIG9mIHR3byBwYXRocy5cclxuICAgKi9cbiAgY29tbW9uOiBmdW5jdGlvbiBjb21tb24ocm9vdCwgcGF0aCwgYW5vdGhlcikge1xuICAgIHZhciBwID0gUGF0aC5jb21tb24ocGF0aCwgYW5vdGhlcik7XG4gICAgdmFyIG4gPSBOb2RlLmdldChyb290LCBwKTtcbiAgICByZXR1cm4gW24sIHBdO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgbm9kZSBhdCBhIHNwZWNpZmljIHBhdGgsIGFzc2VydGluZyB0aGF0IGl0J3MgYSBkZXNjZW5kYW50IG5vZGUuXHJcbiAgICovXG4gIGRlc2NlbmRhbnQ6IGZ1bmN0aW9uIGRlc2NlbmRhbnQocm9vdCwgcGF0aCkge1xuICAgIHZhciBub2RlID0gTm9kZS5nZXQocm9vdCwgcGF0aCk7XG5cbiAgICBpZiAoRWRpdG9yLmlzRWRpdG9yKG5vZGUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZ2V0IHRoZSBkZXNjZW5kYW50IG5vZGUgYXQgcGF0aCBbXCIuY29uY2F0KHBhdGgsIFwiXSBiZWNhdXNlIGl0IHJlZmVycyB0byB0aGUgcm9vdCBlZGl0b3Igbm9kZSBpbnN0ZWFkOiBcIikuY29uY2F0KFNjcnViYmVyLnN0cmluZ2lmeShub2RlKSkpO1xuICAgIH1cblxuICAgIHJldHVybiBub2RlO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIFJldHVybiBhIGdlbmVyYXRvciBvZiBhbGwgdGhlIGRlc2NlbmRhbnQgbm9kZSBlbnRyaWVzIGluc2lkZSBhIHJvb3Qgbm9kZS5cclxuICAgKi9cbiAgZGVzY2VuZGFudHM6IGZ1bmN0aW9uKiBkZXNjZW5kYW50cyhyb290KSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gICAgdmFyIF9pdGVyYXRvcjIgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciQ0KE5vZGUubm9kZXMocm9vdCwgb3B0aW9ucykpLFxuICAgICAgICBfc3RlcDI7XG5cbiAgICB0cnkge1xuICAgICAgZm9yIChfaXRlcmF0b3IyLnMoKTsgIShfc3RlcDIgPSBfaXRlcmF0b3IyLm4oKSkuZG9uZTspIHtcbiAgICAgICAgdmFyIF9zdGVwMiR2YWx1ZSA9IF9zbGljZWRUb0FycmF5KF9zdGVwMi52YWx1ZSwgMiksXG4gICAgICAgICAgICBub2RlID0gX3N0ZXAyJHZhbHVlWzBdLFxuICAgICAgICAgICAgcGF0aCA9IF9zdGVwMiR2YWx1ZVsxXTtcblxuICAgICAgICBpZiAocGF0aC5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAvLyBOT1RFOiB3ZSBoYXZlIHRvIGNvZXJjZSBoZXJlIGJlY2F1c2UgY2hlY2tpbmcgdGhlIHBhdGgncyBsZW5ndGggZG9lc1xuICAgICAgICAgIC8vIGd1YXJhbnRlZSB0aGF0IGBub2RlYCBpcyBub3QgYSBgRWRpdG9yYCwgYnV0IFR5cGVTY3JpcHQgZG9lc24ndCBrbm93LlxuICAgICAgICAgIHlpZWxkIFtub2RlLCBwYXRoXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgX2l0ZXJhdG9yMi5lKGVycik7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIF9pdGVyYXRvcjIuZigpO1xuICAgIH1cbiAgfSxcblxuICAvKipcclxuICAgKiBSZXR1cm4gYSBnZW5lcmF0b3Igb2YgYWxsIHRoZSBlbGVtZW50IG5vZGVzIGluc2lkZSBhIHJvb3Qgbm9kZS4gRWFjaCBpdGVyYXRpb25cclxuICAgKiB3aWxsIHJldHVybiBhbiBgRWxlbWVudEVudHJ5YCB0dXBsZSBjb25zaXN0aW5nIG9mIGBbRWxlbWVudCwgUGF0aF1gLiBJZiB0aGVcclxuICAgKiByb290IG5vZGUgaXMgYW4gZWxlbWVudCBpdCB3aWxsIGJlIGluY2x1ZGVkIGluIHRoZSBpdGVyYXRpb24gYXMgd2VsbC5cclxuICAgKi9cbiAgZWxlbWVudHM6IGZ1bmN0aW9uKiBlbGVtZW50cyhyb290KSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gICAgdmFyIF9pdGVyYXRvcjMgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciQ0KE5vZGUubm9kZXMocm9vdCwgb3B0aW9ucykpLFxuICAgICAgICBfc3RlcDM7XG5cbiAgICB0cnkge1xuICAgICAgZm9yIChfaXRlcmF0b3IzLnMoKTsgIShfc3RlcDMgPSBfaXRlcmF0b3IzLm4oKSkuZG9uZTspIHtcbiAgICAgICAgdmFyIF9zdGVwMyR2YWx1ZSA9IF9zbGljZWRUb0FycmF5KF9zdGVwMy52YWx1ZSwgMiksXG4gICAgICAgICAgICBub2RlID0gX3N0ZXAzJHZhbHVlWzBdLFxuICAgICAgICAgICAgcGF0aCA9IF9zdGVwMyR2YWx1ZVsxXTtcblxuICAgICAgICBpZiAoRWxlbWVudC5pc0VsZW1lbnQobm9kZSkpIHtcbiAgICAgICAgICB5aWVsZCBbbm9kZSwgcGF0aF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIF9pdGVyYXRvcjMuZShlcnIpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBfaXRlcmF0b3IzLmYoKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogRXh0cmFjdCBwcm9wcyBmcm9tIGEgTm9kZS5cclxuICAgKi9cbiAgZXh0cmFjdFByb3BzOiBmdW5jdGlvbiBleHRyYWN0UHJvcHMobm9kZSkge1xuICAgIGlmIChFbGVtZW50LmlzQW5jZXN0b3Iobm9kZSkpIHtcbiAgICAgIG5vZGUuY2hpbGRyZW47XG4gICAgICAgICAgdmFyIHByb3BlcnRpZXMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMobm9kZSwgX2V4Y2x1ZGVkJDMpO1xuXG4gICAgICByZXR1cm4gcHJvcGVydGllcztcbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZS50ZXh0O1xuICAgICAgICAgIHZhciBfcHJvcGVydGllcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhub2RlLCBfZXhjbHVkZWQyJDIpO1xuXG4gICAgICByZXR1cm4gX3Byb3BlcnRpZXM7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgZmlyc3Qgbm9kZSBlbnRyeSBpbiBhIHJvb3Qgbm9kZSBmcm9tIGEgcGF0aC5cclxuICAgKi9cbiAgZmlyc3Q6IGZ1bmN0aW9uIGZpcnN0KHJvb3QsIHBhdGgpIHtcbiAgICB2YXIgcCA9IHBhdGguc2xpY2UoKTtcbiAgICB2YXIgbiA9IE5vZGUuZ2V0KHJvb3QsIHApO1xuXG4gICAgd2hpbGUgKG4pIHtcbiAgICAgIGlmIChUZXh0LmlzVGV4dChuKSB8fCBuLmNoaWxkcmVuLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG4gPSBuLmNoaWxkcmVuWzBdO1xuICAgICAgICBwLnB1c2goMCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIFtuLCBwXTtcbiAgfSxcblxuICAvKipcclxuICAgKiBHZXQgdGhlIHNsaWNlZCBmcmFnbWVudCByZXByZXNlbnRlZCBieSBhIHJhbmdlIGluc2lkZSBhIHJvb3Qgbm9kZS5cclxuICAgKi9cbiAgZnJhZ21lbnQ6IGZ1bmN0aW9uIGZyYWdtZW50KHJvb3QsIHJhbmdlKSB7XG4gICAgaWYgKFRleHQuaXNUZXh0KHJvb3QpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZ2V0IGEgZnJhZ21lbnQgc3RhcnRpbmcgZnJvbSBhIHJvb3QgdGV4dCBub2RlOiBcIi5jb25jYXQoU2NydWJiZXIuc3RyaW5naWZ5KHJvb3QpKSk7XG4gICAgfVxuXG4gICAgdmFyIG5ld1Jvb3QgPSBpbW1lci5wcm9kdWNlKHtcbiAgICAgIGNoaWxkcmVuOiByb290LmNoaWxkcmVuXG4gICAgfSwgZnVuY3Rpb24gKHIpIHtcbiAgICAgIHZhciBfUmFuZ2UkZWRnZXMgPSBSYW5nZS5lZGdlcyhyYW5nZSksXG4gICAgICAgICAgX1JhbmdlJGVkZ2VzMiA9IF9zbGljZWRUb0FycmF5KF9SYW5nZSRlZGdlcywgMiksXG4gICAgICAgICAgc3RhcnQgPSBfUmFuZ2UkZWRnZXMyWzBdLFxuICAgICAgICAgIGVuZCA9IF9SYW5nZSRlZGdlczJbMV07XG5cbiAgICAgIHZhciBub2RlRW50cmllcyA9IE5vZGUubm9kZXMociwge1xuICAgICAgICByZXZlcnNlOiB0cnVlLFxuICAgICAgICBwYXNzOiBmdW5jdGlvbiBwYXNzKF9yZWYpIHtcbiAgICAgICAgICB2YXIgX3JlZjIgPSBfc2xpY2VkVG9BcnJheShfcmVmLCAyKSxcbiAgICAgICAgICAgICAgcGF0aCA9IF9yZWYyWzFdO1xuXG4gICAgICAgICAgcmV0dXJuICFSYW5nZS5pbmNsdWRlcyhyYW5nZSwgcGF0aCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICB2YXIgX2l0ZXJhdG9yNCA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDQobm9kZUVudHJpZXMpLFxuICAgICAgICAgIF9zdGVwNDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChfaXRlcmF0b3I0LnMoKTsgIShfc3RlcDQgPSBfaXRlcmF0b3I0Lm4oKSkuZG9uZTspIHtcbiAgICAgICAgICB2YXIgX3N0ZXA0JHZhbHVlID0gX3NsaWNlZFRvQXJyYXkoX3N0ZXA0LnZhbHVlLCAyKSxcbiAgICAgICAgICAgICAgcGF0aCA9IF9zdGVwNCR2YWx1ZVsxXTtcblxuICAgICAgICAgIGlmICghUmFuZ2UuaW5jbHVkZXMocmFuZ2UsIHBhdGgpKSB7XG4gICAgICAgICAgICB2YXIgcGFyZW50ID0gTm9kZS5wYXJlbnQociwgcGF0aCk7XG4gICAgICAgICAgICB2YXIgaW5kZXggPSBwYXRoW3BhdGgubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICBwYXJlbnQuY2hpbGRyZW4uc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoUGF0aC5lcXVhbHMocGF0aCwgZW5kLnBhdGgpKSB7XG4gICAgICAgICAgICB2YXIgbGVhZiA9IE5vZGUubGVhZihyLCBwYXRoKTtcbiAgICAgICAgICAgIGxlYWYudGV4dCA9IGxlYWYudGV4dC5zbGljZSgwLCBlbmQub2Zmc2V0KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoUGF0aC5lcXVhbHMocGF0aCwgc3RhcnQucGF0aCkpIHtcbiAgICAgICAgICAgIHZhciBfbGVhZiA9IE5vZGUubGVhZihyLCBwYXRoKTtcblxuICAgICAgICAgICAgX2xlYWYudGV4dCA9IF9sZWFmLnRleHQuc2xpY2Uoc3RhcnQub2Zmc2V0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3I0LmUoZXJyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIF9pdGVyYXRvcjQuZigpO1xuICAgICAgfVxuXG4gICAgICBpZiAoRWRpdG9yLmlzRWRpdG9yKHIpKSB7XG4gICAgICAgIHIuc2VsZWN0aW9uID0gbnVsbDtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gbmV3Um9vdC5jaGlsZHJlbjtcbiAgfSxcblxuICAvKipcclxuICAgKiBHZXQgdGhlIGRlc2NlbmRhbnQgbm9kZSByZWZlcnJlZCB0byBieSBhIHNwZWNpZmljIHBhdGguIElmIHRoZSBwYXRoIGlzIGFuXHJcbiAgICogZW1wdHkgYXJyYXksIGl0IHJlZmVycyB0byB0aGUgcm9vdCBub2RlIGl0c2VsZi5cclxuICAgKi9cbiAgZ2V0OiBmdW5jdGlvbiBnZXQocm9vdCwgcGF0aCkge1xuICAgIHZhciBub2RlID0gcm9vdDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0aC5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHAgPSBwYXRoW2ldO1xuXG4gICAgICBpZiAoVGV4dC5pc1RleHQobm9kZSkgfHwgIW5vZGUuY2hpbGRyZW5bcF0pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgYSBkZXNjZW5kYW50IGF0IHBhdGggW1wiLmNvbmNhdChwYXRoLCBcIl0gaW4gbm9kZTogXCIpLmNvbmNhdChTY3J1YmJlci5zdHJpbmdpZnkocm9vdCkpKTtcbiAgICAgIH1cblxuICAgICAgbm9kZSA9IG5vZGUuY2hpbGRyZW5bcF07XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGU7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSBkZXNjZW5kYW50IG5vZGUgZXhpc3RzIGF0IGEgc3BlY2lmaWMgcGF0aC5cclxuICAgKi9cbiAgaGFzOiBmdW5jdGlvbiBoYXMocm9vdCwgcGF0aCkge1xuICAgIHZhciBub2RlID0gcm9vdDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0aC5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHAgPSBwYXRoW2ldO1xuXG4gICAgICBpZiAoVGV4dC5pc1RleHQobm9kZSkgfHwgIW5vZGUuY2hpbGRyZW5bcF0pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBub2RlID0gbm9kZS5jaGlsZHJlbltwXTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhIHZhbHVlIGltcGxlbWVudHMgdGhlIGBOb2RlYCBpbnRlcmZhY2UuXHJcbiAgICovXG4gIGlzTm9kZTogZnVuY3Rpb24gaXNOb2RlKHZhbHVlKSB7XG4gICAgcmV0dXJuIFRleHQuaXNUZXh0KHZhbHVlKSB8fCBFbGVtZW50LmlzRWxlbWVudCh2YWx1ZSkgfHwgRWRpdG9yLmlzRWRpdG9yKHZhbHVlKTtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhIHZhbHVlIGlzIGEgbGlzdCBvZiBgTm9kZWAgb2JqZWN0cy5cclxuICAgKi9cbiAgaXNOb2RlTGlzdDogZnVuY3Rpb24gaXNOb2RlTGlzdCh2YWx1ZSkge1xuICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgY2FjaGVkUmVzdWx0ID0gSVNfTk9ERV9MSVNUX0NBQ0hFLmdldCh2YWx1ZSk7XG5cbiAgICBpZiAoY2FjaGVkUmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBjYWNoZWRSZXN1bHQ7XG4gICAgfVxuXG4gICAgdmFyIGlzTm9kZUxpc3QgPSB2YWx1ZS5ldmVyeShmdW5jdGlvbiAodmFsKSB7XG4gICAgICByZXR1cm4gTm9kZS5pc05vZGUodmFsKTtcbiAgICB9KTtcbiAgICBJU19OT0RFX0xJU1RfQ0FDSEUuc2V0KHZhbHVlLCBpc05vZGVMaXN0KTtcbiAgICByZXR1cm4gaXNOb2RlTGlzdDtcbiAgfSxcblxuICAvKipcclxuICAgKiBHZXQgdGhlIGxhc3Qgbm9kZSBlbnRyeSBpbiBhIHJvb3Qgbm9kZSBmcm9tIGEgcGF0aC5cclxuICAgKi9cbiAgbGFzdDogZnVuY3Rpb24gbGFzdChyb290LCBwYXRoKSB7XG4gICAgdmFyIHAgPSBwYXRoLnNsaWNlKCk7XG4gICAgdmFyIG4gPSBOb2RlLmdldChyb290LCBwKTtcblxuICAgIHdoaWxlIChuKSB7XG4gICAgICBpZiAoVGV4dC5pc1RleHQobikgfHwgbi5jaGlsZHJlbi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgaSA9IG4uY2hpbGRyZW4ubGVuZ3RoIC0gMTtcbiAgICAgICAgbiA9IG4uY2hpbGRyZW5baV07XG4gICAgICAgIHAucHVzaChpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gW24sIHBdO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgbm9kZSBhdCBhIHNwZWNpZmljIHBhdGgsIGVuc3VyaW5nIGl0J3MgYSBsZWFmIHRleHQgbm9kZS5cclxuICAgKi9cbiAgbGVhZjogZnVuY3Rpb24gbGVhZihyb290LCBwYXRoKSB7XG4gICAgdmFyIG5vZGUgPSBOb2RlLmdldChyb290LCBwYXRoKTtcblxuICAgIGlmICghVGV4dC5pc1RleHQobm9kZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBnZXQgdGhlIGxlYWYgbm9kZSBhdCBwYXRoIFtcIi5jb25jYXQocGF0aCwgXCJdIGJlY2F1c2UgaXQgcmVmZXJzIHRvIGEgbm9uLWxlYWYgbm9kZTogXCIpLmNvbmNhdChTY3J1YmJlci5zdHJpbmdpZnkobm9kZSkpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbm9kZTtcbiAgfSxcblxuICAvKipcclxuICAgKiBSZXR1cm4gYSBnZW5lcmF0b3Igb2YgdGhlIGluIGEgYnJhbmNoIG9mIHRoZSB0cmVlLCBmcm9tIGEgc3BlY2lmaWMgcGF0aC5cclxuICAgKlxyXG4gICAqIEJ5IGRlZmF1bHQgdGhlIG9yZGVyIGlzIHRvcC1kb3duLCBmcm9tIGhpZ2hlc3QgdG8gbG93ZXN0IG5vZGUgaW4gdGhlIHRyZWUsXHJcbiAgICogYnV0IHlvdSBjYW4gcGFzcyB0aGUgYHJldmVyc2U6IHRydWVgIG9wdGlvbiB0byBnbyBib3R0b20tdXAuXHJcbiAgICovXG4gIGxldmVsczogZnVuY3Rpb24qIGxldmVscyhyb290LCBwYXRoKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuXG4gICAgdmFyIF9pdGVyYXRvcjUgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciQ0KFBhdGgubGV2ZWxzKHBhdGgsIG9wdGlvbnMpKSxcbiAgICAgICAgX3N0ZXA1O1xuXG4gICAgdHJ5IHtcbiAgICAgIGZvciAoX2l0ZXJhdG9yNS5zKCk7ICEoX3N0ZXA1ID0gX2l0ZXJhdG9yNS5uKCkpLmRvbmU7KSB7XG4gICAgICAgIHZhciBwID0gX3N0ZXA1LnZhbHVlO1xuICAgICAgICB2YXIgbiA9IE5vZGUuZ2V0KHJvb3QsIHApO1xuICAgICAgICB5aWVsZCBbbiwgcF07XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBfaXRlcmF0b3I1LmUoZXJyKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgX2l0ZXJhdG9yNS5mKCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgbm9kZSBtYXRjaGVzIGEgc2V0IG9mIHByb3BzLlxyXG4gICAqL1xuICBtYXRjaGVzOiBmdW5jdGlvbiBtYXRjaGVzKG5vZGUsIHByb3BzKSB7XG4gICAgcmV0dXJuIEVsZW1lbnQuaXNFbGVtZW50KG5vZGUpICYmIEVsZW1lbnQuaXNFbGVtZW50UHJvcHMocHJvcHMpICYmIEVsZW1lbnQubWF0Y2hlcyhub2RlLCBwcm9wcykgfHwgVGV4dC5pc1RleHQobm9kZSkgJiYgVGV4dC5pc1RleHRQcm9wcyhwcm9wcykgJiYgVGV4dC5tYXRjaGVzKG5vZGUsIHByb3BzKTtcbiAgfSxcblxuICAvKipcclxuICAgKiBSZXR1cm4gYSBnZW5lcmF0b3Igb2YgYWxsIHRoZSBub2RlIGVudHJpZXMgb2YgYSByb290IG5vZGUuIEVhY2ggZW50cnkgaXNcclxuICAgKiByZXR1cm5lZCBhcyBhIGBbTm9kZSwgUGF0aF1gIHR1cGxlLCB3aXRoIHRoZSBwYXRoIHJlZmVycmluZyB0byB0aGUgbm9kZSdzXHJcbiAgICogcG9zaXRpb24gaW5zaWRlIHRoZSByb290IG5vZGUuXHJcbiAgICovXG4gIG5vZGVzOiBmdW5jdGlvbiogbm9kZXMocm9vdCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICB2YXIgcGFzcyA9IG9wdGlvbnMucGFzcyxcbiAgICAgICAgX29wdGlvbnMkcmV2ZXJzZTIgPSBvcHRpb25zLnJldmVyc2UsXG4gICAgICAgIHJldmVyc2UgPSBfb3B0aW9ucyRyZXZlcnNlMiA9PT0gdm9pZCAwID8gZmFsc2UgOiBfb3B0aW9ucyRyZXZlcnNlMjtcbiAgICB2YXIgX29wdGlvbnMkZnJvbSA9IG9wdGlvbnMuZnJvbSxcbiAgICAgICAgZnJvbSA9IF9vcHRpb25zJGZyb20gPT09IHZvaWQgMCA/IFtdIDogX29wdGlvbnMkZnJvbSxcbiAgICAgICAgdG8gPSBvcHRpb25zLnRvO1xuICAgIHZhciB2aXNpdGVkID0gbmV3IFNldCgpO1xuICAgIHZhciBwID0gW107XG4gICAgdmFyIG4gPSByb290O1xuXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGlmICh0byAmJiAocmV2ZXJzZSA/IFBhdGguaXNCZWZvcmUocCwgdG8pIDogUGF0aC5pc0FmdGVyKHAsIHRvKSkpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGlmICghdmlzaXRlZC5oYXMobikpIHtcbiAgICAgICAgeWllbGQgW24sIHBdO1xuICAgICAgfSAvLyBJZiB3ZSdyZSBhbGxvd2VkIHRvIGdvIGRvd253YXJkIGFuZCB3ZSBoYXZlbid0IGRlc2NlbmRlZCB5ZXQsIGRvLlxuXG5cbiAgICAgIGlmICghdmlzaXRlZC5oYXMobikgJiYgIVRleHQuaXNUZXh0KG4pICYmIG4uY2hpbGRyZW4ubGVuZ3RoICE9PSAwICYmIChwYXNzID09IG51bGwgfHwgcGFzcyhbbiwgcF0pID09PSBmYWxzZSkpIHtcbiAgICAgICAgdmlzaXRlZC5hZGQobik7XG4gICAgICAgIHZhciBuZXh0SW5kZXggPSByZXZlcnNlID8gbi5jaGlsZHJlbi5sZW5ndGggLSAxIDogMDtcblxuICAgICAgICBpZiAoUGF0aC5pc0FuY2VzdG9yKHAsIGZyb20pKSB7XG4gICAgICAgICAgbmV4dEluZGV4ID0gZnJvbVtwLmxlbmd0aF07XG4gICAgICAgIH1cblxuICAgICAgICBwID0gcC5jb25jYXQobmV4dEluZGV4KTtcbiAgICAgICAgbiA9IE5vZGUuZ2V0KHJvb3QsIHApO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gLy8gSWYgd2UncmUgYXQgdGhlIHJvb3QgYW5kIHdlIGNhbid0IGdvIGRvd24sIHdlJ3JlIGRvbmUuXG5cblxuICAgICAgaWYgKHAubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfSAvLyBJZiB3ZSdyZSBnb2luZyBmb3J3YXJkLi4uXG5cblxuICAgICAgaWYgKCFyZXZlcnNlKSB7XG4gICAgICAgIHZhciBuZXdQYXRoID0gUGF0aC5uZXh0KHApO1xuXG4gICAgICAgIGlmIChOb2RlLmhhcyhyb290LCBuZXdQYXRoKSkge1xuICAgICAgICAgIHAgPSBuZXdQYXRoO1xuICAgICAgICAgIG4gPSBOb2RlLmdldChyb290LCBwKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfSAvLyBJZiB3ZSdyZSBnb2luZyBiYWNrd2FyZC4uLlxuXG5cbiAgICAgIGlmIChyZXZlcnNlICYmIHBbcC5sZW5ndGggLSAxXSAhPT0gMCkge1xuICAgICAgICB2YXIgX25ld1BhdGggPSBQYXRoLnByZXZpb3VzKHApO1xuXG4gICAgICAgIHAgPSBfbmV3UGF0aDtcbiAgICAgICAgbiA9IE5vZGUuZ2V0KHJvb3QsIHApO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gLy8gT3RoZXJ3aXNlIHdlJ3JlIGdvaW5nIHVwd2FyZC4uLlxuXG5cbiAgICAgIHAgPSBQYXRoLnBhcmVudChwKTtcbiAgICAgIG4gPSBOb2RlLmdldChyb290LCBwKTtcbiAgICAgIHZpc2l0ZWQuYWRkKG4pO1xuICAgIH1cbiAgfSxcblxuICAvKipcclxuICAgKiBHZXQgdGhlIHBhcmVudCBvZiBhIG5vZGUgYXQgYSBzcGVjaWZpYyBwYXRoLlxyXG4gICAqL1xuICBwYXJlbnQ6IGZ1bmN0aW9uIHBhcmVudChyb290LCBwYXRoKSB7XG4gICAgdmFyIHBhcmVudFBhdGggPSBQYXRoLnBhcmVudChwYXRoKTtcbiAgICB2YXIgcCA9IE5vZGUuZ2V0KHJvb3QsIHBhcmVudFBhdGgpO1xuXG4gICAgaWYgKFRleHQuaXNUZXh0KHApKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZ2V0IHRoZSBwYXJlbnQgb2YgcGF0aCBbXCIuY29uY2F0KHBhdGgsIFwiXSBiZWNhdXNlIGl0IGRvZXMgbm90IGV4aXN0IGluIHRoZSByb290LlwiKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHA7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogR2V0IHRoZSBjb25jYXRlbmF0ZWQgdGV4dCBzdHJpbmcgb2YgYSBub2RlJ3MgY29udGVudC5cclxuICAgKlxyXG4gICAqIE5vdGUgdGhhdCB0aGlzIHdpbGwgbm90IGluY2x1ZGUgc3BhY2VzIG9yIGxpbmUgYnJlYWtzIGJldHdlZW4gYmxvY2sgbm9kZXMuXHJcbiAgICogSXQgaXMgbm90IGEgdXNlci1mYWNpbmcgc3RyaW5nLCBidXQgYSBzdHJpbmcgZm9yIHBlcmZvcm1pbmcgb2Zmc2V0LXJlbGF0ZWRcclxuICAgKiBjb21wdXRhdGlvbnMgZm9yIGEgbm9kZS5cclxuICAgKi9cbiAgc3RyaW5nOiBmdW5jdGlvbiBzdHJpbmcobm9kZSkge1xuICAgIGlmIChUZXh0LmlzVGV4dChub2RlKSkge1xuICAgICAgcmV0dXJuIG5vZGUudGV4dDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5vZGUuY2hpbGRyZW4ubWFwKE5vZGUuc3RyaW5nKS5qb2luKCcnKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogUmV0dXJuIGEgZ2VuZXJhdG9yIG9mIGFsbCBsZWFmIHRleHQgbm9kZXMgaW4gYSByb290IG5vZGUuXHJcbiAgICovXG4gIHRleHRzOiBmdW5jdGlvbiogdGV4dHMocm9vdCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICAgIHZhciBfaXRlcmF0b3I2ID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkNChOb2RlLm5vZGVzKHJvb3QsIG9wdGlvbnMpKSxcbiAgICAgICAgX3N0ZXA2O1xuXG4gICAgdHJ5IHtcbiAgICAgIGZvciAoX2l0ZXJhdG9yNi5zKCk7ICEoX3N0ZXA2ID0gX2l0ZXJhdG9yNi5uKCkpLmRvbmU7KSB7XG4gICAgICAgIHZhciBfc3RlcDYkdmFsdWUgPSBfc2xpY2VkVG9BcnJheShfc3RlcDYudmFsdWUsIDIpLFxuICAgICAgICAgICAgbm9kZSA9IF9zdGVwNiR2YWx1ZVswXSxcbiAgICAgICAgICAgIHBhdGggPSBfc3RlcDYkdmFsdWVbMV07XG5cbiAgICAgICAgaWYgKFRleHQuaXNUZXh0KG5vZGUpKSB7XG4gICAgICAgICAgeWllbGQgW25vZGUsIHBhdGhdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBfaXRlcmF0b3I2LmUoZXJyKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgX2l0ZXJhdG9yNi5mKCk7XG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBvd25LZXlzJDcob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBpZiAoZW51bWVyYWJsZU9ubHkpIHsgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyB9IGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkJDcodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgb3duS2V5cyQ3KE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pOyB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7IH0gZWxzZSB7IG93bktleXMkNyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxudmFyIE9wZXJhdGlvbiA9IHtcbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSB2YWx1ZSBpcyBhIGBOb2RlT3BlcmF0aW9uYCBvYmplY3QuXHJcbiAgICovXG4gIGlzTm9kZU9wZXJhdGlvbjogZnVuY3Rpb24gaXNOb2RlT3BlcmF0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIE9wZXJhdGlvbi5pc09wZXJhdGlvbih2YWx1ZSkgJiYgdmFsdWUudHlwZS5lbmRzV2l0aCgnX25vZGUnKTtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhIHZhbHVlIGlzIGFuIGBPcGVyYXRpb25gIG9iamVjdC5cclxuICAgKi9cbiAgaXNPcGVyYXRpb246IGZ1bmN0aW9uIGlzT3BlcmF0aW9uKHZhbHVlKSB7XG4gICAgaWYgKCFpc1BsYWluT2JqZWN0LmlzUGxhaW5PYmplY3QodmFsdWUpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgc3dpdGNoICh2YWx1ZS50eXBlKSB7XG4gICAgICBjYXNlICdpbnNlcnRfbm9kZSc6XG4gICAgICAgIHJldHVybiBQYXRoLmlzUGF0aCh2YWx1ZS5wYXRoKSAmJiBOb2RlLmlzTm9kZSh2YWx1ZS5ub2RlKTtcblxuICAgICAgY2FzZSAnaW5zZXJ0X3RleHQnOlxuICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlLm9mZnNldCA9PT0gJ251bWJlcicgJiYgdHlwZW9mIHZhbHVlLnRleHQgPT09ICdzdHJpbmcnICYmIFBhdGguaXNQYXRoKHZhbHVlLnBhdGgpO1xuXG4gICAgICBjYXNlICdtZXJnZV9ub2RlJzpcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZS5wb3NpdGlvbiA9PT0gJ251bWJlcicgJiYgUGF0aC5pc1BhdGgodmFsdWUucGF0aCkgJiYgaXNQbGFpbk9iamVjdC5pc1BsYWluT2JqZWN0KHZhbHVlLnByb3BlcnRpZXMpO1xuXG4gICAgICBjYXNlICdtb3ZlX25vZGUnOlxuICAgICAgICByZXR1cm4gUGF0aC5pc1BhdGgodmFsdWUucGF0aCkgJiYgUGF0aC5pc1BhdGgodmFsdWUubmV3UGF0aCk7XG5cbiAgICAgIGNhc2UgJ3JlbW92ZV9ub2RlJzpcbiAgICAgICAgcmV0dXJuIFBhdGguaXNQYXRoKHZhbHVlLnBhdGgpICYmIE5vZGUuaXNOb2RlKHZhbHVlLm5vZGUpO1xuXG4gICAgICBjYXNlICdyZW1vdmVfdGV4dCc6XG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUub2Zmc2V0ID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgdmFsdWUudGV4dCA9PT0gJ3N0cmluZycgJiYgUGF0aC5pc1BhdGgodmFsdWUucGF0aCk7XG5cbiAgICAgIGNhc2UgJ3NldF9ub2RlJzpcbiAgICAgICAgcmV0dXJuIFBhdGguaXNQYXRoKHZhbHVlLnBhdGgpICYmIGlzUGxhaW5PYmplY3QuaXNQbGFpbk9iamVjdCh2YWx1ZS5wcm9wZXJ0aWVzKSAmJiBpc1BsYWluT2JqZWN0LmlzUGxhaW5PYmplY3QodmFsdWUubmV3UHJvcGVydGllcyk7XG5cbiAgICAgIGNhc2UgJ3NldF9zZWxlY3Rpb24nOlxuICAgICAgICByZXR1cm4gdmFsdWUucHJvcGVydGllcyA9PT0gbnVsbCAmJiBSYW5nZS5pc1JhbmdlKHZhbHVlLm5ld1Byb3BlcnRpZXMpIHx8IHZhbHVlLm5ld1Byb3BlcnRpZXMgPT09IG51bGwgJiYgUmFuZ2UuaXNSYW5nZSh2YWx1ZS5wcm9wZXJ0aWVzKSB8fCBpc1BsYWluT2JqZWN0LmlzUGxhaW5PYmplY3QodmFsdWUucHJvcGVydGllcykgJiYgaXNQbGFpbk9iamVjdC5pc1BsYWluT2JqZWN0KHZhbHVlLm5ld1Byb3BlcnRpZXMpO1xuXG4gICAgICBjYXNlICdzcGxpdF9ub2RlJzpcbiAgICAgICAgcmV0dXJuIFBhdGguaXNQYXRoKHZhbHVlLnBhdGgpICYmIHR5cGVvZiB2YWx1ZS5wb3NpdGlvbiA9PT0gJ251bWJlcicgJiYgaXNQbGFpbk9iamVjdC5pc1BsYWluT2JqZWN0KHZhbHVlLnByb3BlcnRpZXMpO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgdmFsdWUgaXMgYSBsaXN0IG9mIGBPcGVyYXRpb25gIG9iamVjdHMuXHJcbiAgICovXG4gIGlzT3BlcmF0aW9uTGlzdDogZnVuY3Rpb24gaXNPcGVyYXRpb25MaXN0KHZhbHVlKSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsdWUpICYmIHZhbHVlLmV2ZXJ5KGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgIHJldHVybiBPcGVyYXRpb24uaXNPcGVyYXRpb24odmFsKTtcbiAgICB9KTtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhIHZhbHVlIGlzIGEgYFNlbGVjdGlvbk9wZXJhdGlvbmAgb2JqZWN0LlxyXG4gICAqL1xuICBpc1NlbGVjdGlvbk9wZXJhdGlvbjogZnVuY3Rpb24gaXNTZWxlY3Rpb25PcGVyYXRpb24odmFsdWUpIHtcbiAgICByZXR1cm4gT3BlcmF0aW9uLmlzT3BlcmF0aW9uKHZhbHVlKSAmJiB2YWx1ZS50eXBlLmVuZHNXaXRoKCdfc2VsZWN0aW9uJyk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSB2YWx1ZSBpcyBhIGBUZXh0T3BlcmF0aW9uYCBvYmplY3QuXHJcbiAgICovXG4gIGlzVGV4dE9wZXJhdGlvbjogZnVuY3Rpb24gaXNUZXh0T3BlcmF0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIE9wZXJhdGlvbi5pc09wZXJhdGlvbih2YWx1ZSkgJiYgdmFsdWUudHlwZS5lbmRzV2l0aCgnX3RleHQnKTtcbiAgfSxcblxuICAvKipcclxuICAgKiBJbnZlcnQgYW4gb3BlcmF0aW9uLCByZXR1cm5pbmcgYSBuZXcgb3BlcmF0aW9uIHRoYXQgd2lsbCBleGFjdGx5IHVuZG8gdGhlXHJcbiAgICogb3JpZ2luYWwgd2hlbiBhcHBsaWVkLlxyXG4gICAqL1xuICBpbnZlcnNlOiBmdW5jdGlvbiBpbnZlcnNlKG9wKSB7XG4gICAgc3dpdGNoIChvcC50eXBlKSB7XG4gICAgICBjYXNlICdpbnNlcnRfbm9kZSc6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gX29iamVjdFNwcmVhZCQ3KF9vYmplY3RTcHJlYWQkNyh7fSwgb3ApLCB7fSwge1xuICAgICAgICAgICAgdHlwZTogJ3JlbW92ZV9ub2RlJ1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgJ2luc2VydF90ZXh0JzpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkJDcoX29iamVjdFNwcmVhZCQ3KHt9LCBvcCksIHt9LCB7XG4gICAgICAgICAgICB0eXBlOiAncmVtb3ZlX3RleHQnXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSAnbWVyZ2Vfbm9kZSc6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gX29iamVjdFNwcmVhZCQ3KF9vYmplY3RTcHJlYWQkNyh7fSwgb3ApLCB7fSwge1xuICAgICAgICAgICAgdHlwZTogJ3NwbGl0X25vZGUnLFxuICAgICAgICAgICAgcGF0aDogUGF0aC5wcmV2aW91cyhvcC5wYXRoKVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgJ21vdmVfbm9kZSc6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbmV3UGF0aCA9IG9wLm5ld1BhdGgsXG4gICAgICAgICAgICAgIHBhdGggPSBvcC5wYXRoOyAvLyBQRVJGOiBpbiB0aGlzIGNhc2UgdGhlIG1vdmUgb3BlcmF0aW9uIGlzIGEgbm8tb3AgYW55d2F5cy5cblxuICAgICAgICAgIGlmIChQYXRoLmVxdWFscyhuZXdQYXRoLCBwYXRoKSkge1xuICAgICAgICAgICAgcmV0dXJuIG9wO1xuICAgICAgICAgIH0gLy8gSWYgdGhlIG1vdmUgaGFwcGVucyBjb21wbGV0ZWx5IHdpdGhpbiBhIHNpbmdsZSBwYXJlbnQgdGhlIHBhdGggYW5kXG4gICAgICAgICAgLy8gbmV3UGF0aCBhcmUgc3RhYmxlIHdpdGggcmVzcGVjdCB0byBlYWNoIG90aGVyLlxuXG5cbiAgICAgICAgICBpZiAoUGF0aC5pc1NpYmxpbmcocGF0aCwgbmV3UGF0aCkpIHtcbiAgICAgICAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkJDcoX29iamVjdFNwcmVhZCQ3KHt9LCBvcCksIHt9LCB7XG4gICAgICAgICAgICAgIHBhdGg6IG5ld1BhdGgsXG4gICAgICAgICAgICAgIG5ld1BhdGg6IHBhdGhcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gLy8gSWYgdGhlIG1vdmUgZG9lcyBub3QgaGFwcGVuIHdpdGhpbiBhIHNpbmdsZSBwYXJlbnQgaXQgaXMgcG9zc2libGVcbiAgICAgICAgICAvLyBmb3IgdGhlIG1vdmUgdG8gaW1wYWN0IHRoZSB0cnVlIHBhdGggdG8gdGhlIGxvY2F0aW9uIHdoZXJlIHRoZSBub2RlXG4gICAgICAgICAgLy8gd2FzIHJlbW92ZWQgZnJvbSBhbmQgd2hlcmUgaXQgd2FzIGluc2VydGVkLiBXZSBoYXZlIHRvIGFkanVzdCBmb3IgdGhpc1xuICAgICAgICAgIC8vIGFuZCBmaW5kIHRoZSBvcmlnaW5hbCBwYXRoLiBXZSBjYW4gYWNjb21wbGlzaCB0aGlzIChvbmx5IGluIG5vbi1zaWJsaW5nKVxuICAgICAgICAgIC8vIG1vdmVzIGJ5IGxvb2tpbmcgYXQgdGhlIGltcGFjdCBvZiB0aGUgbW92ZSBvcGVyYXRpb24gb24gdGhlIG5vZGVcbiAgICAgICAgICAvLyBhZnRlciB0aGUgb3JpZ2luYWwgbW92ZSBwYXRoLlxuXG5cbiAgICAgICAgICB2YXIgaW52ZXJzZVBhdGggPSBQYXRoLnRyYW5zZm9ybShwYXRoLCBvcCk7XG4gICAgICAgICAgdmFyIGludmVyc2VOZXdQYXRoID0gUGF0aC50cmFuc2Zvcm0oUGF0aC5uZXh0KHBhdGgpLCBvcCk7XG4gICAgICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQkNyhfb2JqZWN0U3ByZWFkJDcoe30sIG9wKSwge30sIHtcbiAgICAgICAgICAgIHBhdGg6IGludmVyc2VQYXRoLFxuICAgICAgICAgICAgbmV3UGF0aDogaW52ZXJzZU5ld1BhdGhcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlICdyZW1vdmVfbm9kZSc6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gX29iamVjdFNwcmVhZCQ3KF9vYmplY3RTcHJlYWQkNyh7fSwgb3ApLCB7fSwge1xuICAgICAgICAgICAgdHlwZTogJ2luc2VydF9ub2RlJ1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgJ3JlbW92ZV90ZXh0JzpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkJDcoX29iamVjdFNwcmVhZCQ3KHt9LCBvcCksIHt9LCB7XG4gICAgICAgICAgICB0eXBlOiAnaW5zZXJ0X3RleHQnXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSAnc2V0X25vZGUnOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIHByb3BlcnRpZXMgPSBvcC5wcm9wZXJ0aWVzLFxuICAgICAgICAgICAgICBuZXdQcm9wZXJ0aWVzID0gb3AubmV3UHJvcGVydGllcztcbiAgICAgICAgICByZXR1cm4gX29iamVjdFNwcmVhZCQ3KF9vYmplY3RTcHJlYWQkNyh7fSwgb3ApLCB7fSwge1xuICAgICAgICAgICAgcHJvcGVydGllczogbmV3UHJvcGVydGllcyxcbiAgICAgICAgICAgIG5ld1Byb3BlcnRpZXM6IHByb3BlcnRpZXNcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlICdzZXRfc2VsZWN0aW9uJzpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBfcHJvcGVydGllcyA9IG9wLnByb3BlcnRpZXMsXG4gICAgICAgICAgICAgIF9uZXdQcm9wZXJ0aWVzID0gb3AubmV3UHJvcGVydGllcztcblxuICAgICAgICAgIGlmIChfcHJvcGVydGllcyA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gX29iamVjdFNwcmVhZCQ3KF9vYmplY3RTcHJlYWQkNyh7fSwgb3ApLCB7fSwge1xuICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiBfbmV3UHJvcGVydGllcyxcbiAgICAgICAgICAgICAgbmV3UHJvcGVydGllczogbnVsbFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChfbmV3UHJvcGVydGllcyA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gX29iamVjdFNwcmVhZCQ3KF9vYmplY3RTcHJlYWQkNyh7fSwgb3ApLCB7fSwge1xuICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiBudWxsLFxuICAgICAgICAgICAgICBuZXdQcm9wZXJ0aWVzOiBfcHJvcGVydGllc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkJDcoX29iamVjdFNwcmVhZCQ3KHt9LCBvcCksIHt9LCB7XG4gICAgICAgICAgICAgIHByb3BlcnRpZXM6IF9uZXdQcm9wZXJ0aWVzLFxuICAgICAgICAgICAgICBuZXdQcm9wZXJ0aWVzOiBfcHJvcGVydGllc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgIGNhc2UgJ3NwbGl0X25vZGUnOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQkNyhfb2JqZWN0U3ByZWFkJDcoe30sIG9wKSwge30sIHtcbiAgICAgICAgICAgIHR5cGU6ICdtZXJnZV9ub2RlJyxcbiAgICAgICAgICAgIHBhdGg6IFBhdGgubmV4dChvcC5wYXRoKVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICB9XG59O1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVkZWNsYXJlXG52YXIgUGF0aCA9IHtcbiAgLyoqXHJcbiAgICogR2V0IGEgbGlzdCBvZiBhbmNlc3RvciBwYXRocyBmb3IgYSBnaXZlbiBwYXRoLlxyXG4gICAqXHJcbiAgICogVGhlIHBhdGhzIGFyZSBzb3J0ZWQgZnJvbSBzaGFsbG93ZXN0IHRvIGRlZXBlc3QgYW5jZXN0b3IuIEhvd2V2ZXIsIGlmIHRoZVxyXG4gICAqIGByZXZlcnNlOiB0cnVlYCBvcHRpb24gaXMgcGFzc2VkLCB0aGV5IGFyZSByZXZlcnNlZC5cclxuICAgKi9cbiAgYW5jZXN0b3JzOiBmdW5jdGlvbiBhbmNlc3RvcnMocGF0aCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICB2YXIgX29wdGlvbnMkcmV2ZXJzZSA9IG9wdGlvbnMucmV2ZXJzZSxcbiAgICAgICAgcmV2ZXJzZSA9IF9vcHRpb25zJHJldmVyc2UgPT09IHZvaWQgMCA/IGZhbHNlIDogX29wdGlvbnMkcmV2ZXJzZTtcbiAgICB2YXIgcGF0aHMgPSBQYXRoLmxldmVscyhwYXRoLCBvcHRpb25zKTtcblxuICAgIGlmIChyZXZlcnNlKSB7XG4gICAgICBwYXRocyA9IHBhdGhzLnNsaWNlKDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXRocyA9IHBhdGhzLnNsaWNlKDAsIC0xKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGF0aHM7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogR2V0IHRoZSBjb21tb24gYW5jZXN0b3IgcGF0aCBvZiB0d28gcGF0aHMuXHJcbiAgICovXG4gIGNvbW1vbjogZnVuY3Rpb24gY29tbW9uKHBhdGgsIGFub3RoZXIpIHtcbiAgICB2YXIgY29tbW9uID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdGgubGVuZ3RoICYmIGkgPCBhbm90aGVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgYXYgPSBwYXRoW2ldO1xuICAgICAgdmFyIGJ2ID0gYW5vdGhlcltpXTtcblxuICAgICAgaWYgKGF2ICE9PSBidikge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgY29tbW9uLnB1c2goYXYpO1xuICAgIH1cblxuICAgIHJldHVybiBjb21tb247XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ29tcGFyZSBhIHBhdGggdG8gYW5vdGhlciwgcmV0dXJuaW5nIGFuIGludGVnZXIgaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBwYXRoXHJcbiAgICogd2FzIGJlZm9yZSwgYXQsIG9yIGFmdGVyIHRoZSBvdGhlci5cclxuICAgKlxyXG4gICAqIE5vdGU6IFR3byBwYXRocyBvZiB1bmVxdWFsIGxlbmd0aCBjYW4gc3RpbGwgcmVjZWl2ZSBhIGAwYCByZXN1bHQgaWYgb25lIGlzXHJcbiAgICogZGlyZWN0bHkgYWJvdmUgb3IgYmVsb3cgdGhlIG90aGVyLiBJZiB5b3Ugd2FudCBleGFjdCBtYXRjaGluZywgdXNlXHJcbiAgICogW1tQYXRoLmVxdWFsc11dIGluc3RlYWQuXHJcbiAgICovXG4gIGNvbXBhcmU6IGZ1bmN0aW9uIGNvbXBhcmUocGF0aCwgYW5vdGhlcikge1xuICAgIHZhciBtaW4gPSBNYXRoLm1pbihwYXRoLmxlbmd0aCwgYW5vdGhlci5sZW5ndGgpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtaW47IGkrKykge1xuICAgICAgaWYgKHBhdGhbaV0gPCBhbm90aGVyW2ldKSByZXR1cm4gLTE7XG4gICAgICBpZiAocGF0aFtpXSA+IGFub3RoZXJbaV0pIHJldHVybiAxO1xuICAgIH1cblxuICAgIHJldHVybiAwO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgcGF0aCBlbmRzIGFmdGVyIG9uZSBvZiB0aGUgaW5kZXhlcyBpbiBhbm90aGVyLlxyXG4gICAqL1xuICBlbmRzQWZ0ZXI6IGZ1bmN0aW9uIGVuZHNBZnRlcihwYXRoLCBhbm90aGVyKSB7XG4gICAgdmFyIGkgPSBwYXRoLmxlbmd0aCAtIDE7XG4gICAgdmFyIGFzID0gcGF0aC5zbGljZSgwLCBpKTtcbiAgICB2YXIgYnMgPSBhbm90aGVyLnNsaWNlKDAsIGkpO1xuICAgIHZhciBhdiA9IHBhdGhbaV07XG4gICAgdmFyIGJ2ID0gYW5vdGhlcltpXTtcbiAgICByZXR1cm4gUGF0aC5lcXVhbHMoYXMsIGJzKSAmJiBhdiA+IGJ2O1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgcGF0aCBlbmRzIGF0IG9uZSBvZiB0aGUgaW5kZXhlcyBpbiBhbm90aGVyLlxyXG4gICAqL1xuICBlbmRzQXQ6IGZ1bmN0aW9uIGVuZHNBdChwYXRoLCBhbm90aGVyKSB7XG4gICAgdmFyIGkgPSBwYXRoLmxlbmd0aDtcbiAgICB2YXIgYXMgPSBwYXRoLnNsaWNlKDAsIGkpO1xuICAgIHZhciBicyA9IGFub3RoZXIuc2xpY2UoMCwgaSk7XG4gICAgcmV0dXJuIFBhdGguZXF1YWxzKGFzLCBicyk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSBwYXRoIGVuZHMgYmVmb3JlIG9uZSBvZiB0aGUgaW5kZXhlcyBpbiBhbm90aGVyLlxyXG4gICAqL1xuICBlbmRzQmVmb3JlOiBmdW5jdGlvbiBlbmRzQmVmb3JlKHBhdGgsIGFub3RoZXIpIHtcbiAgICB2YXIgaSA9IHBhdGgubGVuZ3RoIC0gMTtcbiAgICB2YXIgYXMgPSBwYXRoLnNsaWNlKDAsIGkpO1xuICAgIHZhciBicyA9IGFub3RoZXIuc2xpY2UoMCwgaSk7XG4gICAgdmFyIGF2ID0gcGF0aFtpXTtcbiAgICB2YXIgYnYgPSBhbm90aGVyW2ldO1xuICAgIHJldHVybiBQYXRoLmVxdWFscyhhcywgYnMpICYmIGF2IDwgYnY7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSBwYXRoIGlzIGV4YWN0bHkgZXF1YWwgdG8gYW5vdGhlci5cclxuICAgKi9cbiAgZXF1YWxzOiBmdW5jdGlvbiBlcXVhbHMocGF0aCwgYW5vdGhlcikge1xuICAgIHJldHVybiBwYXRoLmxlbmd0aCA9PT0gYW5vdGhlci5sZW5ndGggJiYgcGF0aC5ldmVyeShmdW5jdGlvbiAobiwgaSkge1xuICAgICAgcmV0dXJuIG4gPT09IGFub3RoZXJbaV07XG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgdGhlIHBhdGggb2YgcHJldmlvdXMgc2libGluZyBub2RlIGV4aXN0c1xyXG4gICAqL1xuICBoYXNQcmV2aW91czogZnVuY3Rpb24gaGFzUHJldmlvdXMocGF0aCkge1xuICAgIHJldHVybiBwYXRoW3BhdGgubGVuZ3RoIC0gMV0gPiAwO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgcGF0aCBpcyBhZnRlciBhbm90aGVyLlxyXG4gICAqL1xuICBpc0FmdGVyOiBmdW5jdGlvbiBpc0FmdGVyKHBhdGgsIGFub3RoZXIpIHtcbiAgICByZXR1cm4gUGF0aC5jb21wYXJlKHBhdGgsIGFub3RoZXIpID09PSAxO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgcGF0aCBpcyBhbiBhbmNlc3RvciBvZiBhbm90aGVyLlxyXG4gICAqL1xuICBpc0FuY2VzdG9yOiBmdW5jdGlvbiBpc0FuY2VzdG9yKHBhdGgsIGFub3RoZXIpIHtcbiAgICByZXR1cm4gcGF0aC5sZW5ndGggPCBhbm90aGVyLmxlbmd0aCAmJiBQYXRoLmNvbXBhcmUocGF0aCwgYW5vdGhlcikgPT09IDA7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSBwYXRoIGlzIGJlZm9yZSBhbm90aGVyLlxyXG4gICAqL1xuICBpc0JlZm9yZTogZnVuY3Rpb24gaXNCZWZvcmUocGF0aCwgYW5vdGhlcikge1xuICAgIHJldHVybiBQYXRoLmNvbXBhcmUocGF0aCwgYW5vdGhlcikgPT09IC0xO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgcGF0aCBpcyBhIGNoaWxkIG9mIGFub3RoZXIuXHJcbiAgICovXG4gIGlzQ2hpbGQ6IGZ1bmN0aW9uIGlzQ2hpbGQocGF0aCwgYW5vdGhlcikge1xuICAgIHJldHVybiBwYXRoLmxlbmd0aCA9PT0gYW5vdGhlci5sZW5ndGggKyAxICYmIFBhdGguY29tcGFyZShwYXRoLCBhbm90aGVyKSA9PT0gMDtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhIHBhdGggaXMgZXF1YWwgdG8gb3IgYW4gYW5jZXN0b3Igb2YgYW5vdGhlci5cclxuICAgKi9cbiAgaXNDb21tb246IGZ1bmN0aW9uIGlzQ29tbW9uKHBhdGgsIGFub3RoZXIpIHtcbiAgICByZXR1cm4gcGF0aC5sZW5ndGggPD0gYW5vdGhlci5sZW5ndGggJiYgUGF0aC5jb21wYXJlKHBhdGgsIGFub3RoZXIpID09PSAwO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgcGF0aCBpcyBhIGRlc2NlbmRhbnQgb2YgYW5vdGhlci5cclxuICAgKi9cbiAgaXNEZXNjZW5kYW50OiBmdW5jdGlvbiBpc0Rlc2NlbmRhbnQocGF0aCwgYW5vdGhlcikge1xuICAgIHJldHVybiBwYXRoLmxlbmd0aCA+IGFub3RoZXIubGVuZ3RoICYmIFBhdGguY29tcGFyZShwYXRoLCBhbm90aGVyKSA9PT0gMDtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhIHBhdGggaXMgdGhlIHBhcmVudCBvZiBhbm90aGVyLlxyXG4gICAqL1xuICBpc1BhcmVudDogZnVuY3Rpb24gaXNQYXJlbnQocGF0aCwgYW5vdGhlcikge1xuICAgIHJldHVybiBwYXRoLmxlbmd0aCArIDEgPT09IGFub3RoZXIubGVuZ3RoICYmIFBhdGguY29tcGFyZShwYXRoLCBhbm90aGVyKSA9PT0gMDtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpcyBhIHZhbHVlIGltcGxlbWVudHMgdGhlIGBQYXRoYCBpbnRlcmZhY2UuXHJcbiAgICovXG4gIGlzUGF0aDogZnVuY3Rpb24gaXNQYXRoKHZhbHVlKSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsdWUpICYmICh2YWx1ZS5sZW5ndGggPT09IDAgfHwgdHlwZW9mIHZhbHVlWzBdID09PSAnbnVtYmVyJyk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSBwYXRoIGlzIGEgc2libGluZyBvZiBhbm90aGVyLlxyXG4gICAqL1xuICBpc1NpYmxpbmc6IGZ1bmN0aW9uIGlzU2libGluZyhwYXRoLCBhbm90aGVyKSB7XG4gICAgaWYgKHBhdGgubGVuZ3RoICE9PSBhbm90aGVyLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBhcyA9IHBhdGguc2xpY2UoMCwgLTEpO1xuICAgIHZhciBicyA9IGFub3RoZXIuc2xpY2UoMCwgLTEpO1xuICAgIHZhciBhbCA9IHBhdGhbcGF0aC5sZW5ndGggLSAxXTtcbiAgICB2YXIgYmwgPSBhbm90aGVyW2Fub3RoZXIubGVuZ3RoIC0gMV07XG4gICAgcmV0dXJuIGFsICE9PSBibCAmJiBQYXRoLmVxdWFscyhhcywgYnMpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEdldCBhIGxpc3Qgb2YgcGF0aHMgYXQgZXZlcnkgbGV2ZWwgZG93biB0byBhIHBhdGguIE5vdGU6IHRoaXMgaXMgdGhlIHNhbWVcclxuICAgKiBhcyBgUGF0aC5hbmNlc3RvcnNgLCBidXQgaW5jbHVkaW5nIHRoZSBwYXRoIGl0c2VsZi5cclxuICAgKlxyXG4gICAqIFRoZSBwYXRocyBhcmUgc29ydGVkIGZyb20gc2hhbGxvd2VzdCB0byBkZWVwZXN0LiBIb3dldmVyLCBpZiB0aGUgYHJldmVyc2U6XHJcbiAgICogdHJ1ZWAgb3B0aW9uIGlzIHBhc3NlZCwgdGhleSBhcmUgcmV2ZXJzZWQuXHJcbiAgICovXG4gIGxldmVsczogZnVuY3Rpb24gbGV2ZWxzKHBhdGgpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgdmFyIF9vcHRpb25zJHJldmVyc2UyID0gb3B0aW9ucy5yZXZlcnNlLFxuICAgICAgICByZXZlcnNlID0gX29wdGlvbnMkcmV2ZXJzZTIgPT09IHZvaWQgMCA/IGZhbHNlIDogX29wdGlvbnMkcmV2ZXJzZTI7XG4gICAgdmFyIGxpc3QgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDw9IHBhdGgubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxpc3QucHVzaChwYXRoLnNsaWNlKDAsIGkpKTtcbiAgICB9XG5cbiAgICBpZiAocmV2ZXJzZSkge1xuICAgICAgbGlzdC5yZXZlcnNlKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGxpc3Q7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogR2l2ZW4gYSBwYXRoLCBnZXQgdGhlIHBhdGggdG8gdGhlIG5leHQgc2libGluZyBub2RlLlxyXG4gICAqL1xuICBuZXh0OiBmdW5jdGlvbiBuZXh0KHBhdGgpIHtcbiAgICBpZiAocGF0aC5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBnZXQgdGhlIG5leHQgcGF0aCBvZiBhIHJvb3QgcGF0aCBbXCIuY29uY2F0KHBhdGgsIFwiXSwgYmVjYXVzZSBpdCBoYXMgbm8gbmV4dCBpbmRleC5cIikpO1xuICAgIH1cblxuICAgIHZhciBsYXN0ID0gcGF0aFtwYXRoLmxlbmd0aCAtIDFdO1xuICAgIHJldHVybiBwYXRoLnNsaWNlKDAsIC0xKS5jb25jYXQobGFzdCArIDEpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIFJldHVybnMgd2hldGhlciB0aGlzIG9wZXJhdGlvbiBjYW4gYWZmZWN0IHBhdGhzIG9yIG5vdC4gVXNlZCBhcyBhblxyXG4gICAqIG9wdGltaXphdGlvbiB3aGVuIHVwZGF0aW5nIGRpcnR5IHBhdGhzIGR1cmluZyBub3JtYWxpemF0aW9uXHJcbiAgICpcclxuICAgKiBOT1RFOiBUaGlzICptdXN0KiBiZSBrZXB0IGluIHN5bmMgd2l0aCB0aGUgaW1wbGVtZW50YXRpb24gb2YgJ3RyYW5zZm9ybSdcclxuICAgKiBiZWxvd1xyXG4gICAqL1xuICBvcGVyYXRpb25DYW5UcmFuc2Zvcm1QYXRoOiBmdW5jdGlvbiBvcGVyYXRpb25DYW5UcmFuc2Zvcm1QYXRoKG9wZXJhdGlvbikge1xuICAgIHN3aXRjaCAob3BlcmF0aW9uLnR5cGUpIHtcbiAgICAgIGNhc2UgJ2luc2VydF9ub2RlJzpcbiAgICAgIGNhc2UgJ3JlbW92ZV9ub2RlJzpcbiAgICAgIGNhc2UgJ21lcmdlX25vZGUnOlxuICAgICAgY2FzZSAnc3BsaXRfbm9kZSc6XG4gICAgICBjYXNlICdtb3ZlX25vZGUnOlxuICAgICAgICByZXR1cm4gdHJ1ZTtcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSxcblxuICAvKipcclxuICAgKiBHaXZlbiBhIHBhdGgsIHJldHVybiBhIG5ldyBwYXRoIHJlZmVycmluZyB0byB0aGUgcGFyZW50IG5vZGUgYWJvdmUgaXQuXHJcbiAgICovXG4gIHBhcmVudDogZnVuY3Rpb24gcGFyZW50KHBhdGgpIHtcbiAgICBpZiAocGF0aC5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBnZXQgdGhlIHBhcmVudCBwYXRoIG9mIHRoZSByb290IHBhdGggW1wiLmNvbmNhdChwYXRoLCBcIl0uXCIpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGF0aC5zbGljZSgwLCAtMSk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogR2l2ZW4gYSBwYXRoLCBnZXQgdGhlIHBhdGggdG8gdGhlIHByZXZpb3VzIHNpYmxpbmcgbm9kZS5cclxuICAgKi9cbiAgcHJldmlvdXM6IGZ1bmN0aW9uIHByZXZpb3VzKHBhdGgpIHtcbiAgICBpZiAocGF0aC5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBnZXQgdGhlIHByZXZpb3VzIHBhdGggb2YgYSByb290IHBhdGggW1wiLmNvbmNhdChwYXRoLCBcIl0sIGJlY2F1c2UgaXQgaGFzIG5vIHByZXZpb3VzIGluZGV4LlwiKSk7XG4gICAgfVxuXG4gICAgdmFyIGxhc3QgPSBwYXRoW3BhdGgubGVuZ3RoIC0gMV07XG5cbiAgICBpZiAobGFzdCA8PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZ2V0IHRoZSBwcmV2aW91cyBwYXRoIG9mIGEgZmlyc3QgY2hpbGQgcGF0aCBbXCIuY29uY2F0KHBhdGgsIFwiXSBiZWNhdXNlIGl0IHdvdWxkIHJlc3VsdCBpbiBhIG5lZ2F0aXZlIGluZGV4LlwiKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhdGguc2xpY2UoMCwgLTEpLmNvbmNhdChsYXN0IC0gMSk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogR2V0IGEgcGF0aCByZWxhdGl2ZSB0byBhbiBhbmNlc3Rvci5cclxuICAgKi9cbiAgcmVsYXRpdmU6IGZ1bmN0aW9uIHJlbGF0aXZlKHBhdGgsIGFuY2VzdG9yKSB7XG4gICAgaWYgKCFQYXRoLmlzQW5jZXN0b3IoYW5jZXN0b3IsIHBhdGgpICYmICFQYXRoLmVxdWFscyhwYXRoLCBhbmNlc3RvcikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBnZXQgdGhlIHJlbGF0aXZlIHBhdGggb2YgW1wiLmNvbmNhdChwYXRoLCBcIl0gaW5zaWRlIGFuY2VzdG9yIFtcIikuY29uY2F0KGFuY2VzdG9yLCBcIl0sIGJlY2F1c2UgaXQgaXMgbm90IGFib3ZlIG9yIGVxdWFsIHRvIHRoZSBwYXRoLlwiKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhdGguc2xpY2UoYW5jZXN0b3IubGVuZ3RoKTtcbiAgfSxcblxuICAvKipcclxuICAgKiBUcmFuc2Zvcm0gYSBwYXRoIGJ5IGFuIG9wZXJhdGlvbi5cclxuICAgKi9cbiAgdHJhbnNmb3JtOiBmdW5jdGlvbiB0cmFuc2Zvcm0ocGF0aCwgb3BlcmF0aW9uKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIGlmICghcGF0aCkgcmV0dXJuIG51bGw7IC8vIFBFUkY6IHVzZSBkZXN0cnVjdGluZyBpbnN0ZWFkIG9mIGltbWVyXG5cbiAgICB2YXIgcCA9IF90b0NvbnN1bWFibGVBcnJheShwYXRoKTtcblxuICAgIHZhciBfb3B0aW9ucyRhZmZpbml0eSA9IG9wdGlvbnMuYWZmaW5pdHksXG4gICAgICAgIGFmZmluaXR5ID0gX29wdGlvbnMkYWZmaW5pdHkgPT09IHZvaWQgMCA/ICdmb3J3YXJkJyA6IF9vcHRpb25zJGFmZmluaXR5OyAvLyBQRVJGOiBFeGl0IGVhcmx5IGlmIHRoZSBvcGVyYXRpb24gaXMgZ3VhcmFudGVlZCBub3QgdG8gaGF2ZSBhbiBlZmZlY3QuXG5cbiAgICBpZiAocGF0aC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBwO1xuICAgIH1cblxuICAgIHN3aXRjaCAob3BlcmF0aW9uLnR5cGUpIHtcbiAgICAgIGNhc2UgJ2luc2VydF9ub2RlJzpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBvcCA9IG9wZXJhdGlvbi5wYXRoO1xuXG4gICAgICAgICAgaWYgKFBhdGguZXF1YWxzKG9wLCBwKSB8fCBQYXRoLmVuZHNCZWZvcmUob3AsIHApIHx8IFBhdGguaXNBbmNlc3RvcihvcCwgcCkpIHtcbiAgICAgICAgICAgIHBbb3AubGVuZ3RoIC0gMV0gKz0gMTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlICdyZW1vdmVfbm9kZSc6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgX29wID0gb3BlcmF0aW9uLnBhdGg7XG5cbiAgICAgICAgICBpZiAoUGF0aC5lcXVhbHMoX29wLCBwKSB8fCBQYXRoLmlzQW5jZXN0b3IoX29wLCBwKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfSBlbHNlIGlmIChQYXRoLmVuZHNCZWZvcmUoX29wLCBwKSkge1xuICAgICAgICAgICAgcFtfb3AubGVuZ3RoIC0gMV0gLT0gMTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlICdtZXJnZV9ub2RlJzpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBfb3AyID0gb3BlcmF0aW9uLnBhdGgsXG4gICAgICAgICAgICAgIHBvc2l0aW9uID0gb3BlcmF0aW9uLnBvc2l0aW9uO1xuXG4gICAgICAgICAgaWYgKFBhdGguZXF1YWxzKF9vcDIsIHApIHx8IFBhdGguZW5kc0JlZm9yZShfb3AyLCBwKSkge1xuICAgICAgICAgICAgcFtfb3AyLmxlbmd0aCAtIDFdIC09IDE7XG4gICAgICAgICAgfSBlbHNlIGlmIChQYXRoLmlzQW5jZXN0b3IoX29wMiwgcCkpIHtcbiAgICAgICAgICAgIHBbX29wMi5sZW5ndGggLSAxXSAtPSAxO1xuICAgICAgICAgICAgcFtfb3AyLmxlbmd0aF0gKz0gcG9zaXRpb247XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSAnc3BsaXRfbm9kZSc6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgX29wMyA9IG9wZXJhdGlvbi5wYXRoLFxuICAgICAgICAgICAgICBfcG9zaXRpb24gPSBvcGVyYXRpb24ucG9zaXRpb247XG5cbiAgICAgICAgICBpZiAoUGF0aC5lcXVhbHMoX29wMywgcCkpIHtcbiAgICAgICAgICAgIGlmIChhZmZpbml0eSA9PT0gJ2ZvcndhcmQnKSB7XG4gICAgICAgICAgICAgIHBbcC5sZW5ndGggLSAxXSArPSAxO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChhZmZpbml0eSA9PT0gJ2JhY2t3YXJkJykgOyBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChQYXRoLmVuZHNCZWZvcmUoX29wMywgcCkpIHtcbiAgICAgICAgICAgIHBbX29wMy5sZW5ndGggLSAxXSArPSAxO1xuICAgICAgICAgIH0gZWxzZSBpZiAoUGF0aC5pc0FuY2VzdG9yKF9vcDMsIHApICYmIHBhdGhbX29wMy5sZW5ndGhdID49IF9wb3NpdGlvbikge1xuICAgICAgICAgICAgcFtfb3AzLmxlbmd0aCAtIDFdICs9IDE7XG4gICAgICAgICAgICBwW19vcDMubGVuZ3RoXSAtPSBfcG9zaXRpb247XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSAnbW92ZV9ub2RlJzpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBfb3A0ID0gb3BlcmF0aW9uLnBhdGgsXG4gICAgICAgICAgICAgIG9ucCA9IG9wZXJhdGlvbi5uZXdQYXRoOyAvLyBJZiB0aGUgb2xkIGFuZCBuZXcgcGF0aCBhcmUgdGhlIHNhbWUsIGl0J3MgYSBuby1vcC5cblxuICAgICAgICAgIGlmIChQYXRoLmVxdWFscyhfb3A0LCBvbnApKSB7XG4gICAgICAgICAgICByZXR1cm4gcDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoUGF0aC5pc0FuY2VzdG9yKF9vcDQsIHApIHx8IFBhdGguZXF1YWxzKF9vcDQsIHApKSB7XG4gICAgICAgICAgICB2YXIgY29weSA9IG9ucC5zbGljZSgpO1xuXG4gICAgICAgICAgICBpZiAoUGF0aC5lbmRzQmVmb3JlKF9vcDQsIG9ucCkgJiYgX29wNC5sZW5ndGggPCBvbnAubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIGNvcHlbX29wNC5sZW5ndGggLSAxXSAtPSAxO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gY29weS5jb25jYXQocC5zbGljZShfb3A0Lmxlbmd0aCkpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoUGF0aC5pc1NpYmxpbmcoX29wNCwgb25wKSAmJiAoUGF0aC5pc0FuY2VzdG9yKG9ucCwgcCkgfHwgUGF0aC5lcXVhbHMob25wLCBwKSkpIHtcbiAgICAgICAgICAgIGlmIChQYXRoLmVuZHNCZWZvcmUoX29wNCwgcCkpIHtcbiAgICAgICAgICAgICAgcFtfb3A0Lmxlbmd0aCAtIDFdIC09IDE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBwW19vcDQubGVuZ3RoIC0gMV0gKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKFBhdGguZW5kc0JlZm9yZShvbnAsIHApIHx8IFBhdGguZXF1YWxzKG9ucCwgcCkgfHwgUGF0aC5pc0FuY2VzdG9yKG9ucCwgcCkpIHtcbiAgICAgICAgICAgIGlmIChQYXRoLmVuZHNCZWZvcmUoX29wNCwgcCkpIHtcbiAgICAgICAgICAgICAgcFtfb3A0Lmxlbmd0aCAtIDFdIC09IDE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHBbb25wLmxlbmd0aCAtIDFdICs9IDE7XG4gICAgICAgICAgfSBlbHNlIGlmIChQYXRoLmVuZHNCZWZvcmUoX29wNCwgcCkpIHtcbiAgICAgICAgICAgIGlmIChQYXRoLmVxdWFscyhvbnAsIHApKSB7XG4gICAgICAgICAgICAgIHBbb25wLmxlbmd0aCAtIDFdICs9IDE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHBbX29wNC5sZW5ndGggLSAxXSAtPSAxO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHA7XG4gIH1cbn07XG5cbnZhciBQYXRoUmVmID0ge1xuICAvKipcclxuICAgKiBUcmFuc2Zvcm0gdGhlIHBhdGggcmVmJ3MgY3VycmVudCB2YWx1ZSBieSBhbiBvcGVyYXRpb24uXHJcbiAgICovXG4gIHRyYW5zZm9ybTogZnVuY3Rpb24gdHJhbnNmb3JtKHJlZiwgb3ApIHtcbiAgICB2YXIgY3VycmVudCA9IHJlZi5jdXJyZW50LFxuICAgICAgICBhZmZpbml0eSA9IHJlZi5hZmZpbml0eTtcblxuICAgIGlmIChjdXJyZW50ID09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgcGF0aCA9IFBhdGgudHJhbnNmb3JtKGN1cnJlbnQsIG9wLCB7XG4gICAgICBhZmZpbml0eTogYWZmaW5pdHlcbiAgICB9KTtcbiAgICByZWYuY3VycmVudCA9IHBhdGg7XG5cbiAgICBpZiAocGF0aCA9PSBudWxsKSB7XG4gICAgICByZWYudW5yZWYoKTtcbiAgICB9XG4gIH1cbn07XG5cbmZ1bmN0aW9uIG93bktleXMkNihvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgeyBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSk7IH0ga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQkNih0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyBvd25LZXlzJDYoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHsgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTsgfSBlbHNlIHsgb3duS2V5cyQ2KE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG52YXIgUG9pbnQgPSB7XG4gIC8qKlxyXG4gICAqIENvbXBhcmUgYSBwb2ludCB0byBhbm90aGVyLCByZXR1cm5pbmcgYW4gaW50ZWdlciBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlXHJcbiAgICogcG9pbnQgd2FzIGJlZm9yZSwgYXQsIG9yIGFmdGVyIHRoZSBvdGhlci5cclxuICAgKi9cbiAgY29tcGFyZTogZnVuY3Rpb24gY29tcGFyZShwb2ludCwgYW5vdGhlcikge1xuICAgIHZhciByZXN1bHQgPSBQYXRoLmNvbXBhcmUocG9pbnQucGF0aCwgYW5vdGhlci5wYXRoKTtcblxuICAgIGlmIChyZXN1bHQgPT09IDApIHtcbiAgICAgIGlmIChwb2ludC5vZmZzZXQgPCBhbm90aGVyLm9mZnNldCkgcmV0dXJuIC0xO1xuICAgICAgaWYgKHBvaW50Lm9mZnNldCA+IGFub3RoZXIub2Zmc2V0KSByZXR1cm4gMTtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSBwb2ludCBpcyBhZnRlciBhbm90aGVyLlxyXG4gICAqL1xuICBpc0FmdGVyOiBmdW5jdGlvbiBpc0FmdGVyKHBvaW50LCBhbm90aGVyKSB7XG4gICAgcmV0dXJuIFBvaW50LmNvbXBhcmUocG9pbnQsIGFub3RoZXIpID09PSAxO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgcG9pbnQgaXMgYmVmb3JlIGFub3RoZXIuXHJcbiAgICovXG4gIGlzQmVmb3JlOiBmdW5jdGlvbiBpc0JlZm9yZShwb2ludCwgYW5vdGhlcikge1xuICAgIHJldHVybiBQb2ludC5jb21wYXJlKHBvaW50LCBhbm90aGVyKSA9PT0gLTE7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSBwb2ludCBpcyBleGFjdGx5IGVxdWFsIHRvIGFub3RoZXIuXHJcbiAgICovXG4gIGVxdWFsczogZnVuY3Rpb24gZXF1YWxzKHBvaW50LCBhbm90aGVyKSB7XG4gICAgLy8gUEVSRjogZW5zdXJlIHRoZSBvZmZzZXRzIGFyZSBlcXVhbCBmaXJzdCBzaW5jZSB0aGV5IGFyZSBjaGVhcGVyIHRvIGNoZWNrLlxuICAgIHJldHVybiBwb2ludC5vZmZzZXQgPT09IGFub3RoZXIub2Zmc2V0ICYmIFBhdGguZXF1YWxzKHBvaW50LnBhdGgsIGFub3RoZXIucGF0aCk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSB2YWx1ZSBpbXBsZW1lbnRzIHRoZSBgUG9pbnRgIGludGVyZmFjZS5cclxuICAgKi9cbiAgaXNQb2ludDogZnVuY3Rpb24gaXNQb2ludCh2YWx1ZSkge1xuICAgIHJldHVybiBpc1BsYWluT2JqZWN0LmlzUGxhaW5PYmplY3QodmFsdWUpICYmIHR5cGVvZiB2YWx1ZS5vZmZzZXQgPT09ICdudW1iZXInICYmIFBhdGguaXNQYXRoKHZhbHVlLnBhdGgpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIFRyYW5zZm9ybSBhIHBvaW50IGJ5IGFuIG9wZXJhdGlvbi5cclxuICAgKi9cbiAgdHJhbnNmb3JtOiBmdW5jdGlvbiB0cmFuc2Zvcm0ocG9pbnQsIG9wKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIHJldHVybiBpbW1lci5wcm9kdWNlKHBvaW50LCBmdW5jdGlvbiAocCkge1xuICAgICAgaWYgKHAgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciBfb3B0aW9ucyRhZmZpbml0eSA9IG9wdGlvbnMuYWZmaW5pdHksXG4gICAgICAgICAgYWZmaW5pdHkgPSBfb3B0aW9ucyRhZmZpbml0eSA9PT0gdm9pZCAwID8gJ2ZvcndhcmQnIDogX29wdGlvbnMkYWZmaW5pdHk7XG4gICAgICB2YXIgcGF0aCA9IHAucGF0aCxcbiAgICAgICAgICBvZmZzZXQgPSBwLm9mZnNldDtcblxuICAgICAgc3dpdGNoIChvcC50eXBlKSB7XG4gICAgICAgIGNhc2UgJ2luc2VydF9ub2RlJzpcbiAgICAgICAgY2FzZSAnbW92ZV9ub2RlJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBwLnBhdGggPSBQYXRoLnRyYW5zZm9ybShwYXRoLCBvcCwgb3B0aW9ucyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSAnaW5zZXJ0X3RleHQnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmIChQYXRoLmVxdWFscyhvcC5wYXRoLCBwYXRoKSAmJiAob3Aub2Zmc2V0IDwgb2Zmc2V0IHx8IG9wLm9mZnNldCA9PT0gb2Zmc2V0ICYmIGFmZmluaXR5ID09PSAnZm9yd2FyZCcpKSB7XG4gICAgICAgICAgICAgIHAub2Zmc2V0ICs9IG9wLnRleHQubGVuZ3RoO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSAnbWVyZ2Vfbm9kZSc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgaWYgKFBhdGguZXF1YWxzKG9wLnBhdGgsIHBhdGgpKSB7XG4gICAgICAgICAgICAgIHAub2Zmc2V0ICs9IG9wLnBvc2l0aW9uO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwLnBhdGggPSBQYXRoLnRyYW5zZm9ybShwYXRoLCBvcCwgb3B0aW9ucyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSAncmVtb3ZlX3RleHQnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmIChQYXRoLmVxdWFscyhvcC5wYXRoLCBwYXRoKSAmJiBvcC5vZmZzZXQgPD0gb2Zmc2V0KSB7XG4gICAgICAgICAgICAgIHAub2Zmc2V0IC09IE1hdGgubWluKG9mZnNldCAtIG9wLm9mZnNldCwgb3AudGV4dC5sZW5ndGgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSAncmVtb3ZlX25vZGUnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmIChQYXRoLmVxdWFscyhvcC5wYXRoLCBwYXRoKSB8fCBQYXRoLmlzQW5jZXN0b3Iob3AucGF0aCwgcGF0aCkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHAucGF0aCA9IFBhdGgudHJhbnNmb3JtKHBhdGgsIG9wLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlICdzcGxpdF9ub2RlJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZiAoUGF0aC5lcXVhbHMob3AucGF0aCwgcGF0aCkpIHtcbiAgICAgICAgICAgICAgaWYgKG9wLnBvc2l0aW9uID09PSBvZmZzZXQgJiYgYWZmaW5pdHkgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKG9wLnBvc2l0aW9uIDwgb2Zmc2V0IHx8IG9wLnBvc2l0aW9uID09PSBvZmZzZXQgJiYgYWZmaW5pdHkgPT09ICdmb3J3YXJkJykge1xuICAgICAgICAgICAgICAgIHAub2Zmc2V0IC09IG9wLnBvc2l0aW9uO1xuICAgICAgICAgICAgICAgIHAucGF0aCA9IFBhdGgudHJhbnNmb3JtKHBhdGgsIG9wLCBfb2JqZWN0U3ByZWFkJDYoX29iamVjdFNwcmVhZCQ2KHt9LCBvcHRpb25zKSwge30sIHtcbiAgICAgICAgICAgICAgICAgIGFmZmluaXR5OiAnZm9yd2FyZCdcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHAucGF0aCA9IFBhdGgudHJhbnNmb3JtKHBhdGgsIG9wLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG59O1xuXG52YXIgUG9pbnRSZWYgPSB7XG4gIC8qKlxyXG4gICAqIFRyYW5zZm9ybSB0aGUgcG9pbnQgcmVmJ3MgY3VycmVudCB2YWx1ZSBieSBhbiBvcGVyYXRpb24uXHJcbiAgICovXG4gIHRyYW5zZm9ybTogZnVuY3Rpb24gdHJhbnNmb3JtKHJlZiwgb3ApIHtcbiAgICB2YXIgY3VycmVudCA9IHJlZi5jdXJyZW50LFxuICAgICAgICBhZmZpbml0eSA9IHJlZi5hZmZpbml0eTtcblxuICAgIGlmIChjdXJyZW50ID09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgcG9pbnQgPSBQb2ludC50cmFuc2Zvcm0oY3VycmVudCwgb3AsIHtcbiAgICAgIGFmZmluaXR5OiBhZmZpbml0eVxuICAgIH0pO1xuICAgIHJlZi5jdXJyZW50ID0gcG9pbnQ7XG5cbiAgICBpZiAocG9pbnQgPT0gbnVsbCkge1xuICAgICAgcmVmLnVucmVmKCk7XG4gICAgfVxuICB9XG59O1xuXG52YXIgX2V4Y2x1ZGVkJDIgPSBbXCJhbmNob3JcIiwgXCJmb2N1c1wiXTtcblxuZnVuY3Rpb24gb3duS2V5cyQ1KG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgaWYgKGVudW1lcmFibGVPbmx5KSB7IHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KTsgfSBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCQ1KHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgaWYgKGkgJSAyKSB7IG93bktleXMkNShPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBvd25LZXlzJDUoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbnZhciBSYW5nZSA9IHtcbiAgLyoqXHJcbiAgICogR2V0IHRoZSBzdGFydCBhbmQgZW5kIHBvaW50cyBvZiBhIHJhbmdlLCBpbiB0aGUgb3JkZXIgaW4gd2hpY2ggdGhleSBhcHBlYXJcclxuICAgKiBpbiB0aGUgZG9jdW1lbnQuXHJcbiAgICovXG4gIGVkZ2VzOiBmdW5jdGlvbiBlZGdlcyhyYW5nZSkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICB2YXIgX29wdGlvbnMkcmV2ZXJzZSA9IG9wdGlvbnMucmV2ZXJzZSxcbiAgICAgICAgcmV2ZXJzZSA9IF9vcHRpb25zJHJldmVyc2UgPT09IHZvaWQgMCA/IGZhbHNlIDogX29wdGlvbnMkcmV2ZXJzZTtcbiAgICB2YXIgYW5jaG9yID0gcmFuZ2UuYW5jaG9yLFxuICAgICAgICBmb2N1cyA9IHJhbmdlLmZvY3VzO1xuICAgIHJldHVybiBSYW5nZS5pc0JhY2t3YXJkKHJhbmdlKSA9PT0gcmV2ZXJzZSA/IFthbmNob3IsIGZvY3VzXSA6IFtmb2N1cywgYW5jaG9yXTtcbiAgfSxcblxuICAvKipcclxuICAgKiBHZXQgdGhlIGVuZCBwb2ludCBvZiBhIHJhbmdlLlxyXG4gICAqL1xuICBlbmQ6IGZ1bmN0aW9uIGVuZChyYW5nZSkge1xuICAgIHZhciBfUmFuZ2UkZWRnZXMgPSBSYW5nZS5lZGdlcyhyYW5nZSksXG4gICAgICAgIF9SYW5nZSRlZGdlczIgPSBfc2xpY2VkVG9BcnJheShfUmFuZ2UkZWRnZXMsIDIpLFxuICAgICAgICBlbmQgPSBfUmFuZ2UkZWRnZXMyWzFdO1xuXG4gICAgcmV0dXJuIGVuZDtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhIHJhbmdlIGlzIGV4YWN0bHkgZXF1YWwgdG8gYW5vdGhlci5cclxuICAgKi9cbiAgZXF1YWxzOiBmdW5jdGlvbiBlcXVhbHMocmFuZ2UsIGFub3RoZXIpIHtcbiAgICByZXR1cm4gUG9pbnQuZXF1YWxzKHJhbmdlLmFuY2hvciwgYW5vdGhlci5hbmNob3IpICYmIFBvaW50LmVxdWFscyhyYW5nZS5mb2N1cywgYW5vdGhlci5mb2N1cyk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSByYW5nZSBpbmNsdWRlcyBhIHBhdGgsIGEgcG9pbnQgb3IgcGFydCBvZiBhbm90aGVyIHJhbmdlLlxyXG4gICAqL1xuICBpbmNsdWRlczogZnVuY3Rpb24gaW5jbHVkZXMocmFuZ2UsIHRhcmdldCkge1xuICAgIGlmIChSYW5nZS5pc1JhbmdlKHRhcmdldCkpIHtcbiAgICAgIGlmIChSYW5nZS5pbmNsdWRlcyhyYW5nZSwgdGFyZ2V0LmFuY2hvcikgfHwgUmFuZ2UuaW5jbHVkZXMocmFuZ2UsIHRhcmdldC5mb2N1cykpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBfUmFuZ2UkZWRnZXMzID0gUmFuZ2UuZWRnZXMocmFuZ2UpLFxuICAgICAgICAgIF9SYW5nZSRlZGdlczQgPSBfc2xpY2VkVG9BcnJheShfUmFuZ2UkZWRnZXMzLCAyKSxcbiAgICAgICAgICBycyA9IF9SYW5nZSRlZGdlczRbMF0sXG4gICAgICAgICAgcmUgPSBfUmFuZ2UkZWRnZXM0WzFdO1xuXG4gICAgICB2YXIgX1JhbmdlJGVkZ2VzNSA9IFJhbmdlLmVkZ2VzKHRhcmdldCksXG4gICAgICAgICAgX1JhbmdlJGVkZ2VzNiA9IF9zbGljZWRUb0FycmF5KF9SYW5nZSRlZGdlczUsIDIpLFxuICAgICAgICAgIHRzID0gX1JhbmdlJGVkZ2VzNlswXSxcbiAgICAgICAgICB0ZSA9IF9SYW5nZSRlZGdlczZbMV07XG5cbiAgICAgIHJldHVybiBQb2ludC5pc0JlZm9yZShycywgdHMpICYmIFBvaW50LmlzQWZ0ZXIocmUsIHRlKTtcbiAgICB9XG5cbiAgICB2YXIgX1JhbmdlJGVkZ2VzNyA9IFJhbmdlLmVkZ2VzKHJhbmdlKSxcbiAgICAgICAgX1JhbmdlJGVkZ2VzOCA9IF9zbGljZWRUb0FycmF5KF9SYW5nZSRlZGdlczcsIDIpLFxuICAgICAgICBzdGFydCA9IF9SYW5nZSRlZGdlczhbMF0sXG4gICAgICAgIGVuZCA9IF9SYW5nZSRlZGdlczhbMV07XG5cbiAgICB2YXIgaXNBZnRlclN0YXJ0ID0gZmFsc2U7XG4gICAgdmFyIGlzQmVmb3JlRW5kID0gZmFsc2U7XG5cbiAgICBpZiAoUG9pbnQuaXNQb2ludCh0YXJnZXQpKSB7XG4gICAgICBpc0FmdGVyU3RhcnQgPSBQb2ludC5jb21wYXJlKHRhcmdldCwgc3RhcnQpID49IDA7XG4gICAgICBpc0JlZm9yZUVuZCA9IFBvaW50LmNvbXBhcmUodGFyZ2V0LCBlbmQpIDw9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlzQWZ0ZXJTdGFydCA9IFBhdGguY29tcGFyZSh0YXJnZXQsIHN0YXJ0LnBhdGgpID49IDA7XG4gICAgICBpc0JlZm9yZUVuZCA9IFBhdGguY29tcGFyZSh0YXJnZXQsIGVuZC5wYXRoKSA8PSAwO1xuICAgIH1cblxuICAgIHJldHVybiBpc0FmdGVyU3RhcnQgJiYgaXNCZWZvcmVFbmQ7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogR2V0IHRoZSBpbnRlcnNlY3Rpb24gb2YgYSByYW5nZSB3aXRoIGFub3RoZXIuXHJcbiAgICovXG4gIGludGVyc2VjdGlvbjogZnVuY3Rpb24gaW50ZXJzZWN0aW9uKHJhbmdlLCBhbm90aGVyKSB7XG4gICAgcmFuZ2UuYW5jaG9yO1xuICAgICAgICByYW5nZS5mb2N1cztcbiAgICAgICAgdmFyIHJlc3QgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMocmFuZ2UsIF9leGNsdWRlZCQyKTtcblxuICAgIHZhciBfUmFuZ2UkZWRnZXM5ID0gUmFuZ2UuZWRnZXMocmFuZ2UpLFxuICAgICAgICBfUmFuZ2UkZWRnZXMxMCA9IF9zbGljZWRUb0FycmF5KF9SYW5nZSRlZGdlczksIDIpLFxuICAgICAgICBzMSA9IF9SYW5nZSRlZGdlczEwWzBdLFxuICAgICAgICBlMSA9IF9SYW5nZSRlZGdlczEwWzFdO1xuXG4gICAgdmFyIF9SYW5nZSRlZGdlczExID0gUmFuZ2UuZWRnZXMoYW5vdGhlciksXG4gICAgICAgIF9SYW5nZSRlZGdlczEyID0gX3NsaWNlZFRvQXJyYXkoX1JhbmdlJGVkZ2VzMTEsIDIpLFxuICAgICAgICBzMiA9IF9SYW5nZSRlZGdlczEyWzBdLFxuICAgICAgICBlMiA9IF9SYW5nZSRlZGdlczEyWzFdO1xuXG4gICAgdmFyIHN0YXJ0ID0gUG9pbnQuaXNCZWZvcmUoczEsIHMyKSA/IHMyIDogczE7XG4gICAgdmFyIGVuZCA9IFBvaW50LmlzQmVmb3JlKGUxLCBlMikgPyBlMSA6IGUyO1xuXG4gICAgaWYgKFBvaW50LmlzQmVmb3JlKGVuZCwgc3RhcnQpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQkNSh7XG4gICAgICAgIGFuY2hvcjogc3RhcnQsXG4gICAgICAgIGZvY3VzOiBlbmRcbiAgICAgIH0sIHJlc3QpO1xuICAgIH1cbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhIHJhbmdlIGlzIGJhY2t3YXJkLCBtZWFuaW5nIHRoYXQgaXRzIGFuY2hvciBwb2ludCBhcHBlYXJzIGluIHRoZVxyXG4gICAqIGRvY3VtZW50IF9hZnRlcl8gaXRzIGZvY3VzIHBvaW50LlxyXG4gICAqL1xuICBpc0JhY2t3YXJkOiBmdW5jdGlvbiBpc0JhY2t3YXJkKHJhbmdlKSB7XG4gICAgdmFyIGFuY2hvciA9IHJhbmdlLmFuY2hvcixcbiAgICAgICAgZm9jdXMgPSByYW5nZS5mb2N1cztcbiAgICByZXR1cm4gUG9pbnQuaXNBZnRlcihhbmNob3IsIGZvY3VzKTtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhIHJhbmdlIGlzIGNvbGxhcHNlZCwgbWVhbmluZyB0aGF0IGJvdGggaXRzIGFuY2hvciBhbmQgZm9jdXNcclxuICAgKiBwb2ludHMgcmVmZXIgdG8gdGhlIGV4YWN0IHNhbWUgcG9zaXRpb24gaW4gdGhlIGRvY3VtZW50LlxyXG4gICAqL1xuICBpc0NvbGxhcHNlZDogZnVuY3Rpb24gaXNDb2xsYXBzZWQocmFuZ2UpIHtcbiAgICB2YXIgYW5jaG9yID0gcmFuZ2UuYW5jaG9yLFxuICAgICAgICBmb2N1cyA9IHJhbmdlLmZvY3VzO1xuICAgIHJldHVybiBQb2ludC5lcXVhbHMoYW5jaG9yLCBmb2N1cyk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSByYW5nZSBpcyBleHBhbmRlZC5cclxuICAgKlxyXG4gICAqIFRoaXMgaXMgdGhlIG9wcG9zaXRlIG9mIFtbUmFuZ2UuaXNDb2xsYXBzZWRdXSBhbmQgaXMgcHJvdmlkZWQgZm9yIGxlZ2liaWxpdHkuXHJcbiAgICovXG4gIGlzRXhwYW5kZWQ6IGZ1bmN0aW9uIGlzRXhwYW5kZWQocmFuZ2UpIHtcbiAgICByZXR1cm4gIVJhbmdlLmlzQ29sbGFwc2VkKHJhbmdlKTtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhIHJhbmdlIGlzIGZvcndhcmQuXHJcbiAgICpcclxuICAgKiBUaGlzIGlzIHRoZSBvcHBvc2l0ZSBvZiBbW1JhbmdlLmlzQmFja3dhcmRdXSBhbmQgaXMgcHJvdmlkZWQgZm9yIGxlZ2liaWxpdHkuXHJcbiAgICovXG4gIGlzRm9yd2FyZDogZnVuY3Rpb24gaXNGb3J3YXJkKHJhbmdlKSB7XG4gICAgcmV0dXJuICFSYW5nZS5pc0JhY2t3YXJkKHJhbmdlKTtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhIHZhbHVlIGltcGxlbWVudHMgdGhlIFtbUmFuZ2VdXSBpbnRlcmZhY2UuXHJcbiAgICovXG4gIGlzUmFuZ2U6IGZ1bmN0aW9uIGlzUmFuZ2UodmFsdWUpIHtcbiAgICByZXR1cm4gaXNQbGFpbk9iamVjdC5pc1BsYWluT2JqZWN0KHZhbHVlKSAmJiBQb2ludC5pc1BvaW50KHZhbHVlLmFuY2hvcikgJiYgUG9pbnQuaXNQb2ludCh2YWx1ZS5mb2N1cyk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogSXRlcmF0ZSB0aHJvdWdoIGFsbCBvZiB0aGUgcG9pbnQgZW50cmllcyBpbiBhIHJhbmdlLlxyXG4gICAqL1xuICBwb2ludHM6IGZ1bmN0aW9uKiBwb2ludHMocmFuZ2UpIHtcbiAgICB5aWVsZCBbcmFuZ2UuYW5jaG9yLCAnYW5jaG9yJ107XG4gICAgeWllbGQgW3JhbmdlLmZvY3VzLCAnZm9jdXMnXTtcbiAgfSxcblxuICAvKipcclxuICAgKiBHZXQgdGhlIHN0YXJ0IHBvaW50IG9mIGEgcmFuZ2UuXHJcbiAgICovXG4gIHN0YXJ0OiBmdW5jdGlvbiBzdGFydChyYW5nZSkge1xuICAgIHZhciBfUmFuZ2UkZWRnZXMxMyA9IFJhbmdlLmVkZ2VzKHJhbmdlKSxcbiAgICAgICAgX1JhbmdlJGVkZ2VzMTQgPSBfc2xpY2VkVG9BcnJheShfUmFuZ2UkZWRnZXMxMywgMSksXG4gICAgICAgIHN0YXJ0ID0gX1JhbmdlJGVkZ2VzMTRbMF07XG5cbiAgICByZXR1cm4gc3RhcnQ7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogVHJhbnNmb3JtIGEgcmFuZ2UgYnkgYW4gb3BlcmF0aW9uLlxyXG4gICAqL1xuICB0cmFuc2Zvcm06IGZ1bmN0aW9uIHRyYW5zZm9ybShyYW5nZSwgb3ApIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgcmV0dXJuIGltbWVyLnByb2R1Y2UocmFuZ2UsIGZ1bmN0aW9uIChyKSB7XG4gICAgICBpZiAociA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdmFyIF9vcHRpb25zJGFmZmluaXR5ID0gb3B0aW9ucy5hZmZpbml0eSxcbiAgICAgICAgICBhZmZpbml0eSA9IF9vcHRpb25zJGFmZmluaXR5ID09PSB2b2lkIDAgPyAnaW53YXJkJyA6IF9vcHRpb25zJGFmZmluaXR5O1xuICAgICAgdmFyIGFmZmluaXR5QW5jaG9yO1xuICAgICAgdmFyIGFmZmluaXR5Rm9jdXM7XG5cbiAgICAgIGlmIChhZmZpbml0eSA9PT0gJ2lud2FyZCcpIHtcbiAgICAgICAgLy8gSWYgdGhlIHJhbmdlIGlzIGNvbGxhcHNlZCwgbWFrZSBzdXJlIHRvIHVzZSB0aGUgc2FtZSBhZmZpbml0eSB0b1xuICAgICAgICAvLyBhdm9pZCB0aGUgdHdvIHBvaW50cyBwYXNzaW5nIGVhY2ggb3RoZXIgYW5kIGV4cGFuZGluZyBpbiB0aGUgb3Bwb3NpdGVcbiAgICAgICAgLy8gZGlyZWN0aW9uXG4gICAgICAgIHZhciBpc0NvbGxhcHNlZCA9IFJhbmdlLmlzQ29sbGFwc2VkKHIpO1xuXG4gICAgICAgIGlmIChSYW5nZS5pc0ZvcndhcmQocikpIHtcbiAgICAgICAgICBhZmZpbml0eUFuY2hvciA9ICdmb3J3YXJkJztcbiAgICAgICAgICBhZmZpbml0eUZvY3VzID0gaXNDb2xsYXBzZWQgPyBhZmZpbml0eUFuY2hvciA6ICdiYWNrd2FyZCc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWZmaW5pdHlBbmNob3IgPSAnYmFja3dhcmQnO1xuICAgICAgICAgIGFmZmluaXR5Rm9jdXMgPSBpc0NvbGxhcHNlZCA/IGFmZmluaXR5QW5jaG9yIDogJ2ZvcndhcmQnO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGFmZmluaXR5ID09PSAnb3V0d2FyZCcpIHtcbiAgICAgICAgaWYgKFJhbmdlLmlzRm9yd2FyZChyKSkge1xuICAgICAgICAgIGFmZmluaXR5QW5jaG9yID0gJ2JhY2t3YXJkJztcbiAgICAgICAgICBhZmZpbml0eUZvY3VzID0gJ2ZvcndhcmQnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFmZmluaXR5QW5jaG9yID0gJ2ZvcndhcmQnO1xuICAgICAgICAgIGFmZmluaXR5Rm9jdXMgPSAnYmFja3dhcmQnO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhZmZpbml0eUFuY2hvciA9IGFmZmluaXR5O1xuICAgICAgICBhZmZpbml0eUZvY3VzID0gYWZmaW5pdHk7XG4gICAgICB9XG5cbiAgICAgIHZhciBhbmNob3IgPSBQb2ludC50cmFuc2Zvcm0oci5hbmNob3IsIG9wLCB7XG4gICAgICAgIGFmZmluaXR5OiBhZmZpbml0eUFuY2hvclxuICAgICAgfSk7XG4gICAgICB2YXIgZm9jdXMgPSBQb2ludC50cmFuc2Zvcm0oci5mb2N1cywgb3AsIHtcbiAgICAgICAgYWZmaW5pdHk6IGFmZmluaXR5Rm9jdXNcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoIWFuY2hvciB8fCAhZm9jdXMpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHIuYW5jaG9yID0gYW5jaG9yO1xuICAgICAgci5mb2N1cyA9IGZvY3VzO1xuICAgIH0pO1xuICB9XG59O1xuXG52YXIgUmFuZ2VSZWYgPSB7XG4gIC8qKlxyXG4gICAqIFRyYW5zZm9ybSB0aGUgcmFuZ2UgcmVmJ3MgY3VycmVudCB2YWx1ZSBieSBhbiBvcGVyYXRpb24uXHJcbiAgICovXG4gIHRyYW5zZm9ybTogZnVuY3Rpb24gdHJhbnNmb3JtKHJlZiwgb3ApIHtcbiAgICB2YXIgY3VycmVudCA9IHJlZi5jdXJyZW50LFxuICAgICAgICBhZmZpbml0eSA9IHJlZi5hZmZpbml0eTtcblxuICAgIGlmIChjdXJyZW50ID09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgcGF0aCA9IFJhbmdlLnRyYW5zZm9ybShjdXJyZW50LCBvcCwge1xuICAgICAgYWZmaW5pdHk6IGFmZmluaXR5XG4gICAgfSk7XG4gICAgcmVmLmN1cnJlbnQgPSBwYXRoO1xuXG4gICAgaWYgKHBhdGggPT0gbnVsbCkge1xuICAgICAgcmVmLnVucmVmKCk7XG4gICAgfVxuICB9XG59O1xuXG52YXIgX3NjcnViYmVyID0gdW5kZWZpbmVkO1xuLyoqXHJcbiAqIFRoaXMgaW50ZXJmYWNlIGltcGxlbWVudHMgYSBzdHJpbmdpZnkoKSBmdW5jdGlvbiwgd2hpY2ggaXMgdXNlZCBieSBTbGF0ZVxyXG4gKiBpbnRlcm5hbGx5IHdoZW4gZ2VuZXJhdGluZyBleGNlcHRpb25zIGNvbnRhaW5pbmcgZW5kIHVzZXIgZGF0YS4gRGV2ZWxvcGVyc1xyXG4gKiB1c2luZyBTbGF0ZSBtYXkgY2FsbCBTY3J1YmJlci5zZXRTY3J1YmJlcigpIHRvIGFsdGVyIHRoZSBiZWhhdmlvciBvZiB0aGlzXHJcbiAqIHN0cmluZ2lmeSgpIGZ1bmN0aW9uLlxyXG4gKlxyXG4gKiBGb3IgZXhhbXBsZSwgdG8gcHJldmVudCB0aGUgY2xlYXJ0ZXh0IGxvZ2dpbmcgb2YgJ3RleHQnIGZpZWxkcyB3aXRoaW4gTm9kZXM6XHJcbiAqXHJcbiAqICAgIGltcG9ydCB7IFNjcnViYmVyIH0gZnJvbSAnc2xhdGUnO1xyXG4gKiAgICBTY3J1YmJlci5zZXRTY3J1YmJlcigoa2V5LCB2YWwpID0+IHtcclxuICogICAgICBpZiAoa2V5ID09PSAndGV4dCcpIHJldHVybiAnLi4uc2NydWJiZWQuLi4nXHJcbiAqICAgICAgcmV0dXJuIHZhbFxyXG4gKiAgICB9KTtcclxuICpcclxuICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVkZWNsYXJlXG5cbnZhciBTY3J1YmJlciA9IHtcbiAgc2V0U2NydWJiZXI6IGZ1bmN0aW9uIHNldFNjcnViYmVyKHNjcnViYmVyKSB7XG4gICAgX3NjcnViYmVyID0gc2NydWJiZXI7XG4gIH0sXG4gIHN0cmluZ2lmeTogZnVuY3Rpb24gc3RyaW5naWZ5KHZhbHVlKSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHZhbHVlLCBfc2NydWJiZXIpO1xuICB9XG59O1xuXG4vKlxyXG4gIEN1c3RvbSBkZWVwIGVxdWFsIGNvbXBhcmlzb24gZm9yIFNsYXRlIG5vZGVzLlxyXG5cbiAgV2UgZG9uJ3QgbmVlZCBnZW5lcmFsIHB1cnBvc2UgZGVlcCBlcXVhbGl0eTtcclxuICBTbGF0ZSBvbmx5IHN1cHBvcnRzIHBsYWluIHZhbHVlcywgQXJyYXlzLCBhbmQgbmVzdGVkIG9iamVjdHMuXHJcbiAgQ29tcGxleCB2YWx1ZXMgbmVzdGVkIGluc2lkZSBBcnJheXMgYXJlIG5vdCBzdXBwb3J0ZWQuXHJcblxuICBTbGF0ZSBvYmplY3RzIGFyZSBkZXNpZ25lZCB0byBiZSBzZXJpYWxpc2VkLCBzb1xyXG4gIG1pc3Npbmcga2V5cyBhcmUgZGVsaWJlcmF0ZWx5IG5vcm1hbGlzZWQgdG8gdW5kZWZpbmVkLlxyXG4gKi9cblxudmFyIGlzRGVlcEVxdWFsID0gZnVuY3Rpb24gaXNEZWVwRXF1YWwobm9kZSwgYW5vdGhlcikge1xuICBmb3IgKHZhciBrZXkgaW4gbm9kZSkge1xuICAgIHZhciBhID0gbm9kZVtrZXldO1xuICAgIHZhciBiID0gYW5vdGhlcltrZXldO1xuXG4gICAgaWYgKGlzUGxhaW5PYmplY3QuaXNQbGFpbk9iamVjdChhKSAmJiBpc1BsYWluT2JqZWN0LmlzUGxhaW5PYmplY3QoYikpIHtcbiAgICAgIGlmICghaXNEZWVwRXF1YWwoYSwgYikpIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoYSkgJiYgQXJyYXkuaXNBcnJheShiKSkge1xuICAgICAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGFbaV0gIT09IGJbaV0pIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGEgIT09IGIpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgLypcclxuICAgIERlZXAgb2JqZWN0IGVxdWFsaXR5IGlzIG9ubHkgbmVjZXNzYXJ5IGluIG9uZSBkaXJlY3Rpb247IGluIHRoZSByZXZlcnNlIGRpcmVjdGlvblxyXG4gICAgd2UgYXJlIG9ubHkgbG9va2luZyBmb3Iga2V5cyB0aGF0IGFyZSBtaXNzaW5nLlxyXG4gICAgQXMgYWJvdmUsIHVuZGVmaW5lZCBrZXlzIGFyZSBub3JtYWxpc2VkIHRvIG1pc3NpbmcuXHJcbiAgKi9cblxuXG4gIGZvciAodmFyIF9rZXkgaW4gYW5vdGhlcikge1xuICAgIGlmIChub2RlW19rZXldID09PSB1bmRlZmluZWQgJiYgYW5vdGhlcltfa2V5XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG52YXIgX2V4Y2x1ZGVkJDEgPSBbXCJ0ZXh0XCJdLFxuICAgIF9leGNsdWRlZDIkMSA9IFtcImFuY2hvclwiLCBcImZvY3VzXCJdO1xuXG5mdW5jdGlvbiBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciQzKG8sIGFsbG93QXJyYXlMaWtlKSB7IHZhciBpdCA9IHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdIHx8IG9bXCJAQGl0ZXJhdG9yXCJdOyBpZiAoIWl0KSB7IGlmIChBcnJheS5pc0FycmF5KG8pIHx8IChpdCA9IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSQzKG8pKSB8fCBhbGxvd0FycmF5TGlrZSAmJiBvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgeyBpZiAoaXQpIG8gPSBpdDsgdmFyIGkgPSAwOyB2YXIgRiA9IGZ1bmN0aW9uIEYoKSB7fTsgcmV0dXJuIHsgczogRiwgbjogZnVuY3Rpb24gbigpIHsgaWYgKGkgPj0gby5sZW5ndGgpIHJldHVybiB7IGRvbmU6IHRydWUgfTsgcmV0dXJuIHsgZG9uZTogZmFsc2UsIHZhbHVlOiBvW2krK10gfTsgfSwgZTogZnVuY3Rpb24gZShfZSkgeyB0aHJvdyBfZTsgfSwgZjogRiB9OyB9IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfSB2YXIgbm9ybWFsQ29tcGxldGlvbiA9IHRydWUsIGRpZEVyciA9IGZhbHNlLCBlcnI7IHJldHVybiB7IHM6IGZ1bmN0aW9uIHMoKSB7IGl0ID0gaXQuY2FsbChvKTsgfSwgbjogZnVuY3Rpb24gbigpIHsgdmFyIHN0ZXAgPSBpdC5uZXh0KCk7IG5vcm1hbENvbXBsZXRpb24gPSBzdGVwLmRvbmU7IHJldHVybiBzdGVwOyB9LCBlOiBmdW5jdGlvbiBlKF9lMikgeyBkaWRFcnIgPSB0cnVlOyBlcnIgPSBfZTI7IH0sIGY6IGZ1bmN0aW9uIGYoKSB7IHRyeSB7IGlmICghbm9ybWFsQ29tcGxldGlvbiAmJiBpdFtcInJldHVyblwiXSAhPSBudWxsKSBpdFtcInJldHVyblwiXSgpOyB9IGZpbmFsbHkgeyBpZiAoZGlkRXJyKSB0aHJvdyBlcnI7IH0gfSB9OyB9XG5cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSQzKG8sIG1pbkxlbikgeyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkkMyhvLCBtaW5MZW4pOyB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5JDMobywgbWluTGVuKTsgfVxuXG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheSQzKGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfVxuXG5mdW5jdGlvbiBvd25LZXlzJDQob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBpZiAoZW51bWVyYWJsZU9ubHkpIHsgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyB9IGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkJDQodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgb3duS2V5cyQ0KE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pOyB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7IH0gZWxzZSB7IG93bktleXMkNChPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxudmFyIFRleHQgPSB7XG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIHR3byB0ZXh0IG5vZGVzIGFyZSBlcXVhbC5cclxuICAgKlxyXG4gICAqIFdoZW4gbG9vc2UgaXMgc2V0LCB0aGUgdGV4dCBpcyBub3QgY29tcGFyZWQuIFRoaXMgaXNcclxuICAgKiB1c2VkIHRvIGNoZWNrIHdoZXRoZXIgc2libGluZyB0ZXh0IG5vZGVzIGNhbiBiZSBtZXJnZWQuXHJcbiAgICovXG4gIGVxdWFsczogZnVuY3Rpb24gZXF1YWxzKHRleHQsIGFub3RoZXIpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgdmFyIF9vcHRpb25zJGxvb3NlID0gb3B0aW9ucy5sb29zZSxcbiAgICAgICAgbG9vc2UgPSBfb3B0aW9ucyRsb29zZSA9PT0gdm9pZCAwID8gZmFsc2UgOiBfb3B0aW9ucyRsb29zZTtcblxuICAgIGZ1bmN0aW9uIG9taXRUZXh0KG9iaikge1xuICAgICAgb2JqLnRleHQ7XG4gICAgICAgICAgdmFyIHJlc3QgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMob2JqLCBfZXhjbHVkZWQkMSk7XG5cbiAgICAgIHJldHVybiByZXN0O1xuICAgIH1cblxuICAgIHJldHVybiBpc0RlZXBFcXVhbChsb29zZSA/IG9taXRUZXh0KHRleHQpIDogdGV4dCwgbG9vc2UgPyBvbWl0VGV4dChhbm90aGVyKSA6IGFub3RoZXIpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgdmFsdWUgaW1wbGVtZW50cyB0aGUgYFRleHRgIGludGVyZmFjZS5cclxuICAgKi9cbiAgaXNUZXh0OiBmdW5jdGlvbiBpc1RleHQodmFsdWUpIHtcbiAgICByZXR1cm4gaXNQbGFpbk9iamVjdC5pc1BsYWluT2JqZWN0KHZhbHVlKSAmJiB0eXBlb2YgdmFsdWUudGV4dCA9PT0gJ3N0cmluZyc7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSB2YWx1ZSBpcyBhIGxpc3Qgb2YgYFRleHRgIG9iamVjdHMuXHJcbiAgICovXG4gIGlzVGV4dExpc3Q6IGZ1bmN0aW9uIGlzVGV4dExpc3QodmFsdWUpIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiYgdmFsdWUuZXZlcnkoZnVuY3Rpb24gKHZhbCkge1xuICAgICAgcmV0dXJuIFRleHQuaXNUZXh0KHZhbCk7XG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgc29tZSBwcm9wcyBhcmUgYSBwYXJ0aWFsIG9mIFRleHQuXHJcbiAgICovXG4gIGlzVGV4dFByb3BzOiBmdW5jdGlvbiBpc1RleHRQcm9wcyhwcm9wcykge1xuICAgIHJldHVybiBwcm9wcy50ZXh0ICE9PSB1bmRlZmluZWQ7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYW4gdGV4dCBtYXRjaGVzIHNldCBvZiBwcm9wZXJ0aWVzLlxyXG4gICAqXHJcbiAgICogTm90ZTogdGhpcyBpcyBmb3IgbWF0Y2hpbmcgY3VzdG9tIHByb3BlcnRpZXMsIGFuZCBpdCBkb2VzIG5vdCBlbnN1cmUgdGhhdFxyXG4gICAqIHRoZSBgdGV4dGAgcHJvcGVydHkgYXJlIHR3byBub2RlcyBlcXVhbC5cclxuICAgKi9cbiAgbWF0Y2hlczogZnVuY3Rpb24gbWF0Y2hlcyh0ZXh0LCBwcm9wcykge1xuICAgIGZvciAodmFyIGtleSBpbiBwcm9wcykge1xuICAgICAgaWYgKGtleSA9PT0gJ3RleHQnKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRleHQuaGFzT3duUHJvcGVydHkoa2V5KSB8fCB0ZXh0W2tleV0gIT09IHByb3BzW2tleV0pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgbGVhdmVzIGZvciBhIHRleHQgbm9kZSBnaXZlbiBkZWNvcmF0aW9ucy5cclxuICAgKi9cbiAgZGVjb3JhdGlvbnM6IGZ1bmN0aW9uIGRlY29yYXRpb25zKG5vZGUsIF9kZWNvcmF0aW9ucykge1xuICAgIHZhciBsZWF2ZXMgPSBbX29iamVjdFNwcmVhZCQ0KHt9LCBub2RlKV07XG5cbiAgICB2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkMyhfZGVjb3JhdGlvbnMpLFxuICAgICAgICBfc3RlcDtcblxuICAgIHRyeSB7XG4gICAgICBmb3IgKF9pdGVyYXRvci5zKCk7ICEoX3N0ZXAgPSBfaXRlcmF0b3IubigpKS5kb25lOykge1xuICAgICAgICB2YXIgZGVjID0gX3N0ZXAudmFsdWU7XG5cbiAgICAgICAgdmFyIGFuY2hvciA9IGRlYy5hbmNob3IsXG4gICAgICAgICAgICBmb2N1cyA9IGRlYy5mb2N1cyxcbiAgICAgICAgICAgIHJlc3QgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoZGVjLCBfZXhjbHVkZWQyJDEpO1xuXG4gICAgICAgIHZhciBfUmFuZ2UkZWRnZXMgPSBSYW5nZS5lZGdlcyhkZWMpLFxuICAgICAgICAgICAgX1JhbmdlJGVkZ2VzMiA9IF9zbGljZWRUb0FycmF5KF9SYW5nZSRlZGdlcywgMiksXG4gICAgICAgICAgICBzdGFydCA9IF9SYW5nZSRlZGdlczJbMF0sXG4gICAgICAgICAgICBlbmQgPSBfUmFuZ2UkZWRnZXMyWzFdO1xuXG4gICAgICAgIHZhciBuZXh0ID0gW107XG4gICAgICAgIHZhciBsZWFmRW5kID0gMDtcbiAgICAgICAgdmFyIGRlY29yYXRpb25TdGFydCA9IHN0YXJ0Lm9mZnNldDtcbiAgICAgICAgdmFyIGRlY29yYXRpb25FbmQgPSBlbmQub2Zmc2V0O1xuXG4gICAgICAgIHZhciBfaXRlcmF0b3IyID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkMyhsZWF2ZXMpLFxuICAgICAgICAgICAgX3N0ZXAyO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZm9yIChfaXRlcmF0b3IyLnMoKTsgIShfc3RlcDIgPSBfaXRlcmF0b3IyLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICAgIHZhciBsZWFmID0gX3N0ZXAyLnZhbHVlO1xuICAgICAgICAgICAgdmFyIGxlbmd0aCA9IGxlYWYudGV4dC5sZW5ndGg7XG4gICAgICAgICAgICB2YXIgbGVhZlN0YXJ0ID0gbGVhZkVuZDtcbiAgICAgICAgICAgIGxlYWZFbmQgKz0gbGVuZ3RoOyAvLyBJZiB0aGUgcmFuZ2UgZW5jb21wYXNzZXMgdGhlIGVudGlyZSBsZWFmLCBhZGQgdGhlIHJhbmdlLlxuXG4gICAgICAgICAgICBpZiAoZGVjb3JhdGlvblN0YXJ0IDw9IGxlYWZTdGFydCAmJiBsZWFmRW5kIDw9IGRlY29yYXRpb25FbmQpIHtcbiAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihsZWFmLCByZXN0KTtcbiAgICAgICAgICAgICAgbmV4dC5wdXNoKGxlYWYpO1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH0gLy8gSWYgdGhlIHJhbmdlIGV4cGFuZGVkIGFuZCBtYXRjaCB0aGUgbGVhZiwgb3Igc3RhcnRzIGFmdGVyLCBvciBlbmRzIGJlZm9yZSBpdCwgY29udGludWUuXG5cblxuICAgICAgICAgICAgaWYgKGRlY29yYXRpb25TdGFydCAhPT0gZGVjb3JhdGlvbkVuZCAmJiAoZGVjb3JhdGlvblN0YXJ0ID09PSBsZWFmRW5kIHx8IGRlY29yYXRpb25FbmQgPT09IGxlYWZTdGFydCkgfHwgZGVjb3JhdGlvblN0YXJ0ID4gbGVhZkVuZCB8fCBkZWNvcmF0aW9uRW5kIDwgbGVhZlN0YXJ0IHx8IGRlY29yYXRpb25FbmQgPT09IGxlYWZTdGFydCAmJiBsZWFmU3RhcnQgIT09IDApIHtcbiAgICAgICAgICAgICAgbmV4dC5wdXNoKGxlYWYpO1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH0gLy8gT3RoZXJ3aXNlIHdlIG5lZWQgdG8gc3BsaXQgdGhlIGxlYWYsIGF0IHRoZSBzdGFydCwgZW5kLCBvciBib3RoLFxuICAgICAgICAgICAgLy8gYW5kIGFkZCB0aGUgcmFuZ2UgdG8gdGhlIG1pZGRsZSBpbnRlcnNlY3Rpbmcgc2VjdGlvbi4gRG8gdGhlIGVuZFxuICAgICAgICAgICAgLy8gc3BsaXQgZmlyc3Qgc2luY2Ugd2UgZG9uJ3QgbmVlZCB0byB1cGRhdGUgdGhlIG9mZnNldCB0aGF0IHdheS5cblxuXG4gICAgICAgICAgICB2YXIgbWlkZGxlID0gbGVhZjtcbiAgICAgICAgICAgIHZhciBiZWZvcmUgPSB2b2lkIDA7XG4gICAgICAgICAgICB2YXIgYWZ0ZXIgPSB2b2lkIDA7XG5cbiAgICAgICAgICAgIGlmIChkZWNvcmF0aW9uRW5kIDwgbGVhZkVuZCkge1xuICAgICAgICAgICAgICB2YXIgb2ZmID0gZGVjb3JhdGlvbkVuZCAtIGxlYWZTdGFydDtcbiAgICAgICAgICAgICAgYWZ0ZXIgPSBfb2JqZWN0U3ByZWFkJDQoX29iamVjdFNwcmVhZCQ0KHt9LCBtaWRkbGUpLCB7fSwge1xuICAgICAgICAgICAgICAgIHRleHQ6IG1pZGRsZS50ZXh0LnNsaWNlKG9mZilcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIG1pZGRsZSA9IF9vYmplY3RTcHJlYWQkNChfb2JqZWN0U3ByZWFkJDQoe30sIG1pZGRsZSksIHt9LCB7XG4gICAgICAgICAgICAgICAgdGV4dDogbWlkZGxlLnRleHQuc2xpY2UoMCwgb2ZmKVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGRlY29yYXRpb25TdGFydCA+IGxlYWZTdGFydCkge1xuICAgICAgICAgICAgICB2YXIgX29mZiA9IGRlY29yYXRpb25TdGFydCAtIGxlYWZTdGFydDtcblxuICAgICAgICAgICAgICBiZWZvcmUgPSBfb2JqZWN0U3ByZWFkJDQoX29iamVjdFNwcmVhZCQ0KHt9LCBtaWRkbGUpLCB7fSwge1xuICAgICAgICAgICAgICAgIHRleHQ6IG1pZGRsZS50ZXh0LnNsaWNlKDAsIF9vZmYpXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBtaWRkbGUgPSBfb2JqZWN0U3ByZWFkJDQoX29iamVjdFNwcmVhZCQ0KHt9LCBtaWRkbGUpLCB7fSwge1xuICAgICAgICAgICAgICAgIHRleHQ6IG1pZGRsZS50ZXh0LnNsaWNlKF9vZmYpXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKG1pZGRsZSwgcmVzdCk7XG5cbiAgICAgICAgICAgIGlmIChiZWZvcmUpIHtcbiAgICAgICAgICAgICAgbmV4dC5wdXNoKGJlZm9yZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG5leHQucHVzaChtaWRkbGUpO1xuXG4gICAgICAgICAgICBpZiAoYWZ0ZXIpIHtcbiAgICAgICAgICAgICAgbmV4dC5wdXNoKGFmdGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIF9pdGVyYXRvcjIuZShlcnIpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIF9pdGVyYXRvcjIuZigpO1xuICAgICAgICB9XG5cbiAgICAgICAgbGVhdmVzID0gbmV4dDtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIF9pdGVyYXRvci5lKGVycik7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIF9pdGVyYXRvci5mKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGxlYXZlcztcbiAgfVxufTtcblxuZnVuY3Rpb24gb3duS2V5cyQzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgaWYgKGVudW1lcmFibGVPbmx5KSB7IHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KTsgfSBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCQzKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgaWYgKGkgJSAyKSB7IG93bktleXMkMyhPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBvd25LZXlzJDMoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDIobywgYWxsb3dBcnJheUxpa2UpIHsgdmFyIGl0ID0gdHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl0gfHwgb1tcIkBAaXRlcmF0b3JcIl07IGlmICghaXQpIHsgaWYgKEFycmF5LmlzQXJyYXkobykgfHwgKGl0ID0gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5JDIobykpIHx8IGFsbG93QXJyYXlMaWtlICYmIG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSB7IGlmIChpdCkgbyA9IGl0OyB2YXIgaSA9IDA7IHZhciBGID0gZnVuY3Rpb24gRigpIHt9OyByZXR1cm4geyBzOiBGLCBuOiBmdW5jdGlvbiBuKCkgeyBpZiAoaSA+PSBvLmxlbmd0aCkgcmV0dXJuIHsgZG9uZTogdHJ1ZSB9OyByZXR1cm4geyBkb25lOiBmYWxzZSwgdmFsdWU6IG9baSsrXSB9OyB9LCBlOiBmdW5jdGlvbiBlKF9lKSB7IHRocm93IF9lOyB9LCBmOiBGIH07IH0gdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9IHZhciBub3JtYWxDb21wbGV0aW9uID0gdHJ1ZSwgZGlkRXJyID0gZmFsc2UsIGVycjsgcmV0dXJuIHsgczogZnVuY3Rpb24gcygpIHsgaXQgPSBpdC5jYWxsKG8pOyB9LCBuOiBmdW5jdGlvbiBuKCkgeyB2YXIgc3RlcCA9IGl0Lm5leHQoKTsgbm9ybWFsQ29tcGxldGlvbiA9IHN0ZXAuZG9uZTsgcmV0dXJuIHN0ZXA7IH0sIGU6IGZ1bmN0aW9uIGUoX2UyKSB7IGRpZEVyciA9IHRydWU7IGVyciA9IF9lMjsgfSwgZjogZnVuY3Rpb24gZigpIHsgdHJ5IHsgaWYgKCFub3JtYWxDb21wbGV0aW9uICYmIGl0W1wicmV0dXJuXCJdICE9IG51bGwpIGl0W1wicmV0dXJuXCJdKCk7IH0gZmluYWxseSB7IGlmIChkaWRFcnIpIHRocm93IGVycjsgfSB9IH07IH1cblxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5JDIobywgbWluTGVuKSB7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheSQyKG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkkMihvLCBtaW5MZW4pOyB9XG5cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5JDIoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgeyBhcnIyW2ldID0gYXJyW2ldOyB9IHJldHVybiBhcnIyOyB9XG5cbnZhciBhcHBseVRvRHJhZnQgPSBmdW5jdGlvbiBhcHBseVRvRHJhZnQoZWRpdG9yLCBzZWxlY3Rpb24sIG9wKSB7XG4gIHN3aXRjaCAob3AudHlwZSkge1xuICAgIGNhc2UgJ2luc2VydF9ub2RlJzpcbiAgICAgIHtcbiAgICAgICAgdmFyIHBhdGggPSBvcC5wYXRoLFxuICAgICAgICAgICAgbm9kZSA9IG9wLm5vZGU7XG4gICAgICAgIHZhciBwYXJlbnQgPSBOb2RlLnBhcmVudChlZGl0b3IsIHBhdGgpO1xuICAgICAgICB2YXIgaW5kZXggPSBwYXRoW3BhdGgubGVuZ3RoIC0gMV07XG5cbiAgICAgICAgaWYgKGluZGV4ID4gcGFyZW50LmNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBhcHBseSBhbiBcXFwiaW5zZXJ0X25vZGVcXFwiIG9wZXJhdGlvbiBhdCBwYXRoIFtcIi5jb25jYXQocGF0aCwgXCJdIGJlY2F1c2UgdGhlIGRlc3RpbmF0aW9uIGlzIHBhc3QgdGhlIGVuZCBvZiB0aGUgbm9kZS5cIikpO1xuICAgICAgICB9XG5cbiAgICAgICAgcGFyZW50LmNoaWxkcmVuLnNwbGljZShpbmRleCwgMCwgbm9kZSk7XG5cbiAgICAgICAgaWYgKHNlbGVjdGlvbikge1xuICAgICAgICAgIHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciQyKFJhbmdlLnBvaW50cyhzZWxlY3Rpb24pKSxcbiAgICAgICAgICAgICAgX3N0ZXA7XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yIChfaXRlcmF0b3IucygpOyAhKF9zdGVwID0gX2l0ZXJhdG9yLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICAgICAgdmFyIF9zdGVwJHZhbHVlID0gX3NsaWNlZFRvQXJyYXkoX3N0ZXAudmFsdWUsIDIpLFxuICAgICAgICAgICAgICAgICAgcG9pbnQgPSBfc3RlcCR2YWx1ZVswXSxcbiAgICAgICAgICAgICAgICAgIGtleSA9IF9zdGVwJHZhbHVlWzFdO1xuXG4gICAgICAgICAgICAgIHNlbGVjdGlvbltrZXldID0gUG9pbnQudHJhbnNmb3JtKHBvaW50LCBvcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBfaXRlcmF0b3IuZShlcnIpO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBfaXRlcmF0b3IuZigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSAnaW5zZXJ0X3RleHQnOlxuICAgICAge1xuICAgICAgICB2YXIgX3BhdGggPSBvcC5wYXRoLFxuICAgICAgICAgICAgb2Zmc2V0ID0gb3Aub2Zmc2V0LFxuICAgICAgICAgICAgdGV4dCA9IG9wLnRleHQ7XG4gICAgICAgIGlmICh0ZXh0Lmxlbmd0aCA9PT0gMCkgYnJlYWs7XG5cbiAgICAgICAgdmFyIF9ub2RlID0gTm9kZS5sZWFmKGVkaXRvciwgX3BhdGgpO1xuXG4gICAgICAgIHZhciBiZWZvcmUgPSBfbm9kZS50ZXh0LnNsaWNlKDAsIG9mZnNldCk7XG5cbiAgICAgICAgdmFyIGFmdGVyID0gX25vZGUudGV4dC5zbGljZShvZmZzZXQpO1xuXG4gICAgICAgIF9ub2RlLnRleHQgPSBiZWZvcmUgKyB0ZXh0ICsgYWZ0ZXI7XG5cbiAgICAgICAgaWYgKHNlbGVjdGlvbikge1xuICAgICAgICAgIHZhciBfaXRlcmF0b3IyID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkMihSYW5nZS5wb2ludHMoc2VsZWN0aW9uKSksXG4gICAgICAgICAgICAgIF9zdGVwMjtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKF9pdGVyYXRvcjIucygpOyAhKF9zdGVwMiA9IF9pdGVyYXRvcjIubigpKS5kb25lOykge1xuICAgICAgICAgICAgICB2YXIgX3N0ZXAyJHZhbHVlID0gX3NsaWNlZFRvQXJyYXkoX3N0ZXAyLnZhbHVlLCAyKSxcbiAgICAgICAgICAgICAgICAgIF9wb2ludCA9IF9zdGVwMiR2YWx1ZVswXSxcbiAgICAgICAgICAgICAgICAgIF9rZXkgPSBfc3RlcDIkdmFsdWVbMV07XG5cbiAgICAgICAgICAgICAgc2VsZWN0aW9uW19rZXldID0gUG9pbnQudHJhbnNmb3JtKF9wb2ludCwgb3ApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgX2l0ZXJhdG9yMi5lKGVycik7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIF9pdGVyYXRvcjIuZigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSAnbWVyZ2Vfbm9kZSc6XG4gICAgICB7XG4gICAgICAgIHZhciBfcGF0aDIgPSBvcC5wYXRoO1xuXG4gICAgICAgIHZhciBfbm9kZTIgPSBOb2RlLmdldChlZGl0b3IsIF9wYXRoMik7XG5cbiAgICAgICAgdmFyIHByZXZQYXRoID0gUGF0aC5wcmV2aW91cyhfcGF0aDIpO1xuICAgICAgICB2YXIgcHJldiA9IE5vZGUuZ2V0KGVkaXRvciwgcHJldlBhdGgpO1xuXG4gICAgICAgIHZhciBfcGFyZW50ID0gTm9kZS5wYXJlbnQoZWRpdG9yLCBfcGF0aDIpO1xuXG4gICAgICAgIHZhciBfaW5kZXggPSBfcGF0aDJbX3BhdGgyLmxlbmd0aCAtIDFdO1xuXG4gICAgICAgIGlmIChUZXh0LmlzVGV4dChfbm9kZTIpICYmIFRleHQuaXNUZXh0KHByZXYpKSB7XG4gICAgICAgICAgcHJldi50ZXh0ICs9IF9ub2RlMi50ZXh0O1xuICAgICAgICB9IGVsc2UgaWYgKCFUZXh0LmlzVGV4dChfbm9kZTIpICYmICFUZXh0LmlzVGV4dChwcmV2KSkge1xuICAgICAgICAgIHZhciBfcHJldiRjaGlsZHJlbjtcblxuICAgICAgICAgIChfcHJldiRjaGlsZHJlbiA9IHByZXYuY2hpbGRyZW4pLnB1c2guYXBwbHkoX3ByZXYkY2hpbGRyZW4sIF90b0NvbnN1bWFibGVBcnJheShfbm9kZTIuY2hpbGRyZW4pKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgYXBwbHkgYSBcXFwibWVyZ2Vfbm9kZVxcXCIgb3BlcmF0aW9uIGF0IHBhdGggW1wiLmNvbmNhdChfcGF0aDIsIFwiXSB0byBub2RlcyBvZiBkaWZmZXJlbnQgaW50ZXJmYWNlczogXCIpLmNvbmNhdChTY3J1YmJlci5zdHJpbmdpZnkoX25vZGUyKSwgXCIgXCIpLmNvbmNhdChTY3J1YmJlci5zdHJpbmdpZnkocHJldikpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIF9wYXJlbnQuY2hpbGRyZW4uc3BsaWNlKF9pbmRleCwgMSk7XG5cbiAgICAgICAgaWYgKHNlbGVjdGlvbikge1xuICAgICAgICAgIHZhciBfaXRlcmF0b3IzID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkMihSYW5nZS5wb2ludHMoc2VsZWN0aW9uKSksXG4gICAgICAgICAgICAgIF9zdGVwMztcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKF9pdGVyYXRvcjMucygpOyAhKF9zdGVwMyA9IF9pdGVyYXRvcjMubigpKS5kb25lOykge1xuICAgICAgICAgICAgICB2YXIgX3N0ZXAzJHZhbHVlID0gX3NsaWNlZFRvQXJyYXkoX3N0ZXAzLnZhbHVlLCAyKSxcbiAgICAgICAgICAgICAgICAgIF9wb2ludDIgPSBfc3RlcDMkdmFsdWVbMF0sXG4gICAgICAgICAgICAgICAgICBfa2V5MiA9IF9zdGVwMyR2YWx1ZVsxXTtcblxuICAgICAgICAgICAgICBzZWxlY3Rpb25bX2tleTJdID0gUG9pbnQudHJhbnNmb3JtKF9wb2ludDIsIG9wKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIF9pdGVyYXRvcjMuZShlcnIpO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBfaXRlcmF0b3IzLmYoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGNhc2UgJ21vdmVfbm9kZSc6XG4gICAgICB7XG4gICAgICAgIHZhciBfcGF0aDMgPSBvcC5wYXRoLFxuICAgICAgICAgICAgbmV3UGF0aCA9IG9wLm5ld1BhdGg7XG5cbiAgICAgICAgaWYgKFBhdGguaXNBbmNlc3RvcihfcGF0aDMsIG5ld1BhdGgpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IG1vdmUgYSBwYXRoIFtcIi5jb25jYXQoX3BhdGgzLCBcIl0gdG8gbmV3IHBhdGggW1wiKS5jb25jYXQobmV3UGF0aCwgXCJdIGJlY2F1c2UgdGhlIGRlc3RpbmF0aW9uIGlzIGluc2lkZSBpdHNlbGYuXCIpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBfbm9kZTMgPSBOb2RlLmdldChlZGl0b3IsIF9wYXRoMyk7XG5cbiAgICAgICAgdmFyIF9wYXJlbnQyID0gTm9kZS5wYXJlbnQoZWRpdG9yLCBfcGF0aDMpO1xuXG4gICAgICAgIHZhciBfaW5kZXgyID0gX3BhdGgzW19wYXRoMy5sZW5ndGggLSAxXTsgLy8gVGhpcyBpcyB0cmlja3ksIGJ1dCBzaW5jZSB0aGUgYHBhdGhgIGFuZCBgbmV3UGF0aGAgYm90aCByZWZlciB0b1xuICAgICAgICAvLyB0aGUgc2FtZSBzbmFwc2hvdCBpbiB0aW1lLCB0aGVyZSdzIGEgbWlzbWF0Y2guIEFmdGVyIGVpdGhlclxuICAgICAgICAvLyByZW1vdmluZyB0aGUgb3JpZ2luYWwgcG9zaXRpb24sIHRoZSBzZWNvbmQgc3RlcCdzIHBhdGggY2FuIGJlIG91dFxuICAgICAgICAvLyBvZiBkYXRlLiBTbyBpbnN0ZWFkIG9mIHVzaW5nIHRoZSBgb3AubmV3UGF0aGAgZGlyZWN0bHksIHdlXG4gICAgICAgIC8vIHRyYW5zZm9ybSBgb3AucGF0aGAgdG8gYXNjZXJ0YWluIHdoYXQgdGhlIGBuZXdQYXRoYCB3b3VsZCBiZSBhZnRlclxuICAgICAgICAvLyB0aGUgb3BlcmF0aW9uIHdhcyBhcHBsaWVkLlxuXG4gICAgICAgIF9wYXJlbnQyLmNoaWxkcmVuLnNwbGljZShfaW5kZXgyLCAxKTtcblxuICAgICAgICB2YXIgdHJ1ZVBhdGggPSBQYXRoLnRyYW5zZm9ybShfcGF0aDMsIG9wKTtcbiAgICAgICAgdmFyIG5ld1BhcmVudCA9IE5vZGUuZ2V0KGVkaXRvciwgUGF0aC5wYXJlbnQodHJ1ZVBhdGgpKTtcbiAgICAgICAgdmFyIG5ld0luZGV4ID0gdHJ1ZVBhdGhbdHJ1ZVBhdGgubGVuZ3RoIC0gMV07XG4gICAgICAgIG5ld1BhcmVudC5jaGlsZHJlbi5zcGxpY2UobmV3SW5kZXgsIDAsIF9ub2RlMyk7XG5cbiAgICAgICAgaWYgKHNlbGVjdGlvbikge1xuICAgICAgICAgIHZhciBfaXRlcmF0b3I0ID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkMihSYW5nZS5wb2ludHMoc2VsZWN0aW9uKSksXG4gICAgICAgICAgICAgIF9zdGVwNDtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKF9pdGVyYXRvcjQucygpOyAhKF9zdGVwNCA9IF9pdGVyYXRvcjQubigpKS5kb25lOykge1xuICAgICAgICAgICAgICB2YXIgX3N0ZXA0JHZhbHVlID0gX3NsaWNlZFRvQXJyYXkoX3N0ZXA0LnZhbHVlLCAyKSxcbiAgICAgICAgICAgICAgICAgIF9wb2ludDMgPSBfc3RlcDQkdmFsdWVbMF0sXG4gICAgICAgICAgICAgICAgICBfa2V5MyA9IF9zdGVwNCR2YWx1ZVsxXTtcblxuICAgICAgICAgICAgICBzZWxlY3Rpb25bX2tleTNdID0gUG9pbnQudHJhbnNmb3JtKF9wb2ludDMsIG9wKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIF9pdGVyYXRvcjQuZShlcnIpO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBfaXRlcmF0b3I0LmYoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGNhc2UgJ3JlbW92ZV9ub2RlJzpcbiAgICAgIHtcbiAgICAgICAgdmFyIF9wYXRoNCA9IG9wLnBhdGg7XG4gICAgICAgIHZhciBfaW5kZXgzID0gX3BhdGg0W19wYXRoNC5sZW5ndGggLSAxXTtcblxuICAgICAgICB2YXIgX3BhcmVudDMgPSBOb2RlLnBhcmVudChlZGl0b3IsIF9wYXRoNCk7XG5cbiAgICAgICAgX3BhcmVudDMuY2hpbGRyZW4uc3BsaWNlKF9pbmRleDMsIDEpOyAvLyBUcmFuc2Zvcm0gYWxsIG9mIHRoZSBwb2ludHMgaW4gdGhlIHZhbHVlLCBidXQgaWYgdGhlIHBvaW50IHdhcyBpbiB0aGVcbiAgICAgICAgLy8gbm9kZSB0aGF0IHdhcyByZW1vdmVkIHdlIG5lZWQgdG8gdXBkYXRlIHRoZSByYW5nZSBvciByZW1vdmUgaXQuXG5cblxuICAgICAgICBpZiAoc2VsZWN0aW9uKSB7XG4gICAgICAgICAgdmFyIF9pdGVyYXRvcjUgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciQyKFJhbmdlLnBvaW50cyhzZWxlY3Rpb24pKSxcbiAgICAgICAgICAgICAgX3N0ZXA1O1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAoX2l0ZXJhdG9yNS5zKCk7ICEoX3N0ZXA1ID0gX2l0ZXJhdG9yNS5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgICAgIHZhciBfc3RlcDUkdmFsdWUgPSBfc2xpY2VkVG9BcnJheShfc3RlcDUudmFsdWUsIDIpLFxuICAgICAgICAgICAgICAgICAgX3BvaW50NCA9IF9zdGVwNSR2YWx1ZVswXSxcbiAgICAgICAgICAgICAgICAgIF9rZXk0ID0gX3N0ZXA1JHZhbHVlWzFdO1xuXG4gICAgICAgICAgICAgIHZhciByZXN1bHQgPSBQb2ludC50cmFuc2Zvcm0oX3BvaW50NCwgb3ApO1xuXG4gICAgICAgICAgICAgIGlmIChzZWxlY3Rpb24gIT0gbnVsbCAmJiByZXN1bHQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHNlbGVjdGlvbltfa2V5NF0gPSByZXN1bHQ7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIF9wcmV2ID0gdm9pZCAwO1xuXG4gICAgICAgICAgICAgICAgdmFyIG5leHQgPSB2b2lkIDA7XG5cbiAgICAgICAgICAgICAgICB2YXIgX2l0ZXJhdG9yNiA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDIoTm9kZS50ZXh0cyhlZGl0b3IpKSxcbiAgICAgICAgICAgICAgICAgICAgX3N0ZXA2O1xuXG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIGZvciAoX2l0ZXJhdG9yNi5zKCk7ICEoX3N0ZXA2ID0gX2l0ZXJhdG9yNi5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfc3RlcDYkdmFsdWUgPSBfc2xpY2VkVG9BcnJheShfc3RlcDYudmFsdWUsIDIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgbiA9IF9zdGVwNiR2YWx1ZVswXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHAgPSBfc3RlcDYkdmFsdWVbMV07XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKFBhdGguY29tcGFyZShwLCBfcGF0aDQpID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgIF9wcmV2ID0gW24sIHBdO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIG5leHQgPSBbbiwgcF07XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgIF9pdGVyYXRvcjYuZShlcnIpO1xuICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICBfaXRlcmF0b3I2LmYoKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgcHJlZmVyTmV4dCA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgaWYgKF9wcmV2ICYmIG5leHQpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChQYXRoLmVxdWFscyhuZXh0WzFdLCBfcGF0aDQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHByZWZlck5leHQgPSAhUGF0aC5oYXNQcmV2aW91cyhuZXh0WzFdKTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHByZWZlck5leHQgPSBQYXRoLmNvbW1vbihfcHJldlsxXSwgX3BhdGg0KS5sZW5ndGggPCBQYXRoLmNvbW1vbihuZXh0WzFdLCBfcGF0aDQpLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoX3ByZXYgJiYgIXByZWZlck5leHQpIHtcbiAgICAgICAgICAgICAgICAgIF9wb2ludDQucGF0aCA9IF9wcmV2WzFdO1xuICAgICAgICAgICAgICAgICAgX3BvaW50NC5vZmZzZXQgPSBfcHJldlswXS50ZXh0Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG5leHQpIHtcbiAgICAgICAgICAgICAgICAgIF9wb2ludDQucGF0aCA9IG5leHRbMV07XG4gICAgICAgICAgICAgICAgICBfcG9pbnQ0Lm9mZnNldCA9IDA7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHNlbGVjdGlvbiA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBfaXRlcmF0b3I1LmUoZXJyKTtcbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgX2l0ZXJhdG9yNS5mKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlICdyZW1vdmVfdGV4dCc6XG4gICAgICB7XG4gICAgICAgIHZhciBfcGF0aDUgPSBvcC5wYXRoLFxuICAgICAgICAgICAgX29mZnNldCA9IG9wLm9mZnNldCxcbiAgICAgICAgICAgIF90ZXh0ID0gb3AudGV4dDtcbiAgICAgICAgaWYgKF90ZXh0Lmxlbmd0aCA9PT0gMCkgYnJlYWs7XG5cbiAgICAgICAgdmFyIF9ub2RlNCA9IE5vZGUubGVhZihlZGl0b3IsIF9wYXRoNSk7XG5cbiAgICAgICAgdmFyIF9iZWZvcmUgPSBfbm9kZTQudGV4dC5zbGljZSgwLCBfb2Zmc2V0KTtcblxuICAgICAgICB2YXIgX2FmdGVyID0gX25vZGU0LnRleHQuc2xpY2UoX29mZnNldCArIF90ZXh0Lmxlbmd0aCk7XG5cbiAgICAgICAgX25vZGU0LnRleHQgPSBfYmVmb3JlICsgX2FmdGVyO1xuXG4gICAgICAgIGlmIChzZWxlY3Rpb24pIHtcbiAgICAgICAgICB2YXIgX2l0ZXJhdG9yNyA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDIoUmFuZ2UucG9pbnRzKHNlbGVjdGlvbikpLFxuICAgICAgICAgICAgICBfc3RlcDc7XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yIChfaXRlcmF0b3I3LnMoKTsgIShfc3RlcDcgPSBfaXRlcmF0b3I3Lm4oKSkuZG9uZTspIHtcbiAgICAgICAgICAgICAgdmFyIF9zdGVwNyR2YWx1ZSA9IF9zbGljZWRUb0FycmF5KF9zdGVwNy52YWx1ZSwgMiksXG4gICAgICAgICAgICAgICAgICBfcG9pbnQ1ID0gX3N0ZXA3JHZhbHVlWzBdLFxuICAgICAgICAgICAgICAgICAgX2tleTUgPSBfc3RlcDckdmFsdWVbMV07XG5cbiAgICAgICAgICAgICAgc2VsZWN0aW9uW19rZXk1XSA9IFBvaW50LnRyYW5zZm9ybShfcG9pbnQ1LCBvcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBfaXRlcmF0b3I3LmUoZXJyKTtcbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgX2l0ZXJhdG9yNy5mKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlICdzZXRfbm9kZSc6XG4gICAgICB7XG4gICAgICAgIHZhciBfcGF0aDYgPSBvcC5wYXRoLFxuICAgICAgICAgICAgcHJvcGVydGllcyA9IG9wLnByb3BlcnRpZXMsXG4gICAgICAgICAgICBuZXdQcm9wZXJ0aWVzID0gb3AubmV3UHJvcGVydGllcztcblxuICAgICAgICBpZiAoX3BhdGg2Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBzZXQgcHJvcGVydGllcyBvbiB0aGUgcm9vdCBub2RlIVwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBfbm9kZTUgPSBOb2RlLmdldChlZGl0b3IsIF9wYXRoNik7XG5cbiAgICAgICAgZm9yICh2YXIgX2tleTYgaW4gbmV3UHJvcGVydGllcykge1xuICAgICAgICAgIGlmIChfa2V5NiA9PT0gJ2NoaWxkcmVuJyB8fCBfa2V5NiA9PT0gJ3RleHQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3Qgc2V0IHRoZSBcXFwiXCIuY29uY2F0KF9rZXk2LCBcIlxcXCIgcHJvcGVydHkgb2Ygbm9kZXMhXCIpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgdmFsdWUgPSBuZXdQcm9wZXJ0aWVzW19rZXk2XTtcblxuICAgICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICBkZWxldGUgX25vZGU1W19rZXk2XTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgX25vZGU1W19rZXk2XSA9IHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBwcm9wZXJ0aWVzIHRoYXQgd2VyZSBwcmV2aW91c2x5IGRlZmluZWQsIGJ1dCBhcmUgbm93IG1pc3NpbmcsIG11c3QgYmUgZGVsZXRlZFxuXG5cbiAgICAgICAgZm9yICh2YXIgX2tleTcgaW4gcHJvcGVydGllcykge1xuICAgICAgICAgIGlmICghbmV3UHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShfa2V5NykpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBfbm9kZTVbX2tleTddO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSAnc2V0X3NlbGVjdGlvbic6XG4gICAgICB7XG4gICAgICAgIHZhciBfbmV3UHJvcGVydGllcyA9IG9wLm5ld1Byb3BlcnRpZXM7XG5cbiAgICAgICAgaWYgKF9uZXdQcm9wZXJ0aWVzID09IG51bGwpIHtcbiAgICAgICAgICBzZWxlY3Rpb24gPSBfbmV3UHJvcGVydGllcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoc2VsZWN0aW9uID09IG51bGwpIHtcbiAgICAgICAgICAgIGlmICghUmFuZ2UuaXNSYW5nZShfbmV3UHJvcGVydGllcykpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGFwcGx5IGFuIGluY29tcGxldGUgXFxcInNldF9zZWxlY3Rpb25cXFwiIG9wZXJhdGlvbiBwcm9wZXJ0aWVzIFwiLmNvbmNhdChTY3J1YmJlci5zdHJpbmdpZnkoX25ld1Byb3BlcnRpZXMpLCBcIiB3aGVuIHRoZXJlIGlzIG5vIGN1cnJlbnQgc2VsZWN0aW9uLlwiKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNlbGVjdGlvbiA9IF9vYmplY3RTcHJlYWQkMyh7fSwgX25ld1Byb3BlcnRpZXMpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZvciAodmFyIF9rZXk4IGluIF9uZXdQcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICB2YXIgX3ZhbHVlID0gX25ld1Byb3BlcnRpZXNbX2tleThdO1xuXG4gICAgICAgICAgICBpZiAoX3ZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgaWYgKF9rZXk4ID09PSAnYW5jaG9yJyB8fCBfa2V5OCA9PT0gJ2ZvY3VzJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCByZW1vdmUgdGhlIFxcXCJcIi5jb25jYXQoX2tleTgsIFwiXFxcIiBzZWxlY3Rpb24gcHJvcGVydHlcIikpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgZGVsZXRlIHNlbGVjdGlvbltfa2V5OF07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzZWxlY3Rpb25bX2tleThdID0gX3ZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSAnc3BsaXRfbm9kZSc6XG4gICAgICB7XG4gICAgICAgIHZhciBfcGF0aDcgPSBvcC5wYXRoLFxuICAgICAgICAgICAgcG9zaXRpb24gPSBvcC5wb3NpdGlvbixcbiAgICAgICAgICAgIF9wcm9wZXJ0aWVzID0gb3AucHJvcGVydGllcztcblxuICAgICAgICBpZiAoX3BhdGg3Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBhcHBseSBhIFxcXCJzcGxpdF9ub2RlXFxcIiBvcGVyYXRpb24gYXQgcGF0aCBbXCIuY29uY2F0KF9wYXRoNywgXCJdIGJlY2F1c2UgdGhlIHJvb3Qgbm9kZSBjYW5ub3QgYmUgc3BsaXQuXCIpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBfbm9kZTYgPSBOb2RlLmdldChlZGl0b3IsIF9wYXRoNyk7XG5cbiAgICAgICAgdmFyIF9wYXJlbnQ0ID0gTm9kZS5wYXJlbnQoZWRpdG9yLCBfcGF0aDcpO1xuXG4gICAgICAgIHZhciBfaW5kZXg0ID0gX3BhdGg3W19wYXRoNy5sZW5ndGggLSAxXTtcbiAgICAgICAgdmFyIG5ld05vZGU7XG5cbiAgICAgICAgaWYgKFRleHQuaXNUZXh0KF9ub2RlNikpIHtcbiAgICAgICAgICB2YXIgX2JlZm9yZTIgPSBfbm9kZTYudGV4dC5zbGljZSgwLCBwb3NpdGlvbik7XG5cbiAgICAgICAgICB2YXIgX2FmdGVyMiA9IF9ub2RlNi50ZXh0LnNsaWNlKHBvc2l0aW9uKTtcblxuICAgICAgICAgIF9ub2RlNi50ZXh0ID0gX2JlZm9yZTI7XG4gICAgICAgICAgbmV3Tm9kZSA9IF9vYmplY3RTcHJlYWQkMyhfb2JqZWN0U3ByZWFkJDMoe30sIF9wcm9wZXJ0aWVzKSwge30sIHtcbiAgICAgICAgICAgIHRleHQ6IF9hZnRlcjJcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgX2JlZm9yZTMgPSBfbm9kZTYuY2hpbGRyZW4uc2xpY2UoMCwgcG9zaXRpb24pO1xuXG4gICAgICAgICAgdmFyIF9hZnRlcjMgPSBfbm9kZTYuY2hpbGRyZW4uc2xpY2UocG9zaXRpb24pO1xuXG4gICAgICAgICAgX25vZGU2LmNoaWxkcmVuID0gX2JlZm9yZTM7XG4gICAgICAgICAgbmV3Tm9kZSA9IF9vYmplY3RTcHJlYWQkMyhfb2JqZWN0U3ByZWFkJDMoe30sIF9wcm9wZXJ0aWVzKSwge30sIHtcbiAgICAgICAgICAgIGNoaWxkcmVuOiBfYWZ0ZXIzXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBfcGFyZW50NC5jaGlsZHJlbi5zcGxpY2UoX2luZGV4NCArIDEsIDAsIG5ld05vZGUpO1xuXG4gICAgICAgIGlmIChzZWxlY3Rpb24pIHtcbiAgICAgICAgICB2YXIgX2l0ZXJhdG9yOCA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDIoUmFuZ2UucG9pbnRzKHNlbGVjdGlvbikpLFxuICAgICAgICAgICAgICBfc3RlcDg7XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yIChfaXRlcmF0b3I4LnMoKTsgIShfc3RlcDggPSBfaXRlcmF0b3I4Lm4oKSkuZG9uZTspIHtcbiAgICAgICAgICAgICAgdmFyIF9zdGVwOCR2YWx1ZSA9IF9zbGljZWRUb0FycmF5KF9zdGVwOC52YWx1ZSwgMiksXG4gICAgICAgICAgICAgICAgICBfcG9pbnQ2ID0gX3N0ZXA4JHZhbHVlWzBdLFxuICAgICAgICAgICAgICAgICAgX2tleTkgPSBfc3RlcDgkdmFsdWVbMV07XG5cbiAgICAgICAgICAgICAgc2VsZWN0aW9uW19rZXk5XSA9IFBvaW50LnRyYW5zZm9ybShfcG9pbnQ2LCBvcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBfaXRlcmF0b3I4LmUoZXJyKTtcbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgX2l0ZXJhdG9yOC5mKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gIH1cblxuICByZXR1cm4gc2VsZWN0aW9uO1xufTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlZGVjbGFyZVxuXG5cbnZhciBHZW5lcmFsVHJhbnNmb3JtcyA9IHtcbiAgLyoqXHJcbiAgICogVHJhbnNmb3JtIHRoZSBlZGl0b3IgYnkgYW4gb3BlcmF0aW9uLlxyXG4gICAqL1xuICB0cmFuc2Zvcm06IGZ1bmN0aW9uIHRyYW5zZm9ybShlZGl0b3IsIG9wKSB7XG4gICAgZWRpdG9yLmNoaWxkcmVuID0gaW1tZXIuY3JlYXRlRHJhZnQoZWRpdG9yLmNoaWxkcmVuKTtcbiAgICB2YXIgc2VsZWN0aW9uID0gZWRpdG9yLnNlbGVjdGlvbiAmJiBpbW1lci5jcmVhdGVEcmFmdChlZGl0b3Iuc2VsZWN0aW9uKTtcblxuICAgIHRyeSB7XG4gICAgICBzZWxlY3Rpb24gPSBhcHBseVRvRHJhZnQoZWRpdG9yLCBzZWxlY3Rpb24sIG9wKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgZWRpdG9yLmNoaWxkcmVuID0gaW1tZXIuZmluaXNoRHJhZnQoZWRpdG9yLmNoaWxkcmVuKTtcblxuICAgICAgaWYgKHNlbGVjdGlvbikge1xuICAgICAgICBlZGl0b3Iuc2VsZWN0aW9uID0gaW1tZXIuaXNEcmFmdChzZWxlY3Rpb24pID8gaW1tZXIuZmluaXNoRHJhZnQoc2VsZWN0aW9uKSA6IHNlbGVjdGlvbjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVkaXRvci5zZWxlY3Rpb24gPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxudmFyIF9leGNsdWRlZCA9IFtcInRleHRcIl0sXG4gICAgX2V4Y2x1ZGVkMiA9IFtcImNoaWxkcmVuXCJdO1xuXG5mdW5jdGlvbiBvd25LZXlzJDIob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBpZiAoZW51bWVyYWJsZU9ubHkpIHsgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyB9IGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkJDIodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgb3duS2V5cyQyKE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pOyB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7IH0gZWxzZSB7IG93bktleXMkMihPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkMShvLCBhbGxvd0FycmF5TGlrZSkgeyB2YXIgaXQgPSB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXSB8fCBvW1wiQEBpdGVyYXRvclwiXTsgaWYgKCFpdCkgeyBpZiAoQXJyYXkuaXNBcnJheShvKSB8fCAoaXQgPSBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkkMShvKSkgfHwgYWxsb3dBcnJheUxpa2UgJiYgbyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHsgaWYgKGl0KSBvID0gaXQ7IHZhciBpID0gMDsgdmFyIEYgPSBmdW5jdGlvbiBGKCkge307IHJldHVybiB7IHM6IEYsIG46IGZ1bmN0aW9uIG4oKSB7IGlmIChpID49IG8ubGVuZ3RoKSByZXR1cm4geyBkb25lOiB0cnVlIH07IHJldHVybiB7IGRvbmU6IGZhbHNlLCB2YWx1ZTogb1tpKytdIH07IH0sIGU6IGZ1bmN0aW9uIGUoX2UpIHsgdGhyb3cgX2U7IH0sIGY6IEYgfTsgfSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGl0ZXJhdGUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH0gdmFyIG5vcm1hbENvbXBsZXRpb24gPSB0cnVlLCBkaWRFcnIgPSBmYWxzZSwgZXJyOyByZXR1cm4geyBzOiBmdW5jdGlvbiBzKCkgeyBpdCA9IGl0LmNhbGwobyk7IH0sIG46IGZ1bmN0aW9uIG4oKSB7IHZhciBzdGVwID0gaXQubmV4dCgpOyBub3JtYWxDb21wbGV0aW9uID0gc3RlcC5kb25lOyByZXR1cm4gc3RlcDsgfSwgZTogZnVuY3Rpb24gZShfZTIpIHsgZGlkRXJyID0gdHJ1ZTsgZXJyID0gX2UyOyB9LCBmOiBmdW5jdGlvbiBmKCkgeyB0cnkgeyBpZiAoIW5vcm1hbENvbXBsZXRpb24gJiYgaXRbXCJyZXR1cm5cIl0gIT0gbnVsbCkgaXRbXCJyZXR1cm5cIl0oKTsgfSBmaW5hbGx5IHsgaWYgKGRpZEVycikgdGhyb3cgZXJyOyB9IH0gfTsgfVxuXG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkkMShvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5JDEobywgbWluTGVuKTsgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheSQxKG8sIG1pbkxlbik7IH1cblxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkkMShhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH1cblxudmFyIE5vZGVUcmFuc2Zvcm1zID0ge1xuICAvKipcclxuICAgKiBJbnNlcnQgbm9kZXMgYXQgYSBzcGVjaWZpYyBsb2NhdGlvbiBpbiB0aGUgRWRpdG9yLlxyXG4gICAqL1xuICBpbnNlcnROb2RlczogZnVuY3Rpb24gaW5zZXJ0Tm9kZXMoZWRpdG9yLCBub2Rlcykge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICBFZGl0b3Iud2l0aG91dE5vcm1hbGl6aW5nKGVkaXRvciwgZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9vcHRpb25zJGhhbmdpbmcgPSBvcHRpb25zLmhhbmdpbmcsXG4gICAgICAgICAgaGFuZ2luZyA9IF9vcHRpb25zJGhhbmdpbmcgPT09IHZvaWQgMCA/IGZhbHNlIDogX29wdGlvbnMkaGFuZ2luZyxcbiAgICAgICAgICBfb3B0aW9ucyR2b2lkcyA9IG9wdGlvbnMudm9pZHMsXG4gICAgICAgICAgdm9pZHMgPSBfb3B0aW9ucyR2b2lkcyA9PT0gdm9pZCAwID8gZmFsc2UgOiBfb3B0aW9ucyR2b2lkcyxcbiAgICAgICAgICBfb3B0aW9ucyRtb2RlID0gb3B0aW9ucy5tb2RlLFxuICAgICAgICAgIG1vZGUgPSBfb3B0aW9ucyRtb2RlID09PSB2b2lkIDAgPyAnbG93ZXN0JyA6IF9vcHRpb25zJG1vZGU7XG4gICAgICB2YXIgYXQgPSBvcHRpb25zLmF0LFxuICAgICAgICAgIG1hdGNoID0gb3B0aW9ucy5tYXRjaCxcbiAgICAgICAgICBzZWxlY3QgPSBvcHRpb25zLnNlbGVjdDtcblxuICAgICAgaWYgKE5vZGUuaXNOb2RlKG5vZGVzKSkge1xuICAgICAgICBub2RlcyA9IFtub2Rlc107XG4gICAgICB9XG5cbiAgICAgIGlmIChub2Rlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgX25vZGVzID0gbm9kZXMsXG4gICAgICAgICAgX25vZGVzMiA9IF9zbGljZWRUb0FycmF5KF9ub2RlcywgMSksXG4gICAgICAgICAgbm9kZSA9IF9ub2RlczJbMF07IC8vIEJ5IGRlZmF1bHQsIHVzZSB0aGUgc2VsZWN0aW9uIGFzIHRoZSB0YXJnZXQgbG9jYXRpb24uIEJ1dCBpZiB0aGVyZSBpc1xuICAgICAgLy8gbm8gc2VsZWN0aW9uLCBpbnNlcnQgYXQgdGhlIGVuZCBvZiB0aGUgZG9jdW1lbnQgc2luY2UgdGhhdCBpcyBzdWNoIGFcbiAgICAgIC8vIGNvbW1vbiB1c2UgY2FzZSB3aGVuIGluc2VydGluZyBmcm9tIGEgbm9uLXNlbGVjdGVkIHN0YXRlLlxuXG5cbiAgICAgIGlmICghYXQpIHtcbiAgICAgICAgaWYgKGVkaXRvci5zZWxlY3Rpb24pIHtcbiAgICAgICAgICBhdCA9IGVkaXRvci5zZWxlY3Rpb247XG4gICAgICAgIH0gZWxzZSBpZiAoZWRpdG9yLmNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBhdCA9IEVkaXRvci5lbmQoZWRpdG9yLCBbXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYXQgPSBbMF07XG4gICAgICAgIH1cblxuICAgICAgICBzZWxlY3QgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2VsZWN0ID09IG51bGwpIHtcbiAgICAgICAgc2VsZWN0ID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmIChSYW5nZS5pc1JhbmdlKGF0KSkge1xuICAgICAgICBpZiAoIWhhbmdpbmcpIHtcbiAgICAgICAgICBhdCA9IEVkaXRvci51bmhhbmdSYW5nZShlZGl0b3IsIGF0LCB7XG4gICAgICAgICAgICB2b2lkczogdm9pZHNcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChSYW5nZS5pc0NvbGxhcHNlZChhdCkpIHtcbiAgICAgICAgICBhdCA9IGF0LmFuY2hvcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgX1JhbmdlJGVkZ2VzID0gUmFuZ2UuZWRnZXMoYXQpLFxuICAgICAgICAgICAgICBfUmFuZ2UkZWRnZXMyID0gX3NsaWNlZFRvQXJyYXkoX1JhbmdlJGVkZ2VzLCAyKSxcbiAgICAgICAgICAgICAgZW5kID0gX1JhbmdlJGVkZ2VzMlsxXTtcblxuICAgICAgICAgIHZhciBwb2ludFJlZiA9IEVkaXRvci5wb2ludFJlZihlZGl0b3IsIGVuZCk7XG4gICAgICAgICAgVHJhbnNmb3Jtc1tcImRlbGV0ZVwiXShlZGl0b3IsIHtcbiAgICAgICAgICAgIGF0OiBhdFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGF0ID0gcG9pbnRSZWYudW5yZWYoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoUG9pbnQuaXNQb2ludChhdCkpIHtcbiAgICAgICAgaWYgKG1hdGNoID09IG51bGwpIHtcbiAgICAgICAgICBpZiAoVGV4dC5pc1RleHQobm9kZSkpIHtcbiAgICAgICAgICAgIG1hdGNoID0gZnVuY3Rpb24gbWF0Y2gobikge1xuICAgICAgICAgICAgICByZXR1cm4gVGV4dC5pc1RleHQobik7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0gZWxzZSBpZiAoZWRpdG9yLmlzSW5saW5lKG5vZGUpKSB7XG4gICAgICAgICAgICBtYXRjaCA9IGZ1bmN0aW9uIG1hdGNoKG4pIHtcbiAgICAgICAgICAgICAgcmV0dXJuIFRleHQuaXNUZXh0KG4pIHx8IEVkaXRvci5pc0lubGluZShlZGl0b3IsIG4pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWF0Y2ggPSBmdW5jdGlvbiBtYXRjaChuKSB7XG4gICAgICAgICAgICAgIHJldHVybiBFbGVtZW50LmlzRWxlbWVudChuKSAmJiBFZGl0b3IuaXNCbG9jayhlZGl0b3IsIG4pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgX0VkaXRvciRub2RlcyA9IEVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICBhdDogYXQucGF0aCxcbiAgICAgICAgICBtYXRjaDogbWF0Y2gsXG4gICAgICAgICAgbW9kZTogbW9kZSxcbiAgICAgICAgICB2b2lkczogdm9pZHNcbiAgICAgICAgfSksXG4gICAgICAgICAgICBfRWRpdG9yJG5vZGVzMiA9IF9zbGljZWRUb0FycmF5KF9FZGl0b3Ikbm9kZXMsIDEpLFxuICAgICAgICAgICAgZW50cnkgPSBfRWRpdG9yJG5vZGVzMlswXTtcblxuICAgICAgICBpZiAoZW50cnkpIHtcbiAgICAgICAgICB2YXIgX2VudHJ5ID0gX3NsaWNlZFRvQXJyYXkoZW50cnksIDIpLFxuICAgICAgICAgICAgICBfbWF0Y2hQYXRoID0gX2VudHJ5WzFdO1xuXG4gICAgICAgICAgdmFyIHBhdGhSZWYgPSBFZGl0b3IucGF0aFJlZihlZGl0b3IsIF9tYXRjaFBhdGgpO1xuICAgICAgICAgIHZhciBpc0F0RW5kID0gRWRpdG9yLmlzRW5kKGVkaXRvciwgYXQsIF9tYXRjaFBhdGgpO1xuICAgICAgICAgIFRyYW5zZm9ybXMuc3BsaXROb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAgIGF0OiBhdCxcbiAgICAgICAgICAgIG1hdGNoOiBtYXRjaCxcbiAgICAgICAgICAgIG1vZGU6IG1vZGUsXG4gICAgICAgICAgICB2b2lkczogdm9pZHNcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB2YXIgcGF0aCA9IHBhdGhSZWYudW5yZWYoKTtcbiAgICAgICAgICBhdCA9IGlzQXRFbmQgPyBQYXRoLm5leHQocGF0aCkgOiBwYXRoO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgcGFyZW50UGF0aCA9IFBhdGgucGFyZW50KGF0KTtcbiAgICAgIHZhciBpbmRleCA9IGF0W2F0Lmxlbmd0aCAtIDFdO1xuXG4gICAgICBpZiAoIXZvaWRzICYmIEVkaXRvcltcInZvaWRcIl0oZWRpdG9yLCB7XG4gICAgICAgIGF0OiBwYXJlbnRQYXRoXG4gICAgICB9KSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciQxKG5vZGVzKSxcbiAgICAgICAgICBfc3RlcDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChfaXRlcmF0b3IucygpOyAhKF9zdGVwID0gX2l0ZXJhdG9yLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICB2YXIgX25vZGUgPSBfc3RlcC52YWx1ZTtcblxuICAgICAgICAgIHZhciBfcGF0aCA9IHBhcmVudFBhdGguY29uY2F0KGluZGV4KTtcblxuICAgICAgICAgIGluZGV4Kys7XG4gICAgICAgICAgZWRpdG9yLmFwcGx5KHtcbiAgICAgICAgICAgIHR5cGU6ICdpbnNlcnRfbm9kZScsXG4gICAgICAgICAgICBwYXRoOiBfcGF0aCxcbiAgICAgICAgICAgIG5vZGU6IF9ub2RlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYXQgPSBQYXRoLm5leHQoYXQpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2l0ZXJhdG9yLmUoZXJyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIF9pdGVyYXRvci5mKCk7XG4gICAgICB9XG5cbiAgICAgIGF0ID0gUGF0aC5wcmV2aW91cyhhdCk7XG5cbiAgICAgIGlmIChzZWxlY3QpIHtcbiAgICAgICAgdmFyIHBvaW50ID0gRWRpdG9yLmVuZChlZGl0b3IsIGF0KTtcblxuICAgICAgICBpZiAocG9pbnQpIHtcbiAgICAgICAgICBUcmFuc2Zvcm1zLnNlbGVjdChlZGl0b3IsIHBvaW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIExpZnQgbm9kZXMgYXQgYSBzcGVjaWZpYyBsb2NhdGlvbiB1cHdhcmRzIGluIHRoZSBkb2N1bWVudCB0cmVlLCBzcGxpdHRpbmdcclxuICAgKiB0aGVpciBwYXJlbnQgaW4gdHdvIGlmIG5lY2Vzc2FyeS5cclxuICAgKi9cbiAgbGlmdE5vZGVzOiBmdW5jdGlvbiBsaWZ0Tm9kZXMoZWRpdG9yKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIEVkaXRvci53aXRob3V0Tm9ybWFsaXppbmcoZWRpdG9yLCBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX29wdGlvbnMkYXQgPSBvcHRpb25zLmF0LFxuICAgICAgICAgIGF0ID0gX29wdGlvbnMkYXQgPT09IHZvaWQgMCA/IGVkaXRvci5zZWxlY3Rpb24gOiBfb3B0aW9ucyRhdCxcbiAgICAgICAgICBfb3B0aW9ucyRtb2RlMiA9IG9wdGlvbnMubW9kZSxcbiAgICAgICAgICBtb2RlID0gX29wdGlvbnMkbW9kZTIgPT09IHZvaWQgMCA/ICdsb3dlc3QnIDogX29wdGlvbnMkbW9kZTIsXG4gICAgICAgICAgX29wdGlvbnMkdm9pZHMyID0gb3B0aW9ucy52b2lkcyxcbiAgICAgICAgICB2b2lkcyA9IF9vcHRpb25zJHZvaWRzMiA9PT0gdm9pZCAwID8gZmFsc2UgOiBfb3B0aW9ucyR2b2lkczI7XG4gICAgICB2YXIgbWF0Y2ggPSBvcHRpb25zLm1hdGNoO1xuXG4gICAgICBpZiAobWF0Y2ggPT0gbnVsbCkge1xuICAgICAgICBtYXRjaCA9IFBhdGguaXNQYXRoKGF0KSA/IG1hdGNoUGF0aChlZGl0b3IsIGF0KSA6IGZ1bmN0aW9uIChuKSB7XG4gICAgICAgICAgcmV0dXJuIEVsZW1lbnQuaXNFbGVtZW50KG4pICYmIEVkaXRvci5pc0Jsb2NrKGVkaXRvciwgbik7XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGlmICghYXQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgbWF0Y2hlcyA9IEVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICAgICAgYXQ6IGF0LFxuICAgICAgICBtYXRjaDogbWF0Y2gsXG4gICAgICAgIG1vZGU6IG1vZGUsXG4gICAgICAgIHZvaWRzOiB2b2lkc1xuICAgICAgfSk7XG4gICAgICB2YXIgcGF0aFJlZnMgPSBBcnJheS5mcm9tKG1hdGNoZXMsIGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgICAgIHZhciBfcmVmMiA9IF9zbGljZWRUb0FycmF5KF9yZWYsIDIpLFxuICAgICAgICAgICAgcCA9IF9yZWYyWzFdO1xuXG4gICAgICAgIHJldHVybiBFZGl0b3IucGF0aFJlZihlZGl0b3IsIHApO1xuICAgICAgfSk7XG5cbiAgICAgIGZvciAodmFyIF9pID0gMCwgX3BhdGhSZWZzID0gcGF0aFJlZnM7IF9pIDwgX3BhdGhSZWZzLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgcGF0aFJlZiA9IF9wYXRoUmVmc1tfaV07XG4gICAgICAgIHZhciBwYXRoID0gcGF0aFJlZi51bnJlZigpO1xuXG4gICAgICAgIGlmIChwYXRoLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgbGlmdCBub2RlIGF0IGEgcGF0aCBbXCIuY29uY2F0KHBhdGgsIFwiXSBiZWNhdXNlIGl0IGhhcyBhIGRlcHRoIG9mIGxlc3MgdGhhbiBgMmAuXCIpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwYXJlbnROb2RlRW50cnkgPSBFZGl0b3Iubm9kZShlZGl0b3IsIFBhdGgucGFyZW50KHBhdGgpKTtcblxuICAgICAgICB2YXIgX3BhcmVudE5vZGVFbnRyeSA9IF9zbGljZWRUb0FycmF5KHBhcmVudE5vZGVFbnRyeSwgMiksXG4gICAgICAgICAgICBwYXJlbnQgPSBfcGFyZW50Tm9kZUVudHJ5WzBdLFxuICAgICAgICAgICAgcGFyZW50UGF0aCA9IF9wYXJlbnROb2RlRW50cnlbMV07XG5cbiAgICAgICAgdmFyIGluZGV4ID0gcGF0aFtwYXRoLmxlbmd0aCAtIDFdO1xuICAgICAgICB2YXIgbGVuZ3RoID0gcGFyZW50LmNoaWxkcmVuLmxlbmd0aDtcblxuICAgICAgICBpZiAobGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgdmFyIHRvUGF0aCA9IFBhdGgubmV4dChwYXJlbnRQYXRoKTtcbiAgICAgICAgICBUcmFuc2Zvcm1zLm1vdmVOb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAgIGF0OiBwYXRoLFxuICAgICAgICAgICAgdG86IHRvUGF0aCxcbiAgICAgICAgICAgIHZvaWRzOiB2b2lkc1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIFRyYW5zZm9ybXMucmVtb3ZlTm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICBhdDogcGFyZW50UGF0aCxcbiAgICAgICAgICAgIHZvaWRzOiB2b2lkc1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKGluZGV4ID09PSAwKSB7XG4gICAgICAgICAgVHJhbnNmb3Jtcy5tb3ZlTm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICBhdDogcGF0aCxcbiAgICAgICAgICAgIHRvOiBwYXJlbnRQYXRoLFxuICAgICAgICAgICAgdm9pZHM6IHZvaWRzXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaW5kZXggPT09IGxlbmd0aCAtIDEpIHtcbiAgICAgICAgICB2YXIgX3RvUGF0aCA9IFBhdGgubmV4dChwYXJlbnRQYXRoKTtcblxuICAgICAgICAgIFRyYW5zZm9ybXMubW92ZU5vZGVzKGVkaXRvciwge1xuICAgICAgICAgICAgYXQ6IHBhdGgsXG4gICAgICAgICAgICB0bzogX3RvUGF0aCxcbiAgICAgICAgICAgIHZvaWRzOiB2b2lkc1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBzcGxpdFBhdGggPSBQYXRoLm5leHQocGF0aCk7XG5cbiAgICAgICAgICB2YXIgX3RvUGF0aDIgPSBQYXRoLm5leHQocGFyZW50UGF0aCk7XG5cbiAgICAgICAgICBUcmFuc2Zvcm1zLnNwbGl0Tm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICBhdDogc3BsaXRQYXRoLFxuICAgICAgICAgICAgdm9pZHM6IHZvaWRzXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgVHJhbnNmb3Jtcy5tb3ZlTm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICBhdDogcGF0aCxcbiAgICAgICAgICAgIHRvOiBfdG9QYXRoMixcbiAgICAgICAgICAgIHZvaWRzOiB2b2lkc1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogTWVyZ2UgYSBub2RlIGF0IGEgbG9jYXRpb24gd2l0aCB0aGUgcHJldmlvdXMgbm9kZSBvZiB0aGUgc2FtZSBkZXB0aCxcclxuICAgKiByZW1vdmluZyBhbnkgZW1wdHkgY29udGFpbmluZyBub2RlcyBhZnRlciB0aGUgbWVyZ2UgaWYgbmVjZXNzYXJ5LlxyXG4gICAqL1xuICBtZXJnZU5vZGVzOiBmdW5jdGlvbiBtZXJnZU5vZGVzKGVkaXRvcikge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICBFZGl0b3Iud2l0aG91dE5vcm1hbGl6aW5nKGVkaXRvciwgZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIG1hdGNoID0gb3B0aW9ucy5tYXRjaCxcbiAgICAgICAgICBfb3B0aW9ucyRhdDIgPSBvcHRpb25zLmF0LFxuICAgICAgICAgIGF0ID0gX29wdGlvbnMkYXQyID09PSB2b2lkIDAgPyBlZGl0b3Iuc2VsZWN0aW9uIDogX29wdGlvbnMkYXQyO1xuICAgICAgdmFyIF9vcHRpb25zJGhhbmdpbmcyID0gb3B0aW9ucy5oYW5naW5nLFxuICAgICAgICAgIGhhbmdpbmcgPSBfb3B0aW9ucyRoYW5naW5nMiA9PT0gdm9pZCAwID8gZmFsc2UgOiBfb3B0aW9ucyRoYW5naW5nMixcbiAgICAgICAgICBfb3B0aW9ucyR2b2lkczMgPSBvcHRpb25zLnZvaWRzLFxuICAgICAgICAgIHZvaWRzID0gX29wdGlvbnMkdm9pZHMzID09PSB2b2lkIDAgPyBmYWxzZSA6IF9vcHRpb25zJHZvaWRzMyxcbiAgICAgICAgICBfb3B0aW9ucyRtb2RlMyA9IG9wdGlvbnMubW9kZSxcbiAgICAgICAgICBtb2RlID0gX29wdGlvbnMkbW9kZTMgPT09IHZvaWQgMCA/ICdsb3dlc3QnIDogX29wdGlvbnMkbW9kZTM7XG5cbiAgICAgIGlmICghYXQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAobWF0Y2ggPT0gbnVsbCkge1xuICAgICAgICBpZiAoUGF0aC5pc1BhdGgoYXQpKSB7XG4gICAgICAgICAgdmFyIF9FZGl0b3IkcGFyZW50ID0gRWRpdG9yLnBhcmVudChlZGl0b3IsIGF0KSxcbiAgICAgICAgICAgICAgX0VkaXRvciRwYXJlbnQyID0gX3NsaWNlZFRvQXJyYXkoX0VkaXRvciRwYXJlbnQsIDEpLFxuICAgICAgICAgICAgICBwYXJlbnQgPSBfRWRpdG9yJHBhcmVudDJbMF07XG5cbiAgICAgICAgICBtYXRjaCA9IGZ1bmN0aW9uIG1hdGNoKG4pIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJlbnQuY2hpbGRyZW4uaW5jbHVkZXMobik7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtYXRjaCA9IGZ1bmN0aW9uIG1hdGNoKG4pIHtcbiAgICAgICAgICAgIHJldHVybiBFbGVtZW50LmlzRWxlbWVudChuKSAmJiBFZGl0b3IuaXNCbG9jayhlZGl0b3IsIG4pO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCFoYW5naW5nICYmIFJhbmdlLmlzUmFuZ2UoYXQpKSB7XG4gICAgICAgIGF0ID0gRWRpdG9yLnVuaGFuZ1JhbmdlKGVkaXRvciwgYXQsIHtcbiAgICAgICAgICB2b2lkczogdm9pZHNcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChSYW5nZS5pc1JhbmdlKGF0KSkge1xuICAgICAgICBpZiAoUmFuZ2UuaXNDb2xsYXBzZWQoYXQpKSB7XG4gICAgICAgICAgYXQgPSBhdC5hbmNob3I7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIF9SYW5nZSRlZGdlczMgPSBSYW5nZS5lZGdlcyhhdCksXG4gICAgICAgICAgICAgIF9SYW5nZSRlZGdlczQgPSBfc2xpY2VkVG9BcnJheShfUmFuZ2UkZWRnZXMzLCAyKSxcbiAgICAgICAgICAgICAgZW5kID0gX1JhbmdlJGVkZ2VzNFsxXTtcblxuICAgICAgICAgIHZhciBwb2ludFJlZiA9IEVkaXRvci5wb2ludFJlZihlZGl0b3IsIGVuZCk7XG4gICAgICAgICAgVHJhbnNmb3Jtc1tcImRlbGV0ZVwiXShlZGl0b3IsIHtcbiAgICAgICAgICAgIGF0OiBhdFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGF0ID0gcG9pbnRSZWYudW5yZWYoKTtcblxuICAgICAgICAgIGlmIChvcHRpb25zLmF0ID09IG51bGwpIHtcbiAgICAgICAgICAgIFRyYW5zZm9ybXMuc2VsZWN0KGVkaXRvciwgYXQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgX0VkaXRvciRub2RlczMgPSBFZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgICAgIGF0OiBhdCxcbiAgICAgICAgbWF0Y2g6IG1hdGNoLFxuICAgICAgICB2b2lkczogdm9pZHMsXG4gICAgICAgIG1vZGU6IG1vZGVcbiAgICAgIH0pLFxuICAgICAgICAgIF9FZGl0b3Ikbm9kZXM0ID0gX3NsaWNlZFRvQXJyYXkoX0VkaXRvciRub2RlczMsIDEpLFxuICAgICAgICAgIGN1cnJlbnQgPSBfRWRpdG9yJG5vZGVzNFswXTtcblxuICAgICAgdmFyIHByZXYgPSBFZGl0b3IucHJldmlvdXMoZWRpdG9yLCB7XG4gICAgICAgIGF0OiBhdCxcbiAgICAgICAgbWF0Y2g6IG1hdGNoLFxuICAgICAgICB2b2lkczogdm9pZHMsXG4gICAgICAgIG1vZGU6IG1vZGVcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoIWN1cnJlbnQgfHwgIXByZXYpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgX2N1cnJlbnQgPSBfc2xpY2VkVG9BcnJheShjdXJyZW50LCAyKSxcbiAgICAgICAgICBub2RlID0gX2N1cnJlbnRbMF0sXG4gICAgICAgICAgcGF0aCA9IF9jdXJyZW50WzFdO1xuXG4gICAgICB2YXIgX3ByZXYgPSBfc2xpY2VkVG9BcnJheShwcmV2LCAyKSxcbiAgICAgICAgICBwcmV2Tm9kZSA9IF9wcmV2WzBdLFxuICAgICAgICAgIHByZXZQYXRoID0gX3ByZXZbMV07XG5cbiAgICAgIGlmIChwYXRoLmxlbmd0aCA9PT0gMCB8fCBwcmV2UGF0aC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgbmV3UGF0aCA9IFBhdGgubmV4dChwcmV2UGF0aCk7XG4gICAgICB2YXIgY29tbW9uUGF0aCA9IFBhdGguY29tbW9uKHBhdGgsIHByZXZQYXRoKTtcbiAgICAgIHZhciBpc1ByZXZpb3VzU2libGluZyA9IFBhdGguaXNTaWJsaW5nKHBhdGgsIHByZXZQYXRoKTtcbiAgICAgIHZhciBsZXZlbHMgPSBBcnJheS5mcm9tKEVkaXRvci5sZXZlbHMoZWRpdG9yLCB7XG4gICAgICAgIGF0OiBwYXRoXG4gICAgICB9KSwgZnVuY3Rpb24gKF9yZWYzKSB7XG4gICAgICAgIHZhciBfcmVmNCA9IF9zbGljZWRUb0FycmF5KF9yZWYzLCAxKSxcbiAgICAgICAgICAgIG4gPSBfcmVmNFswXTtcblxuICAgICAgICByZXR1cm4gbjtcbiAgICAgIH0pLnNsaWNlKGNvbW1vblBhdGgubGVuZ3RoKS5zbGljZSgwLCAtMSk7IC8vIERldGVybWluZSBpZiB0aGUgbWVyZ2Ugd2lsbCBsZWF2ZSBhbiBhbmNlc3RvciBvZiB0aGUgcGF0aCBlbXB0eSBhcyBhXG4gICAgICAvLyByZXN1bHQsIGluIHdoaWNoIGNhc2Ugd2UnbGwgd2FudCB0byByZW1vdmUgaXQgYWZ0ZXIgbWVyZ2luZy5cblxuICAgICAgdmFyIGVtcHR5QW5jZXN0b3IgPSBFZGl0b3IuYWJvdmUoZWRpdG9yLCB7XG4gICAgICAgIGF0OiBwYXRoLFxuICAgICAgICBtb2RlOiAnaGlnaGVzdCcsXG4gICAgICAgIG1hdGNoOiBmdW5jdGlvbiBtYXRjaChuKSB7XG4gICAgICAgICAgcmV0dXJuIGxldmVscy5pbmNsdWRlcyhuKSAmJiBoYXNTaW5nbGVDaGlsZE5lc3QoZWRpdG9yLCBuKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB2YXIgZW1wdHlSZWYgPSBlbXB0eUFuY2VzdG9yICYmIEVkaXRvci5wYXRoUmVmKGVkaXRvciwgZW1wdHlBbmNlc3RvclsxXSk7XG4gICAgICB2YXIgcHJvcGVydGllcztcbiAgICAgIHZhciBwb3NpdGlvbjsgLy8gRW5zdXJlIHRoYXQgdGhlIG5vZGVzIGFyZSBlcXVpdmFsZW50LCBhbmQgZmlndXJlIG91dCB3aGF0IHRoZSBwb3NpdGlvblxuICAgICAgLy8gYW5kIGV4dHJhIHByb3BlcnRpZXMgb2YgdGhlIG1lcmdlIHdpbGwgYmUuXG5cbiAgICAgIGlmIChUZXh0LmlzVGV4dChub2RlKSAmJiBUZXh0LmlzVGV4dChwcmV2Tm9kZSkpIHtcbiAgICAgICAgbm9kZS50ZXh0O1xuICAgICAgICAgICAgdmFyIHJlc3QgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMobm9kZSwgX2V4Y2x1ZGVkKTtcblxuICAgICAgICBwb3NpdGlvbiA9IHByZXZOb2RlLnRleHQubGVuZ3RoO1xuICAgICAgICBwcm9wZXJ0aWVzID0gcmVzdDtcbiAgICAgIH0gZWxzZSBpZiAoRWxlbWVudC5pc0VsZW1lbnQobm9kZSkgJiYgRWxlbWVudC5pc0VsZW1lbnQocHJldk5vZGUpKSB7XG4gICAgICAgIG5vZGUuY2hpbGRyZW47XG4gICAgICAgICAgICB2YXIgX3Jlc3QgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMobm9kZSwgX2V4Y2x1ZGVkMik7XG5cbiAgICAgICAgcG9zaXRpb24gPSBwcmV2Tm9kZS5jaGlsZHJlbi5sZW5ndGg7XG4gICAgICAgIHByb3BlcnRpZXMgPSBfcmVzdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBtZXJnZSB0aGUgbm9kZSBhdCBwYXRoIFtcIi5jb25jYXQocGF0aCwgXCJdIHdpdGggdGhlIHByZXZpb3VzIHNpYmxpbmcgYmVjYXVzZSBpdCBpcyBub3QgdGhlIHNhbWUga2luZDogXCIpLmNvbmNhdChTY3J1YmJlci5zdHJpbmdpZnkobm9kZSksIFwiIFwiKS5jb25jYXQoU2NydWJiZXIuc3RyaW5naWZ5KHByZXZOb2RlKSkpO1xuICAgICAgfSAvLyBJZiB0aGUgbm9kZSBpc24ndCBhbHJlYWR5IHRoZSBuZXh0IHNpYmxpbmcgb2YgdGhlIHByZXZpb3VzIG5vZGUsIG1vdmVcbiAgICAgIC8vIGl0IHNvIHRoYXQgaXQgaXMgYmVmb3JlIG1lcmdpbmcuXG5cblxuICAgICAgaWYgKCFpc1ByZXZpb3VzU2libGluZykge1xuICAgICAgICBUcmFuc2Zvcm1zLm1vdmVOb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICBhdDogcGF0aCxcbiAgICAgICAgICB0bzogbmV3UGF0aCxcbiAgICAgICAgICB2b2lkczogdm9pZHNcbiAgICAgICAgfSk7XG4gICAgICB9IC8vIElmIHRoZXJlIHdhcyBnb2luZyB0byBiZSBhbiBlbXB0eSBhbmNlc3RvciBvZiB0aGUgbm9kZSB0aGF0IHdhcyBtZXJnZWQsXG4gICAgICAvLyB3ZSByZW1vdmUgaXQgZnJvbSB0aGUgdHJlZS5cblxuXG4gICAgICBpZiAoZW1wdHlSZWYpIHtcbiAgICAgICAgVHJhbnNmb3Jtcy5yZW1vdmVOb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICBhdDogZW1wdHlSZWYuY3VycmVudCxcbiAgICAgICAgICB2b2lkczogdm9pZHNcbiAgICAgICAgfSk7XG4gICAgICB9IC8vIElmIHRoZSB0YXJnZXQgbm9kZSB0aGF0IHdlJ3JlIG1lcmdpbmcgd2l0aCBpcyBlbXB0eSwgcmVtb3ZlIGl0IGluc3RlYWRcbiAgICAgIC8vIG9mIG1lcmdpbmcgdGhlIHR3by4gVGhpcyBpcyBhIGNvbW1vbiByaWNoIHRleHQgZWRpdG9yIGJlaGF2aW9yIHRvXG4gICAgICAvLyBwcmV2ZW50IGxvc2luZyBmb3JtYXR0aW5nIHdoZW4gZGVsZXRpbmcgZW50aXJlIG5vZGVzIHdoZW4geW91IGhhdmUgYVxuICAgICAgLy8gaGFuZ2luZyBzZWxlY3Rpb24uXG4gICAgICAvLyBpZiBwcmV2Tm9kZSBpcyBmaXJzdCBjaGlsZCBpbiBwYXJlbnQsZG9uJ3QgcmVtb3ZlIGl0LlxuXG5cbiAgICAgIGlmIChFbGVtZW50LmlzRWxlbWVudChwcmV2Tm9kZSkgJiYgRWRpdG9yLmlzRW1wdHkoZWRpdG9yLCBwcmV2Tm9kZSkgfHwgVGV4dC5pc1RleHQocHJldk5vZGUpICYmIHByZXZOb2RlLnRleHQgPT09ICcnICYmIHByZXZQYXRoW3ByZXZQYXRoLmxlbmd0aCAtIDFdICE9PSAwKSB7XG4gICAgICAgIFRyYW5zZm9ybXMucmVtb3ZlTm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgYXQ6IHByZXZQYXRoLFxuICAgICAgICAgIHZvaWRzOiB2b2lkc1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVkaXRvci5hcHBseSh7XG4gICAgICAgICAgdHlwZTogJ21lcmdlX25vZGUnLFxuICAgICAgICAgIHBhdGg6IG5ld1BhdGgsXG4gICAgICAgICAgcG9zaXRpb246IHBvc2l0aW9uLFxuICAgICAgICAgIHByb3BlcnRpZXM6IHByb3BlcnRpZXNcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChlbXB0eVJlZikge1xuICAgICAgICBlbXB0eVJlZi51bnJlZigpO1xuICAgICAgfVxuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIE1vdmUgdGhlIG5vZGVzIGF0IGEgbG9jYXRpb24gdG8gYSBuZXcgbG9jYXRpb24uXHJcbiAgICovXG4gIG1vdmVOb2RlczogZnVuY3Rpb24gbW92ZU5vZGVzKGVkaXRvciwgb3B0aW9ucykge1xuICAgIEVkaXRvci53aXRob3V0Tm9ybWFsaXppbmcoZWRpdG9yLCBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgdG8gPSBvcHRpb25zLnRvLFxuICAgICAgICAgIF9vcHRpb25zJGF0MyA9IG9wdGlvbnMuYXQsXG4gICAgICAgICAgYXQgPSBfb3B0aW9ucyRhdDMgPT09IHZvaWQgMCA/IGVkaXRvci5zZWxlY3Rpb24gOiBfb3B0aW9ucyRhdDMsXG4gICAgICAgICAgX29wdGlvbnMkbW9kZTQgPSBvcHRpb25zLm1vZGUsXG4gICAgICAgICAgbW9kZSA9IF9vcHRpb25zJG1vZGU0ID09PSB2b2lkIDAgPyAnbG93ZXN0JyA6IF9vcHRpb25zJG1vZGU0LFxuICAgICAgICAgIF9vcHRpb25zJHZvaWRzNCA9IG9wdGlvbnMudm9pZHMsXG4gICAgICAgICAgdm9pZHMgPSBfb3B0aW9ucyR2b2lkczQgPT09IHZvaWQgMCA/IGZhbHNlIDogX29wdGlvbnMkdm9pZHM0O1xuICAgICAgdmFyIG1hdGNoID0gb3B0aW9ucy5tYXRjaDtcblxuICAgICAgaWYgKCFhdCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChtYXRjaCA9PSBudWxsKSB7XG4gICAgICAgIG1hdGNoID0gUGF0aC5pc1BhdGgoYXQpID8gbWF0Y2hQYXRoKGVkaXRvciwgYXQpIDogZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgICByZXR1cm4gRWxlbWVudC5pc0VsZW1lbnQobikgJiYgRWRpdG9yLmlzQmxvY2soZWRpdG9yLCBuKTtcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgdmFyIHRvUmVmID0gRWRpdG9yLnBhdGhSZWYoZWRpdG9yLCB0byk7XG4gICAgICB2YXIgdGFyZ2V0cyA9IEVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICAgICAgYXQ6IGF0LFxuICAgICAgICBtYXRjaDogbWF0Y2gsXG4gICAgICAgIG1vZGU6IG1vZGUsXG4gICAgICAgIHZvaWRzOiB2b2lkc1xuICAgICAgfSk7XG4gICAgICB2YXIgcGF0aFJlZnMgPSBBcnJheS5mcm9tKHRhcmdldHMsIGZ1bmN0aW9uIChfcmVmNSkge1xuICAgICAgICB2YXIgX3JlZjYgPSBfc2xpY2VkVG9BcnJheShfcmVmNSwgMiksXG4gICAgICAgICAgICBwID0gX3JlZjZbMV07XG5cbiAgICAgICAgcmV0dXJuIEVkaXRvci5wYXRoUmVmKGVkaXRvciwgcCk7XG4gICAgICB9KTtcblxuICAgICAgZm9yICh2YXIgX2kyID0gMCwgX3BhdGhSZWZzMiA9IHBhdGhSZWZzOyBfaTIgPCBfcGF0aFJlZnMyLmxlbmd0aDsgX2kyKyspIHtcbiAgICAgICAgdmFyIHBhdGhSZWYgPSBfcGF0aFJlZnMyW19pMl07XG4gICAgICAgIHZhciBwYXRoID0gcGF0aFJlZi51bnJlZigpO1xuICAgICAgICB2YXIgbmV3UGF0aCA9IHRvUmVmLmN1cnJlbnQ7XG5cbiAgICAgICAgaWYgKHBhdGgubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgZWRpdG9yLmFwcGx5KHtcbiAgICAgICAgICAgIHR5cGU6ICdtb3ZlX25vZGUnLFxuICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgIG5ld1BhdGg6IG5ld1BhdGhcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0b1JlZi5jdXJyZW50ICYmIFBhdGguaXNTaWJsaW5nKG5ld1BhdGgsIHBhdGgpICYmIFBhdGguaXNBZnRlcihuZXdQYXRoLCBwYXRoKSkge1xuICAgICAgICAgIC8vIFdoZW4gcGVyZm9ybWluZyBhIHNpYmxpbmcgbW92ZSB0byBhIGxhdGVyIGluZGV4LCB0aGUgcGF0aCBhdCB0aGUgZGVzdGluYXRpb24gaXMgc2hpZnRlZFxuICAgICAgICAgIC8vIHRvIGJlZm9yZSB0aGUgaW5zZXJ0aW9uIHBvaW50IGluc3RlYWQgb2YgYWZ0ZXIuIFRvIGVuc3VyZSBvdXIgZ3JvdXAgb2Ygbm9kZXMgYXJlIGluc2VydGVkXG4gICAgICAgICAgLy8gaW4gdGhlIGNvcnJlY3Qgb3JkZXIgd2UgaW5jcmVtZW50IHRvUmVmIHRvIGFjY291bnQgZm9yIHRoYXRcbiAgICAgICAgICB0b1JlZi5jdXJyZW50ID0gUGF0aC5uZXh0KHRvUmVmLmN1cnJlbnQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRvUmVmLnVucmVmKCk7XG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogUmVtb3ZlIHRoZSBub2RlcyBhdCBhIHNwZWNpZmljIGxvY2F0aW9uIGluIHRoZSBkb2N1bWVudC5cclxuICAgKi9cbiAgcmVtb3ZlTm9kZXM6IGZ1bmN0aW9uIHJlbW92ZU5vZGVzKGVkaXRvcikge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICBFZGl0b3Iud2l0aG91dE5vcm1hbGl6aW5nKGVkaXRvciwgZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9vcHRpb25zJGhhbmdpbmczID0gb3B0aW9ucy5oYW5naW5nLFxuICAgICAgICAgIGhhbmdpbmcgPSBfb3B0aW9ucyRoYW5naW5nMyA9PT0gdm9pZCAwID8gZmFsc2UgOiBfb3B0aW9ucyRoYW5naW5nMyxcbiAgICAgICAgICBfb3B0aW9ucyR2b2lkczUgPSBvcHRpb25zLnZvaWRzLFxuICAgICAgICAgIHZvaWRzID0gX29wdGlvbnMkdm9pZHM1ID09PSB2b2lkIDAgPyBmYWxzZSA6IF9vcHRpb25zJHZvaWRzNSxcbiAgICAgICAgICBfb3B0aW9ucyRtb2RlNSA9IG9wdGlvbnMubW9kZSxcbiAgICAgICAgICBtb2RlID0gX29wdGlvbnMkbW9kZTUgPT09IHZvaWQgMCA/ICdsb3dlc3QnIDogX29wdGlvbnMkbW9kZTU7XG4gICAgICB2YXIgX29wdGlvbnMkYXQ0ID0gb3B0aW9ucy5hdCxcbiAgICAgICAgICBhdCA9IF9vcHRpb25zJGF0NCA9PT0gdm9pZCAwID8gZWRpdG9yLnNlbGVjdGlvbiA6IF9vcHRpb25zJGF0NCxcbiAgICAgICAgICBtYXRjaCA9IG9wdGlvbnMubWF0Y2g7XG5cbiAgICAgIGlmICghYXQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAobWF0Y2ggPT0gbnVsbCkge1xuICAgICAgICBtYXRjaCA9IFBhdGguaXNQYXRoKGF0KSA/IG1hdGNoUGF0aChlZGl0b3IsIGF0KSA6IGZ1bmN0aW9uIChuKSB7XG4gICAgICAgICAgcmV0dXJuIEVsZW1lbnQuaXNFbGVtZW50KG4pICYmIEVkaXRvci5pc0Jsb2NrKGVkaXRvciwgbik7XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGlmICghaGFuZ2luZyAmJiBSYW5nZS5pc1JhbmdlKGF0KSkge1xuICAgICAgICBhdCA9IEVkaXRvci51bmhhbmdSYW5nZShlZGl0b3IsIGF0LCB7XG4gICAgICAgICAgdm9pZHM6IHZvaWRzXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICB2YXIgZGVwdGhzID0gRWRpdG9yLm5vZGVzKGVkaXRvciwge1xuICAgICAgICBhdDogYXQsXG4gICAgICAgIG1hdGNoOiBtYXRjaCxcbiAgICAgICAgbW9kZTogbW9kZSxcbiAgICAgICAgdm9pZHM6IHZvaWRzXG4gICAgICB9KTtcbiAgICAgIHZhciBwYXRoUmVmcyA9IEFycmF5LmZyb20oZGVwdGhzLCBmdW5jdGlvbiAoX3JlZjcpIHtcbiAgICAgICAgdmFyIF9yZWY4ID0gX3NsaWNlZFRvQXJyYXkoX3JlZjcsIDIpLFxuICAgICAgICAgICAgcCA9IF9yZWY4WzFdO1xuXG4gICAgICAgIHJldHVybiBFZGl0b3IucGF0aFJlZihlZGl0b3IsIHApO1xuICAgICAgfSk7XG5cbiAgICAgIGZvciAodmFyIF9pMyA9IDAsIF9wYXRoUmVmczMgPSBwYXRoUmVmczsgX2kzIDwgX3BhdGhSZWZzMy5sZW5ndGg7IF9pMysrKSB7XG4gICAgICAgIHZhciBwYXRoUmVmID0gX3BhdGhSZWZzM1tfaTNdO1xuICAgICAgICB2YXIgcGF0aCA9IHBhdGhSZWYudW5yZWYoKTtcblxuICAgICAgICBpZiAocGF0aCkge1xuICAgICAgICAgIHZhciBfRWRpdG9yJG5vZGUgPSBFZGl0b3Iubm9kZShlZGl0b3IsIHBhdGgpLFxuICAgICAgICAgICAgICBfRWRpdG9yJG5vZGUyID0gX3NsaWNlZFRvQXJyYXkoX0VkaXRvciRub2RlLCAxKSxcbiAgICAgICAgICAgICAgbm9kZSA9IF9FZGl0b3Ikbm9kZTJbMF07XG5cbiAgICAgICAgICBlZGl0b3IuYXBwbHkoe1xuICAgICAgICAgICAgdHlwZTogJ3JlbW92ZV9ub2RlJyxcbiAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICBub2RlOiBub2RlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcblxuICAvKipcclxuICAgKiBTZXQgbmV3IHByb3BlcnRpZXMgb24gdGhlIG5vZGVzIGF0IGEgbG9jYXRpb24uXHJcbiAgICovXG4gIHNldE5vZGVzOiBmdW5jdGlvbiBzZXROb2RlcyhlZGl0b3IsIHByb3BzKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIEVkaXRvci53aXRob3V0Tm9ybWFsaXppbmcoZWRpdG9yLCBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgbWF0Y2ggPSBvcHRpb25zLm1hdGNoLFxuICAgICAgICAgIF9vcHRpb25zJGF0NSA9IG9wdGlvbnMuYXQsXG4gICAgICAgICAgYXQgPSBfb3B0aW9ucyRhdDUgPT09IHZvaWQgMCA/IGVkaXRvci5zZWxlY3Rpb24gOiBfb3B0aW9ucyRhdDUsXG4gICAgICAgICAgY29tcGFyZSA9IG9wdGlvbnMuY29tcGFyZSxcbiAgICAgICAgICBtZXJnZSA9IG9wdGlvbnMubWVyZ2U7XG4gICAgICB2YXIgX29wdGlvbnMkaGFuZ2luZzQgPSBvcHRpb25zLmhhbmdpbmcsXG4gICAgICAgICAgaGFuZ2luZyA9IF9vcHRpb25zJGhhbmdpbmc0ID09PSB2b2lkIDAgPyBmYWxzZSA6IF9vcHRpb25zJGhhbmdpbmc0LFxuICAgICAgICAgIF9vcHRpb25zJG1vZGU2ID0gb3B0aW9ucy5tb2RlLFxuICAgICAgICAgIG1vZGUgPSBfb3B0aW9ucyRtb2RlNiA9PT0gdm9pZCAwID8gJ2xvd2VzdCcgOiBfb3B0aW9ucyRtb2RlNixcbiAgICAgICAgICBfb3B0aW9ucyRzcGxpdCA9IG9wdGlvbnMuc3BsaXQsXG4gICAgICAgICAgc3BsaXQgPSBfb3B0aW9ucyRzcGxpdCA9PT0gdm9pZCAwID8gZmFsc2UgOiBfb3B0aW9ucyRzcGxpdCxcbiAgICAgICAgICBfb3B0aW9ucyR2b2lkczYgPSBvcHRpb25zLnZvaWRzLFxuICAgICAgICAgIHZvaWRzID0gX29wdGlvbnMkdm9pZHM2ID09PSB2b2lkIDAgPyBmYWxzZSA6IF9vcHRpb25zJHZvaWRzNjtcblxuICAgICAgaWYgKCFhdCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChtYXRjaCA9PSBudWxsKSB7XG4gICAgICAgIG1hdGNoID0gUGF0aC5pc1BhdGgoYXQpID8gbWF0Y2hQYXRoKGVkaXRvciwgYXQpIDogZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgICByZXR1cm4gRWxlbWVudC5pc0VsZW1lbnQobikgJiYgRWRpdG9yLmlzQmxvY2soZWRpdG9yLCBuKTtcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFoYW5naW5nICYmIFJhbmdlLmlzUmFuZ2UoYXQpKSB7XG4gICAgICAgIGF0ID0gRWRpdG9yLnVuaGFuZ1JhbmdlKGVkaXRvciwgYXQsIHtcbiAgICAgICAgICB2b2lkczogdm9pZHNcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzcGxpdCAmJiBSYW5nZS5pc1JhbmdlKGF0KSkge1xuICAgICAgICBpZiAoUmFuZ2UuaXNDb2xsYXBzZWQoYXQpICYmIEVkaXRvci5sZWFmKGVkaXRvciwgYXQuYW5jaG9yKVswXS50ZXh0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAvLyBJZiB0aGUgcmFuZ2UgaXMgY29sbGFwc2VkIGluIGEgbm9uLWVtcHR5IG5vZGUgYW5kICdzcGxpdCcgaXMgdHJ1ZSwgdGhlcmUncyBub3RoaW5nIHRvXG4gICAgICAgICAgLy8gc2V0IHRoYXQgd29uJ3QgZ2V0IG5vcm1hbGl6ZWQgYXdheVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByYW5nZVJlZiA9IEVkaXRvci5yYW5nZVJlZihlZGl0b3IsIGF0LCB7XG4gICAgICAgICAgYWZmaW5pdHk6ICdpbndhcmQnXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciBfUmFuZ2UkZWRnZXM1ID0gUmFuZ2UuZWRnZXMoYXQpLFxuICAgICAgICAgICAgX1JhbmdlJGVkZ2VzNiA9IF9zbGljZWRUb0FycmF5KF9SYW5nZSRlZGdlczUsIDIpLFxuICAgICAgICAgICAgc3RhcnQgPSBfUmFuZ2UkZWRnZXM2WzBdLFxuICAgICAgICAgICAgZW5kID0gX1JhbmdlJGVkZ2VzNlsxXTtcblxuICAgICAgICB2YXIgc3BsaXRNb2RlID0gbW9kZSA9PT0gJ2xvd2VzdCcgPyAnbG93ZXN0JyA6ICdoaWdoZXN0JztcbiAgICAgICAgdmFyIGVuZEF0RW5kT2ZOb2RlID0gRWRpdG9yLmlzRW5kKGVkaXRvciwgZW5kLCBlbmQucGF0aCk7XG4gICAgICAgIFRyYW5zZm9ybXMuc3BsaXROb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICBhdDogZW5kLFxuICAgICAgICAgIG1hdGNoOiBtYXRjaCxcbiAgICAgICAgICBtb2RlOiBzcGxpdE1vZGUsXG4gICAgICAgICAgdm9pZHM6IHZvaWRzLFxuICAgICAgICAgIGFsd2F5czogIWVuZEF0RW5kT2ZOb2RlXG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgc3RhcnRBdFN0YXJ0T2ZOb2RlID0gRWRpdG9yLmlzU3RhcnQoZWRpdG9yLCBzdGFydCwgc3RhcnQucGF0aCk7XG4gICAgICAgIFRyYW5zZm9ybXMuc3BsaXROb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICBhdDogc3RhcnQsXG4gICAgICAgICAgbWF0Y2g6IG1hdGNoLFxuICAgICAgICAgIG1vZGU6IHNwbGl0TW9kZSxcbiAgICAgICAgICB2b2lkczogdm9pZHMsXG4gICAgICAgICAgYWx3YXlzOiAhc3RhcnRBdFN0YXJ0T2ZOb2RlXG4gICAgICAgIH0pO1xuICAgICAgICBhdCA9IHJhbmdlUmVmLnVucmVmKCk7XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuYXQgPT0gbnVsbCkge1xuICAgICAgICAgIFRyYW5zZm9ybXMuc2VsZWN0KGVkaXRvciwgYXQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghY29tcGFyZSkge1xuICAgICAgICBjb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZShwcm9wLCBub2RlUHJvcCkge1xuICAgICAgICAgIHJldHVybiBwcm9wICE9PSBub2RlUHJvcDtcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgdmFyIF9pdGVyYXRvcjIgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciQxKEVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICAgICAgYXQ6IGF0LFxuICAgICAgICBtYXRjaDogbWF0Y2gsXG4gICAgICAgIG1vZGU6IG1vZGUsXG4gICAgICAgIHZvaWRzOiB2b2lkc1xuICAgICAgfSkpLFxuICAgICAgICAgIF9zdGVwMjtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChfaXRlcmF0b3IyLnMoKTsgIShfc3RlcDIgPSBfaXRlcmF0b3IyLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICB2YXIgX3N0ZXAyJHZhbHVlID0gX3NsaWNlZFRvQXJyYXkoX3N0ZXAyLnZhbHVlLCAyKSxcbiAgICAgICAgICAgICAgbm9kZSA9IF9zdGVwMiR2YWx1ZVswXSxcbiAgICAgICAgICAgICAgcGF0aCA9IF9zdGVwMiR2YWx1ZVsxXTtcblxuICAgICAgICAgIHZhciBwcm9wZXJ0aWVzID0ge307XG4gICAgICAgICAgdmFyIG5ld1Byb3BlcnRpZXMgPSB7fTsgLy8gWW91IGNhbid0IHNldCBwcm9wZXJ0aWVzIG9uIHRoZSBlZGl0b3Igbm9kZS5cblxuICAgICAgICAgIGlmIChwYXRoLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGhhc0NoYW5nZXMgPSBmYWxzZTtcblxuICAgICAgICAgIGZvciAodmFyIGsgaW4gcHJvcHMpIHtcbiAgICAgICAgICAgIGlmIChrID09PSAnY2hpbGRyZW4nIHx8IGsgPT09ICd0ZXh0Jykge1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGNvbXBhcmUocHJvcHNba10sIG5vZGVba10pKSB7XG4gICAgICAgICAgICAgIGhhc0NoYW5nZXMgPSB0cnVlOyAvLyBPbWl0IG5ldyBwcm9wZXJ0aWVzIGZyb20gdGhlIG9sZCBwcm9wZXJ0aWVzIGxpc3RcblxuICAgICAgICAgICAgICBpZiAobm9kZS5oYXNPd25Qcm9wZXJ0eShrKSkgcHJvcGVydGllc1trXSA9IG5vZGVba107IC8vIE9taXQgcHJvcGVydGllcyB0aGF0IGhhdmUgYmVlbiByZW1vdmVkIGZyb20gdGhlIG5ldyBwcm9wZXJ0aWVzIGxpc3RcblxuICAgICAgICAgICAgICBpZiAobWVyZ2UpIHtcbiAgICAgICAgICAgICAgICBpZiAocHJvcHNba10gIT0gbnVsbCkgbmV3UHJvcGVydGllc1trXSA9IG1lcmdlKG5vZGVba10sIHByb3BzW2tdKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAocHJvcHNba10gIT0gbnVsbCkgbmV3UHJvcGVydGllc1trXSA9IHByb3BzW2tdO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGhhc0NoYW5nZXMpIHtcbiAgICAgICAgICAgIGVkaXRvci5hcHBseSh7XG4gICAgICAgICAgICAgIHR5cGU6ICdzZXRfbm9kZScsXG4gICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgIHByb3BlcnRpZXM6IHByb3BlcnRpZXMsXG4gICAgICAgICAgICAgIG5ld1Byb3BlcnRpZXM6IG5ld1Byb3BlcnRpZXNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9pdGVyYXRvcjIuZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yMi5mKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogU3BsaXQgdGhlIG5vZGVzIGF0IGEgc3BlY2lmaWMgbG9jYXRpb24uXHJcbiAgICovXG4gIHNwbGl0Tm9kZXM6IGZ1bmN0aW9uIHNwbGl0Tm9kZXMoZWRpdG9yKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIEVkaXRvci53aXRob3V0Tm9ybWFsaXppbmcoZWRpdG9yLCBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX29wdGlvbnMkbW9kZTcgPSBvcHRpb25zLm1vZGUsXG4gICAgICAgICAgbW9kZSA9IF9vcHRpb25zJG1vZGU3ID09PSB2b2lkIDAgPyAnbG93ZXN0JyA6IF9vcHRpb25zJG1vZGU3LFxuICAgICAgICAgIF9vcHRpb25zJHZvaWRzNyA9IG9wdGlvbnMudm9pZHMsXG4gICAgICAgICAgdm9pZHMgPSBfb3B0aW9ucyR2b2lkczcgPT09IHZvaWQgMCA/IGZhbHNlIDogX29wdGlvbnMkdm9pZHM3O1xuICAgICAgdmFyIG1hdGNoID0gb3B0aW9ucy5tYXRjaCxcbiAgICAgICAgICBfb3B0aW9ucyRhdDYgPSBvcHRpb25zLmF0LFxuICAgICAgICAgIGF0ID0gX29wdGlvbnMkYXQ2ID09PSB2b2lkIDAgPyBlZGl0b3Iuc2VsZWN0aW9uIDogX29wdGlvbnMkYXQ2LFxuICAgICAgICAgIF9vcHRpb25zJGhlaWdodCA9IG9wdGlvbnMuaGVpZ2h0LFxuICAgICAgICAgIGhlaWdodCA9IF9vcHRpb25zJGhlaWdodCA9PT0gdm9pZCAwID8gMCA6IF9vcHRpb25zJGhlaWdodCxcbiAgICAgICAgICBfb3B0aW9ucyRhbHdheXMgPSBvcHRpb25zLmFsd2F5cyxcbiAgICAgICAgICBhbHdheXMgPSBfb3B0aW9ucyRhbHdheXMgPT09IHZvaWQgMCA/IGZhbHNlIDogX29wdGlvbnMkYWx3YXlzO1xuXG4gICAgICBpZiAobWF0Y2ggPT0gbnVsbCkge1xuICAgICAgICBtYXRjaCA9IGZ1bmN0aW9uIG1hdGNoKG4pIHtcbiAgICAgICAgICByZXR1cm4gRWxlbWVudC5pc0VsZW1lbnQobikgJiYgRWRpdG9yLmlzQmxvY2soZWRpdG9yLCBuKTtcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgaWYgKFJhbmdlLmlzUmFuZ2UoYXQpKSB7XG4gICAgICAgIGF0ID0gZGVsZXRlUmFuZ2UoZWRpdG9yLCBhdCk7XG4gICAgICB9IC8vIElmIHRoZSB0YXJnZXQgaXMgYSBwYXRoLCB0aGUgZGVmYXVsdCBoZWlnaHQtc2tpcHBpbmcgYW5kIHBvc2l0aW9uXG4gICAgICAvLyBjb3VudGVycyBuZWVkIHRvIGFjY291bnQgZm9yIHVzIHBvdGVudGlhbGx5IHNwbGl0dGluZyBhdCBhIG5vbi1sZWFmLlxuXG5cbiAgICAgIGlmIChQYXRoLmlzUGF0aChhdCkpIHtcbiAgICAgICAgdmFyIHBhdGggPSBhdDtcbiAgICAgICAgdmFyIHBvaW50ID0gRWRpdG9yLnBvaW50KGVkaXRvciwgcGF0aCk7XG5cbiAgICAgICAgdmFyIF9FZGl0b3IkcGFyZW50MyA9IEVkaXRvci5wYXJlbnQoZWRpdG9yLCBwYXRoKSxcbiAgICAgICAgICAgIF9FZGl0b3IkcGFyZW50NCA9IF9zbGljZWRUb0FycmF5KF9FZGl0b3IkcGFyZW50MywgMSksXG4gICAgICAgICAgICBwYXJlbnQgPSBfRWRpdG9yJHBhcmVudDRbMF07XG5cbiAgICAgICAgbWF0Y2ggPSBmdW5jdGlvbiBtYXRjaChuKSB7XG4gICAgICAgICAgcmV0dXJuIG4gPT09IHBhcmVudDtcbiAgICAgICAgfTtcblxuICAgICAgICBoZWlnaHQgPSBwb2ludC5wYXRoLmxlbmd0aCAtIHBhdGgubGVuZ3RoICsgMTtcbiAgICAgICAgYXQgPSBwb2ludDtcbiAgICAgICAgYWx3YXlzID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFhdCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBiZWZvcmVSZWYgPSBFZGl0b3IucG9pbnRSZWYoZWRpdG9yLCBhdCwge1xuICAgICAgICBhZmZpbml0eTogJ2JhY2t3YXJkJ1xuICAgICAgfSk7XG4gICAgICB2YXIgYWZ0ZXJSZWY7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBfRWRpdG9yJG5vZGVzNSA9IEVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICBhdDogYXQsXG4gICAgICAgICAgbWF0Y2g6IG1hdGNoLFxuICAgICAgICAgIG1vZGU6IG1vZGUsXG4gICAgICAgICAgdm9pZHM6IHZvaWRzXG4gICAgICAgIH0pLFxuICAgICAgICAgICAgX0VkaXRvciRub2RlczYgPSBfc2xpY2VkVG9BcnJheShfRWRpdG9yJG5vZGVzNSwgMSksXG4gICAgICAgICAgICBoaWdoZXN0ID0gX0VkaXRvciRub2RlczZbMF07XG5cbiAgICAgICAgaWYgKCFoaWdoZXN0KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHZvaWRNYXRjaCA9IEVkaXRvcltcInZvaWRcIl0oZWRpdG9yLCB7XG4gICAgICAgICAgYXQ6IGF0LFxuICAgICAgICAgIG1vZGU6ICdoaWdoZXN0J1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIG51ZGdlID0gMDtcblxuICAgICAgICBpZiAoIXZvaWRzICYmIHZvaWRNYXRjaCkge1xuICAgICAgICAgIHZhciBfdm9pZE1hdGNoID0gX3NsaWNlZFRvQXJyYXkodm9pZE1hdGNoLCAyKSxcbiAgICAgICAgICAgICAgdm9pZE5vZGUgPSBfdm9pZE1hdGNoWzBdLFxuICAgICAgICAgICAgICB2b2lkUGF0aCA9IF92b2lkTWF0Y2hbMV07XG5cbiAgICAgICAgICBpZiAoRWxlbWVudC5pc0VsZW1lbnQodm9pZE5vZGUpICYmIGVkaXRvci5pc0lubGluZSh2b2lkTm9kZSkpIHtcbiAgICAgICAgICAgIHZhciBhZnRlciA9IEVkaXRvci5hZnRlcihlZGl0b3IsIHZvaWRQYXRoKTtcblxuICAgICAgICAgICAgaWYgKCFhZnRlcikge1xuICAgICAgICAgICAgICB2YXIgdGV4dCA9IHtcbiAgICAgICAgICAgICAgICB0ZXh0OiAnJ1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB2YXIgYWZ0ZXJQYXRoID0gUGF0aC5uZXh0KHZvaWRQYXRoKTtcbiAgICAgICAgICAgICAgVHJhbnNmb3Jtcy5pbnNlcnROb2RlcyhlZGl0b3IsIHRleHQsIHtcbiAgICAgICAgICAgICAgICBhdDogYWZ0ZXJQYXRoLFxuICAgICAgICAgICAgICAgIHZvaWRzOiB2b2lkc1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgYWZ0ZXIgPSBFZGl0b3IucG9pbnQoZWRpdG9yLCBhZnRlclBhdGgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBhdCA9IGFmdGVyO1xuICAgICAgICAgICAgYWx3YXlzID0gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgc2libGluZ0hlaWdodCA9IGF0LnBhdGgubGVuZ3RoIC0gdm9pZFBhdGgubGVuZ3RoO1xuICAgICAgICAgIGhlaWdodCA9IHNpYmxpbmdIZWlnaHQgKyAxO1xuICAgICAgICAgIGFsd2F5cyA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBhZnRlclJlZiA9IEVkaXRvci5wb2ludFJlZihlZGl0b3IsIGF0KTtcbiAgICAgICAgdmFyIGRlcHRoID0gYXQucGF0aC5sZW5ndGggLSBoZWlnaHQ7XG5cbiAgICAgICAgdmFyIF9oaWdoZXN0ID0gX3NsaWNlZFRvQXJyYXkoaGlnaGVzdCwgMiksXG4gICAgICAgICAgICBoaWdoZXN0UGF0aCA9IF9oaWdoZXN0WzFdO1xuXG4gICAgICAgIHZhciBsb3dlc3RQYXRoID0gYXQucGF0aC5zbGljZSgwLCBkZXB0aCk7XG4gICAgICAgIHZhciBwb3NpdGlvbiA9IGhlaWdodCA9PT0gMCA/IGF0Lm9mZnNldCA6IGF0LnBhdGhbZGVwdGhdICsgbnVkZ2U7XG5cbiAgICAgICAgdmFyIF9pdGVyYXRvcjMgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciQxKEVkaXRvci5sZXZlbHMoZWRpdG9yLCB7XG4gICAgICAgICAgYXQ6IGxvd2VzdFBhdGgsXG4gICAgICAgICAgcmV2ZXJzZTogdHJ1ZSxcbiAgICAgICAgICB2b2lkczogdm9pZHNcbiAgICAgICAgfSkpLFxuICAgICAgICAgICAgX3N0ZXAzO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZm9yIChfaXRlcmF0b3IzLnMoKTsgIShfc3RlcDMgPSBfaXRlcmF0b3IzLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICAgIHZhciBfc3RlcDMkdmFsdWUgPSBfc2xpY2VkVG9BcnJheShfc3RlcDMudmFsdWUsIDIpLFxuICAgICAgICAgICAgICAgIG5vZGUgPSBfc3RlcDMkdmFsdWVbMF0sXG4gICAgICAgICAgICAgICAgX3BhdGgyID0gX3N0ZXAzJHZhbHVlWzFdO1xuXG4gICAgICAgICAgICB2YXIgc3BsaXQgPSBmYWxzZTtcblxuICAgICAgICAgICAgaWYgKF9wYXRoMi5sZW5ndGggPCBoaWdoZXN0UGF0aC5sZW5ndGggfHwgX3BhdGgyLmxlbmd0aCA9PT0gMCB8fCAhdm9pZHMgJiYgRWxlbWVudC5pc0VsZW1lbnQobm9kZSkgJiYgRWRpdG9yLmlzVm9pZChlZGl0b3IsIG5vZGUpKSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgX3BvaW50MiA9IGJlZm9yZVJlZi5jdXJyZW50O1xuICAgICAgICAgICAgdmFyIGlzRW5kID0gRWRpdG9yLmlzRW5kKGVkaXRvciwgX3BvaW50MiwgX3BhdGgyKTtcblxuICAgICAgICAgICAgaWYgKGFsd2F5cyB8fCAhYmVmb3JlUmVmIHx8ICFFZGl0b3IuaXNFZGdlKGVkaXRvciwgX3BvaW50MiwgX3BhdGgyKSkge1xuICAgICAgICAgICAgICBzcGxpdCA9IHRydWU7XG4gICAgICAgICAgICAgIHZhciBwcm9wZXJ0aWVzID0gTm9kZS5leHRyYWN0UHJvcHMobm9kZSk7XG4gICAgICAgICAgICAgIGVkaXRvci5hcHBseSh7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3NwbGl0X25vZGUnLFxuICAgICAgICAgICAgICAgIHBhdGg6IF9wYXRoMixcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogcG9zaXRpb24sXG4gICAgICAgICAgICAgICAgcHJvcGVydGllczogcHJvcGVydGllc1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcG9zaXRpb24gPSBfcGF0aDJbX3BhdGgyLmxlbmd0aCAtIDFdICsgKHNwbGl0IHx8IGlzRW5kID8gMSA6IDApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgX2l0ZXJhdG9yMy5lKGVycik7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgX2l0ZXJhdG9yMy5mKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0aW9ucy5hdCA9PSBudWxsKSB7XG4gICAgICAgICAgdmFyIF9wb2ludCA9IGFmdGVyUmVmLmN1cnJlbnQgfHwgRWRpdG9yLmVuZChlZGl0b3IsIFtdKTtcblxuICAgICAgICAgIFRyYW5zZm9ybXMuc2VsZWN0KGVkaXRvciwgX3BvaW50KTtcbiAgICAgICAgfVxuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdmFyIF9hZnRlclJlZjtcblxuICAgICAgICBiZWZvcmVSZWYudW5yZWYoKTtcbiAgICAgICAgKF9hZnRlclJlZiA9IGFmdGVyUmVmKSA9PT0gbnVsbCB8fCBfYWZ0ZXJSZWYgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hZnRlclJlZi51bnJlZigpO1xuICAgICAgfVxuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIFVuc2V0IHByb3BlcnRpZXMgb24gdGhlIG5vZGVzIGF0IGEgbG9jYXRpb24uXHJcbiAgICovXG4gIHVuc2V0Tm9kZXM6IGZ1bmN0aW9uIHVuc2V0Tm9kZXMoZWRpdG9yLCBwcm9wcykge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcblxuICAgIGlmICghQXJyYXkuaXNBcnJheShwcm9wcykpIHtcbiAgICAgIHByb3BzID0gW3Byb3BzXTtcbiAgICB9XG5cbiAgICB2YXIgb2JqID0ge307XG5cbiAgICB2YXIgX2l0ZXJhdG9yNCA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDEocHJvcHMpLFxuICAgICAgICBfc3RlcDQ7XG5cbiAgICB0cnkge1xuICAgICAgZm9yIChfaXRlcmF0b3I0LnMoKTsgIShfc3RlcDQgPSBfaXRlcmF0b3I0Lm4oKSkuZG9uZTspIHtcbiAgICAgICAgdmFyIGtleSA9IF9zdGVwNC52YWx1ZTtcbiAgICAgICAgb2JqW2tleV0gPSBudWxsO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgX2l0ZXJhdG9yNC5lKGVycik7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIF9pdGVyYXRvcjQuZigpO1xuICAgIH1cblxuICAgIFRyYW5zZm9ybXMuc2V0Tm9kZXMoZWRpdG9yLCBvYmosIG9wdGlvbnMpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIFVud3JhcCB0aGUgbm9kZXMgYXQgYSBsb2NhdGlvbiBmcm9tIGEgcGFyZW50IG5vZGUsIHNwbGl0dGluZyB0aGUgcGFyZW50IGlmXHJcbiAgICogbmVjZXNzYXJ5IHRvIGVuc3VyZSB0aGF0IG9ubHkgdGhlIGNvbnRlbnQgaW4gdGhlIHJhbmdlIGlzIHVud3JhcHBlZC5cclxuICAgKi9cbiAgdW53cmFwTm9kZXM6IGZ1bmN0aW9uIHVud3JhcE5vZGVzKGVkaXRvcikge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICBFZGl0b3Iud2l0aG91dE5vcm1hbGl6aW5nKGVkaXRvciwgZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9vcHRpb25zJG1vZGU4ID0gb3B0aW9ucy5tb2RlLFxuICAgICAgICAgIG1vZGUgPSBfb3B0aW9ucyRtb2RlOCA9PT0gdm9pZCAwID8gJ2xvd2VzdCcgOiBfb3B0aW9ucyRtb2RlOCxcbiAgICAgICAgICBfb3B0aW9ucyRzcGxpdDIgPSBvcHRpb25zLnNwbGl0LFxuICAgICAgICAgIHNwbGl0ID0gX29wdGlvbnMkc3BsaXQyID09PSB2b2lkIDAgPyBmYWxzZSA6IF9vcHRpb25zJHNwbGl0MixcbiAgICAgICAgICBfb3B0aW9ucyR2b2lkczggPSBvcHRpb25zLnZvaWRzLFxuICAgICAgICAgIHZvaWRzID0gX29wdGlvbnMkdm9pZHM4ID09PSB2b2lkIDAgPyBmYWxzZSA6IF9vcHRpb25zJHZvaWRzODtcbiAgICAgIHZhciBfb3B0aW9ucyRhdDcgPSBvcHRpb25zLmF0LFxuICAgICAgICAgIGF0ID0gX29wdGlvbnMkYXQ3ID09PSB2b2lkIDAgPyBlZGl0b3Iuc2VsZWN0aW9uIDogX29wdGlvbnMkYXQ3LFxuICAgICAgICAgIG1hdGNoID0gb3B0aW9ucy5tYXRjaDtcblxuICAgICAgaWYgKCFhdCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChtYXRjaCA9PSBudWxsKSB7XG4gICAgICAgIG1hdGNoID0gUGF0aC5pc1BhdGgoYXQpID8gbWF0Y2hQYXRoKGVkaXRvciwgYXQpIDogZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgICByZXR1cm4gRWxlbWVudC5pc0VsZW1lbnQobikgJiYgRWRpdG9yLmlzQmxvY2soZWRpdG9yLCBuKTtcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgaWYgKFBhdGguaXNQYXRoKGF0KSkge1xuICAgICAgICBhdCA9IEVkaXRvci5yYW5nZShlZGl0b3IsIGF0KTtcbiAgICAgIH1cblxuICAgICAgdmFyIHJhbmdlUmVmID0gUmFuZ2UuaXNSYW5nZShhdCkgPyBFZGl0b3IucmFuZ2VSZWYoZWRpdG9yLCBhdCkgOiBudWxsO1xuICAgICAgdmFyIG1hdGNoZXMgPSBFZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgICAgIGF0OiBhdCxcbiAgICAgICAgbWF0Y2g6IG1hdGNoLFxuICAgICAgICBtb2RlOiBtb2RlLFxuICAgICAgICB2b2lkczogdm9pZHNcbiAgICAgIH0pO1xuICAgICAgdmFyIHBhdGhSZWZzID0gQXJyYXkuZnJvbShtYXRjaGVzLCBmdW5jdGlvbiAoX3JlZjkpIHtcbiAgICAgICAgdmFyIF9yZWYxMCA9IF9zbGljZWRUb0FycmF5KF9yZWY5LCAyKSxcbiAgICAgICAgICAgIHAgPSBfcmVmMTBbMV07XG5cbiAgICAgICAgcmV0dXJuIEVkaXRvci5wYXRoUmVmKGVkaXRvciwgcCk7XG4gICAgICB9IC8vIHVud3JhcE5vZGUgd2lsbCBjYWxsIGxpZnROb2RlIHdoaWNoIGRvZXMgbm90IHN1cHBvcnQgc3BsaXR0aW5nIHRoZSBub2RlIHdoZW4gbmVzdGVkLlxuICAgICAgLy8gSWYgd2UgZG8gbm90IHJldmVyc2UgdGhlIG9yZGVyIGFuZCBjYWxsIGl0IGZyb20gdG9wIHRvIHRoZSBib3R0b20sIGl0IHdpbGwgcmVtb3ZlIGFsbCBibG9ja3NcbiAgICAgIC8vIHRoYXQgd3JhcCB0YXJnZXQgbm9kZS4gU28gd2UgcmV2ZXJzZSB0aGUgb3JkZXIuXG4gICAgICApLnJldmVyc2UoKTtcblxuICAgICAgdmFyIF9pdGVyYXRvcjUgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciQxKHBhdGhSZWZzKSxcbiAgICAgICAgICBfc3RlcDU7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBfbG9vcCA9IGZ1bmN0aW9uIF9sb29wKCkge1xuICAgICAgICAgIHZhciBwYXRoUmVmID0gX3N0ZXA1LnZhbHVlO1xuICAgICAgICAgIHZhciBwYXRoID0gcGF0aFJlZi51bnJlZigpO1xuXG4gICAgICAgICAgdmFyIF9FZGl0b3Ikbm9kZTMgPSBFZGl0b3Iubm9kZShlZGl0b3IsIHBhdGgpLFxuICAgICAgICAgICAgICBfRWRpdG9yJG5vZGU0ID0gX3NsaWNlZFRvQXJyYXkoX0VkaXRvciRub2RlMywgMSksXG4gICAgICAgICAgICAgIG5vZGUgPSBfRWRpdG9yJG5vZGU0WzBdO1xuXG4gICAgICAgICAgdmFyIHJhbmdlID0gRWRpdG9yLnJhbmdlKGVkaXRvciwgcGF0aCk7XG5cbiAgICAgICAgICBpZiAoc3BsaXQgJiYgcmFuZ2VSZWYpIHtcbiAgICAgICAgICAgIHJhbmdlID0gUmFuZ2UuaW50ZXJzZWN0aW9uKHJhbmdlUmVmLmN1cnJlbnQsIHJhbmdlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBUcmFuc2Zvcm1zLmxpZnROb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAgIGF0OiByYW5nZSxcbiAgICAgICAgICAgIG1hdGNoOiBmdW5jdGlvbiBtYXRjaChuKSB7XG4gICAgICAgICAgICAgIHJldHVybiBFbGVtZW50LmlzQW5jZXN0b3Iobm9kZSkgJiYgbm9kZS5jaGlsZHJlbi5pbmNsdWRlcyhuKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2b2lkczogdm9pZHNcbiAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICBmb3IgKF9pdGVyYXRvcjUucygpOyAhKF9zdGVwNSA9IF9pdGVyYXRvcjUubigpKS5kb25lOykge1xuICAgICAgICAgIF9sb29wKCk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3I1LmUoZXJyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIF9pdGVyYXRvcjUuZigpO1xuICAgICAgfVxuXG4gICAgICBpZiAocmFuZ2VSZWYpIHtcbiAgICAgICAgcmFuZ2VSZWYudW5yZWYoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcblxuICAvKipcclxuICAgKiBXcmFwIHRoZSBub2RlcyBhdCBhIGxvY2F0aW9uIGluIGEgbmV3IGNvbnRhaW5lciBub2RlLCBzcGxpdHRpbmcgdGhlIGVkZ2VzXHJcbiAgICogb2YgdGhlIHJhbmdlIGZpcnN0IHRvIGVuc3VyZSB0aGF0IG9ubHkgdGhlIGNvbnRlbnQgaW4gdGhlIHJhbmdlIGlzIHdyYXBwZWQuXHJcbiAgICovXG4gIHdyYXBOb2RlczogZnVuY3Rpb24gd3JhcE5vZGVzKGVkaXRvciwgZWxlbWVudCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICBFZGl0b3Iud2l0aG91dE5vcm1hbGl6aW5nKGVkaXRvciwgZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9vcHRpb25zJG1vZGU5ID0gb3B0aW9ucy5tb2RlLFxuICAgICAgICAgIG1vZGUgPSBfb3B0aW9ucyRtb2RlOSA9PT0gdm9pZCAwID8gJ2xvd2VzdCcgOiBfb3B0aW9ucyRtb2RlOSxcbiAgICAgICAgICBfb3B0aW9ucyRzcGxpdDMgPSBvcHRpb25zLnNwbGl0LFxuICAgICAgICAgIHNwbGl0ID0gX29wdGlvbnMkc3BsaXQzID09PSB2b2lkIDAgPyBmYWxzZSA6IF9vcHRpb25zJHNwbGl0MyxcbiAgICAgICAgICBfb3B0aW9ucyR2b2lkczkgPSBvcHRpb25zLnZvaWRzLFxuICAgICAgICAgIHZvaWRzID0gX29wdGlvbnMkdm9pZHM5ID09PSB2b2lkIDAgPyBmYWxzZSA6IF9vcHRpb25zJHZvaWRzOTtcbiAgICAgIHZhciBtYXRjaCA9IG9wdGlvbnMubWF0Y2gsXG4gICAgICAgICAgX29wdGlvbnMkYXQ4ID0gb3B0aW9ucy5hdCxcbiAgICAgICAgICBhdCA9IF9vcHRpb25zJGF0OCA9PT0gdm9pZCAwID8gZWRpdG9yLnNlbGVjdGlvbiA6IF9vcHRpb25zJGF0ODtcblxuICAgICAgaWYgKCFhdCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChtYXRjaCA9PSBudWxsKSB7XG4gICAgICAgIGlmIChQYXRoLmlzUGF0aChhdCkpIHtcbiAgICAgICAgICBtYXRjaCA9IG1hdGNoUGF0aChlZGl0b3IsIGF0KTtcbiAgICAgICAgfSBlbHNlIGlmIChlZGl0b3IuaXNJbmxpbmUoZWxlbWVudCkpIHtcbiAgICAgICAgICBtYXRjaCA9IGZ1bmN0aW9uIG1hdGNoKG4pIHtcbiAgICAgICAgICAgIHJldHVybiBFbGVtZW50LmlzRWxlbWVudChuKSAmJiBFZGl0b3IuaXNJbmxpbmUoZWRpdG9yLCBuKSB8fCBUZXh0LmlzVGV4dChuKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1hdGNoID0gZnVuY3Rpb24gbWF0Y2gobikge1xuICAgICAgICAgICAgcmV0dXJuIEVsZW1lbnQuaXNFbGVtZW50KG4pICYmIEVkaXRvci5pc0Jsb2NrKGVkaXRvciwgbik7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoc3BsaXQgJiYgUmFuZ2UuaXNSYW5nZShhdCkpIHtcbiAgICAgICAgdmFyIF9SYW5nZSRlZGdlczcgPSBSYW5nZS5lZGdlcyhhdCksXG4gICAgICAgICAgICBfUmFuZ2UkZWRnZXM4ID0gX3NsaWNlZFRvQXJyYXkoX1JhbmdlJGVkZ2VzNywgMiksXG4gICAgICAgICAgICBzdGFydCA9IF9SYW5nZSRlZGdlczhbMF0sXG4gICAgICAgICAgICBlbmQgPSBfUmFuZ2UkZWRnZXM4WzFdO1xuXG4gICAgICAgIHZhciByYW5nZVJlZiA9IEVkaXRvci5yYW5nZVJlZihlZGl0b3IsIGF0LCB7XG4gICAgICAgICAgYWZmaW5pdHk6ICdpbndhcmQnXG4gICAgICAgIH0pO1xuICAgICAgICBUcmFuc2Zvcm1zLnNwbGl0Tm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgYXQ6IGVuZCxcbiAgICAgICAgICBtYXRjaDogbWF0Y2gsXG4gICAgICAgICAgdm9pZHM6IHZvaWRzXG4gICAgICAgIH0pO1xuICAgICAgICBUcmFuc2Zvcm1zLnNwbGl0Tm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgYXQ6IHN0YXJ0LFxuICAgICAgICAgIG1hdGNoOiBtYXRjaCxcbiAgICAgICAgICB2b2lkczogdm9pZHNcbiAgICAgICAgfSk7XG4gICAgICAgIGF0ID0gcmFuZ2VSZWYudW5yZWYoKTtcblxuICAgICAgICBpZiAob3B0aW9ucy5hdCA9PSBudWxsKSB7XG4gICAgICAgICAgVHJhbnNmb3Jtcy5zZWxlY3QoZWRpdG9yLCBhdCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHJvb3RzID0gQXJyYXkuZnJvbShFZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgICAgIGF0OiBhdCxcbiAgICAgICAgbWF0Y2g6IGVkaXRvci5pc0lubGluZShlbGVtZW50KSA/IGZ1bmN0aW9uIChuKSB7XG4gICAgICAgICAgcmV0dXJuIEVsZW1lbnQuaXNFbGVtZW50KG4pICYmIEVkaXRvci5pc0Jsb2NrKGVkaXRvciwgbik7XG4gICAgICAgIH0gOiBmdW5jdGlvbiAobikge1xuICAgICAgICAgIHJldHVybiBFZGl0b3IuaXNFZGl0b3Iobik7XG4gICAgICAgIH0sXG4gICAgICAgIG1vZGU6ICdsb3dlc3QnLFxuICAgICAgICB2b2lkczogdm9pZHNcbiAgICAgIH0pKTtcblxuICAgICAgZm9yICh2YXIgX2k0ID0gMCwgX3Jvb3RzID0gcm9vdHM7IF9pNCA8IF9yb290cy5sZW5ndGg7IF9pNCsrKSB7XG4gICAgICAgIHZhciBfcm9vdHMkX2kgPSBfc2xpY2VkVG9BcnJheShfcm9vdHNbX2k0XSwgMiksXG4gICAgICAgICAgICByb290UGF0aCA9IF9yb290cyRfaVsxXTtcblxuICAgICAgICB2YXIgYSA9IFJhbmdlLmlzUmFuZ2UoYXQpID8gUmFuZ2UuaW50ZXJzZWN0aW9uKGF0LCBFZGl0b3IucmFuZ2UoZWRpdG9yLCByb290UGF0aCkpIDogYXQ7XG5cbiAgICAgICAgaWYgKCFhKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbWF0Y2hlcyA9IEFycmF5LmZyb20oRWRpdG9yLm5vZGVzKGVkaXRvciwge1xuICAgICAgICAgIGF0OiBhLFxuICAgICAgICAgIG1hdGNoOiBtYXRjaCxcbiAgICAgICAgICBtb2RlOiBtb2RlLFxuICAgICAgICAgIHZvaWRzOiB2b2lkc1xuICAgICAgICB9KSk7XG5cbiAgICAgICAgaWYgKG1hdGNoZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHZhciBfcmV0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF9tYXRjaGVzID0gX3NsaWNlZFRvQXJyYXkobWF0Y2hlcywgMSksXG4gICAgICAgICAgICAgICAgZmlyc3QgPSBfbWF0Y2hlc1swXTtcblxuICAgICAgICAgICAgdmFyIGxhc3QgPSBtYXRjaGVzW21hdGNoZXMubGVuZ3RoIC0gMV07XG5cbiAgICAgICAgICAgIHZhciBfZmlyc3QgPSBfc2xpY2VkVG9BcnJheShmaXJzdCwgMiksXG4gICAgICAgICAgICAgICAgZmlyc3RQYXRoID0gX2ZpcnN0WzFdO1xuXG4gICAgICAgICAgICB2YXIgX2xhc3QgPSBfc2xpY2VkVG9BcnJheShsYXN0LCAyKSxcbiAgICAgICAgICAgICAgICBsYXN0UGF0aCA9IF9sYXN0WzFdO1xuXG4gICAgICAgICAgICBpZiAoZmlyc3RQYXRoLmxlbmd0aCA9PT0gMCAmJiBsYXN0UGF0aC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgLy8gaWYgdGhlcmUncyBubyBtYXRjaGluZyBwYXJlbnQgLSB1c3VhbGx5IG1lYW5zIHRoZSBub2RlIGlzIGFuIGVkaXRvciAtIGRvbid0IGRvIGFueXRoaW5nXG4gICAgICAgICAgICAgIHJldHVybiBcImNvbnRpbnVlXCI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBjb21tb25QYXRoID0gUGF0aC5lcXVhbHMoZmlyc3RQYXRoLCBsYXN0UGF0aCkgPyBQYXRoLnBhcmVudChmaXJzdFBhdGgpIDogUGF0aC5jb21tb24oZmlyc3RQYXRoLCBsYXN0UGF0aCk7XG4gICAgICAgICAgICB2YXIgcmFuZ2UgPSBFZGl0b3IucmFuZ2UoZWRpdG9yLCBmaXJzdFBhdGgsIGxhc3RQYXRoKTtcbiAgICAgICAgICAgIHZhciBjb21tb25Ob2RlRW50cnkgPSBFZGl0b3Iubm9kZShlZGl0b3IsIGNvbW1vblBhdGgpO1xuXG4gICAgICAgICAgICB2YXIgX2NvbW1vbk5vZGVFbnRyeSA9IF9zbGljZWRUb0FycmF5KGNvbW1vbk5vZGVFbnRyeSwgMSksXG4gICAgICAgICAgICAgICAgY29tbW9uTm9kZSA9IF9jb21tb25Ob2RlRW50cnlbMF07XG5cbiAgICAgICAgICAgIHZhciBkZXB0aCA9IGNvbW1vblBhdGgubGVuZ3RoICsgMTtcbiAgICAgICAgICAgIHZhciB3cmFwcGVyUGF0aCA9IFBhdGgubmV4dChsYXN0UGF0aC5zbGljZSgwLCBkZXB0aCkpO1xuXG4gICAgICAgICAgICB2YXIgd3JhcHBlciA9IF9vYmplY3RTcHJlYWQkMihfb2JqZWN0U3ByZWFkJDIoe30sIGVsZW1lbnQpLCB7fSwge1xuICAgICAgICAgICAgICBjaGlsZHJlbjogW11cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBUcmFuc2Zvcm1zLmluc2VydE5vZGVzKGVkaXRvciwgd3JhcHBlciwge1xuICAgICAgICAgICAgICBhdDogd3JhcHBlclBhdGgsXG4gICAgICAgICAgICAgIHZvaWRzOiB2b2lkc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBUcmFuc2Zvcm1zLm1vdmVOb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAgICAgYXQ6IHJhbmdlLFxuICAgICAgICAgICAgICBtYXRjaDogZnVuY3Rpb24gbWF0Y2gobikge1xuICAgICAgICAgICAgICAgIHJldHVybiBFbGVtZW50LmlzQW5jZXN0b3IoY29tbW9uTm9kZSkgJiYgY29tbW9uTm9kZS5jaGlsZHJlbi5pbmNsdWRlcyhuKTtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgdG86IHdyYXBwZXJQYXRoLmNvbmNhdCgwKSxcbiAgICAgICAgICAgICAgdm9pZHM6IHZvaWRzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KCk7XG5cbiAgICAgICAgICBpZiAoX3JldCA9PT0gXCJjb250aW51ZVwiKSBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG59O1xuXG52YXIgaGFzU2luZ2xlQ2hpbGROZXN0ID0gZnVuY3Rpb24gaGFzU2luZ2xlQ2hpbGROZXN0KGVkaXRvciwgbm9kZSkge1xuICBpZiAoRWxlbWVudC5pc0VsZW1lbnQobm9kZSkpIHtcbiAgICB2YXIgZWxlbWVudCA9IG5vZGU7XG5cbiAgICBpZiAoRWRpdG9yLmlzVm9pZChlZGl0b3IsIG5vZGUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKGVsZW1lbnQuY2hpbGRyZW4ubGVuZ3RoID09PSAxKSB7XG4gICAgICByZXR1cm4gaGFzU2luZ2xlQ2hpbGROZXN0KGVkaXRvciwgZWxlbWVudC5jaGlsZHJlblswXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoRWRpdG9yLmlzRWRpdG9yKG5vZGUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59O1xuLyoqXHJcbiAqIENvbnZlcnQgYSByYW5nZSBpbnRvIGEgcG9pbnQgYnkgZGVsZXRpbmcgaXQncyBjb250ZW50LlxyXG4gKi9cblxuXG52YXIgZGVsZXRlUmFuZ2UgPSBmdW5jdGlvbiBkZWxldGVSYW5nZShlZGl0b3IsIHJhbmdlKSB7XG4gIGlmIChSYW5nZS5pc0NvbGxhcHNlZChyYW5nZSkpIHtcbiAgICByZXR1cm4gcmFuZ2UuYW5jaG9yO1xuICB9IGVsc2Uge1xuICAgIHZhciBfUmFuZ2UkZWRnZXM5ID0gUmFuZ2UuZWRnZXMocmFuZ2UpLFxuICAgICAgICBfUmFuZ2UkZWRnZXMxMCA9IF9zbGljZWRUb0FycmF5KF9SYW5nZSRlZGdlczksIDIpLFxuICAgICAgICBlbmQgPSBfUmFuZ2UkZWRnZXMxMFsxXTtcblxuICAgIHZhciBwb2ludFJlZiA9IEVkaXRvci5wb2ludFJlZihlZGl0b3IsIGVuZCk7XG4gICAgVHJhbnNmb3Jtc1tcImRlbGV0ZVwiXShlZGl0b3IsIHtcbiAgICAgIGF0OiByYW5nZVxuICAgIH0pO1xuICAgIHJldHVybiBwb2ludFJlZi51bnJlZigpO1xuICB9XG59O1xuXG52YXIgbWF0Y2hQYXRoID0gZnVuY3Rpb24gbWF0Y2hQYXRoKGVkaXRvciwgcGF0aCkge1xuICB2YXIgX0VkaXRvciRub2RlNSA9IEVkaXRvci5ub2RlKGVkaXRvciwgcGF0aCksXG4gICAgICBfRWRpdG9yJG5vZGU2ID0gX3NsaWNlZFRvQXJyYXkoX0VkaXRvciRub2RlNSwgMSksXG4gICAgICBub2RlID0gX0VkaXRvciRub2RlNlswXTtcblxuICByZXR1cm4gZnVuY3Rpb24gKG4pIHtcbiAgICByZXR1cm4gbiA9PT0gbm9kZTtcbiAgfTtcbn07XG5cbmZ1bmN0aW9uIG93bktleXMkMShvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgeyBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSk7IH0ga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQkMSh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyBvd25LZXlzJDEoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHsgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTsgfSBlbHNlIHsgb3duS2V5cyQxKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG52YXIgU2VsZWN0aW9uVHJhbnNmb3JtcyA9IHtcbiAgLyoqXHJcbiAgICogQ29sbGFwc2UgdGhlIHNlbGVjdGlvbi5cclxuICAgKi9cbiAgY29sbGFwc2U6IGZ1bmN0aW9uIGNvbGxhcHNlKGVkaXRvcikge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICB2YXIgX29wdGlvbnMkZWRnZSA9IG9wdGlvbnMuZWRnZSxcbiAgICAgICAgZWRnZSA9IF9vcHRpb25zJGVkZ2UgPT09IHZvaWQgMCA/ICdhbmNob3InIDogX29wdGlvbnMkZWRnZTtcbiAgICB2YXIgc2VsZWN0aW9uID0gZWRpdG9yLnNlbGVjdGlvbjtcblxuICAgIGlmICghc2VsZWN0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIGlmIChlZGdlID09PSAnYW5jaG9yJykge1xuICAgICAgVHJhbnNmb3Jtcy5zZWxlY3QoZWRpdG9yLCBzZWxlY3Rpb24uYW5jaG9yKTtcbiAgICB9IGVsc2UgaWYgKGVkZ2UgPT09ICdmb2N1cycpIHtcbiAgICAgIFRyYW5zZm9ybXMuc2VsZWN0KGVkaXRvciwgc2VsZWN0aW9uLmZvY3VzKTtcbiAgICB9IGVsc2UgaWYgKGVkZ2UgPT09ICdzdGFydCcpIHtcbiAgICAgIHZhciBfUmFuZ2UkZWRnZXMgPSBSYW5nZS5lZGdlcyhzZWxlY3Rpb24pLFxuICAgICAgICAgIF9SYW5nZSRlZGdlczIgPSBfc2xpY2VkVG9BcnJheShfUmFuZ2UkZWRnZXMsIDEpLFxuICAgICAgICAgIHN0YXJ0ID0gX1JhbmdlJGVkZ2VzMlswXTtcblxuICAgICAgVHJhbnNmb3Jtcy5zZWxlY3QoZWRpdG9yLCBzdGFydCk7XG4gICAgfSBlbHNlIGlmIChlZGdlID09PSAnZW5kJykge1xuICAgICAgdmFyIF9SYW5nZSRlZGdlczMgPSBSYW5nZS5lZGdlcyhzZWxlY3Rpb24pLFxuICAgICAgICAgIF9SYW5nZSRlZGdlczQgPSBfc2xpY2VkVG9BcnJheShfUmFuZ2UkZWRnZXMzLCAyKSxcbiAgICAgICAgICBlbmQgPSBfUmFuZ2UkZWRnZXM0WzFdO1xuXG4gICAgICBUcmFuc2Zvcm1zLnNlbGVjdChlZGl0b3IsIGVuZCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxyXG4gICAqIFVuc2V0IHRoZSBzZWxlY3Rpb24uXHJcbiAgICovXG4gIGRlc2VsZWN0OiBmdW5jdGlvbiBkZXNlbGVjdChlZGl0b3IpIHtcbiAgICB2YXIgc2VsZWN0aW9uID0gZWRpdG9yLnNlbGVjdGlvbjtcblxuICAgIGlmIChzZWxlY3Rpb24pIHtcbiAgICAgIGVkaXRvci5hcHBseSh7XG4gICAgICAgIHR5cGU6ICdzZXRfc2VsZWN0aW9uJyxcbiAgICAgICAgcHJvcGVydGllczogc2VsZWN0aW9uLFxuICAgICAgICBuZXdQcm9wZXJ0aWVzOiBudWxsXG4gICAgICB9KTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogTW92ZSB0aGUgc2VsZWN0aW9uJ3MgcG9pbnQgZm9yd2FyZCBvciBiYWNrd2FyZC5cclxuICAgKi9cbiAgbW92ZTogZnVuY3Rpb24gbW92ZShlZGl0b3IpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgdmFyIHNlbGVjdGlvbiA9IGVkaXRvci5zZWxlY3Rpb247XG4gICAgdmFyIF9vcHRpb25zJGRpc3RhbmNlID0gb3B0aW9ucy5kaXN0YW5jZSxcbiAgICAgICAgZGlzdGFuY2UgPSBfb3B0aW9ucyRkaXN0YW5jZSA9PT0gdm9pZCAwID8gMSA6IF9vcHRpb25zJGRpc3RhbmNlLFxuICAgICAgICBfb3B0aW9ucyR1bml0ID0gb3B0aW9ucy51bml0LFxuICAgICAgICB1bml0ID0gX29wdGlvbnMkdW5pdCA9PT0gdm9pZCAwID8gJ2NoYXJhY3RlcicgOiBfb3B0aW9ucyR1bml0LFxuICAgICAgICBfb3B0aW9ucyRyZXZlcnNlID0gb3B0aW9ucy5yZXZlcnNlLFxuICAgICAgICByZXZlcnNlID0gX29wdGlvbnMkcmV2ZXJzZSA9PT0gdm9pZCAwID8gZmFsc2UgOiBfb3B0aW9ucyRyZXZlcnNlO1xuICAgIHZhciBfb3B0aW9ucyRlZGdlMiA9IG9wdGlvbnMuZWRnZSxcbiAgICAgICAgZWRnZSA9IF9vcHRpb25zJGVkZ2UyID09PSB2b2lkIDAgPyBudWxsIDogX29wdGlvbnMkZWRnZTI7XG5cbiAgICBpZiAoIXNlbGVjdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChlZGdlID09PSAnc3RhcnQnKSB7XG4gICAgICBlZGdlID0gUmFuZ2UuaXNCYWNrd2FyZChzZWxlY3Rpb24pID8gJ2ZvY3VzJyA6ICdhbmNob3InO1xuICAgIH1cblxuICAgIGlmIChlZGdlID09PSAnZW5kJykge1xuICAgICAgZWRnZSA9IFJhbmdlLmlzQmFja3dhcmQoc2VsZWN0aW9uKSA/ICdhbmNob3InIDogJ2ZvY3VzJztcbiAgICB9XG5cbiAgICB2YXIgYW5jaG9yID0gc2VsZWN0aW9uLmFuY2hvcixcbiAgICAgICAgZm9jdXMgPSBzZWxlY3Rpb24uZm9jdXM7XG4gICAgdmFyIG9wdHMgPSB7XG4gICAgICBkaXN0YW5jZTogZGlzdGFuY2UsXG4gICAgICB1bml0OiB1bml0XG4gICAgfTtcbiAgICB2YXIgcHJvcHMgPSB7fTtcblxuICAgIGlmIChlZGdlID09IG51bGwgfHwgZWRnZSA9PT0gJ2FuY2hvcicpIHtcbiAgICAgIHZhciBwb2ludCA9IHJldmVyc2UgPyBFZGl0b3IuYmVmb3JlKGVkaXRvciwgYW5jaG9yLCBvcHRzKSA6IEVkaXRvci5hZnRlcihlZGl0b3IsIGFuY2hvciwgb3B0cyk7XG5cbiAgICAgIGlmIChwb2ludCkge1xuICAgICAgICBwcm9wcy5hbmNob3IgPSBwb2ludDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZWRnZSA9PSBudWxsIHx8IGVkZ2UgPT09ICdmb2N1cycpIHtcbiAgICAgIHZhciBfcG9pbnQgPSByZXZlcnNlID8gRWRpdG9yLmJlZm9yZShlZGl0b3IsIGZvY3VzLCBvcHRzKSA6IEVkaXRvci5hZnRlcihlZGl0b3IsIGZvY3VzLCBvcHRzKTtcblxuICAgICAgaWYgKF9wb2ludCkge1xuICAgICAgICBwcm9wcy5mb2N1cyA9IF9wb2ludDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBUcmFuc2Zvcm1zLnNldFNlbGVjdGlvbihlZGl0b3IsIHByb3BzKTtcbiAgfSxcblxuICAvKipcclxuICAgKiBTZXQgdGhlIHNlbGVjdGlvbiB0byBhIG5ldyB2YWx1ZS5cclxuICAgKi9cbiAgc2VsZWN0OiBmdW5jdGlvbiBzZWxlY3QoZWRpdG9yLCB0YXJnZXQpIHtcbiAgICB2YXIgc2VsZWN0aW9uID0gZWRpdG9yLnNlbGVjdGlvbjtcbiAgICB0YXJnZXQgPSBFZGl0b3IucmFuZ2UoZWRpdG9yLCB0YXJnZXQpO1xuXG4gICAgaWYgKHNlbGVjdGlvbikge1xuICAgICAgVHJhbnNmb3Jtcy5zZXRTZWxlY3Rpb24oZWRpdG9yLCB0YXJnZXQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghUmFuZ2UuaXNSYW5nZSh0YXJnZXQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJXaGVuIHNldHRpbmcgdGhlIHNlbGVjdGlvbiBhbmQgdGhlIGN1cnJlbnQgc2VsZWN0aW9uIGlzIGBudWxsYCB5b3UgbXVzdCBwcm92aWRlIGF0IGxlYXN0IGFuIGBhbmNob3JgIGFuZCBgZm9jdXNgLCBidXQgeW91IHBhc3NlZDogXCIuY29uY2F0KFNjcnViYmVyLnN0cmluZ2lmeSh0YXJnZXQpKSk7XG4gICAgfVxuXG4gICAgZWRpdG9yLmFwcGx5KHtcbiAgICAgIHR5cGU6ICdzZXRfc2VsZWN0aW9uJyxcbiAgICAgIHByb3BlcnRpZXM6IHNlbGVjdGlvbixcbiAgICAgIG5ld1Byb3BlcnRpZXM6IHRhcmdldFxuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIFNldCBuZXcgcHJvcGVydGllcyBvbiBvbmUgb2YgdGhlIHNlbGVjdGlvbidzIHBvaW50cy5cclxuICAgKi9cbiAgc2V0UG9pbnQ6IGZ1bmN0aW9uIHNldFBvaW50KGVkaXRvciwgcHJvcHMpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgdmFyIHNlbGVjdGlvbiA9IGVkaXRvci5zZWxlY3Rpb247XG4gICAgdmFyIF9vcHRpb25zJGVkZ2UzID0gb3B0aW9ucy5lZGdlLFxuICAgICAgICBlZGdlID0gX29wdGlvbnMkZWRnZTMgPT09IHZvaWQgMCA/ICdib3RoJyA6IF9vcHRpb25zJGVkZ2UzO1xuXG4gICAgaWYgKCFzZWxlY3Rpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZWRnZSA9PT0gJ3N0YXJ0Jykge1xuICAgICAgZWRnZSA9IFJhbmdlLmlzQmFja3dhcmQoc2VsZWN0aW9uKSA/ICdmb2N1cycgOiAnYW5jaG9yJztcbiAgICB9XG5cbiAgICBpZiAoZWRnZSA9PT0gJ2VuZCcpIHtcbiAgICAgIGVkZ2UgPSBSYW5nZS5pc0JhY2t3YXJkKHNlbGVjdGlvbikgPyAnYW5jaG9yJyA6ICdmb2N1cyc7XG4gICAgfVxuXG4gICAgdmFyIGFuY2hvciA9IHNlbGVjdGlvbi5hbmNob3IsXG4gICAgICAgIGZvY3VzID0gc2VsZWN0aW9uLmZvY3VzO1xuICAgIHZhciBwb2ludCA9IGVkZ2UgPT09ICdhbmNob3InID8gYW5jaG9yIDogZm9jdXM7XG4gICAgVHJhbnNmb3Jtcy5zZXRTZWxlY3Rpb24oZWRpdG9yLCBfZGVmaW5lUHJvcGVydHkoe30sIGVkZ2UgPT09ICdhbmNob3InID8gJ2FuY2hvcicgOiAnZm9jdXMnLCBfb2JqZWN0U3ByZWFkJDEoX29iamVjdFNwcmVhZCQxKHt9LCBwb2ludCksIHByb3BzKSkpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIFNldCBuZXcgcHJvcGVydGllcyBvbiB0aGUgc2VsZWN0aW9uLlxyXG4gICAqL1xuICBzZXRTZWxlY3Rpb246IGZ1bmN0aW9uIHNldFNlbGVjdGlvbihlZGl0b3IsIHByb3BzKSB7XG4gICAgdmFyIHNlbGVjdGlvbiA9IGVkaXRvci5zZWxlY3Rpb247XG4gICAgdmFyIG9sZFByb3BzID0ge307XG4gICAgdmFyIG5ld1Byb3BzID0ge307XG5cbiAgICBpZiAoIXNlbGVjdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGZvciAodmFyIGsgaW4gcHJvcHMpIHtcbiAgICAgIGlmIChrID09PSAnYW5jaG9yJyAmJiBwcm9wcy5hbmNob3IgIT0gbnVsbCAmJiAhUG9pbnQuZXF1YWxzKHByb3BzLmFuY2hvciwgc2VsZWN0aW9uLmFuY2hvcikgfHwgayA9PT0gJ2ZvY3VzJyAmJiBwcm9wcy5mb2N1cyAhPSBudWxsICYmICFQb2ludC5lcXVhbHMocHJvcHMuZm9jdXMsIHNlbGVjdGlvbi5mb2N1cykgfHwgayAhPT0gJ2FuY2hvcicgJiYgayAhPT0gJ2ZvY3VzJyAmJiBwcm9wc1trXSAhPT0gc2VsZWN0aW9uW2tdKSB7XG4gICAgICAgIG9sZFByb3BzW2tdID0gc2VsZWN0aW9uW2tdO1xuICAgICAgICBuZXdQcm9wc1trXSA9IHByb3BzW2tdO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChPYmplY3Qua2V5cyhvbGRQcm9wcykubGVuZ3RoID4gMCkge1xuICAgICAgZWRpdG9yLmFwcGx5KHtcbiAgICAgICAgdHlwZTogJ3NldF9zZWxlY3Rpb24nLFxuICAgICAgICBwcm9wZXJ0aWVzOiBvbGRQcm9wcyxcbiAgICAgICAgbmV3UHJvcGVydGllczogbmV3UHJvcHNcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufTtcblxuZnVuY3Rpb24gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIobywgYWxsb3dBcnJheUxpa2UpIHsgdmFyIGl0ID0gdHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl0gfHwgb1tcIkBAaXRlcmF0b3JcIl07IGlmICghaXQpIHsgaWYgKEFycmF5LmlzQXJyYXkobykgfHwgKGl0ID0gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8pKSB8fCBhbGxvd0FycmF5TGlrZSAmJiBvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgeyBpZiAoaXQpIG8gPSBpdDsgdmFyIGkgPSAwOyB2YXIgRiA9IGZ1bmN0aW9uIEYoKSB7fTsgcmV0dXJuIHsgczogRiwgbjogZnVuY3Rpb24gbigpIHsgaWYgKGkgPj0gby5sZW5ndGgpIHJldHVybiB7IGRvbmU6IHRydWUgfTsgcmV0dXJuIHsgZG9uZTogZmFsc2UsIHZhbHVlOiBvW2krK10gfTsgfSwgZTogZnVuY3Rpb24gZShfZSkgeyB0aHJvdyBfZTsgfSwgZjogRiB9OyB9IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfSB2YXIgbm9ybWFsQ29tcGxldGlvbiA9IHRydWUsIGRpZEVyciA9IGZhbHNlLCBlcnI7IHJldHVybiB7IHM6IGZ1bmN0aW9uIHMoKSB7IGl0ID0gaXQuY2FsbChvKTsgfSwgbjogZnVuY3Rpb24gbigpIHsgdmFyIHN0ZXAgPSBpdC5uZXh0KCk7IG5vcm1hbENvbXBsZXRpb24gPSBzdGVwLmRvbmU7IHJldHVybiBzdGVwOyB9LCBlOiBmdW5jdGlvbiBlKF9lMikgeyBkaWRFcnIgPSB0cnVlOyBlcnIgPSBfZTI7IH0sIGY6IGZ1bmN0aW9uIGYoKSB7IHRyeSB7IGlmICghbm9ybWFsQ29tcGxldGlvbiAmJiBpdFtcInJldHVyblwiXSAhPSBudWxsKSBpdFtcInJldHVyblwiXSgpOyB9IGZpbmFsbHkgeyBpZiAoZGlkRXJyKSB0aHJvdyBlcnI7IH0gfSB9OyB9XG5cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgfVxuXG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH1cblxudmFyIFRleHRUcmFuc2Zvcm1zID0ge1xuICAvKipcclxuICAgKiBEZWxldGUgY29udGVudCBpbiB0aGUgZWRpdG9yLlxyXG4gICAqL1xuICBcImRlbGV0ZVwiOiBmdW5jdGlvbiBfZGVsZXRlKGVkaXRvcikge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICBFZGl0b3Iud2l0aG91dE5vcm1hbGl6aW5nKGVkaXRvciwgZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9vcHRpb25zJHJldmVyc2UgPSBvcHRpb25zLnJldmVyc2UsXG4gICAgICAgICAgcmV2ZXJzZSA9IF9vcHRpb25zJHJldmVyc2UgPT09IHZvaWQgMCA/IGZhbHNlIDogX29wdGlvbnMkcmV2ZXJzZSxcbiAgICAgICAgICBfb3B0aW9ucyR1bml0ID0gb3B0aW9ucy51bml0LFxuICAgICAgICAgIHVuaXQgPSBfb3B0aW9ucyR1bml0ID09PSB2b2lkIDAgPyAnY2hhcmFjdGVyJyA6IF9vcHRpb25zJHVuaXQsXG4gICAgICAgICAgX29wdGlvbnMkZGlzdGFuY2UgPSBvcHRpb25zLmRpc3RhbmNlLFxuICAgICAgICAgIGRpc3RhbmNlID0gX29wdGlvbnMkZGlzdGFuY2UgPT09IHZvaWQgMCA/IDEgOiBfb3B0aW9ucyRkaXN0YW5jZSxcbiAgICAgICAgICBfb3B0aW9ucyR2b2lkcyA9IG9wdGlvbnMudm9pZHMsXG4gICAgICAgICAgdm9pZHMgPSBfb3B0aW9ucyR2b2lkcyA9PT0gdm9pZCAwID8gZmFsc2UgOiBfb3B0aW9ucyR2b2lkcztcbiAgICAgIHZhciBfb3B0aW9ucyRhdCA9IG9wdGlvbnMuYXQsXG4gICAgICAgICAgYXQgPSBfb3B0aW9ucyRhdCA9PT0gdm9pZCAwID8gZWRpdG9yLnNlbGVjdGlvbiA6IF9vcHRpb25zJGF0LFxuICAgICAgICAgIF9vcHRpb25zJGhhbmdpbmcgPSBvcHRpb25zLmhhbmdpbmcsXG4gICAgICAgICAgaGFuZ2luZyA9IF9vcHRpb25zJGhhbmdpbmcgPT09IHZvaWQgMCA/IGZhbHNlIDogX29wdGlvbnMkaGFuZ2luZztcblxuICAgICAgaWYgKCFhdCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBpc0NvbGxhcHNlZCA9IGZhbHNlO1xuXG4gICAgICBpZiAoUmFuZ2UuaXNSYW5nZShhdCkgJiYgUmFuZ2UuaXNDb2xsYXBzZWQoYXQpKSB7XG4gICAgICAgIGlzQ29sbGFwc2VkID0gdHJ1ZTtcbiAgICAgICAgYXQgPSBhdC5hbmNob3I7XG4gICAgICB9XG5cbiAgICAgIGlmIChQb2ludC5pc1BvaW50KGF0KSkge1xuICAgICAgICB2YXIgZnVydGhlc3RWb2lkID0gRWRpdG9yW1widm9pZFwiXShlZGl0b3IsIHtcbiAgICAgICAgICBhdDogYXQsXG4gICAgICAgICAgbW9kZTogJ2hpZ2hlc3QnXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICghdm9pZHMgJiYgZnVydGhlc3RWb2lkKSB7XG4gICAgICAgICAgdmFyIF9mdXJ0aGVzdFZvaWQgPSBfc2xpY2VkVG9BcnJheShmdXJ0aGVzdFZvaWQsIDIpLFxuICAgICAgICAgICAgICB2b2lkUGF0aCA9IF9mdXJ0aGVzdFZvaWRbMV07XG5cbiAgICAgICAgICBhdCA9IHZvaWRQYXRoO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBvcHRzID0ge1xuICAgICAgICAgICAgdW5pdDogdW5pdCxcbiAgICAgICAgICAgIGRpc3RhbmNlOiBkaXN0YW5jZVxuICAgICAgICAgIH07XG4gICAgICAgICAgdmFyIHRhcmdldCA9IHJldmVyc2UgPyBFZGl0b3IuYmVmb3JlKGVkaXRvciwgYXQsIG9wdHMpIHx8IEVkaXRvci5zdGFydChlZGl0b3IsIFtdKSA6IEVkaXRvci5hZnRlcihlZGl0b3IsIGF0LCBvcHRzKSB8fCBFZGl0b3IuZW5kKGVkaXRvciwgW10pO1xuICAgICAgICAgIGF0ID0ge1xuICAgICAgICAgICAgYW5jaG9yOiBhdCxcbiAgICAgICAgICAgIGZvY3VzOiB0YXJnZXRcbiAgICAgICAgICB9O1xuICAgICAgICAgIGhhbmdpbmcgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChQYXRoLmlzUGF0aChhdCkpIHtcbiAgICAgICAgVHJhbnNmb3Jtcy5yZW1vdmVOb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICBhdDogYXQsXG4gICAgICAgICAgdm9pZHM6IHZvaWRzXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChSYW5nZS5pc0NvbGxhcHNlZChhdCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWhhbmdpbmcpIHtcbiAgICAgICAgdmFyIF9SYW5nZSRlZGdlcyA9IFJhbmdlLmVkZ2VzKGF0KSxcbiAgICAgICAgICAgIF9SYW5nZSRlZGdlczIgPSBfc2xpY2VkVG9BcnJheShfUmFuZ2UkZWRnZXMsIDIpLFxuICAgICAgICAgICAgX2VuZCA9IF9SYW5nZSRlZGdlczJbMV07XG5cbiAgICAgICAgdmFyIGVuZE9mRG9jID0gRWRpdG9yLmVuZChlZGl0b3IsIFtdKTtcblxuICAgICAgICBpZiAoIVBvaW50LmVxdWFscyhfZW5kLCBlbmRPZkRvYykpIHtcbiAgICAgICAgICBhdCA9IEVkaXRvci51bmhhbmdSYW5nZShlZGl0b3IsIGF0LCB7XG4gICAgICAgICAgICB2b2lkczogdm9pZHNcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgX1JhbmdlJGVkZ2VzMyA9IFJhbmdlLmVkZ2VzKGF0KSxcbiAgICAgICAgICBfUmFuZ2UkZWRnZXM0ID0gX3NsaWNlZFRvQXJyYXkoX1JhbmdlJGVkZ2VzMywgMiksXG4gICAgICAgICAgc3RhcnQgPSBfUmFuZ2UkZWRnZXM0WzBdLFxuICAgICAgICAgIGVuZCA9IF9SYW5nZSRlZGdlczRbMV07XG5cbiAgICAgIHZhciBzdGFydEJsb2NrID0gRWRpdG9yLmFib3ZlKGVkaXRvciwge1xuICAgICAgICBtYXRjaDogZnVuY3Rpb24gbWF0Y2gobikge1xuICAgICAgICAgIHJldHVybiBFbGVtZW50LmlzRWxlbWVudChuKSAmJiBFZGl0b3IuaXNCbG9jayhlZGl0b3IsIG4pO1xuICAgICAgICB9LFxuICAgICAgICBhdDogc3RhcnQsXG4gICAgICAgIHZvaWRzOiB2b2lkc1xuICAgICAgfSk7XG4gICAgICB2YXIgZW5kQmxvY2sgPSBFZGl0b3IuYWJvdmUoZWRpdG9yLCB7XG4gICAgICAgIG1hdGNoOiBmdW5jdGlvbiBtYXRjaChuKSB7XG4gICAgICAgICAgcmV0dXJuIEVsZW1lbnQuaXNFbGVtZW50KG4pICYmIEVkaXRvci5pc0Jsb2NrKGVkaXRvciwgbik7XG4gICAgICAgIH0sXG4gICAgICAgIGF0OiBlbmQsXG4gICAgICAgIHZvaWRzOiB2b2lkc1xuICAgICAgfSk7XG4gICAgICB2YXIgaXNBY3Jvc3NCbG9ja3MgPSBzdGFydEJsb2NrICYmIGVuZEJsb2NrICYmICFQYXRoLmVxdWFscyhzdGFydEJsb2NrWzFdLCBlbmRCbG9ja1sxXSk7XG4gICAgICB2YXIgaXNTaW5nbGVUZXh0ID0gUGF0aC5lcXVhbHMoc3RhcnQucGF0aCwgZW5kLnBhdGgpO1xuICAgICAgdmFyIHN0YXJ0Vm9pZCA9IHZvaWRzID8gbnVsbCA6IEVkaXRvcltcInZvaWRcIl0oZWRpdG9yLCB7XG4gICAgICAgIGF0OiBzdGFydCxcbiAgICAgICAgbW9kZTogJ2hpZ2hlc3QnXG4gICAgICB9KTtcbiAgICAgIHZhciBlbmRWb2lkID0gdm9pZHMgPyBudWxsIDogRWRpdG9yW1widm9pZFwiXShlZGl0b3IsIHtcbiAgICAgICAgYXQ6IGVuZCxcbiAgICAgICAgbW9kZTogJ2hpZ2hlc3QnXG4gICAgICB9KTsgLy8gSWYgdGhlIHN0YXJ0IG9yIGVuZCBwb2ludHMgYXJlIGluc2lkZSBhbiBpbmxpbmUgdm9pZCwgbnVkZ2UgdGhlbSBvdXQuXG5cbiAgICAgIGlmIChzdGFydFZvaWQpIHtcbiAgICAgICAgdmFyIGJlZm9yZSA9IEVkaXRvci5iZWZvcmUoZWRpdG9yLCBzdGFydCk7XG5cbiAgICAgICAgaWYgKGJlZm9yZSAmJiBzdGFydEJsb2NrICYmIFBhdGguaXNBbmNlc3RvcihzdGFydEJsb2NrWzFdLCBiZWZvcmUucGF0aCkpIHtcbiAgICAgICAgICBzdGFydCA9IGJlZm9yZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZW5kVm9pZCkge1xuICAgICAgICB2YXIgYWZ0ZXIgPSBFZGl0b3IuYWZ0ZXIoZWRpdG9yLCBlbmQpO1xuXG4gICAgICAgIGlmIChhZnRlciAmJiBlbmRCbG9jayAmJiBQYXRoLmlzQW5jZXN0b3IoZW5kQmxvY2tbMV0sIGFmdGVyLnBhdGgpKSB7XG4gICAgICAgICAgZW5kID0gYWZ0ZXI7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gR2V0IHRoZSBoaWdoZXN0IG5vZGVzIHRoYXQgYXJlIGNvbXBsZXRlbHkgaW5zaWRlIHRoZSByYW5nZSwgYXMgd2VsbCBhc1xuICAgICAgLy8gdGhlIHN0YXJ0IGFuZCBlbmQgbm9kZXMuXG5cblxuICAgICAgdmFyIG1hdGNoZXMgPSBbXTtcbiAgICAgIHZhciBsYXN0UGF0aDtcblxuICAgICAgdmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKEVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICAgICAgYXQ6IGF0LFxuICAgICAgICB2b2lkczogdm9pZHNcbiAgICAgIH0pKSxcbiAgICAgICAgICBfc3RlcDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChfaXRlcmF0b3IucygpOyAhKF9zdGVwID0gX2l0ZXJhdG9yLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICB2YXIgZW50cnkgPSBfc3RlcC52YWx1ZTtcblxuICAgICAgICAgIHZhciBfZW50cnkgPSBfc2xpY2VkVG9BcnJheShlbnRyeSwgMiksXG4gICAgICAgICAgICAgIF9ub2RlMiA9IF9lbnRyeVswXSxcbiAgICAgICAgICAgICAgX3BhdGgyID0gX2VudHJ5WzFdO1xuXG4gICAgICAgICAgaWYgKGxhc3RQYXRoICYmIFBhdGguY29tcGFyZShfcGF0aDIsIGxhc3RQYXRoKSA9PT0gMCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCF2b2lkcyAmJiBFbGVtZW50LmlzRWxlbWVudChfbm9kZTIpICYmIEVkaXRvci5pc1ZvaWQoZWRpdG9yLCBfbm9kZTIpIHx8ICFQYXRoLmlzQ29tbW9uKF9wYXRoMiwgc3RhcnQucGF0aCkgJiYgIVBhdGguaXNDb21tb24oX3BhdGgyLCBlbmQucGF0aCkpIHtcbiAgICAgICAgICAgIG1hdGNoZXMucHVzaChlbnRyeSk7XG4gICAgICAgICAgICBsYXN0UGF0aCA9IF9wYXRoMjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3IuZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yLmYoKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHBhdGhSZWZzID0gQXJyYXkuZnJvbShtYXRjaGVzLCBmdW5jdGlvbiAoX3JlZikge1xuICAgICAgICB2YXIgX3JlZjIgPSBfc2xpY2VkVG9BcnJheShfcmVmLCAyKSxcbiAgICAgICAgICAgIHAgPSBfcmVmMlsxXTtcblxuICAgICAgICByZXR1cm4gRWRpdG9yLnBhdGhSZWYoZWRpdG9yLCBwKTtcbiAgICAgIH0pO1xuICAgICAgdmFyIHN0YXJ0UmVmID0gRWRpdG9yLnBvaW50UmVmKGVkaXRvciwgc3RhcnQpO1xuICAgICAgdmFyIGVuZFJlZiA9IEVkaXRvci5wb2ludFJlZihlZGl0b3IsIGVuZCk7XG4gICAgICB2YXIgcmVtb3ZlZFRleHQgPSAnJztcblxuICAgICAgaWYgKCFpc1NpbmdsZVRleHQgJiYgIXN0YXJ0Vm9pZCkge1xuICAgICAgICB2YXIgX3BvaW50ID0gc3RhcnRSZWYuY3VycmVudDtcblxuICAgICAgICB2YXIgX0VkaXRvciRsZWFmID0gRWRpdG9yLmxlYWYoZWRpdG9yLCBfcG9pbnQpLFxuICAgICAgICAgICAgX0VkaXRvciRsZWFmMiA9IF9zbGljZWRUb0FycmF5KF9FZGl0b3IkbGVhZiwgMSksXG4gICAgICAgICAgICBub2RlID0gX0VkaXRvciRsZWFmMlswXTtcblxuICAgICAgICB2YXIgcGF0aCA9IF9wb2ludC5wYXRoO1xuICAgICAgICB2YXIgX3N0YXJ0ID0gc3RhcnQsXG4gICAgICAgICAgICBvZmZzZXQgPSBfc3RhcnQub2Zmc2V0O1xuICAgICAgICB2YXIgdGV4dCA9IG5vZGUudGV4dC5zbGljZShvZmZzZXQpO1xuXG4gICAgICAgIGlmICh0ZXh0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBlZGl0b3IuYXBwbHkoe1xuICAgICAgICAgICAgdHlwZTogJ3JlbW92ZV90ZXh0JyxcbiAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICBvZmZzZXQ6IG9mZnNldCxcbiAgICAgICAgICAgIHRleHQ6IHRleHRcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZW1vdmVkVGV4dCA9IHRleHQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcGF0aFJlZnMucmV2ZXJzZSgpLm1hcChmdW5jdGlvbiAocikge1xuICAgICAgICByZXR1cm4gci51bnJlZigpO1xuICAgICAgfSkuZmlsdGVyKGZ1bmN0aW9uIChyKSB7XG4gICAgICAgIHJldHVybiByICE9PSBudWxsO1xuICAgICAgfSkuZm9yRWFjaChmdW5jdGlvbiAocCkge1xuICAgICAgICByZXR1cm4gVHJhbnNmb3Jtcy5yZW1vdmVOb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICBhdDogcCxcbiAgICAgICAgICB2b2lkczogdm9pZHNcbiAgICAgICAgfSk7XG4gICAgICB9KTtcblxuICAgICAgaWYgKCFlbmRWb2lkKSB7XG4gICAgICAgIHZhciBfcG9pbnQyID0gZW5kUmVmLmN1cnJlbnQ7XG5cbiAgICAgICAgdmFyIF9FZGl0b3IkbGVhZjMgPSBFZGl0b3IubGVhZihlZGl0b3IsIF9wb2ludDIpLFxuICAgICAgICAgICAgX0VkaXRvciRsZWFmNCA9IF9zbGljZWRUb0FycmF5KF9FZGl0b3IkbGVhZjMsIDEpLFxuICAgICAgICAgICAgX25vZGUgPSBfRWRpdG9yJGxlYWY0WzBdO1xuXG4gICAgICAgIHZhciBfcGF0aCA9IF9wb2ludDIucGF0aDtcblxuICAgICAgICB2YXIgX29mZnNldCA9IGlzU2luZ2xlVGV4dCA/IHN0YXJ0Lm9mZnNldCA6IDA7XG5cbiAgICAgICAgdmFyIF90ZXh0ID0gX25vZGUudGV4dC5zbGljZShfb2Zmc2V0LCBlbmQub2Zmc2V0KTtcblxuICAgICAgICBpZiAoX3RleHQubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGVkaXRvci5hcHBseSh7XG4gICAgICAgICAgICB0eXBlOiAncmVtb3ZlX3RleHQnLFxuICAgICAgICAgICAgcGF0aDogX3BhdGgsXG4gICAgICAgICAgICBvZmZzZXQ6IF9vZmZzZXQsXG4gICAgICAgICAgICB0ZXh0OiBfdGV4dFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJlbW92ZWRUZXh0ID0gX3RleHQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCFpc1NpbmdsZVRleHQgJiYgaXNBY3Jvc3NCbG9ja3MgJiYgZW5kUmVmLmN1cnJlbnQgJiYgc3RhcnRSZWYuY3VycmVudCkge1xuICAgICAgICBUcmFuc2Zvcm1zLm1lcmdlTm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgYXQ6IGVuZFJlZi5jdXJyZW50LFxuICAgICAgICAgIGhhbmdpbmc6IHRydWUsXG4gICAgICAgICAgdm9pZHM6IHZvaWRzXG4gICAgICAgIH0pO1xuICAgICAgfSAvLyBGb3IgVGhhaSBzY3JpcHQsIGRlbGV0aW5nIE4gY2hhcmFjdGVyKHMpIGJhY2t3YXJkIHNob3VsZCBkZWxldGVcbiAgICAgIC8vIE4gY29kZSBwb2ludChzKSBpbnN0ZWFkIG9mIGFuIGVudGlyZSBncmFwaGVtZSBjbHVzdGVyLlxuICAgICAgLy8gVGhlcmVmb3JlLCB0aGUgcmVtYWluaW5nIGNvZGUgcG9pbnRzIHNob3VsZCBiZSBpbnNlcnRlZCBiYWNrLlxuXG5cbiAgICAgIGlmIChpc0NvbGxhcHNlZCAmJiByZXZlcnNlICYmIHVuaXQgPT09ICdjaGFyYWN0ZXInICYmIHJlbW92ZWRUZXh0Lmxlbmd0aCA+IDEgJiYgcmVtb3ZlZFRleHQubWF0Y2goL1tcXHUwRTAwLVxcdTBFN0ZdKy8pKSB7XG4gICAgICAgIFRyYW5zZm9ybXMuaW5zZXJ0VGV4dChlZGl0b3IsIHJlbW92ZWRUZXh0LnNsaWNlKDAsIHJlbW92ZWRUZXh0Lmxlbmd0aCAtIGRpc3RhbmNlKSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBzdGFydFVucmVmID0gc3RhcnRSZWYudW5yZWYoKTtcbiAgICAgIHZhciBlbmRVbnJlZiA9IGVuZFJlZi51bnJlZigpO1xuICAgICAgdmFyIHBvaW50ID0gcmV2ZXJzZSA/IHN0YXJ0VW5yZWYgfHwgZW5kVW5yZWYgOiBlbmRVbnJlZiB8fCBzdGFydFVucmVmO1xuXG4gICAgICBpZiAob3B0aW9ucy5hdCA9PSBudWxsICYmIHBvaW50KSB7XG4gICAgICAgIFRyYW5zZm9ybXMuc2VsZWN0KGVkaXRvciwgcG9pbnQpO1xuICAgICAgfVxuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEluc2VydCBhIGZyYWdtZW50IGF0IGEgc3BlY2lmaWMgbG9jYXRpb24gaW4gdGhlIGVkaXRvci5cclxuICAgKi9cbiAgaW5zZXJ0RnJhZ21lbnQ6IGZ1bmN0aW9uIGluc2VydEZyYWdtZW50KGVkaXRvciwgZnJhZ21lbnQpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgRWRpdG9yLndpdGhvdXROb3JtYWxpemluZyhlZGl0b3IsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfb3B0aW9ucyRoYW5naW5nMiA9IG9wdGlvbnMuaGFuZ2luZyxcbiAgICAgICAgICBoYW5naW5nID0gX29wdGlvbnMkaGFuZ2luZzIgPT09IHZvaWQgMCA/IGZhbHNlIDogX29wdGlvbnMkaGFuZ2luZzIsXG4gICAgICAgICAgX29wdGlvbnMkdm9pZHMyID0gb3B0aW9ucy52b2lkcyxcbiAgICAgICAgICB2b2lkcyA9IF9vcHRpb25zJHZvaWRzMiA9PT0gdm9pZCAwID8gZmFsc2UgOiBfb3B0aW9ucyR2b2lkczI7XG4gICAgICB2YXIgX29wdGlvbnMkYXQyID0gb3B0aW9ucy5hdCxcbiAgICAgICAgICBhdCA9IF9vcHRpb25zJGF0MiA9PT0gdm9pZCAwID8gZWRpdG9yLnNlbGVjdGlvbiA6IF9vcHRpb25zJGF0MjtcblxuICAgICAgaWYgKCFmcmFnbWVudC5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWF0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSBpZiAoUmFuZ2UuaXNSYW5nZShhdCkpIHtcbiAgICAgICAgaWYgKCFoYW5naW5nKSB7XG4gICAgICAgICAgYXQgPSBFZGl0b3IudW5oYW5nUmFuZ2UoZWRpdG9yLCBhdCwge1xuICAgICAgICAgICAgdm9pZHM6IHZvaWRzXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoUmFuZ2UuaXNDb2xsYXBzZWQoYXQpKSB7XG4gICAgICAgICAgYXQgPSBhdC5hbmNob3I7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIF9SYW5nZSRlZGdlczUgPSBSYW5nZS5lZGdlcyhhdCksXG4gICAgICAgICAgICAgIF9SYW5nZSRlZGdlczYgPSBfc2xpY2VkVG9BcnJheShfUmFuZ2UkZWRnZXM1LCAyKSxcbiAgICAgICAgICAgICAgZW5kID0gX1JhbmdlJGVkZ2VzNlsxXTtcblxuICAgICAgICAgIGlmICghdm9pZHMgJiYgRWRpdG9yW1widm9pZFwiXShlZGl0b3IsIHtcbiAgICAgICAgICAgIGF0OiBlbmRcbiAgICAgICAgICB9KSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBwb2ludFJlZiA9IEVkaXRvci5wb2ludFJlZihlZGl0b3IsIGVuZCk7XG4gICAgICAgICAgVHJhbnNmb3Jtc1tcImRlbGV0ZVwiXShlZGl0b3IsIHtcbiAgICAgICAgICAgIGF0OiBhdFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGF0ID0gcG9pbnRSZWYudW5yZWYoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChQYXRoLmlzUGF0aChhdCkpIHtcbiAgICAgICAgYXQgPSBFZGl0b3Iuc3RhcnQoZWRpdG9yLCBhdCk7XG4gICAgICB9XG5cbiAgICAgIGlmICghdm9pZHMgJiYgRWRpdG9yW1widm9pZFwiXShlZGl0b3IsIHtcbiAgICAgICAgYXQ6IGF0XG4gICAgICB9KSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IC8vIElmIHRoZSBpbnNlcnQgcG9pbnQgaXMgYXQgdGhlIGVkZ2Ugb2YgYW4gaW5saW5lIG5vZGUsIG1vdmUgaXQgb3V0c2lkZVxuICAgICAgLy8gaW5zdGVhZCBzaW5jZSBpdCB3aWxsIG5lZWQgdG8gYmUgc3BsaXQgb3RoZXJ3aXNlLlxuXG5cbiAgICAgIHZhciBpbmxpbmVFbGVtZW50TWF0Y2ggPSBFZGl0b3IuYWJvdmUoZWRpdG9yLCB7XG4gICAgICAgIGF0OiBhdCxcbiAgICAgICAgbWF0Y2g6IGZ1bmN0aW9uIG1hdGNoKG4pIHtcbiAgICAgICAgICByZXR1cm4gRWxlbWVudC5pc0VsZW1lbnQobikgJiYgRWRpdG9yLmlzSW5saW5lKGVkaXRvciwgbik7XG4gICAgICAgIH0sXG4gICAgICAgIG1vZGU6ICdoaWdoZXN0JyxcbiAgICAgICAgdm9pZHM6IHZvaWRzXG4gICAgICB9KTtcblxuICAgICAgaWYgKGlubGluZUVsZW1lbnRNYXRjaCkge1xuICAgICAgICB2YXIgX2lubGluZUVsZW1lbnRNYXRjaCA9IF9zbGljZWRUb0FycmF5KGlubGluZUVsZW1lbnRNYXRjaCwgMiksXG4gICAgICAgICAgICBfaW5saW5lUGF0aCA9IF9pbmxpbmVFbGVtZW50TWF0Y2hbMV07XG5cbiAgICAgICAgaWYgKEVkaXRvci5pc0VuZChlZGl0b3IsIGF0LCBfaW5saW5lUGF0aCkpIHtcbiAgICAgICAgICB2YXIgYWZ0ZXIgPSBFZGl0b3IuYWZ0ZXIoZWRpdG9yLCBfaW5saW5lUGF0aCk7XG4gICAgICAgICAgYXQgPSBhZnRlcjtcbiAgICAgICAgfSBlbHNlIGlmIChFZGl0b3IuaXNTdGFydChlZGl0b3IsIGF0LCBfaW5saW5lUGF0aCkpIHtcbiAgICAgICAgICB2YXIgYmVmb3JlID0gRWRpdG9yLmJlZm9yZShlZGl0b3IsIF9pbmxpbmVQYXRoKTtcbiAgICAgICAgICBhdCA9IGJlZm9yZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgYmxvY2tNYXRjaCA9IEVkaXRvci5hYm92ZShlZGl0b3IsIHtcbiAgICAgICAgbWF0Y2g6IGZ1bmN0aW9uIG1hdGNoKG4pIHtcbiAgICAgICAgICByZXR1cm4gRWxlbWVudC5pc0VsZW1lbnQobikgJiYgRWRpdG9yLmlzQmxvY2soZWRpdG9yLCBuKTtcbiAgICAgICAgfSxcbiAgICAgICAgYXQ6IGF0LFxuICAgICAgICB2b2lkczogdm9pZHNcbiAgICAgIH0pO1xuXG4gICAgICB2YXIgX2Jsb2NrTWF0Y2ggPSBfc2xpY2VkVG9BcnJheShibG9ja01hdGNoLCAyKSxcbiAgICAgICAgICBibG9ja1BhdGggPSBfYmxvY2tNYXRjaFsxXTtcblxuICAgICAgdmFyIGlzQmxvY2tTdGFydCA9IEVkaXRvci5pc1N0YXJ0KGVkaXRvciwgYXQsIGJsb2NrUGF0aCk7XG4gICAgICB2YXIgaXNCbG9ja0VuZCA9IEVkaXRvci5pc0VuZChlZGl0b3IsIGF0LCBibG9ja1BhdGgpO1xuICAgICAgdmFyIGlzQmxvY2tFbXB0eSA9IGlzQmxvY2tTdGFydCAmJiBpc0Jsb2NrRW5kO1xuICAgICAgdmFyIG1lcmdlU3RhcnQgPSAhaXNCbG9ja1N0YXJ0IHx8IGlzQmxvY2tTdGFydCAmJiBpc0Jsb2NrRW5kO1xuICAgICAgdmFyIG1lcmdlRW5kID0gIWlzQmxvY2tFbmQ7XG5cbiAgICAgIHZhciBfTm9kZSRmaXJzdCA9IE5vZGUuZmlyc3Qoe1xuICAgICAgICBjaGlsZHJlbjogZnJhZ21lbnRcbiAgICAgIH0sIFtdKSxcbiAgICAgICAgICBfTm9kZSRmaXJzdDIgPSBfc2xpY2VkVG9BcnJheShfTm9kZSRmaXJzdCwgMiksXG4gICAgICAgICAgZmlyc3RQYXRoID0gX05vZGUkZmlyc3QyWzFdO1xuXG4gICAgICB2YXIgX05vZGUkbGFzdCA9IE5vZGUubGFzdCh7XG4gICAgICAgIGNoaWxkcmVuOiBmcmFnbWVudFxuICAgICAgfSwgW10pLFxuICAgICAgICAgIF9Ob2RlJGxhc3QyID0gX3NsaWNlZFRvQXJyYXkoX05vZGUkbGFzdCwgMiksXG4gICAgICAgICAgbGFzdFBhdGggPSBfTm9kZSRsYXN0MlsxXTtcblxuICAgICAgdmFyIG1hdGNoZXMgPSBbXTtcblxuICAgICAgdmFyIG1hdGNoZXIgPSBmdW5jdGlvbiBtYXRjaGVyKF9yZWYzKSB7XG4gICAgICAgIHZhciBfcmVmNCA9IF9zbGljZWRUb0FycmF5KF9yZWYzLCAyKSxcbiAgICAgICAgICAgIG4gPSBfcmVmNFswXSxcbiAgICAgICAgICAgIHAgPSBfcmVmNFsxXTtcblxuICAgICAgICB2YXIgaXNSb290ID0gcC5sZW5ndGggPT09IDA7XG5cbiAgICAgICAgaWYgKGlzUm9vdCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0Jsb2NrRW1wdHkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtZXJnZVN0YXJ0ICYmIFBhdGguaXNBbmNlc3RvcihwLCBmaXJzdFBhdGgpICYmIEVsZW1lbnQuaXNFbGVtZW50KG4pICYmICFlZGl0b3IuaXNWb2lkKG4pICYmICFlZGl0b3IuaXNJbmxpbmUobikpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWVyZ2VFbmQgJiYgUGF0aC5pc0FuY2VzdG9yKHAsIGxhc3RQYXRoKSAmJiBFbGVtZW50LmlzRWxlbWVudChuKSAmJiAhZWRpdG9yLmlzVm9pZChuKSAmJiAhZWRpdG9yLmlzSW5saW5lKG4pKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9O1xuXG4gICAgICB2YXIgX2l0ZXJhdG9yMiA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKE5vZGUubm9kZXMoe1xuICAgICAgICBjaGlsZHJlbjogZnJhZ21lbnRcbiAgICAgIH0sIHtcbiAgICAgICAgcGFzczogbWF0Y2hlclxuICAgICAgfSkpLFxuICAgICAgICAgIF9zdGVwMjtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChfaXRlcmF0b3IyLnMoKTsgIShfc3RlcDIgPSBfaXRlcmF0b3IyLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICB2YXIgZW50cnkgPSBfc3RlcDIudmFsdWU7XG5cbiAgICAgICAgICBpZiAobWF0Y2hlcihlbnRyeSkpIHtcbiAgICAgICAgICAgIG1hdGNoZXMucHVzaChlbnRyeSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2l0ZXJhdG9yMi5lKGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBfaXRlcmF0b3IyLmYoKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHN0YXJ0cyA9IFtdO1xuICAgICAgdmFyIG1pZGRsZXMgPSBbXTtcbiAgICAgIHZhciBlbmRzID0gW107XG4gICAgICB2YXIgc3RhcnRpbmcgPSB0cnVlO1xuICAgICAgdmFyIGhhc0Jsb2NrcyA9IGZhbHNlO1xuXG4gICAgICBmb3IgKHZhciBfaSA9IDAsIF9tYXRjaGVzID0gbWF0Y2hlczsgX2kgPCBfbWF0Y2hlcy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgdmFyIF9tYXRjaGVzJF9pID0gX3NsaWNlZFRvQXJyYXkoX21hdGNoZXNbX2ldLCAxKSxcbiAgICAgICAgICAgIG5vZGUgPSBfbWF0Y2hlcyRfaVswXTtcblxuICAgICAgICBpZiAoRWxlbWVudC5pc0VsZW1lbnQobm9kZSkgJiYgIWVkaXRvci5pc0lubGluZShub2RlKSkge1xuICAgICAgICAgIHN0YXJ0aW5nID0gZmFsc2U7XG4gICAgICAgICAgaGFzQmxvY2tzID0gdHJ1ZTtcbiAgICAgICAgICBtaWRkbGVzLnB1c2gobm9kZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoc3RhcnRpbmcpIHtcbiAgICAgICAgICBzdGFydHMucHVzaChub2RlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlbmRzLnB1c2gobm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIF9FZGl0b3Ikbm9kZXMgPSBFZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgICAgIGF0OiBhdCxcbiAgICAgICAgbWF0Y2g6IGZ1bmN0aW9uIG1hdGNoKG4pIHtcbiAgICAgICAgICByZXR1cm4gVGV4dC5pc1RleHQobikgfHwgRWRpdG9yLmlzSW5saW5lKGVkaXRvciwgbik7XG4gICAgICAgIH0sXG4gICAgICAgIG1vZGU6ICdoaWdoZXN0JyxcbiAgICAgICAgdm9pZHM6IHZvaWRzXG4gICAgICB9KSxcbiAgICAgICAgICBfRWRpdG9yJG5vZGVzMiA9IF9zbGljZWRUb0FycmF5KF9FZGl0b3Ikbm9kZXMsIDEpLFxuICAgICAgICAgIGlubGluZU1hdGNoID0gX0VkaXRvciRub2RlczJbMF07XG5cbiAgICAgIHZhciBfaW5saW5lTWF0Y2ggPSBfc2xpY2VkVG9BcnJheShpbmxpbmVNYXRjaCwgMiksXG4gICAgICAgICAgaW5saW5lUGF0aCA9IF9pbmxpbmVNYXRjaFsxXTtcblxuICAgICAgdmFyIGlzSW5saW5lU3RhcnQgPSBFZGl0b3IuaXNTdGFydChlZGl0b3IsIGF0LCBpbmxpbmVQYXRoKTtcbiAgICAgIHZhciBpc0lubGluZUVuZCA9IEVkaXRvci5pc0VuZChlZGl0b3IsIGF0LCBpbmxpbmVQYXRoKTtcbiAgICAgIHZhciBtaWRkbGVSZWYgPSBFZGl0b3IucGF0aFJlZihlZGl0b3IsIGlzQmxvY2tFbmQgJiYgIWVuZHMubGVuZ3RoID8gUGF0aC5uZXh0KGJsb2NrUGF0aCkgOiBibG9ja1BhdGgpO1xuICAgICAgdmFyIGVuZFJlZiA9IEVkaXRvci5wYXRoUmVmKGVkaXRvciwgaXNJbmxpbmVFbmQgPyBQYXRoLm5leHQoaW5saW5lUGF0aCkgOiBpbmxpbmVQYXRoKTtcbiAgICAgIFRyYW5zZm9ybXMuc3BsaXROb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgYXQ6IGF0LFxuICAgICAgICBtYXRjaDogZnVuY3Rpb24gbWF0Y2gobikge1xuICAgICAgICAgIHJldHVybiBoYXNCbG9ja3MgPyBFbGVtZW50LmlzRWxlbWVudChuKSAmJiBFZGl0b3IuaXNCbG9jayhlZGl0b3IsIG4pIDogVGV4dC5pc1RleHQobikgfHwgRWRpdG9yLmlzSW5saW5lKGVkaXRvciwgbik7XG4gICAgICAgIH0sXG4gICAgICAgIG1vZGU6IGhhc0Jsb2NrcyA/ICdsb3dlc3QnIDogJ2hpZ2hlc3QnLFxuICAgICAgICBhbHdheXM6IGhhc0Jsb2NrcyAmJiAoIWlzQmxvY2tTdGFydCB8fCBzdGFydHMubGVuZ3RoID4gMCkgJiYgKCFpc0Jsb2NrRW5kIHx8IGVuZHMubGVuZ3RoID4gMCksXG4gICAgICAgIHZvaWRzOiB2b2lkc1xuICAgICAgfSk7XG4gICAgICB2YXIgc3RhcnRSZWYgPSBFZGl0b3IucGF0aFJlZihlZGl0b3IsICFpc0lubGluZVN0YXJ0IHx8IGlzSW5saW5lU3RhcnQgJiYgaXNJbmxpbmVFbmQgPyBQYXRoLm5leHQoaW5saW5lUGF0aCkgOiBpbmxpbmVQYXRoKTtcbiAgICAgIFRyYW5zZm9ybXMuaW5zZXJ0Tm9kZXMoZWRpdG9yLCBzdGFydHMsIHtcbiAgICAgICAgYXQ6IHN0YXJ0UmVmLmN1cnJlbnQsXG4gICAgICAgIG1hdGNoOiBmdW5jdGlvbiBtYXRjaChuKSB7XG4gICAgICAgICAgcmV0dXJuIFRleHQuaXNUZXh0KG4pIHx8IEVkaXRvci5pc0lubGluZShlZGl0b3IsIG4pO1xuICAgICAgICB9LFxuICAgICAgICBtb2RlOiAnaGlnaGVzdCcsXG4gICAgICAgIHZvaWRzOiB2b2lkc1xuICAgICAgfSk7XG5cbiAgICAgIGlmIChpc0Jsb2NrRW1wdHkgJiYgIXN0YXJ0cy5sZW5ndGggJiYgbWlkZGxlcy5sZW5ndGggJiYgIWVuZHMubGVuZ3RoKSB7XG4gICAgICAgIFRyYW5zZm9ybXNbXCJkZWxldGVcIl0oZWRpdG9yLCB7XG4gICAgICAgICAgYXQ6IGJsb2NrUGF0aCxcbiAgICAgICAgICB2b2lkczogdm9pZHNcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIFRyYW5zZm9ybXMuaW5zZXJ0Tm9kZXMoZWRpdG9yLCBtaWRkbGVzLCB7XG4gICAgICAgIGF0OiBtaWRkbGVSZWYuY3VycmVudCxcbiAgICAgICAgbWF0Y2g6IGZ1bmN0aW9uIG1hdGNoKG4pIHtcbiAgICAgICAgICByZXR1cm4gRWxlbWVudC5pc0VsZW1lbnQobikgJiYgRWRpdG9yLmlzQmxvY2soZWRpdG9yLCBuKTtcbiAgICAgICAgfSxcbiAgICAgICAgbW9kZTogJ2xvd2VzdCcsXG4gICAgICAgIHZvaWRzOiB2b2lkc1xuICAgICAgfSk7XG4gICAgICBUcmFuc2Zvcm1zLmluc2VydE5vZGVzKGVkaXRvciwgZW5kcywge1xuICAgICAgICBhdDogZW5kUmVmLmN1cnJlbnQsXG4gICAgICAgIG1hdGNoOiBmdW5jdGlvbiBtYXRjaChuKSB7XG4gICAgICAgICAgcmV0dXJuIFRleHQuaXNUZXh0KG4pIHx8IEVkaXRvci5pc0lubGluZShlZGl0b3IsIG4pO1xuICAgICAgICB9LFxuICAgICAgICBtb2RlOiAnaGlnaGVzdCcsXG4gICAgICAgIHZvaWRzOiB2b2lkc1xuICAgICAgfSk7XG5cbiAgICAgIGlmICghb3B0aW9ucy5hdCkge1xuICAgICAgICB2YXIgcGF0aDtcblxuICAgICAgICBpZiAoZW5kcy5sZW5ndGggPiAwICYmIGVuZFJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgcGF0aCA9IFBhdGgucHJldmlvdXMoZW5kUmVmLmN1cnJlbnQpO1xuICAgICAgICB9IGVsc2UgaWYgKG1pZGRsZXMubGVuZ3RoID4gMCAmJiBtaWRkbGVSZWYuY3VycmVudCkge1xuICAgICAgICAgIHBhdGggPSBQYXRoLnByZXZpb3VzKG1pZGRsZVJlZi5jdXJyZW50KTtcbiAgICAgICAgfSBlbHNlIGlmIChzdGFydFJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgcGF0aCA9IFBhdGgucHJldmlvdXMoc3RhcnRSZWYuY3VycmVudCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocGF0aCkge1xuICAgICAgICAgIHZhciBfZW5kMiA9IEVkaXRvci5lbmQoZWRpdG9yLCBwYXRoKTtcblxuICAgICAgICAgIFRyYW5zZm9ybXMuc2VsZWN0KGVkaXRvciwgX2VuZDIpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHN0YXJ0UmVmLnVucmVmKCk7XG4gICAgICBtaWRkbGVSZWYudW5yZWYoKTtcbiAgICAgIGVuZFJlZi51bnJlZigpO1xuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEluc2VydCBhIHN0cmluZyBvZiB0ZXh0IGluIHRoZSBFZGl0b3IuXHJcbiAgICovXG4gIGluc2VydFRleHQ6IGZ1bmN0aW9uIGluc2VydFRleHQoZWRpdG9yLCB0ZXh0KSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIEVkaXRvci53aXRob3V0Tm9ybWFsaXppbmcoZWRpdG9yLCBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX29wdGlvbnMkdm9pZHMzID0gb3B0aW9ucy52b2lkcyxcbiAgICAgICAgICB2b2lkcyA9IF9vcHRpb25zJHZvaWRzMyA9PT0gdm9pZCAwID8gZmFsc2UgOiBfb3B0aW9ucyR2b2lkczM7XG4gICAgICB2YXIgX29wdGlvbnMkYXQzID0gb3B0aW9ucy5hdCxcbiAgICAgICAgICBhdCA9IF9vcHRpb25zJGF0MyA9PT0gdm9pZCAwID8gZWRpdG9yLnNlbGVjdGlvbiA6IF9vcHRpb25zJGF0MztcblxuICAgICAgaWYgKCFhdCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChQYXRoLmlzUGF0aChhdCkpIHtcbiAgICAgICAgYXQgPSBFZGl0b3IucmFuZ2UoZWRpdG9yLCBhdCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChSYW5nZS5pc1JhbmdlKGF0KSkge1xuICAgICAgICBpZiAoUmFuZ2UuaXNDb2xsYXBzZWQoYXQpKSB7XG4gICAgICAgICAgYXQgPSBhdC5hbmNob3I7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGVuZCA9IFJhbmdlLmVuZChhdCk7XG5cbiAgICAgICAgICBpZiAoIXZvaWRzICYmIEVkaXRvcltcInZvaWRcIl0oZWRpdG9yLCB7XG4gICAgICAgICAgICBhdDogZW5kXG4gICAgICAgICAgfSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgc3RhcnQgPSBSYW5nZS5zdGFydChhdCk7XG4gICAgICAgICAgdmFyIHN0YXJ0UmVmID0gRWRpdG9yLnBvaW50UmVmKGVkaXRvciwgc3RhcnQpO1xuICAgICAgICAgIHZhciBlbmRSZWYgPSBFZGl0b3IucG9pbnRSZWYoZWRpdG9yLCBlbmQpO1xuICAgICAgICAgIFRyYW5zZm9ybXNbXCJkZWxldGVcIl0oZWRpdG9yLCB7XG4gICAgICAgICAgICBhdDogYXQsXG4gICAgICAgICAgICB2b2lkczogdm9pZHNcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB2YXIgc3RhcnRQb2ludCA9IHN0YXJ0UmVmLnVucmVmKCk7XG4gICAgICAgICAgdmFyIGVuZFBvaW50ID0gZW5kUmVmLnVucmVmKCk7XG4gICAgICAgICAgYXQgPSBzdGFydFBvaW50IHx8IGVuZFBvaW50O1xuICAgICAgICAgIFRyYW5zZm9ybXMuc2V0U2VsZWN0aW9uKGVkaXRvciwge1xuICAgICAgICAgICAgYW5jaG9yOiBhdCxcbiAgICAgICAgICAgIGZvY3VzOiBhdFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghdm9pZHMgJiYgRWRpdG9yW1widm9pZFwiXShlZGl0b3IsIHtcbiAgICAgICAgYXQ6IGF0XG4gICAgICB9KSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBfYXQgPSBhdCxcbiAgICAgICAgICBwYXRoID0gX2F0LnBhdGgsXG4gICAgICAgICAgb2Zmc2V0ID0gX2F0Lm9mZnNldDtcbiAgICAgIGlmICh0ZXh0Lmxlbmd0aCA+IDApIGVkaXRvci5hcHBseSh7XG4gICAgICAgIHR5cGU6ICdpbnNlcnRfdGV4dCcsXG4gICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgIG9mZnNldDogb2Zmc2V0LFxuICAgICAgICB0ZXh0OiB0ZXh0XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxufTtcblxuZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgeyBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSk7IH0ga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgb3duS2V5cyhPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxudmFyIFRyYW5zZm9ybXMgPSBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBHZW5lcmFsVHJhbnNmb3JtcyksIE5vZGVUcmFuc2Zvcm1zKSwgU2VsZWN0aW9uVHJhbnNmb3JtcyksIFRleHRUcmFuc2Zvcm1zKTtcblxuZXhwb3J0cy5FZGl0b3IgPSBFZGl0b3I7XG5leHBvcnRzLkVsZW1lbnQgPSBFbGVtZW50O1xuZXhwb3J0cy5Mb2NhdGlvbiA9IExvY2F0aW9uO1xuZXhwb3J0cy5Ob2RlID0gTm9kZTtcbmV4cG9ydHMuT3BlcmF0aW9uID0gT3BlcmF0aW9uO1xuZXhwb3J0cy5QYXRoID0gUGF0aDtcbmV4cG9ydHMuUGF0aFJlZiA9IFBhdGhSZWY7XG5leHBvcnRzLlBvaW50ID0gUG9pbnQ7XG5leHBvcnRzLlBvaW50UmVmID0gUG9pbnRSZWY7XG5leHBvcnRzLlJhbmdlID0gUmFuZ2U7XG5leHBvcnRzLlJhbmdlUmVmID0gUmFuZ2VSZWY7XG5leHBvcnRzLlNjcnViYmVyID0gU2NydWJiZXI7XG5leHBvcnRzLlNwYW4gPSBTcGFuO1xuZXhwb3J0cy5UZXh0ID0gVGV4dDtcbmV4cG9ydHMuVHJhbnNmb3JtcyA9IFRyYW5zZm9ybXM7XG5leHBvcnRzLmNyZWF0ZUVkaXRvciA9IGNyZWF0ZUVkaXRvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiaXNQbGFpbk9iamVjdCIsInJlcXVpcmUiLCJpbW1lciIsInVud3JhcEV4cG9ydHMiLCJ4IiwiX19lc01vZHVsZSIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsImNyZWF0ZUNvbW1vbmpzTW9kdWxlIiwiZm4iLCJtb2R1bGUiLCJhcnJheUxpa2VUb0FycmF5IiwiX2FycmF5TGlrZVRvQXJyYXkiLCJhcnIiLCJsZW4iLCJsZW5ndGgiLCJpIiwiYXJyMiIsIkFycmF5IiwiYXJyYXlXaXRob3V0SG9sZXMiLCJfYXJyYXlXaXRob3V0SG9sZXMiLCJpc0FycmF5IiwiaXRlcmFibGVUb0FycmF5IiwiX2l0ZXJhYmxlVG9BcnJheSIsIml0ZXIiLCJTeW1ib2wiLCJpdGVyYXRvciIsImZyb20iLCJ1bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSIsIl91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSIsIm8iLCJtaW5MZW4iLCJuIiwidG9TdHJpbmciLCJzbGljZSIsImNvbnN0cnVjdG9yIiwibmFtZSIsInRlc3QiLCJub25JdGVyYWJsZVNwcmVhZCIsIl9ub25JdGVyYWJsZVNwcmVhZCIsIlR5cGVFcnJvciIsInRvQ29uc3VtYWJsZUFycmF5IiwiX3RvQ29uc3VtYWJsZUFycmF5IiwiX2RlZmluZVByb3BlcnR5Iiwib2JqIiwia2V5IiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwiYXJyYXlXaXRoSG9sZXMiLCJfYXJyYXlXaXRoSG9sZXMiLCJpdGVyYWJsZVRvQXJyYXlMaW1pdCIsIl9pdGVyYWJsZVRvQXJyYXlMaW1pdCIsIl9pIiwiX2FyciIsIl9uIiwiX2QiLCJfcyIsIl9lIiwibmV4dCIsImRvbmUiLCJwdXNoIiwiZXJyIiwibm9uSXRlcmFibGVSZXN0IiwiX25vbkl0ZXJhYmxlUmVzdCIsInNsaWNlZFRvQXJyYXkiLCJfc2xpY2VkVG9BcnJheSIsIkRJUlRZX1BBVEhTIiwiV2Vha01hcCIsIkRJUlRZX1BBVEhfS0VZUyIsIkZMVVNISU5HIiwiTk9STUFMSVpJTkciLCJQQVRIX1JFRlMiLCJQT0lOVF9SRUZTIiwiUkFOR0VfUkVGUyIsIm93bktleXMkOSIsIm9iamVjdCIsImVudW1lcmFibGVPbmx5Iiwia2V5cyIsImdldE93blByb3BlcnR5U3ltYm9scyIsInN5bWJvbHMiLCJmaWx0ZXIiLCJzeW0iLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJhcHBseSIsIl9vYmplY3RTcHJlYWQkOSIsInRhcmdldCIsImFyZ3VtZW50cyIsInNvdXJjZSIsImZvckVhY2giLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzIiwiZGVmaW5lUHJvcGVydGllcyIsIl9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDciLCJhbGxvd0FycmF5TGlrZSIsIml0IiwiX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5JDciLCJGIiwicyIsImUiLCJmIiwibm9ybWFsQ29tcGxldGlvbiIsImRpZEVyciIsInN0ZXAiLCJfZTIiLCJfYXJyYXlMaWtlVG9BcnJheSQ3IiwiY3JlYXRlRWRpdG9yIiwiZWRpdG9yIiwiY2hpbGRyZW4iLCJvcGVyYXRpb25zIiwic2VsZWN0aW9uIiwibWFya3MiLCJpc0lubGluZSIsImlzVm9pZCIsIm1hcmthYmxlVm9pZCIsIm9uQ2hhbmdlIiwib3AiLCJfaXRlcmF0b3IiLCJFZGl0b3IiLCJwYXRoUmVmcyIsIl9zdGVwIiwicmVmIiwiUGF0aFJlZiIsInRyYW5zZm9ybSIsIl9pdGVyYXRvcjIiLCJwb2ludFJlZnMiLCJfc3RlcDIiLCJfcmVmIiwiUG9pbnRSZWYiLCJfaXRlcmF0b3IzIiwicmFuZ2VSZWZzIiwiX3N0ZXAzIiwiX3JlZjIiLCJSYW5nZVJlZiIsIm9sZERpcnR5UGF0aHMiLCJnZXQiLCJvbGREaXJ0eVBhdGhLZXlzIiwiU2V0IiwiZGlydHlQYXRocyIsImRpcnR5UGF0aEtleXMiLCJhZGQiLCJwYXRoIiwiam9pbiIsImhhcyIsIlBhdGgiLCJvcGVyYXRpb25DYW5UcmFuc2Zvcm1QYXRoIiwiX2l0ZXJhdG9yNCIsIl9zdGVwNCIsIm5ld1BhdGgiLCJuZXdEaXJ0eVBhdGhzIiwiZ2V0RGlydHlQYXRocyIsIl9pdGVyYXRvcjUiLCJfc3RlcDUiLCJfcGF0aCIsInNldCIsIlRyYW5zZm9ybXMiLCJub3JtYWxpemUiLCJvcGVyYXRpb24iLCJ0eXBlIiwiUHJvbWlzZSIsInJlc29sdmUiLCJ0aGVuIiwiYWRkTWFyayIsIm1hdGNoIiwibm9kZSIsIlRleHQiLCJpc1RleHQiLCJfRWRpdG9yJHBhcmVudCIsInBhcmVudCIsIl9FZGl0b3IkcGFyZW50MiIsInBhcmVudE5vZGUiLCJleHBhbmRlZFNlbGVjdGlvbiIsIlJhbmdlIiwiaXNFeHBhbmRlZCIsIm1hcmtBY2NlcHRpbmdWb2lkU2VsZWN0ZWQiLCJfRWRpdG9yJG5vZGUiLCJfRWRpdG9yJG5vZGUyIiwic2VsZWN0ZWROb2RlIiwic2VsZWN0ZWRQYXRoIiwiX0VkaXRvciRwYXJlbnQzIiwiX0VkaXRvciRwYXJlbnQ0Iiwic2V0Tm9kZXMiLCJzcGxpdCIsInZvaWRzIiwiZGVsZXRlQmFja3dhcmQiLCJ1bml0IiwiaXNDb2xsYXBzZWQiLCJyZXZlcnNlIiwiZGVsZXRlRm9yd2FyZCIsImRlbGV0ZUZyYWdtZW50IiwiZGlyZWN0aW9uIiwiZ2V0RnJhZ21lbnQiLCJOb2RlIiwiZnJhZ21lbnQiLCJpbnNlcnRCcmVhayIsInNwbGl0Tm9kZXMiLCJhbHdheXMiLCJpbnNlcnRTb2Z0QnJlYWsiLCJpbnNlcnRGcmFnbWVudCIsImluc2VydE5vZGUiLCJpbnNlcnROb2RlcyIsImluc2VydFRleHQiLCJ0ZXh0Iiwibm9ybWFsaXplTm9kZSIsImVudHJ5IiwiX2VudHJ5IiwiRWxlbWVudCIsImlzRWxlbWVudCIsImNoaWxkIiwiYXQiLCJjb25jYXQiLCJzaG91bGRIYXZlSW5saW5lcyIsImlzRWRpdG9yIiwiY3VycmVudE5vZGUiLCJfY2hpbGQiLCJwcmV2IiwiaXNMYXN0IiwiaXNJbmxpbmVPclRleHQiLCJyZW1vdmVOb2RlcyIsIm5ld0NoaWxkIiwiX25ld0NoaWxkIiwiZXF1YWxzIiwibG9vc2UiLCJtZXJnZU5vZGVzIiwicmVtb3ZlTWFyayIsIl9FZGl0b3IkcGFyZW50NSIsIl9FZGl0b3IkcGFyZW50NiIsIl9FZGl0b3Ikbm9kZTMiLCJfRWRpdG9yJG5vZGU0IiwiX0VkaXRvciRwYXJlbnQ3IiwiX0VkaXRvciRwYXJlbnQ4IiwidW5zZXROb2RlcyIsImxldmVscyIsIl9wYXRoMiIsImRlc2NlbmRhbnRzIiwibm9kZXMiLCJfcmVmMyIsIl9yZWY0IiwicCIsIl9wYXRoMyIsImFuY2VzdG9ycyIsInByZXZpb3VzUGF0aCIsInByZXZpb3VzIiwiX3BhdGg0Iiwib2xkQW5jZXN0b3JzIiwibmV3QW5jZXN0b3JzIiwiX2l0ZXJhdG9yNiIsIl9zdGVwNiIsImFuY2VzdG9yIiwiX2l0ZXJhdG9yNyIsIl9zdGVwNyIsIl9hbmNlc3RvciIsIl9wIiwibmV3UGFyZW50IiwibmV3SW5kZXgiLCJyZXN1bHRQYXRoIiwiX3BhdGg1IiwiX2FuY2VzdG9ycyIsIl9wYXRoNiIsIl9sZXZlbHMiLCJuZXh0UGF0aCIsInNob3VsZE5vcm1hbGl6ZSIsIl9yZWY1IiwiaXRlcmF0aW9uIiwiaW5pdGlhbERpcnR5UGF0aHNMZW5ndGgiLCJtYXhJdGVyYXRpb25zIiwiRXJyb3IiLCJvYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlIiwiX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UiLCJleGNsdWRlZCIsInNvdXJjZUtleXMiLCJpbmRleE9mIiwib2JqZWN0V2l0aG91dFByb3BlcnRpZXMiLCJfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMiLCJzb3VyY2VTeW1ib2xLZXlzIiwicHJvcGVydHlJc0VudW1lcmFibGUiLCJfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciQ2IiwiX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5JDYiLCJfYXJyYXlMaWtlVG9BcnJheSQ2IiwiZ2V0Q2hhcmFjdGVyRGlzdGFuY2UiLCJzdHIiLCJpc1JUTCIsInVuZGVmaW5lZCIsImlzTFRSIiwiY29kZXBvaW50cyIsImNvZGVwb2ludHNJdGVyYXRvclJUTCIsImxlZnQiLCJDb2RlcG9pbnRUeXBlIiwiTm9uZSIsInJpZ2h0IiwiZGlzdGFuY2UiLCJnYjExIiwiZ2IxMk9yMTMiLCJfY2hhciIsImNvZGUiLCJjb2RlUG9pbnRBdCIsImdldENvZGVwb2ludFR5cGUiLCJpbnRlcnNlY3RzIiwiWldKIiwiRXh0UGljdCIsImVuZHNXaXRoRW1vamlaV0oiLCJzdWJzdHJpbmciLCJSSSIsImVuZHNXaXRoT2RkTnVtYmVyT2ZSSXMiLCJpc0JvdW5kYXJ5UGFpciIsIlNQQUNFIiwiUFVOQ1RVQVRJT04iLCJDSEFNRUxFT04iLCJnZXRXb3JkRGlzdGFuY2UiLCJkaXN0Iiwic3RhcnRlZCIsImNoYXJEaXN0IiwiX3NwbGl0QnlDaGFyYWN0ZXJEaXN0Iiwic3BsaXRCeUNoYXJhY3RlckRpc3RhbmNlIiwiX3NwbGl0QnlDaGFyYWN0ZXJEaXN0MiIsIl9jaGFyMiIsInJlbWFpbmluZyIsImlzV29yZENoYXJhY3RlciIsIl9jaGFyMyIsIl9zcGxpdEJ5Q2hhcmFjdGVyRGlzdDMiLCJfc3BsaXRCeUNoYXJhY3RlckRpc3Q0IiwibmV4dENoYXIiLCJuZXh0UmVtYWluaW5nIiwiZW5kIiwiY2hhcjEiLCJjaGFyQXQiLCJpc0xvd1N1cnJvZ2F0ZSIsImNoYXJDb2RlQXQiLCJjaGFyMiIsImlzSGlnaFN1cnJvZ2F0ZSIsImNoYXJDb2RlIiwicmVFeHRlbmQiLCJyZVByZXBlbmQiLCJyZVNwYWNpbmdNYXJrIiwicmVMIiwicmVWIiwicmVUIiwicmVMViIsInJlTFZUIiwicmVFeHRQaWN0IiwiX2NoYXI0IiwiQW55Iiwic2VhcmNoIiwiRXh0ZW5kIiwiUHJlcGVuZCIsIlNwYWNpbmdNYXJrIiwiTCIsIlYiLCJUIiwiTFYiLCJMVlQiLCJ5IiwiTm9uQm91bmRhcnlQYWlycyIsImZpbmRJbmRleCIsInIiLCJlbmRpbmdFbW9qaVpXSiIsImVuZGluZ1JJcyIsIm51bVJJcyIsImlzTm9kZUxpc3QiLCJpc0FuY2VzdG9yIiwiaXNFbGVtZW50TGlzdCIsImV2ZXJ5IiwidmFsIiwiaXNFbGVtZW50UHJvcHMiLCJwcm9wcyIsImlzRWxlbWVudFR5cGUiLCJlbGVtZW50VmFsIiwiZWxlbWVudEtleSIsIm1hdGNoZXMiLCJlbGVtZW50IiwiX2V4Y2x1ZGVkJDQiLCJfZXhjbHVkZWQyJDMiLCJvd25LZXlzJDgiLCJfb2JqZWN0U3ByZWFkJDgiLCJfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciQ1IiwiX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5JDUiLCJfYXJyYXlMaWtlVG9BcnJheSQ1IiwiSVNfRURJVE9SX0NBQ0hFIiwiYWJvdmUiLCJvcHRpb25zIiwiX29wdGlvbnMkdm9pZHMiLCJfb3B0aW9ucyRtb2RlIiwibW9kZSIsIl9vcHRpb25zJGF0IiwiX3N0ZXAkdmFsdWUiLCJpc1JhbmdlIiwiYW5jaG9yIiwiZm9jdXMiLCJhZnRlciIsInBvaW50IiwiZWRnZSIsInJhbmdlIiwiX29wdGlvbnMkZGlzdGFuY2UiLCJkIiwicG9zaXRpb25zIiwiYmVmb3JlIiwic3RhcnQiLCJfb3B0aW9ucyRkaXN0YW5jZTIiLCJfb3B0aW9ucyR1bml0IiwiX29wdGlvbnMkdW5pdDIiLCJfb3B0aW9ucyRkaXJlY3Rpb24iLCJlZGdlcyIsImZpcnN0IiwiaGFzQmxvY2tzIiwic29tZSIsImlzQmxvY2siLCJoYXNJbmxpbmVzIiwiaGFzVGV4dHMiLCJjYWNoZWRJc0VkaXRvciIsIk9wZXJhdGlvbiIsImlzT3BlcmF0aW9uTGlzdCIsImlzRW5kIiwiUG9pbnQiLCJpc0VkZ2UiLCJpc1N0YXJ0IiwiaXNFbXB0eSIsIl9jaGlsZHJlbiIsImlzTm9ybWFsaXppbmciLCJvZmZzZXQiLCJsYXN0IiwibGVhZiIsIl9vcHRpb25zJGF0MiIsIl9vcHRpb25zJHJldmVyc2UiLCJfb3B0aW9ucyR2b2lkczIiLCJfc3RlcDQkdmFsdWUiLCJfRWRpdG9yJG5vZGVzIiwiX0VkaXRvciRub2RlczIiLCJfbWF0Y2giLCJfbm9kZSIsIl9yZXN0IiwiX0VkaXRvciRsZWFmIiwiX0VkaXRvciRsZWFmMiIsIm1hcmtlZFZvaWQiLCJibG9jayIsIl9wcmV2IiwicHJldk5vZGUiLCJwcmV2UGF0aCIsIl9ibG9jayIsImJsb2NrUGF0aCIsIl9ub2RlMiIsInJlc3QiLCJfb3B0aW9ucyRtb2RlMiIsIl9vcHRpb25zJHZvaWRzMyIsIl9vcHRpb25zJGF0MyIsInBvaW50QWZ0ZXJMb2NhdGlvbiIsIl9FZGl0b3IkbGFzdCIsIl9FZGl0b3IkbGFzdDIiLCJ0byIsInNwYW4iLCJpc1BhdGgiLCJpbmNsdWRlcyIsIl9FZGl0b3Ikbm9kZXMzIiwiX0VkaXRvciRub2RlczQiLCJfb3B0aW9ucyRhdDQiLCJfb3B0aW9ucyRtb2RlMyIsIl9vcHRpb25zJHVuaXZlcnNhbCIsInVuaXZlcnNhbCIsIl9vcHRpb25zJHJldmVyc2UyIiwiX29wdGlvbnMkdm9pZHM0IiwiU3BhbiIsImlzU3BhbiIsIm5vZGVFbnRyaWVzIiwicGFzcyIsImhpdCIsIl9zdGVwNSR2YWx1ZSIsImlzTG93ZXIiLCJjb21wYXJlIiwiZW1pdCIsIl9vcHRpb25zJGZvcmNlIiwiZm9yY2UiLCJnZXREaXJ0eVBhdGhLZXlzIiwicG9wRGlydHlQYXRoIiwicG9wIiwiYWxsUGF0aHMiLCJhbGxQYXRoS2V5cyIsIm1hcCIsIndpdGhvdXROb3JtYWxpemluZyIsIl9kaXJ0eVBhdGgiLCJfZW50cnkyIiwiXyIsImRpcnR5UGF0aCIsInBhcmVudFBhdGgiLCJkZXB0aCIsIl9Ob2RlJGZpcnN0IiwiX05vZGUkZmlyc3QyIiwiZmlyc3RQYXRoIiwiX05vZGUkbGFzdCIsIl9Ob2RlJGxhc3QyIiwibGFzdFBhdGgiLCJjb21tb24iLCJpc1BvaW50IiwiaGFzUGF0aCIsInBhdGhSZWYiLCJfb3B0aW9ucyRhZmZpbml0eSIsImFmZmluaXR5IiwiY3VycmVudCIsInVucmVmIiwicmVmcyIsIl9vcHRpb25zJGVkZ2UiLCJfTm9kZSRsYXN0MyIsIl9Ob2RlJGxhc3Q0IiwiX05vZGUkZmlyc3QzIiwiX05vZGUkZmlyc3Q0IiwiX1JhbmdlJGVkZ2VzIiwiX1JhbmdlJGVkZ2VzMiIsInBvaW50UmVmIiwiX29wdGlvbnMkYWZmaW5pdHkyIiwiX29wdGlvbnMkYXQ1IiwiX29wdGlvbnMkdW5pdDMiLCJfb3B0aW9ucyRyZXZlcnNlMyIsIl9vcHRpb25zJHZvaWRzNSIsIl9SYW5nZSRlZGdlczMiLCJfUmFuZ2UkZWRnZXM0IiwiaXNOZXdCbG9jayIsImJsb2NrVGV4dCIsImxlYWZUZXh0UmVtYWluaW5nIiwibGVhZlRleHRPZmZzZXQiLCJfc3RlcDckdmFsdWUiLCJzdHJpbmciLCJpc0ZpcnN0IiwiY2FsY0Rpc3RhbmNlIiwiX29wdGlvbnMkbW9kZTQiLCJfb3B0aW9ucyR2b2lkczYiLCJfb3B0aW9ucyRhdDYiLCJwb2ludEJlZm9yZUxvY2F0aW9uIiwiX0VkaXRvciRmaXJzdCIsIl9FZGl0b3IkZmlyc3QyIiwiX0VkaXRvciRub2RlczUiLCJfRWRpdG9yJG5vZGVzNiIsInJhbmdlUmVmIiwiX29wdGlvbnMkYWZmaW5pdHkzIiwic2V0Tm9ybWFsaXppbmciLCJfb3B0aW9ucyR2b2lkczciLCJfUmFuZ2UkZWRnZXM1IiwiX1JhbmdlJGVkZ2VzNiIsIl9pdGVyYXRvcjgiLCJfc3RlcDgiLCJfc3RlcDgkdmFsdWUiLCJ0IiwidW5oYW5nUmFuZ2UiLCJfb3B0aW9ucyR2b2lkczgiLCJfUmFuZ2UkZWRnZXM3IiwiX1JhbmdlJGVkZ2VzOCIsImhhc1ByZXZpb3VzIiwiZW5kQmxvY2siLCJza2lwIiwiX2l0ZXJhdG9yOSIsIl9zdGVwOSIsIl9zdGVwOSR2YWx1ZSIsImlzQmVmb3JlIiwiX3ZvaWQiLCJMb2NhdGlvbiIsImlzTG9jYXRpb24iLCJfZXhjbHVkZWQkMyIsIl9leGNsdWRlZDIkMiIsIl9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDQiLCJfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkkNCIsIl9hcnJheUxpa2VUb0FycmF5JDQiLCJJU19OT0RFX0xJU1RfQ0FDSEUiLCJyb290IiwiU2NydWJiZXIiLCJzdHJpbmdpZnkiLCJpbmRleCIsImMiLCJjaGlsZFBhdGgiLCJhbm90aGVyIiwiZGVzY2VuZGFudCIsIl9zdGVwMiR2YWx1ZSIsImVsZW1lbnRzIiwiX3N0ZXAzJHZhbHVlIiwiZXh0cmFjdFByb3BzIiwicHJvcGVydGllcyIsIl9wcm9wZXJ0aWVzIiwibmV3Um9vdCIsInByb2R1Y2UiLCJzcGxpY2UiLCJfbGVhZiIsImlzTm9kZSIsImNhY2hlZFJlc3VsdCIsImlzVGV4dFByb3BzIiwiX29wdGlvbnMkZnJvbSIsInZpc2l0ZWQiLCJpc0FmdGVyIiwibmV4dEluZGV4IiwiX25ld1BhdGgiLCJ0ZXh0cyIsIl9zdGVwNiR2YWx1ZSIsIm93bktleXMkNyIsIl9vYmplY3RTcHJlYWQkNyIsImlzTm9kZU9wZXJhdGlvbiIsImlzT3BlcmF0aW9uIiwiZW5kc1dpdGgiLCJwb3NpdGlvbiIsIm5ld1Byb3BlcnRpZXMiLCJpc1NlbGVjdGlvbk9wZXJhdGlvbiIsImlzVGV4dE9wZXJhdGlvbiIsImludmVyc2UiLCJpc1NpYmxpbmciLCJpbnZlcnNlUGF0aCIsImludmVyc2VOZXdQYXRoIiwiX25ld1Byb3BlcnRpZXMiLCJwYXRocyIsImF2IiwiYnYiLCJtaW4iLCJNYXRoIiwiZW5kc0FmdGVyIiwiYXMiLCJicyIsImVuZHNBdCIsImVuZHNCZWZvcmUiLCJpc0NoaWxkIiwiaXNDb21tb24iLCJpc0Rlc2NlbmRhbnQiLCJpc1BhcmVudCIsImFsIiwiYmwiLCJsaXN0IiwicmVsYXRpdmUiLCJfb3AiLCJfb3AyIiwiX29wMyIsIl9wb3NpdGlvbiIsIl9vcDQiLCJvbnAiLCJjb3B5Iiwib3duS2V5cyQ2IiwiX29iamVjdFNwcmVhZCQ2IiwicmVzdWx0IiwiX2V4Y2x1ZGVkJDIiLCJvd25LZXlzJDUiLCJfb2JqZWN0U3ByZWFkJDUiLCJpc0JhY2t3YXJkIiwicnMiLCJyZSIsInRzIiwidGUiLCJpc0FmdGVyU3RhcnQiLCJpc0JlZm9yZUVuZCIsImludGVyc2VjdGlvbiIsIl9SYW5nZSRlZGdlczkiLCJfUmFuZ2UkZWRnZXMxMCIsInMxIiwiZTEiLCJfUmFuZ2UkZWRnZXMxMSIsIl9SYW5nZSRlZGdlczEyIiwiczIiLCJlMiIsImlzRm9yd2FyZCIsInBvaW50cyIsIl9SYW5nZSRlZGdlczEzIiwiX1JhbmdlJGVkZ2VzMTQiLCJhZmZpbml0eUFuY2hvciIsImFmZmluaXR5Rm9jdXMiLCJfc2NydWJiZXIiLCJzZXRTY3J1YmJlciIsInNjcnViYmVyIiwiSlNPTiIsImlzRGVlcEVxdWFsIiwiYSIsImIiLCJfa2V5IiwiX2V4Y2x1ZGVkJDEiLCJfZXhjbHVkZWQyJDEiLCJfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciQzIiwiX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5JDMiLCJfYXJyYXlMaWtlVG9BcnJheSQzIiwib3duS2V5cyQ0IiwiX29iamVjdFNwcmVhZCQ0IiwiX29wdGlvbnMkbG9vc2UiLCJvbWl0VGV4dCIsImlzVGV4dExpc3QiLCJkZWNvcmF0aW9ucyIsIl9kZWNvcmF0aW9ucyIsImxlYXZlcyIsImRlYyIsImxlYWZFbmQiLCJkZWNvcmF0aW9uU3RhcnQiLCJkZWNvcmF0aW9uRW5kIiwibGVhZlN0YXJ0IiwiYXNzaWduIiwibWlkZGxlIiwib2ZmIiwiX29mZiIsIm93bktleXMkMyIsIl9vYmplY3RTcHJlYWQkMyIsIl9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDIiLCJfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkkMiIsIl9hcnJheUxpa2VUb0FycmF5JDIiLCJhcHBseVRvRHJhZnQiLCJfcG9pbnQiLCJfcGFyZW50IiwiX2luZGV4IiwiX3ByZXYkY2hpbGRyZW4iLCJfcG9pbnQyIiwiX2tleTIiLCJfbm9kZTMiLCJfcGFyZW50MiIsIl9pbmRleDIiLCJ0cnVlUGF0aCIsIl9wb2ludDMiLCJfa2V5MyIsIl9pbmRleDMiLCJfcGFyZW50MyIsIl9wb2ludDQiLCJfa2V5NCIsInByZWZlck5leHQiLCJfb2Zmc2V0IiwiX3RleHQiLCJfbm9kZTQiLCJfYmVmb3JlIiwiX2FmdGVyIiwiX3BvaW50NSIsIl9rZXk1IiwiX25vZGU1IiwiX2tleTYiLCJfa2V5NyIsIl9rZXk4IiwiX3ZhbHVlIiwiX3BhdGg3IiwiX25vZGU2IiwiX3BhcmVudDQiLCJfaW5kZXg0IiwibmV3Tm9kZSIsIl9iZWZvcmUyIiwiX2FmdGVyMiIsIl9iZWZvcmUzIiwiX2FmdGVyMyIsIl9wb2ludDYiLCJfa2V5OSIsIkdlbmVyYWxUcmFuc2Zvcm1zIiwiY3JlYXRlRHJhZnQiLCJmaW5pc2hEcmFmdCIsImlzRHJhZnQiLCJfZXhjbHVkZWQiLCJfZXhjbHVkZWQyIiwib3duS2V5cyQyIiwiX29iamVjdFNwcmVhZCQyIiwiX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkMSIsIl91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSQxIiwiX2FycmF5TGlrZVRvQXJyYXkkMSIsIk5vZGVUcmFuc2Zvcm1zIiwiX29wdGlvbnMkaGFuZ2luZyIsImhhbmdpbmciLCJzZWxlY3QiLCJfbm9kZXMiLCJfbm9kZXMyIiwiX21hdGNoUGF0aCIsImlzQXRFbmQiLCJsaWZ0Tm9kZXMiLCJtYXRjaFBhdGgiLCJfcGF0aFJlZnMiLCJwYXJlbnROb2RlRW50cnkiLCJfcGFyZW50Tm9kZUVudHJ5IiwidG9QYXRoIiwibW92ZU5vZGVzIiwiX3RvUGF0aCIsInNwbGl0UGF0aCIsIl90b1BhdGgyIiwiX29wdGlvbnMkaGFuZ2luZzIiLCJfY3VycmVudCIsImNvbW1vblBhdGgiLCJpc1ByZXZpb3VzU2libGluZyIsImVtcHR5QW5jZXN0b3IiLCJoYXNTaW5nbGVDaGlsZE5lc3QiLCJlbXB0eVJlZiIsInRvUmVmIiwidGFyZ2V0cyIsIl9yZWY2IiwiX2kyIiwiX3BhdGhSZWZzMiIsIl9vcHRpb25zJGhhbmdpbmczIiwiX29wdGlvbnMkbW9kZTUiLCJkZXB0aHMiLCJfcmVmNyIsIl9yZWY4IiwiX2kzIiwiX3BhdGhSZWZzMyIsIm1lcmdlIiwiX29wdGlvbnMkaGFuZ2luZzQiLCJfb3B0aW9ucyRtb2RlNiIsIl9vcHRpb25zJHNwbGl0Iiwic3BsaXRNb2RlIiwiZW5kQXRFbmRPZk5vZGUiLCJzdGFydEF0U3RhcnRPZk5vZGUiLCJwcm9wIiwibm9kZVByb3AiLCJoYXNDaGFuZ2VzIiwiayIsIl9vcHRpb25zJG1vZGU3IiwiX29wdGlvbnMkaGVpZ2h0IiwiaGVpZ2h0IiwiX29wdGlvbnMkYWx3YXlzIiwiZGVsZXRlUmFuZ2UiLCJiZWZvcmVSZWYiLCJhZnRlclJlZiIsImhpZ2hlc3QiLCJ2b2lkTWF0Y2giLCJudWRnZSIsIl92b2lkTWF0Y2giLCJ2b2lkTm9kZSIsInZvaWRQYXRoIiwiYWZ0ZXJQYXRoIiwic2libGluZ0hlaWdodCIsIl9oaWdoZXN0IiwiaGlnaGVzdFBhdGgiLCJsb3dlc3RQYXRoIiwiX2FmdGVyUmVmIiwidW53cmFwTm9kZXMiLCJfb3B0aW9ucyRtb2RlOCIsIl9vcHRpb25zJHNwbGl0MiIsIl9vcHRpb25zJGF0NyIsIl9yZWY5IiwiX3JlZjEwIiwiX2xvb3AiLCJ3cmFwTm9kZXMiLCJfb3B0aW9ucyRtb2RlOSIsIl9vcHRpb25zJHNwbGl0MyIsIl9vcHRpb25zJHZvaWRzOSIsIl9vcHRpb25zJGF0OCIsInJvb3RzIiwiX2k0IiwiX3Jvb3RzIiwiX3Jvb3RzJF9pIiwicm9vdFBhdGgiLCJfcmV0IiwiX21hdGNoZXMiLCJfZmlyc3QiLCJfbGFzdCIsImNvbW1vbk5vZGVFbnRyeSIsIl9jb21tb25Ob2RlRW50cnkiLCJjb21tb25Ob2RlIiwid3JhcHBlclBhdGgiLCJ3cmFwcGVyIiwiX0VkaXRvciRub2RlNSIsIl9FZGl0b3Ikbm9kZTYiLCJvd25LZXlzJDEiLCJfb2JqZWN0U3ByZWFkJDEiLCJTZWxlY3Rpb25UcmFuc2Zvcm1zIiwiY29sbGFwc2UiLCJkZXNlbGVjdCIsIm1vdmUiLCJfb3B0aW9ucyRlZGdlMiIsIm9wdHMiLCJzZXRTZWxlY3Rpb24iLCJzZXRQb2ludCIsIl9vcHRpb25zJGVkZ2UzIiwib2xkUHJvcHMiLCJuZXdQcm9wcyIsIl9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyIiwiVGV4dFRyYW5zZm9ybXMiLCJfZGVsZXRlIiwiZnVydGhlc3RWb2lkIiwiX2Z1cnRoZXN0Vm9pZCIsIl9lbmQiLCJlbmRPZkRvYyIsInN0YXJ0QmxvY2siLCJpc0Fjcm9zc0Jsb2NrcyIsImlzU2luZ2xlVGV4dCIsInN0YXJ0Vm9pZCIsImVuZFZvaWQiLCJzdGFydFJlZiIsImVuZFJlZiIsInJlbW92ZWRUZXh0IiwiX3N0YXJ0IiwiX0VkaXRvciRsZWFmMyIsIl9FZGl0b3IkbGVhZjQiLCJzdGFydFVucmVmIiwiZW5kVW5yZWYiLCJpbmxpbmVFbGVtZW50TWF0Y2giLCJfaW5saW5lRWxlbWVudE1hdGNoIiwiX2lubGluZVBhdGgiLCJibG9ja01hdGNoIiwiX2Jsb2NrTWF0Y2giLCJpc0Jsb2NrU3RhcnQiLCJpc0Jsb2NrRW5kIiwiaXNCbG9ja0VtcHR5IiwibWVyZ2VTdGFydCIsIm1lcmdlRW5kIiwibWF0Y2hlciIsImlzUm9vdCIsInN0YXJ0cyIsIm1pZGRsZXMiLCJlbmRzIiwic3RhcnRpbmciLCJfbWF0Y2hlcyRfaSIsImlubGluZU1hdGNoIiwiX2lubGluZU1hdGNoIiwiaW5saW5lUGF0aCIsImlzSW5saW5lU3RhcnQiLCJpc0lubGluZUVuZCIsIm1pZGRsZVJlZiIsIl9lbmQyIiwic3RhcnRQb2ludCIsImVuZFBvaW50IiwiX2F0Iiwib3duS2V5cyIsIl9vYmplY3RTcHJlYWQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/slate/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/slate/dist/index.js":
/*!******************************************!*\
  !*** ./node_modules/slate/dist/index.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\nvar isPlainObject = __webpack_require__(/*! is-plain-object */ \"(ssr)/./node_modules/is-plain-object/dist/is-plain-object.js\");\nvar immer = __webpack_require__(/*! immer */ \"(ssr)/./node_modules/immer/dist/index.js\");\n\nfunction unwrapExports (x) {\n\treturn x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;\n}\n\nfunction createCommonjsModule(fn, module) {\n\treturn module = { exports: {} }, fn(module, module.exports), module.exports;\n}\n\nvar arrayLikeToArray = createCommonjsModule(function (module) {\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nmodule.exports = _arrayLikeToArray;\nmodule.exports[\"default\"] = module.exports, module.exports.__esModule = true;\n});\n\nunwrapExports(arrayLikeToArray);\n\nvar arrayWithoutHoles = createCommonjsModule(function (module) {\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return arrayLikeToArray(arr);\n}\n\nmodule.exports = _arrayWithoutHoles;\nmodule.exports[\"default\"] = module.exports, module.exports.__esModule = true;\n});\n\nunwrapExports(arrayWithoutHoles);\n\nvar iterableToArray = createCommonjsModule(function (module) {\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\n\nmodule.exports = _iterableToArray;\nmodule.exports[\"default\"] = module.exports, module.exports.__esModule = true;\n});\n\nunwrapExports(iterableToArray);\n\nvar unsupportedIterableToArray = createCommonjsModule(function (module) {\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);\n}\n\nmodule.exports = _unsupportedIterableToArray;\nmodule.exports[\"default\"] = module.exports, module.exports.__esModule = true;\n});\n\nunwrapExports(unsupportedIterableToArray);\n\nvar nonIterableSpread = createCommonjsModule(function (module) {\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nmodule.exports = _nonIterableSpread;\nmodule.exports[\"default\"] = module.exports, module.exports.__esModule = true;\n});\n\nunwrapExports(nonIterableSpread);\n\nvar toConsumableArray = createCommonjsModule(function (module) {\nfunction _toConsumableArray(arr) {\n  return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();\n}\n\nmodule.exports = _toConsumableArray;\nmodule.exports[\"default\"] = module.exports, module.exports.__esModule = true;\n});\n\nvar _toConsumableArray = unwrapExports(toConsumableArray);\n\nvar defineProperty = createCommonjsModule(function (module) {\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nmodule.exports = _defineProperty;\nmodule.exports[\"default\"] = module.exports, module.exports.__esModule = true;\n});\n\nvar _defineProperty = unwrapExports(defineProperty);\n\nvar arrayWithHoles = createCommonjsModule(function (module) {\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nmodule.exports = _arrayWithHoles;\nmodule.exports[\"default\"] = module.exports, module.exports.__esModule = true;\n});\n\nunwrapExports(arrayWithHoles);\n\nvar iterableToArrayLimit = createCommonjsModule(function (module) {\nfunction _iterableToArrayLimit(arr, i) {\n  var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"];\n\n  if (_i == null) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n\n  var _s, _e;\n\n  try {\n    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nmodule.exports = _iterableToArrayLimit;\nmodule.exports[\"default\"] = module.exports, module.exports.__esModule = true;\n});\n\nunwrapExports(iterableToArrayLimit);\n\nvar nonIterableRest = createCommonjsModule(function (module) {\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nmodule.exports = _nonIterableRest;\nmodule.exports[\"default\"] = module.exports, module.exports.__esModule = true;\n});\n\nunwrapExports(nonIterableRest);\n\nvar slicedToArray = createCommonjsModule(function (module) {\nfunction _slicedToArray(arr, i) {\n  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray(arr, i) || nonIterableRest();\n}\n\nmodule.exports = _slicedToArray;\nmodule.exports[\"default\"] = module.exports, module.exports.__esModule = true;\n});\n\nvar _slicedToArray = unwrapExports(slicedToArray);\n\nvar DIRTY_PATHS = new WeakMap();\nvar DIRTY_PATH_KEYS = new WeakMap();\nvar FLUSHING = new WeakMap();\nvar NORMALIZING = new WeakMap();\nvar PATH_REFS = new WeakMap();\nvar POINT_REFS = new WeakMap();\nvar RANGE_REFS = new WeakMap();\n\nfunction ownKeys$9(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread$9(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$9(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$9(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _createForOfIteratorHelper$7(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$7(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray$7(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray$7(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$7(o, minLen); }\n\nfunction _arrayLikeToArray$7(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n/**\r\n * Create a new Slate `Editor` object.\r\n */\n\nvar createEditor = function createEditor() {\n  var editor = {\n    children: [],\n    operations: [],\n    selection: null,\n    marks: null,\n    isInline: function isInline() {\n      return false;\n    },\n    isVoid: function isVoid() {\n      return false;\n    },\n    markableVoid: function markableVoid() {\n      return false;\n    },\n    onChange: function onChange() {},\n    apply: function apply(op) {\n      var _iterator = _createForOfIteratorHelper$7(Editor.pathRefs(editor)),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var ref = _step.value;\n          PathRef.transform(ref, op);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      var _iterator2 = _createForOfIteratorHelper$7(Editor.pointRefs(editor)),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var _ref = _step2.value;\n          PointRef.transform(_ref, op);\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      var _iterator3 = _createForOfIteratorHelper$7(Editor.rangeRefs(editor)),\n          _step3;\n\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var _ref2 = _step3.value;\n          RangeRef.transform(_ref2, op);\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n\n      var oldDirtyPaths = DIRTY_PATHS.get(editor) || [];\n      var oldDirtyPathKeys = DIRTY_PATH_KEYS.get(editor) || new Set();\n      var dirtyPaths;\n      var dirtyPathKeys;\n\n      var add = function add(path) {\n        if (path) {\n          var key = path.join(',');\n\n          if (!dirtyPathKeys.has(key)) {\n            dirtyPathKeys.add(key);\n            dirtyPaths.push(path);\n          }\n        }\n      };\n\n      if (Path.operationCanTransformPath(op)) {\n        dirtyPaths = [];\n        dirtyPathKeys = new Set();\n\n        var _iterator4 = _createForOfIteratorHelper$7(oldDirtyPaths),\n            _step4;\n\n        try {\n          for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n            var path = _step4.value;\n            var newPath = Path.transform(path, op);\n            add(newPath);\n          }\n        } catch (err) {\n          _iterator4.e(err);\n        } finally {\n          _iterator4.f();\n        }\n      } else {\n        dirtyPaths = oldDirtyPaths;\n        dirtyPathKeys = oldDirtyPathKeys;\n      }\n\n      var newDirtyPaths = editor.getDirtyPaths(op);\n\n      var _iterator5 = _createForOfIteratorHelper$7(newDirtyPaths),\n          _step5;\n\n      try {\n        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n          var _path = _step5.value;\n          add(_path);\n        }\n      } catch (err) {\n        _iterator5.e(err);\n      } finally {\n        _iterator5.f();\n      }\n\n      DIRTY_PATHS.set(editor, dirtyPaths);\n      DIRTY_PATH_KEYS.set(editor, dirtyPathKeys);\n      Transforms.transform(editor, op);\n      editor.operations.push(op);\n      Editor.normalize(editor, {\n        operation: op\n      }); // Clear any formats applied to the cursor if the selection changes.\n\n      if (op.type === 'set_selection') {\n        editor.marks = null;\n      }\n\n      if (!FLUSHING.get(editor)) {\n        FLUSHING.set(editor, true);\n        Promise.resolve().then(function () {\n          FLUSHING.set(editor, false);\n          editor.onChange({\n            operation: op\n          });\n          editor.operations = [];\n        });\n      }\n    },\n    addMark: function addMark(key, value) {\n      var selection = editor.selection;\n          editor.markableVoid;\n\n      if (selection) {\n        var match = function match(node, path) {\n          if (!Text.isText(node)) {\n            return false; // marks can only be applied to text\n          }\n\n          var _Editor$parent = Editor.parent(editor, path),\n              _Editor$parent2 = _slicedToArray(_Editor$parent, 2),\n              parentNode = _Editor$parent2[0];\n              _Editor$parent2[1];\n\n          return !editor.isVoid(parentNode) || editor.markableVoid(parentNode);\n        };\n\n        var expandedSelection = Range.isExpanded(selection);\n        var markAcceptingVoidSelected = false;\n\n        if (!expandedSelection) {\n          var _Editor$node = Editor.node(editor, selection),\n              _Editor$node2 = _slicedToArray(_Editor$node, 2),\n              selectedNode = _Editor$node2[0],\n              selectedPath = _Editor$node2[1];\n\n          if (selectedNode && match(selectedNode, selectedPath)) {\n            var _Editor$parent3 = Editor.parent(editor, selectedPath),\n                _Editor$parent4 = _slicedToArray(_Editor$parent3, 1),\n                parentNode = _Editor$parent4[0];\n\n            markAcceptingVoidSelected = parentNode && editor.markableVoid(parentNode);\n          }\n        }\n\n        if (expandedSelection || markAcceptingVoidSelected) {\n          Transforms.setNodes(editor, _defineProperty({}, key, value), {\n            match: match,\n            split: true,\n            voids: true\n          });\n        } else {\n          var marks = _objectSpread$9(_objectSpread$9({}, Editor.marks(editor) || {}), {}, _defineProperty({}, key, value));\n\n          editor.marks = marks;\n\n          if (!FLUSHING.get(editor)) {\n            editor.onChange();\n          }\n        }\n      }\n    },\n    deleteBackward: function deleteBackward(unit) {\n      var selection = editor.selection;\n\n      if (selection && Range.isCollapsed(selection)) {\n        Transforms[\"delete\"](editor, {\n          unit: unit,\n          reverse: true\n        });\n      }\n    },\n    deleteForward: function deleteForward(unit) {\n      var selection = editor.selection;\n\n      if (selection && Range.isCollapsed(selection)) {\n        Transforms[\"delete\"](editor, {\n          unit: unit\n        });\n      }\n    },\n    deleteFragment: function deleteFragment(direction) {\n      var selection = editor.selection;\n\n      if (selection && Range.isExpanded(selection)) {\n        Transforms[\"delete\"](editor, {\n          reverse: direction === 'backward'\n        });\n      }\n    },\n    getFragment: function getFragment() {\n      var selection = editor.selection;\n\n      if (selection) {\n        return Node.fragment(editor, selection);\n      }\n\n      return [];\n    },\n    insertBreak: function insertBreak() {\n      Transforms.splitNodes(editor, {\n        always: true\n      });\n    },\n    insertSoftBreak: function insertSoftBreak() {\n      Transforms.splitNodes(editor, {\n        always: true\n      });\n    },\n    insertFragment: function insertFragment(fragment) {\n      Transforms.insertFragment(editor, fragment);\n    },\n    insertNode: function insertNode(node) {\n      Transforms.insertNodes(editor, node);\n    },\n    insertText: function insertText(text) {\n      var selection = editor.selection,\n          marks = editor.marks;\n\n      if (selection) {\n        if (marks) {\n          var node = _objectSpread$9({\n            text: text\n          }, marks);\n\n          Transforms.insertNodes(editor, node);\n        } else {\n          Transforms.insertText(editor, text);\n        }\n\n        editor.marks = null;\n      }\n    },\n    normalizeNode: function normalizeNode(entry) {\n      var _entry = _slicedToArray(entry, 2),\n          node = _entry[0],\n          path = _entry[1]; // There are no core normalizations for text nodes.\n\n\n      if (Text.isText(node)) {\n        return;\n      } // Ensure that block and inline nodes have at least one text child.\n\n\n      if (Element.isElement(node) && node.children.length === 0) {\n        var child = {\n          text: ''\n        };\n        Transforms.insertNodes(editor, child, {\n          at: path.concat(0),\n          voids: true\n        });\n        return;\n      } // Determine whether the node should have block or inline children.\n\n\n      var shouldHaveInlines = Editor.isEditor(node) ? false : Element.isElement(node) && (editor.isInline(node) || node.children.length === 0 || Text.isText(node.children[0]) || editor.isInline(node.children[0])); // Since we'll be applying operations while iterating, keep track of an\n      // index that accounts for any added/removed nodes.\n\n      var n = 0;\n\n      for (var i = 0; i < node.children.length; i++, n++) {\n        var currentNode = Node.get(editor, path);\n        if (Text.isText(currentNode)) continue;\n        var _child = node.children[i];\n        var prev = currentNode.children[n - 1];\n        var isLast = i === node.children.length - 1;\n        var isInlineOrText = Text.isText(_child) || Element.isElement(_child) && editor.isInline(_child); // Only allow block nodes in the top-level children and parent blocks\n        // that only contain block nodes. Similarly, only allow inline nodes in\n        // other inline nodes, or parent blocks that only contain inlines and\n        // text.\n\n        if (isInlineOrText !== shouldHaveInlines) {\n          Transforms.removeNodes(editor, {\n            at: path.concat(n),\n            voids: true\n          });\n          n--;\n        } else if (Element.isElement(_child)) {\n          // Ensure that inline nodes are surrounded by text nodes.\n          if (editor.isInline(_child)) {\n            if (prev == null || !Text.isText(prev)) {\n              var newChild = {\n                text: ''\n              };\n              Transforms.insertNodes(editor, newChild, {\n                at: path.concat(n),\n                voids: true\n              });\n              n++;\n            } else if (isLast) {\n              var _newChild = {\n                text: ''\n              };\n              Transforms.insertNodes(editor, _newChild, {\n                at: path.concat(n + 1),\n                voids: true\n              });\n              n++;\n            }\n          }\n        } else {\n          // Merge adjacent text nodes that are empty or match.\n          if (prev != null && Text.isText(prev)) {\n            if (Text.equals(_child, prev, {\n              loose: true\n            })) {\n              Transforms.mergeNodes(editor, {\n                at: path.concat(n),\n                voids: true\n              });\n              n--;\n            } else if (prev.text === '') {\n              Transforms.removeNodes(editor, {\n                at: path.concat(n - 1),\n                voids: true\n              });\n              n--;\n            } else if (_child.text === '') {\n              Transforms.removeNodes(editor, {\n                at: path.concat(n),\n                voids: true\n              });\n              n--;\n            }\n          }\n        }\n      }\n    },\n    removeMark: function removeMark(key) {\n      var selection = editor.selection;\n\n      if (selection) {\n        var match = function match(node, path) {\n          if (!Text.isText(node)) {\n            return false; // marks can only be applied to text\n          }\n\n          var _Editor$parent5 = Editor.parent(editor, path),\n              _Editor$parent6 = _slicedToArray(_Editor$parent5, 2),\n              parentNode = _Editor$parent6[0];\n              _Editor$parent6[1];\n\n          return !editor.isVoid(parentNode) || editor.markableVoid(parentNode);\n        };\n\n        var expandedSelection = Range.isExpanded(selection);\n        var markAcceptingVoidSelected = false;\n\n        if (!expandedSelection) {\n          var _Editor$node3 = Editor.node(editor, selection),\n              _Editor$node4 = _slicedToArray(_Editor$node3, 2),\n              selectedNode = _Editor$node4[0],\n              selectedPath = _Editor$node4[1];\n\n          if (selectedNode && match(selectedNode, selectedPath)) {\n            var _Editor$parent7 = Editor.parent(editor, selectedPath),\n                _Editor$parent8 = _slicedToArray(_Editor$parent7, 1),\n                parentNode = _Editor$parent8[0];\n\n            markAcceptingVoidSelected = parentNode && editor.markableVoid(parentNode);\n          }\n        }\n\n        if (expandedSelection || markAcceptingVoidSelected) {\n          Transforms.unsetNodes(editor, key, {\n            match: match,\n            split: true,\n            voids: true\n          });\n        } else {\n          var marks = _objectSpread$9({}, Editor.marks(editor) || {});\n\n          delete marks[key];\n          editor.marks = marks;\n\n          if (!FLUSHING.get(editor)) {\n            editor.onChange();\n          }\n        }\n      }\n    },\n\n    /**\r\n     * Get the \"dirty\" paths generated from an operation.\r\n     */\n    getDirtyPaths: function getDirtyPaths(op) {\n      switch (op.type) {\n        case 'insert_text':\n        case 'remove_text':\n        case 'set_node':\n          {\n            var path = op.path;\n            return Path.levels(path);\n          }\n\n        case 'insert_node':\n          {\n            var node = op.node,\n                _path2 = op.path;\n            var levels = Path.levels(_path2);\n            var descendants = Text.isText(node) ? [] : Array.from(Node.nodes(node), function (_ref3) {\n              var _ref4 = _slicedToArray(_ref3, 2),\n                  p = _ref4[1];\n\n              return _path2.concat(p);\n            });\n            return [].concat(_toConsumableArray(levels), _toConsumableArray(descendants));\n          }\n\n        case 'merge_node':\n          {\n            var _path3 = op.path;\n            var ancestors = Path.ancestors(_path3);\n            var previousPath = Path.previous(_path3);\n            return [].concat(_toConsumableArray(ancestors), [previousPath]);\n          }\n\n        case 'move_node':\n          {\n            var _path4 = op.path,\n                newPath = op.newPath;\n\n            if (Path.equals(_path4, newPath)) {\n              return [];\n            }\n\n            var oldAncestors = [];\n            var newAncestors = [];\n\n            var _iterator6 = _createForOfIteratorHelper$7(Path.ancestors(_path4)),\n                _step6;\n\n            try {\n              for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n                var ancestor = _step6.value;\n                var p = Path.transform(ancestor, op);\n                oldAncestors.push(p);\n              }\n            } catch (err) {\n              _iterator6.e(err);\n            } finally {\n              _iterator6.f();\n            }\n\n            var _iterator7 = _createForOfIteratorHelper$7(Path.ancestors(newPath)),\n                _step7;\n\n            try {\n              for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n                var _ancestor = _step7.value;\n\n                var _p = Path.transform(_ancestor, op);\n\n                newAncestors.push(_p);\n              }\n            } catch (err) {\n              _iterator7.e(err);\n            } finally {\n              _iterator7.f();\n            }\n\n            var newParent = newAncestors[newAncestors.length - 1];\n            var newIndex = newPath[newPath.length - 1];\n            var resultPath = newParent.concat(newIndex);\n            return [].concat(oldAncestors, newAncestors, [resultPath]);\n          }\n\n        case 'remove_node':\n          {\n            var _path5 = op.path;\n\n            var _ancestors = Path.ancestors(_path5);\n\n            return _toConsumableArray(_ancestors);\n          }\n\n        case 'split_node':\n          {\n            var _path6 = op.path;\n\n            var _levels = Path.levels(_path6);\n\n            var nextPath = Path.next(_path6);\n            return [].concat(_toConsumableArray(_levels), [nextPath]);\n          }\n\n        default:\n          {\n            return [];\n          }\n      }\n    },\n    shouldNormalize: function shouldNormalize(_ref5) {\n      var iteration = _ref5.iteration,\n          initialDirtyPathsLength = _ref5.initialDirtyPathsLength;\n      var maxIterations = initialDirtyPathsLength * 42; // HACK: better way?\n\n      if (iteration > maxIterations) {\n        throw new Error(\"Could not completely normalize the editor after \".concat(maxIterations, \" iterations! This is usually due to incorrect normalization logic that leaves a node in an invalid state.\"));\n      }\n\n      return true;\n    }\n  };\n  return editor;\n};\n\nvar objectWithoutPropertiesLoose = createCommonjsModule(function (module) {\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nmodule.exports = _objectWithoutPropertiesLoose;\nmodule.exports[\"default\"] = module.exports, module.exports.__esModule = true;\n});\n\nunwrapExports(objectWithoutPropertiesLoose);\n\nvar objectWithoutProperties = createCommonjsModule(function (module) {\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n  var target = objectWithoutPropertiesLoose(source, excluded);\n  var key, i;\n\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n\nmodule.exports = _objectWithoutProperties;\nmodule.exports[\"default\"] = module.exports, module.exports.__esModule = true;\n});\n\nvar _objectWithoutProperties = unwrapExports(objectWithoutProperties);\n\nfunction _createForOfIteratorHelper$6(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$6(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray$6(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray$6(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$6(o, minLen); }\n\nfunction _arrayLikeToArray$6(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n// Character (grapheme cluster) boundaries are determined according to\n// the default grapheme cluster boundary specification, extended grapheme clusters variant[1].\n//\n// References:\n//\n// [1] https://www.unicode.org/reports/tr29/#Default_Grapheme_Cluster_Table\n// [2] https://www.unicode.org/Public/UCD/latest/ucd/auxiliary/GraphemeBreakProperty.txt\n// [3] https://www.unicode.org/Public/UCD/latest/ucd/auxiliary/GraphemeBreakTest.html\n// [4] https://www.unicode.org/Public/UCD/latest/ucd/auxiliary/GraphemeBreakTest.txt\n\n/**\r\n * Get the distance to the end of the first character in a string of text.\r\n */\nvar getCharacterDistance = function getCharacterDistance(str) {\n  var isRTL = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  var isLTR = !isRTL;\n  var codepoints = isRTL ? codepointsIteratorRTL(str) : str;\n  var left = CodepointType.None;\n  var right = CodepointType.None;\n  var distance = 0; // Evaluation of these conditions are deferred.\n\n  var gb11 = null; // Is GB11 applicable?\n\n  var gb12Or13 = null; // Is GB12 or GB13 applicable?\n\n  var _iterator = _createForOfIteratorHelper$6(codepoints),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var _char = _step.value;\n\n      var code = _char.codePointAt(0);\n\n      if (!code) break;\n      var type = getCodepointType(_char, code);\n\n      var _ref = isLTR ? [right, type] : [type, left];\n\n      var _ref2 = _slicedToArray(_ref, 2);\n\n      left = _ref2[0];\n      right = _ref2[1];\n\n      if (intersects(left, CodepointType.ZWJ) && intersects(right, CodepointType.ExtPict)) {\n        if (isLTR) {\n          gb11 = endsWithEmojiZWJ(str.substring(0, distance));\n        } else {\n          gb11 = endsWithEmojiZWJ(str.substring(0, str.length - distance));\n        }\n\n        if (!gb11) break;\n      }\n\n      if (intersects(left, CodepointType.RI) && intersects(right, CodepointType.RI)) {\n        if (gb12Or13 !== null) {\n          gb12Or13 = !gb12Or13;\n        } else {\n          if (isLTR) {\n            gb12Or13 = true;\n          } else {\n            gb12Or13 = endsWithOddNumberOfRIs(str.substring(0, str.length - distance));\n          }\n        }\n\n        if (!gb12Or13) break;\n      }\n\n      if (left !== CodepointType.None && right !== CodepointType.None && isBoundaryPair(left, right)) {\n        break;\n      }\n\n      distance += _char.length;\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return distance || 1;\n};\nvar SPACE = /\\s/;\nvar PUNCTUATION = /[\\u0021-\\u0023\\u0025-\\u002A\\u002C-\\u002F\\u003A\\u003B\\u003F\\u0040\\u005B-\\u005D\\u005F\\u007B\\u007D\\u00A1\\u00A7\\u00AB\\u00B6\\u00B7\\u00BB\\u00BF\\u037E\\u0387\\u055A-\\u055F\\u0589\\u058A\\u05BE\\u05C0\\u05C3\\u05C6\\u05F3\\u05F4\\u0609\\u060A\\u060C\\u060D\\u061B\\u061E\\u061F\\u066A-\\u066D\\u06D4\\u0700-\\u070D\\u07F7-\\u07F9\\u0830-\\u083E\\u085E\\u0964\\u0965\\u0970\\u0AF0\\u0DF4\\u0E4F\\u0E5A\\u0E5B\\u0F04-\\u0F12\\u0F14\\u0F3A-\\u0F3D\\u0F85\\u0FD0-\\u0FD4\\u0FD9\\u0FDA\\u104A-\\u104F\\u10FB\\u1360-\\u1368\\u1400\\u166D\\u166E\\u169B\\u169C\\u16EB-\\u16ED\\u1735\\u1736\\u17D4-\\u17D6\\u17D8-\\u17DA\\u1800-\\u180A\\u1944\\u1945\\u1A1E\\u1A1F\\u1AA0-\\u1AA6\\u1AA8-\\u1AAD\\u1B5A-\\u1B60\\u1BFC-\\u1BFF\\u1C3B-\\u1C3F\\u1C7E\\u1C7F\\u1CC0-\\u1CC7\\u1CD3\\u2010-\\u2027\\u2030-\\u2043\\u2045-\\u2051\\u2053-\\u205E\\u207D\\u207E\\u208D\\u208E\\u2329\\u232A\\u2768-\\u2775\\u27C5\\u27C6\\u27E6-\\u27EF\\u2983-\\u2998\\u29D8-\\u29DB\\u29FC\\u29FD\\u2CF9-\\u2CFC\\u2CFE\\u2CFF\\u2D70\\u2E00-\\u2E2E\\u2E30-\\u2E3B\\u3001-\\u3003\\u3008-\\u3011\\u3014-\\u301F\\u3030\\u303D\\u30A0\\u30FB\\uA4FE\\uA4FF\\uA60D-\\uA60F\\uA673\\uA67E\\uA6F2-\\uA6F7\\uA874-\\uA877\\uA8CE\\uA8CF\\uA8F8-\\uA8FA\\uA92E\\uA92F\\uA95F\\uA9C1-\\uA9CD\\uA9DE\\uA9DF\\uAA5C-\\uAA5F\\uAADE\\uAADF\\uAAF0\\uAAF1\\uABEB\\uFD3E\\uFD3F\\uFE10-\\uFE19\\uFE30-\\uFE52\\uFE54-\\uFE61\\uFE63\\uFE68\\uFE6A\\uFE6B\\uFF01-\\uFF03\\uFF05-\\uFF0A\\uFF0C-\\uFF0F\\uFF1A\\uFF1B\\uFF1F\\uFF20\\uFF3B-\\uFF3D\\uFF3F\\uFF5B\\uFF5D\\uFF5F-\\uFF65]/;\nvar CHAMELEON = /['\\u2018\\u2019]/;\n/**\r\n * Get the distance to the end of the first word in a string of text.\r\n */\n\nvar getWordDistance = function getWordDistance(text) {\n  var isRTL = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  var dist = 0;\n  var started = false;\n\n  while (text.length > 0) {\n    var charDist = getCharacterDistance(text, isRTL);\n\n    var _splitByCharacterDist = splitByCharacterDistance(text, charDist, isRTL),\n        _splitByCharacterDist2 = _slicedToArray(_splitByCharacterDist, 2),\n        _char2 = _splitByCharacterDist2[0],\n        remaining = _splitByCharacterDist2[1];\n\n    if (isWordCharacter(_char2, remaining, isRTL)) {\n      started = true;\n      dist += charDist;\n    } else if (!started) {\n      dist += charDist;\n    } else {\n      break;\n    }\n\n    text = remaining;\n  }\n\n  return dist;\n};\n/**\r\n * Split a string in two parts at a given distance starting from the end when\r\n * `isRTL` is set to `true`.\r\n */\n\nvar splitByCharacterDistance = function splitByCharacterDistance(str, dist, isRTL) {\n  if (isRTL) {\n    var at = str.length - dist;\n    return [str.slice(at, str.length), str.slice(0, at)];\n  }\n\n  return [str.slice(0, dist), str.slice(dist)];\n};\n/**\r\n * Check if a character is a word character. The `remaining` argument is used\r\n * because sometimes you must read subsequent characters to truly determine it.\r\n */\n\nvar isWordCharacter = function isWordCharacter(_char3, remaining) {\n  var isRTL = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n  if (SPACE.test(_char3)) {\n    return false;\n  } // Chameleons count as word characters as long as they're in a word, so\n  // recurse to see if the next one is a word character or not.\n\n\n  if (CHAMELEON.test(_char3)) {\n    var charDist = getCharacterDistance(remaining, isRTL);\n\n    var _splitByCharacterDist3 = splitByCharacterDistance(remaining, charDist, isRTL),\n        _splitByCharacterDist4 = _slicedToArray(_splitByCharacterDist3, 2),\n        nextChar = _splitByCharacterDist4[0],\n        nextRemaining = _splitByCharacterDist4[1];\n\n    if (isWordCharacter(nextChar, nextRemaining, isRTL)) {\n      return true;\n    }\n  }\n\n  if (PUNCTUATION.test(_char3)) {\n    return false;\n  }\n\n  return true;\n};\n/**\r\n * Iterate on codepoints from right to left.\r\n */\n\n\nvar codepointsIteratorRTL = function* codepointsIteratorRTL(str) {\n  var end = str.length - 1;\n\n  for (var i = 0; i < str.length; i++) {\n    var char1 = str.charAt(end - i);\n\n    if (isLowSurrogate(char1.charCodeAt(0))) {\n      var char2 = str.charAt(end - i - 1);\n\n      if (isHighSurrogate(char2.charCodeAt(0))) {\n        yield char2 + char1;\n        i++;\n        continue;\n      }\n    }\n\n    yield char1;\n  }\n};\n/**\r\n * Is `charCode` a high surrogate.\r\n *\r\n * https://en.wikipedia.org/wiki/Universal_Character_Set_characters#Surrogates\r\n */\n\nvar isHighSurrogate = function isHighSurrogate(charCode) {\n  return charCode >= 0xd800 && charCode <= 0xdbff;\n};\n/**\r\n * Is `charCode` a low surrogate.\r\n *\r\n * https://en.wikipedia.org/wiki/Universal_Character_Set_characters#Surrogates\r\n */\n\n\nvar isLowSurrogate = function isLowSurrogate(charCode) {\n  return charCode >= 0xdc00 && charCode <= 0xdfff;\n};\n\nvar CodepointType;\n\n(function (CodepointType) {\n  CodepointType[CodepointType[\"None\"] = 0] = \"None\";\n  CodepointType[CodepointType[\"Extend\"] = 1] = \"Extend\";\n  CodepointType[CodepointType[\"ZWJ\"] = 2] = \"ZWJ\";\n  CodepointType[CodepointType[\"RI\"] = 4] = \"RI\";\n  CodepointType[CodepointType[\"Prepend\"] = 8] = \"Prepend\";\n  CodepointType[CodepointType[\"SpacingMark\"] = 16] = \"SpacingMark\";\n  CodepointType[CodepointType[\"L\"] = 32] = \"L\";\n  CodepointType[CodepointType[\"V\"] = 64] = \"V\";\n  CodepointType[CodepointType[\"T\"] = 128] = \"T\";\n  CodepointType[CodepointType[\"LV\"] = 256] = \"LV\";\n  CodepointType[CodepointType[\"LVT\"] = 512] = \"LVT\";\n  CodepointType[CodepointType[\"ExtPict\"] = 1024] = \"ExtPict\";\n  CodepointType[CodepointType[\"Any\"] = 2048] = \"Any\";\n})(CodepointType || (CodepointType = {}));\n\nvar reExtend = /^(?:[\\u0300-\\u036F\\u0483-\\u0489\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u0610-\\u061A\\u064B-\\u065F\\u0670\\u06D6-\\u06DC\\u06DF-\\u06E4\\u06E7\\u06E8\\u06EA-\\u06ED\\u0711\\u0730-\\u074A\\u07A6-\\u07B0\\u07EB-\\u07F3\\u07FD\\u0816-\\u0819\\u081B-\\u0823\\u0825-\\u0827\\u0829-\\u082D\\u0859-\\u085B\\u08D3-\\u08E1\\u08E3-\\u0902\\u093A\\u093C\\u0941-\\u0948\\u094D\\u0951-\\u0957\\u0962\\u0963\\u0981\\u09BC\\u09BE\\u09C1-\\u09C4\\u09CD\\u09D7\\u09E2\\u09E3\\u09FE\\u0A01\\u0A02\\u0A3C\\u0A41\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A70\\u0A71\\u0A75\\u0A81\\u0A82\\u0ABC\\u0AC1-\\u0AC5\\u0AC7\\u0AC8\\u0ACD\\u0AE2\\u0AE3\\u0AFA-\\u0AFF\\u0B01\\u0B3C\\u0B3E\\u0B3F\\u0B41-\\u0B44\\u0B4D\\u0B55-\\u0B57\\u0B62\\u0B63\\u0B82\\u0BBE\\u0BC0\\u0BCD\\u0BD7\\u0C00\\u0C04\\u0C3E-\\u0C40\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C62\\u0C63\\u0C81\\u0CBC\\u0CBF\\u0CC2\\u0CC6\\u0CCC\\u0CCD\\u0CD5\\u0CD6\\u0CE2\\u0CE3\\u0D00\\u0D01\\u0D3B\\u0D3C\\u0D3E\\u0D41-\\u0D44\\u0D4D\\u0D57\\u0D62\\u0D63\\u0D81\\u0DCA\\u0DCF\\u0DD2-\\u0DD4\\u0DD6\\u0DDF\\u0E31\\u0E34-\\u0E3A\\u0E47-\\u0E4E\\u0EB1\\u0EB4-\\u0EBC\\u0EC8-\\u0ECD\\u0F18\\u0F19\\u0F35\\u0F37\\u0F39\\u0F71-\\u0F7E\\u0F80-\\u0F84\\u0F86\\u0F87\\u0F8D-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u102D-\\u1030\\u1032-\\u1037\\u1039\\u103A\\u103D\\u103E\\u1058\\u1059\\u105E-\\u1060\\u1071-\\u1074\\u1082\\u1085\\u1086\\u108D\\u109D\\u135D-\\u135F\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17B4\\u17B5\\u17B7-\\u17BD\\u17C6\\u17C9-\\u17D3\\u17DD\\u180B-\\u180D\\u1885\\u1886\\u18A9\\u1920-\\u1922\\u1927\\u1928\\u1932\\u1939-\\u193B\\u1A17\\u1A18\\u1A1B\\u1A56\\u1A58-\\u1A5E\\u1A60\\u1A62\\u1A65-\\u1A6C\\u1A73-\\u1A7C\\u1A7F\\u1AB0-\\u1AC0\\u1B00-\\u1B03\\u1B34-\\u1B3A\\u1B3C\\u1B42\\u1B6B-\\u1B73\\u1B80\\u1B81\\u1BA2-\\u1BA5\\u1BA8\\u1BA9\\u1BAB-\\u1BAD\\u1BE6\\u1BE8\\u1BE9\\u1BED\\u1BEF-\\u1BF1\\u1C2C-\\u1C33\\u1C36\\u1C37\\u1CD0-\\u1CD2\\u1CD4-\\u1CE0\\u1CE2-\\u1CE8\\u1CED\\u1CF4\\u1CF8\\u1CF9\\u1DC0-\\u1DF9\\u1DFB-\\u1DFF\\u200C\\u20D0-\\u20F0\\u2CEF-\\u2CF1\\u2D7F\\u2DE0-\\u2DFF\\u302A-\\u302F\\u3099\\u309A\\uA66F-\\uA672\\uA674-\\uA67D\\uA69E\\uA69F\\uA6F0\\uA6F1\\uA802\\uA806\\uA80B\\uA825\\uA826\\uA82C\\uA8C4\\uA8C5\\uA8E0-\\uA8F1\\uA8FF\\uA926-\\uA92D\\uA947-\\uA951\\uA980-\\uA982\\uA9B3\\uA9B6-\\uA9B9\\uA9BC\\uA9BD\\uA9E5\\uAA29-\\uAA2E\\uAA31\\uAA32\\uAA35\\uAA36\\uAA43\\uAA4C\\uAA7C\\uAAB0\\uAAB2-\\uAAB4\\uAAB7\\uAAB8\\uAABE\\uAABF\\uAAC1\\uAAEC\\uAAED\\uAAF6\\uABE5\\uABE8\\uABED\\uFB1E\\uFE00-\\uFE0F\\uFE20-\\uFE2F\\uFF9E\\uFF9F]|\\uD800[\\uDDFD\\uDEE0\\uDF76-\\uDF7A]|\\uD802[\\uDE01-\\uDE03\\uDE05\\uDE06\\uDE0C-\\uDE0F\\uDE38-\\uDE3A\\uDE3F\\uDEE5\\uDEE6]|\\uD803[\\uDD24-\\uDD27\\uDEAB\\uDEAC\\uDF46-\\uDF50]|\\uD804[\\uDC01\\uDC38-\\uDC46\\uDC7F-\\uDC81\\uDCB3-\\uDCB6\\uDCB9\\uDCBA\\uDD00-\\uDD02\\uDD27-\\uDD2B\\uDD2D-\\uDD34\\uDD73\\uDD80\\uDD81\\uDDB6-\\uDDBE\\uDDC9-\\uDDCC\\uDDCF\\uDE2F-\\uDE31\\uDE34\\uDE36\\uDE37\\uDE3E\\uDEDF\\uDEE3-\\uDEEA\\uDF00\\uDF01\\uDF3B\\uDF3C\\uDF3E\\uDF40\\uDF57\\uDF66-\\uDF6C\\uDF70-\\uDF74]|\\uD805[\\uDC38-\\uDC3F\\uDC42-\\uDC44\\uDC46\\uDC5E\\uDCB0\\uDCB3-\\uDCB8\\uDCBA\\uDCBD\\uDCBF\\uDCC0\\uDCC2\\uDCC3\\uDDAF\\uDDB2-\\uDDB5\\uDDBC\\uDDBD\\uDDBF\\uDDC0\\uDDDC\\uDDDD\\uDE33-\\uDE3A\\uDE3D\\uDE3F\\uDE40\\uDEAB\\uDEAD\\uDEB0-\\uDEB5\\uDEB7\\uDF1D-\\uDF1F\\uDF22-\\uDF25\\uDF27-\\uDF2B]|\\uD806[\\uDC2F-\\uDC37\\uDC39\\uDC3A\\uDD30\\uDD3B\\uDD3C\\uDD3E\\uDD43\\uDDD4-\\uDDD7\\uDDDA\\uDDDB\\uDDE0\\uDE01-\\uDE0A\\uDE33-\\uDE38\\uDE3B-\\uDE3E\\uDE47\\uDE51-\\uDE56\\uDE59-\\uDE5B\\uDE8A-\\uDE96\\uDE98\\uDE99]|\\uD807[\\uDC30-\\uDC36\\uDC38-\\uDC3D\\uDC3F\\uDC92-\\uDCA7\\uDCAA-\\uDCB0\\uDCB2\\uDCB3\\uDCB5\\uDCB6\\uDD31-\\uDD36\\uDD3A\\uDD3C\\uDD3D\\uDD3F-\\uDD45\\uDD47\\uDD90\\uDD91\\uDD95\\uDD97\\uDEF3\\uDEF4]|\\uD81A[\\uDEF0-\\uDEF4\\uDF30-\\uDF36]|\\uD81B[\\uDF4F\\uDF8F-\\uDF92\\uDFE4]|\\uD82F[\\uDC9D\\uDC9E]|\\uD834[\\uDD65\\uDD67-\\uDD69\\uDD6E-\\uDD72\\uDD7B-\\uDD82\\uDD85-\\uDD8B\\uDDAA-\\uDDAD\\uDE42-\\uDE44]|\\uD836[\\uDE00-\\uDE36\\uDE3B-\\uDE6C\\uDE75\\uDE84\\uDE9B-\\uDE9F\\uDEA1-\\uDEAF]|\\uD838[\\uDC00-\\uDC06\\uDC08-\\uDC18\\uDC1B-\\uDC21\\uDC23\\uDC24\\uDC26-\\uDC2A\\uDD30-\\uDD36\\uDEEC-\\uDEEF]|\\uD83A[\\uDCD0-\\uDCD6\\uDD44-\\uDD4A]|\\uD83C[\\uDFFB-\\uDFFF]|\\uDB40[\\uDC20-\\uDC7F\\uDD00-\\uDDEF])$/;\nvar rePrepend = /^(?:[\\u0600-\\u0605\\u06DD\\u070F\\u0890\\u0891\\u08E2\\u0D4E]|\\uD804[\\uDCBD\\uDCCD\\uDDC2\\uDDC3]|\\uD806[\\uDD3F\\uDD41\\uDE3A\\uDE84-\\uDE89]|\\uD807\\uDD46)$/;\nvar reSpacingMark = /^(?:[\\u0903\\u093B\\u093E-\\u0940\\u0949-\\u094C\\u094E\\u094F\\u0982\\u0983\\u09BF\\u09C0\\u09C7\\u09C8\\u09CB\\u09CC\\u0A03\\u0A3E-\\u0A40\\u0A83\\u0ABE-\\u0AC0\\u0AC9\\u0ACB\\u0ACC\\u0B02\\u0B03\\u0B40\\u0B47\\u0B48\\u0B4B\\u0B4C\\u0BBF\\u0BC1\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCC\\u0C01-\\u0C03\\u0C41-\\u0C44\\u0C82\\u0C83\\u0CBE\\u0CC0\\u0CC1\\u0CC3\\u0CC4\\u0CC7\\u0CC8\\u0CCA\\u0CCB\\u0D02\\u0D03\\u0D3F\\u0D40\\u0D46-\\u0D48\\u0D4A-\\u0D4C\\u0D82\\u0D83\\u0DD0\\u0DD1\\u0DD8-\\u0DDE\\u0DF2\\u0DF3\\u0E33\\u0EB3\\u0F3E\\u0F3F\\u0F7F\\u1031\\u103B\\u103C\\u1056\\u1057\\u1084\\u1715\\u1734\\u17B6\\u17BE-\\u17C5\\u17C7\\u17C8\\u1923-\\u1926\\u1929-\\u192B\\u1930\\u1931\\u1933-\\u1938\\u1A19\\u1A1A\\u1A55\\u1A57\\u1A6D-\\u1A72\\u1B04\\u1B3B\\u1B3D-\\u1B41\\u1B43\\u1B44\\u1B82\\u1BA1\\u1BA6\\u1BA7\\u1BAA\\u1BE7\\u1BEA-\\u1BEC\\u1BEE\\u1BF2\\u1BF3\\u1C24-\\u1C2B\\u1C34\\u1C35\\u1CE1\\u1CF7\\uA823\\uA824\\uA827\\uA880\\uA881\\uA8B4-\\uA8C3\\uA952\\uA953\\uA983\\uA9B4\\uA9B5\\uA9BA\\uA9BB\\uA9BE-\\uA9C0\\uAA2F\\uAA30\\uAA33\\uAA34\\uAA4D\\uAAEB\\uAAEE\\uAAEF\\uAAF5\\uABE3\\uABE4\\uABE6\\uABE7\\uABE9\\uABEA\\uABEC]|\\uD804[\\uDC00\\uDC02\\uDC82\\uDCB0-\\uDCB2\\uDCB7\\uDCB8\\uDD2C\\uDD45\\uDD46\\uDD82\\uDDB3-\\uDDB5\\uDDBF\\uDDC0\\uDDCE\\uDE2C-\\uDE2E\\uDE32\\uDE33\\uDE35\\uDEE0-\\uDEE2\\uDF02\\uDF03\\uDF3F\\uDF41-\\uDF44\\uDF47\\uDF48\\uDF4B-\\uDF4D\\uDF62\\uDF63]|\\uD805[\\uDC35-\\uDC37\\uDC40\\uDC41\\uDC45\\uDCB1\\uDCB2\\uDCB9\\uDCBB\\uDCBC\\uDCBE\\uDCC1\\uDDB0\\uDDB1\\uDDB8-\\uDDBB\\uDDBE\\uDE30-\\uDE32\\uDE3B\\uDE3C\\uDE3E\\uDEAC\\uDEAE\\uDEAF\\uDEB6\\uDF26]|\\uD806[\\uDC2C-\\uDC2E\\uDC38\\uDD31-\\uDD35\\uDD37\\uDD38\\uDD3D\\uDD40\\uDD42\\uDDD1-\\uDDD3\\uDDDC-\\uDDDF\\uDDE4\\uDE39\\uDE57\\uDE58\\uDE97]|\\uD807[\\uDC2F\\uDC3E\\uDCA9\\uDCB1\\uDCB4\\uDD8A-\\uDD8E\\uDD93\\uDD94\\uDD96\\uDEF5\\uDEF6]|\\uD81B[\\uDF51-\\uDF87\\uDFF0\\uDFF1]|\\uD834[\\uDD66\\uDD6D])$/;\nvar reL = /^[\\u1100-\\u115F\\uA960-\\uA97C]$/;\nvar reV = /^[\\u1160-\\u11A7\\uD7B0-\\uD7C6]$/;\nvar reT = /^[\\u11A8-\\u11FF\\uD7CB-\\uD7FB]$/;\nvar reLV = /^[\\uAC00\\uAC1C\\uAC38\\uAC54\\uAC70\\uAC8C\\uACA8\\uACC4\\uACE0\\uACFC\\uAD18\\uAD34\\uAD50\\uAD6C\\uAD88\\uADA4\\uADC0\\uADDC\\uADF8\\uAE14\\uAE30\\uAE4C\\uAE68\\uAE84\\uAEA0\\uAEBC\\uAED8\\uAEF4\\uAF10\\uAF2C\\uAF48\\uAF64\\uAF80\\uAF9C\\uAFB8\\uAFD4\\uAFF0\\uB00C\\uB028\\uB044\\uB060\\uB07C\\uB098\\uB0B4\\uB0D0\\uB0EC\\uB108\\uB124\\uB140\\uB15C\\uB178\\uB194\\uB1B0\\uB1CC\\uB1E8\\uB204\\uB220\\uB23C\\uB258\\uB274\\uB290\\uB2AC\\uB2C8\\uB2E4\\uB300\\uB31C\\uB338\\uB354\\uB370\\uB38C\\uB3A8\\uB3C4\\uB3E0\\uB3FC\\uB418\\uB434\\uB450\\uB46C\\uB488\\uB4A4\\uB4C0\\uB4DC\\uB4F8\\uB514\\uB530\\uB54C\\uB568\\uB584\\uB5A0\\uB5BC\\uB5D8\\uB5F4\\uB610\\uB62C\\uB648\\uB664\\uB680\\uB69C\\uB6B8\\uB6D4\\uB6F0\\uB70C\\uB728\\uB744\\uB760\\uB77C\\uB798\\uB7B4\\uB7D0\\uB7EC\\uB808\\uB824\\uB840\\uB85C\\uB878\\uB894\\uB8B0\\uB8CC\\uB8E8\\uB904\\uB920\\uB93C\\uB958\\uB974\\uB990\\uB9AC\\uB9C8\\uB9E4\\uBA00\\uBA1C\\uBA38\\uBA54\\uBA70\\uBA8C\\uBAA8\\uBAC4\\uBAE0\\uBAFC\\uBB18\\uBB34\\uBB50\\uBB6C\\uBB88\\uBBA4\\uBBC0\\uBBDC\\uBBF8\\uBC14\\uBC30\\uBC4C\\uBC68\\uBC84\\uBCA0\\uBCBC\\uBCD8\\uBCF4\\uBD10\\uBD2C\\uBD48\\uBD64\\uBD80\\uBD9C\\uBDB8\\uBDD4\\uBDF0\\uBE0C\\uBE28\\uBE44\\uBE60\\uBE7C\\uBE98\\uBEB4\\uBED0\\uBEEC\\uBF08\\uBF24\\uBF40\\uBF5C\\uBF78\\uBF94\\uBFB0\\uBFCC\\uBFE8\\uC004\\uC020\\uC03C\\uC058\\uC074\\uC090\\uC0AC\\uC0C8\\uC0E4\\uC100\\uC11C\\uC138\\uC154\\uC170\\uC18C\\uC1A8\\uC1C4\\uC1E0\\uC1FC\\uC218\\uC234\\uC250\\uC26C\\uC288\\uC2A4\\uC2C0\\uC2DC\\uC2F8\\uC314\\uC330\\uC34C\\uC368\\uC384\\uC3A0\\uC3BC\\uC3D8\\uC3F4\\uC410\\uC42C\\uC448\\uC464\\uC480\\uC49C\\uC4B8\\uC4D4\\uC4F0\\uC50C\\uC528\\uC544\\uC560\\uC57C\\uC598\\uC5B4\\uC5D0\\uC5EC\\uC608\\uC624\\uC640\\uC65C\\uC678\\uC694\\uC6B0\\uC6CC\\uC6E8\\uC704\\uC720\\uC73C\\uC758\\uC774\\uC790\\uC7AC\\uC7C8\\uC7E4\\uC800\\uC81C\\uC838\\uC854\\uC870\\uC88C\\uC8A8\\uC8C4\\uC8E0\\uC8FC\\uC918\\uC934\\uC950\\uC96C\\uC988\\uC9A4\\uC9C0\\uC9DC\\uC9F8\\uCA14\\uCA30\\uCA4C\\uCA68\\uCA84\\uCAA0\\uCABC\\uCAD8\\uCAF4\\uCB10\\uCB2C\\uCB48\\uCB64\\uCB80\\uCB9C\\uCBB8\\uCBD4\\uCBF0\\uCC0C\\uCC28\\uCC44\\uCC60\\uCC7C\\uCC98\\uCCB4\\uCCD0\\uCCEC\\uCD08\\uCD24\\uCD40\\uCD5C\\uCD78\\uCD94\\uCDB0\\uCDCC\\uCDE8\\uCE04\\uCE20\\uCE3C\\uCE58\\uCE74\\uCE90\\uCEAC\\uCEC8\\uCEE4\\uCF00\\uCF1C\\uCF38\\uCF54\\uCF70\\uCF8C\\uCFA8\\uCFC4\\uCFE0\\uCFFC\\uD018\\uD034\\uD050\\uD06C\\uD088\\uD0A4\\uD0C0\\uD0DC\\uD0F8\\uD114\\uD130\\uD14C\\uD168\\uD184\\uD1A0\\uD1BC\\uD1D8\\uD1F4\\uD210\\uD22C\\uD248\\uD264\\uD280\\uD29C\\uD2B8\\uD2D4\\uD2F0\\uD30C\\uD328\\uD344\\uD360\\uD37C\\uD398\\uD3B4\\uD3D0\\uD3EC\\uD408\\uD424\\uD440\\uD45C\\uD478\\uD494\\uD4B0\\uD4CC\\uD4E8\\uD504\\uD520\\uD53C\\uD558\\uD574\\uD590\\uD5AC\\uD5C8\\uD5E4\\uD600\\uD61C\\uD638\\uD654\\uD670\\uD68C\\uD6A8\\uD6C4\\uD6E0\\uD6FC\\uD718\\uD734\\uD750\\uD76C\\uD788]$/;\nvar reLVT = /^[\\uAC01-\\uAC1B\\uAC1D-\\uAC37\\uAC39-\\uAC53\\uAC55-\\uAC6F\\uAC71-\\uAC8B\\uAC8D-\\uACA7\\uACA9-\\uACC3\\uACC5-\\uACDF\\uACE1-\\uACFB\\uACFD-\\uAD17\\uAD19-\\uAD33\\uAD35-\\uAD4F\\uAD51-\\uAD6B\\uAD6D-\\uAD87\\uAD89-\\uADA3\\uADA5-\\uADBF\\uADC1-\\uADDB\\uADDD-\\uADF7\\uADF9-\\uAE13\\uAE15-\\uAE2F\\uAE31-\\uAE4B\\uAE4D-\\uAE67\\uAE69-\\uAE83\\uAE85-\\uAE9F\\uAEA1-\\uAEBB\\uAEBD-\\uAED7\\uAED9-\\uAEF3\\uAEF5-\\uAF0F\\uAF11-\\uAF2B\\uAF2D-\\uAF47\\uAF49-\\uAF63\\uAF65-\\uAF7F\\uAF81-\\uAF9B\\uAF9D-\\uAFB7\\uAFB9-\\uAFD3\\uAFD5-\\uAFEF\\uAFF1-\\uB00B\\uB00D-\\uB027\\uB029-\\uB043\\uB045-\\uB05F\\uB061-\\uB07B\\uB07D-\\uB097\\uB099-\\uB0B3\\uB0B5-\\uB0CF\\uB0D1-\\uB0EB\\uB0ED-\\uB107\\uB109-\\uB123\\uB125-\\uB13F\\uB141-\\uB15B\\uB15D-\\uB177\\uB179-\\uB193\\uB195-\\uB1AF\\uB1B1-\\uB1CB\\uB1CD-\\uB1E7\\uB1E9-\\uB203\\uB205-\\uB21F\\uB221-\\uB23B\\uB23D-\\uB257\\uB259-\\uB273\\uB275-\\uB28F\\uB291-\\uB2AB\\uB2AD-\\uB2C7\\uB2C9-\\uB2E3\\uB2E5-\\uB2FF\\uB301-\\uB31B\\uB31D-\\uB337\\uB339-\\uB353\\uB355-\\uB36F\\uB371-\\uB38B\\uB38D-\\uB3A7\\uB3A9-\\uB3C3\\uB3C5-\\uB3DF\\uB3E1-\\uB3FB\\uB3FD-\\uB417\\uB419-\\uB433\\uB435-\\uB44F\\uB451-\\uB46B\\uB46D-\\uB487\\uB489-\\uB4A3\\uB4A5-\\uB4BF\\uB4C1-\\uB4DB\\uB4DD-\\uB4F7\\uB4F9-\\uB513\\uB515-\\uB52F\\uB531-\\uB54B\\uB54D-\\uB567\\uB569-\\uB583\\uB585-\\uB59F\\uB5A1-\\uB5BB\\uB5BD-\\uB5D7\\uB5D9-\\uB5F3\\uB5F5-\\uB60F\\uB611-\\uB62B\\uB62D-\\uB647\\uB649-\\uB663\\uB665-\\uB67F\\uB681-\\uB69B\\uB69D-\\uB6B7\\uB6B9-\\uB6D3\\uB6D5-\\uB6EF\\uB6F1-\\uB70B\\uB70D-\\uB727\\uB729-\\uB743\\uB745-\\uB75F\\uB761-\\uB77B\\uB77D-\\uB797\\uB799-\\uB7B3\\uB7B5-\\uB7CF\\uB7D1-\\uB7EB\\uB7ED-\\uB807\\uB809-\\uB823\\uB825-\\uB83F\\uB841-\\uB85B\\uB85D-\\uB877\\uB879-\\uB893\\uB895-\\uB8AF\\uB8B1-\\uB8CB\\uB8CD-\\uB8E7\\uB8E9-\\uB903\\uB905-\\uB91F\\uB921-\\uB93B\\uB93D-\\uB957\\uB959-\\uB973\\uB975-\\uB98F\\uB991-\\uB9AB\\uB9AD-\\uB9C7\\uB9C9-\\uB9E3\\uB9E5-\\uB9FF\\uBA01-\\uBA1B\\uBA1D-\\uBA37\\uBA39-\\uBA53\\uBA55-\\uBA6F\\uBA71-\\uBA8B\\uBA8D-\\uBAA7\\uBAA9-\\uBAC3\\uBAC5-\\uBADF\\uBAE1-\\uBAFB\\uBAFD-\\uBB17\\uBB19-\\uBB33\\uBB35-\\uBB4F\\uBB51-\\uBB6B\\uBB6D-\\uBB87\\uBB89-\\uBBA3\\uBBA5-\\uBBBF\\uBBC1-\\uBBDB\\uBBDD-\\uBBF7\\uBBF9-\\uBC13\\uBC15-\\uBC2F\\uBC31-\\uBC4B\\uBC4D-\\uBC67\\uBC69-\\uBC83\\uBC85-\\uBC9F\\uBCA1-\\uBCBB\\uBCBD-\\uBCD7\\uBCD9-\\uBCF3\\uBCF5-\\uBD0F\\uBD11-\\uBD2B\\uBD2D-\\uBD47\\uBD49-\\uBD63\\uBD65-\\uBD7F\\uBD81-\\uBD9B\\uBD9D-\\uBDB7\\uBDB9-\\uBDD3\\uBDD5-\\uBDEF\\uBDF1-\\uBE0B\\uBE0D-\\uBE27\\uBE29-\\uBE43\\uBE45-\\uBE5F\\uBE61-\\uBE7B\\uBE7D-\\uBE97\\uBE99-\\uBEB3\\uBEB5-\\uBECF\\uBED1-\\uBEEB\\uBEED-\\uBF07\\uBF09-\\uBF23\\uBF25-\\uBF3F\\uBF41-\\uBF5B\\uBF5D-\\uBF77\\uBF79-\\uBF93\\uBF95-\\uBFAF\\uBFB1-\\uBFCB\\uBFCD-\\uBFE7\\uBFE9-\\uC003\\uC005-\\uC01F\\uC021-\\uC03B\\uC03D-\\uC057\\uC059-\\uC073\\uC075-\\uC08F\\uC091-\\uC0AB\\uC0AD-\\uC0C7\\uC0C9-\\uC0E3\\uC0E5-\\uC0FF\\uC101-\\uC11B\\uC11D-\\uC137\\uC139-\\uC153\\uC155-\\uC16F\\uC171-\\uC18B\\uC18D-\\uC1A7\\uC1A9-\\uC1C3\\uC1C5-\\uC1DF\\uC1E1-\\uC1FB\\uC1FD-\\uC217\\uC219-\\uC233\\uC235-\\uC24F\\uC251-\\uC26B\\uC26D-\\uC287\\uC289-\\uC2A3\\uC2A5-\\uC2BF\\uC2C1-\\uC2DB\\uC2DD-\\uC2F7\\uC2F9-\\uC313\\uC315-\\uC32F\\uC331-\\uC34B\\uC34D-\\uC367\\uC369-\\uC383\\uC385-\\uC39F\\uC3A1-\\uC3BB\\uC3BD-\\uC3D7\\uC3D9-\\uC3F3\\uC3F5-\\uC40F\\uC411-\\uC42B\\uC42D-\\uC447\\uC449-\\uC463\\uC465-\\uC47F\\uC481-\\uC49B\\uC49D-\\uC4B7\\uC4B9-\\uC4D3\\uC4D5-\\uC4EF\\uC4F1-\\uC50B\\uC50D-\\uC527\\uC529-\\uC543\\uC545-\\uC55F\\uC561-\\uC57B\\uC57D-\\uC597\\uC599-\\uC5B3\\uC5B5-\\uC5CF\\uC5D1-\\uC5EB\\uC5ED-\\uC607\\uC609-\\uC623\\uC625-\\uC63F\\uC641-\\uC65B\\uC65D-\\uC677\\uC679-\\uC693\\uC695-\\uC6AF\\uC6B1-\\uC6CB\\uC6CD-\\uC6E7\\uC6E9-\\uC703\\uC705-\\uC71F\\uC721-\\uC73B\\uC73D-\\uC757\\uC759-\\uC773\\uC775-\\uC78F\\uC791-\\uC7AB\\uC7AD-\\uC7C7\\uC7C9-\\uC7E3\\uC7E5-\\uC7FF\\uC801-\\uC81B\\uC81D-\\uC837\\uC839-\\uC853\\uC855-\\uC86F\\uC871-\\uC88B\\uC88D-\\uC8A7\\uC8A9-\\uC8C3\\uC8C5-\\uC8DF\\uC8E1-\\uC8FB\\uC8FD-\\uC917\\uC919-\\uC933\\uC935-\\uC94F\\uC951-\\uC96B\\uC96D-\\uC987\\uC989-\\uC9A3\\uC9A5-\\uC9BF\\uC9C1-\\uC9DB\\uC9DD-\\uC9F7\\uC9F9-\\uCA13\\uCA15-\\uCA2F\\uCA31-\\uCA4B\\uCA4D-\\uCA67\\uCA69-\\uCA83\\uCA85-\\uCA9F\\uCAA1-\\uCABB\\uCABD-\\uCAD7\\uCAD9-\\uCAF3\\uCAF5-\\uCB0F\\uCB11-\\uCB2B\\uCB2D-\\uCB47\\uCB49-\\uCB63\\uCB65-\\uCB7F\\uCB81-\\uCB9B\\uCB9D-\\uCBB7\\uCBB9-\\uCBD3\\uCBD5-\\uCBEF\\uCBF1-\\uCC0B\\uCC0D-\\uCC27\\uCC29-\\uCC43\\uCC45-\\uCC5F\\uCC61-\\uCC7B\\uCC7D-\\uCC97\\uCC99-\\uCCB3\\uCCB5-\\uCCCF\\uCCD1-\\uCCEB\\uCCED-\\uCD07\\uCD09-\\uCD23\\uCD25-\\uCD3F\\uCD41-\\uCD5B\\uCD5D-\\uCD77\\uCD79-\\uCD93\\uCD95-\\uCDAF\\uCDB1-\\uCDCB\\uCDCD-\\uCDE7\\uCDE9-\\uCE03\\uCE05-\\uCE1F\\uCE21-\\uCE3B\\uCE3D-\\uCE57\\uCE59-\\uCE73\\uCE75-\\uCE8F\\uCE91-\\uCEAB\\uCEAD-\\uCEC7\\uCEC9-\\uCEE3\\uCEE5-\\uCEFF\\uCF01-\\uCF1B\\uCF1D-\\uCF37\\uCF39-\\uCF53\\uCF55-\\uCF6F\\uCF71-\\uCF8B\\uCF8D-\\uCFA7\\uCFA9-\\uCFC3\\uCFC5-\\uCFDF\\uCFE1-\\uCFFB\\uCFFD-\\uD017\\uD019-\\uD033\\uD035-\\uD04F\\uD051-\\uD06B\\uD06D-\\uD087\\uD089-\\uD0A3\\uD0A5-\\uD0BF\\uD0C1-\\uD0DB\\uD0DD-\\uD0F7\\uD0F9-\\uD113\\uD115-\\uD12F\\uD131-\\uD14B\\uD14D-\\uD167\\uD169-\\uD183\\uD185-\\uD19F\\uD1A1-\\uD1BB\\uD1BD-\\uD1D7\\uD1D9-\\uD1F3\\uD1F5-\\uD20F\\uD211-\\uD22B\\uD22D-\\uD247\\uD249-\\uD263\\uD265-\\uD27F\\uD281-\\uD29B\\uD29D-\\uD2B7\\uD2B9-\\uD2D3\\uD2D5-\\uD2EF\\uD2F1-\\uD30B\\uD30D-\\uD327\\uD329-\\uD343\\uD345-\\uD35F\\uD361-\\uD37B\\uD37D-\\uD397\\uD399-\\uD3B3\\uD3B5-\\uD3CF\\uD3D1-\\uD3EB\\uD3ED-\\uD407\\uD409-\\uD423\\uD425-\\uD43F\\uD441-\\uD45B\\uD45D-\\uD477\\uD479-\\uD493\\uD495-\\uD4AF\\uD4B1-\\uD4CB\\uD4CD-\\uD4E7\\uD4E9-\\uD503\\uD505-\\uD51F\\uD521-\\uD53B\\uD53D-\\uD557\\uD559-\\uD573\\uD575-\\uD58F\\uD591-\\uD5AB\\uD5AD-\\uD5C7\\uD5C9-\\uD5E3\\uD5E5-\\uD5FF\\uD601-\\uD61B\\uD61D-\\uD637\\uD639-\\uD653\\uD655-\\uD66F\\uD671-\\uD68B\\uD68D-\\uD6A7\\uD6A9-\\uD6C3\\uD6C5-\\uD6DF\\uD6E1-\\uD6FB\\uD6FD-\\uD717\\uD719-\\uD733\\uD735-\\uD74F\\uD751-\\uD76B\\uD76D-\\uD787\\uD789-\\uD7A3]$/;\nvar reExtPict = /^(?:[\\xA9\\xAE\\u203C\\u2049\\u2122\\u2139\\u2194-\\u2199\\u21A9\\u21AA\\u231A\\u231B\\u2328\\u2388\\u23CF\\u23E9-\\u23F3\\u23F8-\\u23FA\\u24C2\\u25AA\\u25AB\\u25B6\\u25C0\\u25FB-\\u25FE\\u2600-\\u2605\\u2607-\\u2612\\u2614-\\u2685\\u2690-\\u2705\\u2708-\\u2712\\u2714\\u2716\\u271D\\u2721\\u2728\\u2733\\u2734\\u2744\\u2747\\u274C\\u274E\\u2753-\\u2755\\u2757\\u2763-\\u2767\\u2795-\\u2797\\u27A1\\u27B0\\u27BF\\u2934\\u2935\\u2B05-\\u2B07\\u2B1B\\u2B1C\\u2B50\\u2B55\\u3030\\u303D\\u3297\\u3299]|\\uD83C[\\uDC00-\\uDCFF\\uDD0D-\\uDD0F\\uDD2F\\uDD6C-\\uDD71\\uDD7E\\uDD7F\\uDD8E\\uDD91-\\uDD9A\\uDDAD-\\uDDE5\\uDE01-\\uDE0F\\uDE1A\\uDE2F\\uDE32-\\uDE3A\\uDE3C-\\uDE3F\\uDE49-\\uDFFA]|\\uD83D[\\uDC00-\\uDD3D\\uDD46-\\uDE4F\\uDE80-\\uDEFF\\uDF74-\\uDF7F\\uDFD5-\\uDFFF]|\\uD83E[\\uDC0C-\\uDC0F\\uDC48-\\uDC4F\\uDC5A-\\uDC5F\\uDC88-\\uDC8F\\uDCAE-\\uDCFF\\uDD0C-\\uDD3A\\uDD3C-\\uDD45\\uDD47-\\uDEFF]|\\uD83F[\\uDC00-\\uDFFD])$/;\n\nvar getCodepointType = function getCodepointType(_char4, code) {\n  var type = CodepointType.Any;\n\n  if (_char4.search(reExtend) !== -1) {\n    type |= CodepointType.Extend;\n  }\n\n  if (code === 0x200d) {\n    type |= CodepointType.ZWJ;\n  }\n\n  if (code >= 0x1f1e6 && code <= 0x1f1ff) {\n    type |= CodepointType.RI;\n  }\n\n  if (_char4.search(rePrepend) !== -1) {\n    type |= CodepointType.Prepend;\n  }\n\n  if (_char4.search(reSpacingMark) !== -1) {\n    type |= CodepointType.SpacingMark;\n  }\n\n  if (_char4.search(reL) !== -1) {\n    type |= CodepointType.L;\n  }\n\n  if (_char4.search(reV) !== -1) {\n    type |= CodepointType.V;\n  }\n\n  if (_char4.search(reT) !== -1) {\n    type |= CodepointType.T;\n  }\n\n  if (_char4.search(reLV) !== -1) {\n    type |= CodepointType.LV;\n  }\n\n  if (_char4.search(reLVT) !== -1) {\n    type |= CodepointType.LVT;\n  }\n\n  if (_char4.search(reExtPict) !== -1) {\n    type |= CodepointType.ExtPict;\n  }\n\n  return type;\n};\n\nfunction intersects(x, y) {\n  return (x & y) !== 0;\n}\n\nvar NonBoundaryPairs = [// GB6\n[CodepointType.L, CodepointType.L | CodepointType.V | CodepointType.LV | CodepointType.LVT], // GB7\n[CodepointType.LV | CodepointType.V, CodepointType.V | CodepointType.T], // GB8\n[CodepointType.LVT | CodepointType.T, CodepointType.T], // GB9\n[CodepointType.Any, CodepointType.Extend | CodepointType.ZWJ], // GB9a\n[CodepointType.Any, CodepointType.SpacingMark], // GB9b\n[CodepointType.Prepend, CodepointType.Any], // GB11\n[CodepointType.ZWJ, CodepointType.ExtPict], // GB12 and GB13\n[CodepointType.RI, CodepointType.RI]];\n\nfunction isBoundaryPair(left, right) {\n  return NonBoundaryPairs.findIndex(function (r) {\n    return intersects(left, r[0]) && intersects(right, r[1]);\n  }) === -1;\n}\n\nvar endingEmojiZWJ = /(?:[\\xA9\\xAE\\u203C\\u2049\\u2122\\u2139\\u2194-\\u2199\\u21A9\\u21AA\\u231A\\u231B\\u2328\\u2388\\u23CF\\u23E9-\\u23F3\\u23F8-\\u23FA\\u24C2\\u25AA\\u25AB\\u25B6\\u25C0\\u25FB-\\u25FE\\u2600-\\u2605\\u2607-\\u2612\\u2614-\\u2685\\u2690-\\u2705\\u2708-\\u2712\\u2714\\u2716\\u271D\\u2721\\u2728\\u2733\\u2734\\u2744\\u2747\\u274C\\u274E\\u2753-\\u2755\\u2757\\u2763-\\u2767\\u2795-\\u2797\\u27A1\\u27B0\\u27BF\\u2934\\u2935\\u2B05-\\u2B07\\u2B1B\\u2B1C\\u2B50\\u2B55\\u3030\\u303D\\u3297\\u3299]|\\uD83C[\\uDC00-\\uDCFF\\uDD0D-\\uDD0F\\uDD2F\\uDD6C-\\uDD71\\uDD7E\\uDD7F\\uDD8E\\uDD91-\\uDD9A\\uDDAD-\\uDDE5\\uDE01-\\uDE0F\\uDE1A\\uDE2F\\uDE32-\\uDE3A\\uDE3C-\\uDE3F\\uDE49-\\uDFFA]|\\uD83D[\\uDC00-\\uDD3D\\uDD46-\\uDE4F\\uDE80-\\uDEFF\\uDF74-\\uDF7F\\uDFD5-\\uDFFF]|\\uD83E[\\uDC0C-\\uDC0F\\uDC48-\\uDC4F\\uDC5A-\\uDC5F\\uDC88-\\uDC8F\\uDCAE-\\uDCFF\\uDD0C-\\uDD3A\\uDD3C-\\uDD45\\uDD47-\\uDEFF]|\\uD83F[\\uDC00-\\uDFFD])(?:[\\u0300-\\u036F\\u0483-\\u0489\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u0610-\\u061A\\u064B-\\u065F\\u0670\\u06D6-\\u06DC\\u06DF-\\u06E4\\u06E7\\u06E8\\u06EA-\\u06ED\\u0711\\u0730-\\u074A\\u07A6-\\u07B0\\u07EB-\\u07F3\\u07FD\\u0816-\\u0819\\u081B-\\u0823\\u0825-\\u0827\\u0829-\\u082D\\u0859-\\u085B\\u08D3-\\u08E1\\u08E3-\\u0902\\u093A\\u093C\\u0941-\\u0948\\u094D\\u0951-\\u0957\\u0962\\u0963\\u0981\\u09BC\\u09BE\\u09C1-\\u09C4\\u09CD\\u09D7\\u09E2\\u09E3\\u09FE\\u0A01\\u0A02\\u0A3C\\u0A41\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A70\\u0A71\\u0A75\\u0A81\\u0A82\\u0ABC\\u0AC1-\\u0AC5\\u0AC7\\u0AC8\\u0ACD\\u0AE2\\u0AE3\\u0AFA-\\u0AFF\\u0B01\\u0B3C\\u0B3E\\u0B3F\\u0B41-\\u0B44\\u0B4D\\u0B55-\\u0B57\\u0B62\\u0B63\\u0B82\\u0BBE\\u0BC0\\u0BCD\\u0BD7\\u0C00\\u0C04\\u0C3E-\\u0C40\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C62\\u0C63\\u0C81\\u0CBC\\u0CBF\\u0CC2\\u0CC6\\u0CCC\\u0CCD\\u0CD5\\u0CD6\\u0CE2\\u0CE3\\u0D00\\u0D01\\u0D3B\\u0D3C\\u0D3E\\u0D41-\\u0D44\\u0D4D\\u0D57\\u0D62\\u0D63\\u0D81\\u0DCA\\u0DCF\\u0DD2-\\u0DD4\\u0DD6\\u0DDF\\u0E31\\u0E34-\\u0E3A\\u0E47-\\u0E4E\\u0EB1\\u0EB4-\\u0EBC\\u0EC8-\\u0ECD\\u0F18\\u0F19\\u0F35\\u0F37\\u0F39\\u0F71-\\u0F7E\\u0F80-\\u0F84\\u0F86\\u0F87\\u0F8D-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u102D-\\u1030\\u1032-\\u1037\\u1039\\u103A\\u103D\\u103E\\u1058\\u1059\\u105E-\\u1060\\u1071-\\u1074\\u1082\\u1085\\u1086\\u108D\\u109D\\u135D-\\u135F\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17B4\\u17B5\\u17B7-\\u17BD\\u17C6\\u17C9-\\u17D3\\u17DD\\u180B-\\u180D\\u1885\\u1886\\u18A9\\u1920-\\u1922\\u1927\\u1928\\u1932\\u1939-\\u193B\\u1A17\\u1A18\\u1A1B\\u1A56\\u1A58-\\u1A5E\\u1A60\\u1A62\\u1A65-\\u1A6C\\u1A73-\\u1A7C\\u1A7F\\u1AB0-\\u1AC0\\u1B00-\\u1B03\\u1B34-\\u1B3A\\u1B3C\\u1B42\\u1B6B-\\u1B73\\u1B80\\u1B81\\u1BA2-\\u1BA5\\u1BA8\\u1BA9\\u1BAB-\\u1BAD\\u1BE6\\u1BE8\\u1BE9\\u1BED\\u1BEF-\\u1BF1\\u1C2C-\\u1C33\\u1C36\\u1C37\\u1CD0-\\u1CD2\\u1CD4-\\u1CE0\\u1CE2-\\u1CE8\\u1CED\\u1CF4\\u1CF8\\u1CF9\\u1DC0-\\u1DF9\\u1DFB-\\u1DFF\\u200C\\u20D0-\\u20F0\\u2CEF-\\u2CF1\\u2D7F\\u2DE0-\\u2DFF\\u302A-\\u302F\\u3099\\u309A\\uA66F-\\uA672\\uA674-\\uA67D\\uA69E\\uA69F\\uA6F0\\uA6F1\\uA802\\uA806\\uA80B\\uA825\\uA826\\uA82C\\uA8C4\\uA8C5\\uA8E0-\\uA8F1\\uA8FF\\uA926-\\uA92D\\uA947-\\uA951\\uA980-\\uA982\\uA9B3\\uA9B6-\\uA9B9\\uA9BC\\uA9BD\\uA9E5\\uAA29-\\uAA2E\\uAA31\\uAA32\\uAA35\\uAA36\\uAA43\\uAA4C\\uAA7C\\uAAB0\\uAAB2-\\uAAB4\\uAAB7\\uAAB8\\uAABE\\uAABF\\uAAC1\\uAAEC\\uAAED\\uAAF6\\uABE5\\uABE8\\uABED\\uFB1E\\uFE00-\\uFE0F\\uFE20-\\uFE2F\\uFF9E\\uFF9F]|\\uD800[\\uDDFD\\uDEE0\\uDF76-\\uDF7A]|\\uD802[\\uDE01-\\uDE03\\uDE05\\uDE06\\uDE0C-\\uDE0F\\uDE38-\\uDE3A\\uDE3F\\uDEE5\\uDEE6]|\\uD803[\\uDD24-\\uDD27\\uDEAB\\uDEAC\\uDF46-\\uDF50]|\\uD804[\\uDC01\\uDC38-\\uDC46\\uDC7F-\\uDC81\\uDCB3-\\uDCB6\\uDCB9\\uDCBA\\uDD00-\\uDD02\\uDD27-\\uDD2B\\uDD2D-\\uDD34\\uDD73\\uDD80\\uDD81\\uDDB6-\\uDDBE\\uDDC9-\\uDDCC\\uDDCF\\uDE2F-\\uDE31\\uDE34\\uDE36\\uDE37\\uDE3E\\uDEDF\\uDEE3-\\uDEEA\\uDF00\\uDF01\\uDF3B\\uDF3C\\uDF3E\\uDF40\\uDF57\\uDF66-\\uDF6C\\uDF70-\\uDF74]|\\uD805[\\uDC38-\\uDC3F\\uDC42-\\uDC44\\uDC46\\uDC5E\\uDCB0\\uDCB3-\\uDCB8\\uDCBA\\uDCBD\\uDCBF\\uDCC0\\uDCC2\\uDCC3\\uDDAF\\uDDB2-\\uDDB5\\uDDBC\\uDDBD\\uDDBF\\uDDC0\\uDDDC\\uDDDD\\uDE33-\\uDE3A\\uDE3D\\uDE3F\\uDE40\\uDEAB\\uDEAD\\uDEB0-\\uDEB5\\uDEB7\\uDF1D-\\uDF1F\\uDF22-\\uDF25\\uDF27-\\uDF2B]|\\uD806[\\uDC2F-\\uDC37\\uDC39\\uDC3A\\uDD30\\uDD3B\\uDD3C\\uDD3E\\uDD43\\uDDD4-\\uDDD7\\uDDDA\\uDDDB\\uDDE0\\uDE01-\\uDE0A\\uDE33-\\uDE38\\uDE3B-\\uDE3E\\uDE47\\uDE51-\\uDE56\\uDE59-\\uDE5B\\uDE8A-\\uDE96\\uDE98\\uDE99]|\\uD807[\\uDC30-\\uDC36\\uDC38-\\uDC3D\\uDC3F\\uDC92-\\uDCA7\\uDCAA-\\uDCB0\\uDCB2\\uDCB3\\uDCB5\\uDCB6\\uDD31-\\uDD36\\uDD3A\\uDD3C\\uDD3D\\uDD3F-\\uDD45\\uDD47\\uDD90\\uDD91\\uDD95\\uDD97\\uDEF3\\uDEF4]|\\uD81A[\\uDEF0-\\uDEF4\\uDF30-\\uDF36]|\\uD81B[\\uDF4F\\uDF8F-\\uDF92\\uDFE4]|\\uD82F[\\uDC9D\\uDC9E]|\\uD834[\\uDD65\\uDD67-\\uDD69\\uDD6E-\\uDD72\\uDD7B-\\uDD82\\uDD85-\\uDD8B\\uDDAA-\\uDDAD\\uDE42-\\uDE44]|\\uD836[\\uDE00-\\uDE36\\uDE3B-\\uDE6C\\uDE75\\uDE84\\uDE9B-\\uDE9F\\uDEA1-\\uDEAF]|\\uD838[\\uDC00-\\uDC06\\uDC08-\\uDC18\\uDC1B-\\uDC21\\uDC23\\uDC24\\uDC26-\\uDC2A\\uDD30-\\uDD36\\uDEEC-\\uDEEF]|\\uD83A[\\uDCD0-\\uDCD6\\uDD44-\\uDD4A]|\\uD83C[\\uDFFB-\\uDFFF]|\\uDB40[\\uDC20-\\uDC7F\\uDD00-\\uDDEF])*\\u200D$/;\n\nvar endsWithEmojiZWJ = function endsWithEmojiZWJ(str) {\n  return str.search(endingEmojiZWJ) !== -1;\n};\n\nvar endingRIs = /(?:\\uD83C[\\uDDE6-\\uDDFF])+$/g;\n\nvar endsWithOddNumberOfRIs = function endsWithOddNumberOfRIs(str) {\n  var match = str.match(endingRIs);\n\n  if (match === null) {\n    return false;\n  } else {\n    // A RI is represented by a surrogate pair.\n    var numRIs = match[0].length / 2;\n    return numRIs % 2 === 1;\n  }\n};\n\n/**\r\n * Shared the function with isElementType utility\r\n */\n\nvar isElement = function isElement(value) {\n  return isPlainObject.isPlainObject(value) && Node.isNodeList(value.children) && !Editor.isEditor(value);\n}; // eslint-disable-next-line no-redeclare\n\n\nvar Element = {\n  /**\r\n   * Check if a value implements the 'Ancestor' interface.\r\n   */\n  isAncestor: function isAncestor(value) {\n    return isPlainObject.isPlainObject(value) && Node.isNodeList(value.children);\n  },\n\n  /**\r\n   * Check if a value implements the `Element` interface.\r\n   */\n  isElement: isElement,\n\n  /**\r\n   * Check if a value is an array of `Element` objects.\r\n   */\n  isElementList: function isElementList(value) {\n    return Array.isArray(value) && value.every(function (val) {\n      return Element.isElement(val);\n    });\n  },\n\n  /**\r\n   * Check if a set of props is a partial of Element.\r\n   */\n  isElementProps: function isElementProps(props) {\n    return props.children !== undefined;\n  },\n\n  /**\r\n   * Check if a value implements the `Element` interface and has elementKey with selected value.\r\n   * Default it check to `type` key value\r\n   */\n  isElementType: function isElementType(value, elementVal) {\n    var elementKey = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'type';\n    return isElement(value) && value[elementKey] === elementVal;\n  },\n\n  /**\r\n   * Check if an element matches set of properties.\r\n   *\r\n   * Note: this checks custom properties, and it does not ensure that any\r\n   * children are equivalent.\r\n   */\n  matches: function matches(element, props) {\n    for (var key in props) {\n      if (key === 'children') {\n        continue;\n      }\n\n      if (element[key] !== props[key]) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n};\n\nvar _excluded$4 = [\"text\"],\n    _excluded2$3 = [\"text\"];\n\nfunction ownKeys$8(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread$8(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$8(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$8(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _createForOfIteratorHelper$5(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$5(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray$5(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray$5(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$5(o, minLen); }\n\nfunction _arrayLikeToArray$5(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\nvar IS_EDITOR_CACHE = new WeakMap(); // eslint-disable-next-line no-redeclare\n\nvar Editor = {\n  /**\r\n   * Get the ancestor above a location in the document.\r\n   */\n  above: function above(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var _options$voids = options.voids,\n        voids = _options$voids === void 0 ? false : _options$voids,\n        _options$mode = options.mode,\n        mode = _options$mode === void 0 ? 'lowest' : _options$mode,\n        _options$at = options.at,\n        at = _options$at === void 0 ? editor.selection : _options$at,\n        match = options.match;\n\n    if (!at) {\n      return;\n    }\n\n    var path = Editor.path(editor, at);\n    var reverse = mode === 'lowest';\n\n    var _iterator = _createForOfIteratorHelper$5(Editor.levels(editor, {\n      at: path,\n      voids: voids,\n      match: match,\n      reverse: reverse\n    })),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var _step$value = _slicedToArray(_step.value, 2),\n            n = _step$value[0],\n            p = _step$value[1];\n\n        if (Text.isText(n)) continue;\n\n        if (Range.isRange(at)) {\n          if (Path.isAncestor(p, at.anchor.path) && Path.isAncestor(p, at.focus.path)) {\n            return [n, p];\n          }\n        } else {\n          if (!Path.equals(path, p)) {\n            return [n, p];\n          }\n        }\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n  },\n\n  /**\r\n   * Add a custom property to the leaf text nodes in the current selection.\r\n   *\r\n   * If the selection is currently collapsed, the marks will be added to the\r\n   * `editor.marks` property instead, and applied when text is inserted next.\r\n   */\n  addMark: function addMark(editor, key, value) {\n    editor.addMark(key, value);\n  },\n\n  /**\r\n   * Get the point after a location.\r\n   */\n  after: function after(editor, at) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var anchor = Editor.point(editor, at, {\n      edge: 'end'\n    });\n    var focus = Editor.end(editor, []);\n    var range = {\n      anchor: anchor,\n      focus: focus\n    };\n    var _options$distance = options.distance,\n        distance = _options$distance === void 0 ? 1 : _options$distance;\n    var d = 0;\n    var target;\n\n    var _iterator2 = _createForOfIteratorHelper$5(Editor.positions(editor, _objectSpread$8(_objectSpread$8({}, options), {}, {\n      at: range\n    }))),\n        _step2;\n\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var p = _step2.value;\n\n        if (d > distance) {\n          break;\n        }\n\n        if (d !== 0) {\n          target = p;\n        }\n\n        d++;\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n\n    return target;\n  },\n\n  /**\r\n   * Get the point before a location.\r\n   */\n  before: function before(editor, at) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var anchor = Editor.start(editor, []);\n    var focus = Editor.point(editor, at, {\n      edge: 'start'\n    });\n    var range = {\n      anchor: anchor,\n      focus: focus\n    };\n    var _options$distance2 = options.distance,\n        distance = _options$distance2 === void 0 ? 1 : _options$distance2;\n    var d = 0;\n    var target;\n\n    var _iterator3 = _createForOfIteratorHelper$5(Editor.positions(editor, _objectSpread$8(_objectSpread$8({}, options), {}, {\n      at: range,\n      reverse: true\n    }))),\n        _step3;\n\n    try {\n      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n        var p = _step3.value;\n\n        if (d > distance) {\n          break;\n        }\n\n        if (d !== 0) {\n          target = p;\n        }\n\n        d++;\n      }\n    } catch (err) {\n      _iterator3.e(err);\n    } finally {\n      _iterator3.f();\n    }\n\n    return target;\n  },\n\n  /**\r\n   * Delete content in the editor backward from the current selection.\r\n   */\n  deleteBackward: function deleteBackward(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var _options$unit = options.unit,\n        unit = _options$unit === void 0 ? 'character' : _options$unit;\n    editor.deleteBackward(unit);\n  },\n\n  /**\r\n   * Delete content in the editor forward from the current selection.\r\n   */\n  deleteForward: function deleteForward(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var _options$unit2 = options.unit,\n        unit = _options$unit2 === void 0 ? 'character' : _options$unit2;\n    editor.deleteForward(unit);\n  },\n\n  /**\r\n   * Delete the content in the current selection.\r\n   */\n  deleteFragment: function deleteFragment(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var _options$direction = options.direction,\n        direction = _options$direction === void 0 ? 'forward' : _options$direction;\n    editor.deleteFragment(direction);\n  },\n\n  /**\r\n   * Get the start and end points of a location.\r\n   */\n  edges: function edges(editor, at) {\n    return [Editor.start(editor, at), Editor.end(editor, at)];\n  },\n\n  /**\r\n   * Get the end point of a location.\r\n   */\n  end: function end(editor, at) {\n    return Editor.point(editor, at, {\n      edge: 'end'\n    });\n  },\n\n  /**\r\n   * Get the first node at a location.\r\n   */\n  first: function first(editor, at) {\n    var path = Editor.path(editor, at, {\n      edge: 'start'\n    });\n    return Editor.node(editor, path);\n  },\n\n  /**\r\n   * Get the fragment at a location.\r\n   */\n  fragment: function fragment(editor, at) {\n    var range = Editor.range(editor, at);\n    var fragment = Node.fragment(editor, range);\n    return fragment;\n  },\n\n  /**\r\n   * Check if a node has block children.\r\n   */\n  hasBlocks: function hasBlocks(editor, element) {\n    return element.children.some(function (n) {\n      return Element.isElement(n) && Editor.isBlock(editor, n);\n    });\n  },\n\n  /**\r\n   * Check if a node has inline and text children.\r\n   */\n  hasInlines: function hasInlines(editor, element) {\n    return element.children.some(function (n) {\n      return Text.isText(n) || Editor.isInline(editor, n);\n    });\n  },\n\n  /**\r\n   * Check if a node has text children.\r\n   */\n  hasTexts: function hasTexts(editor, element) {\n    return element.children.every(function (n) {\n      return Text.isText(n);\n    });\n  },\n\n  /**\r\n   * Insert a block break at the current selection.\r\n   *\r\n   * If the selection is currently expanded, it will be deleted first.\r\n   */\n  insertBreak: function insertBreak(editor) {\n    editor.insertBreak();\n  },\n\n  /**\r\n   * Insert a soft break at the current selection.\r\n   *\r\n   * If the selection is currently expanded, it will be deleted first.\r\n   */\n  insertSoftBreak: function insertSoftBreak(editor) {\n    editor.insertSoftBreak();\n  },\n\n  /**\r\n   * Insert a fragment at the current selection.\r\n   *\r\n   * If the selection is currently expanded, it will be deleted first.\r\n   */\n  insertFragment: function insertFragment(editor, fragment) {\n    editor.insertFragment(fragment);\n  },\n\n  /**\r\n   * Insert a node at the current selection.\r\n   *\r\n   * If the selection is currently expanded, it will be deleted first.\r\n   */\n  insertNode: function insertNode(editor, node) {\n    editor.insertNode(node);\n  },\n\n  /**\r\n   * Insert text at the current selection.\r\n   *\r\n   * If the selection is currently expanded, it will be deleted first.\r\n   */\n  insertText: function insertText(editor, text) {\n    editor.insertText(text);\n  },\n\n  /**\r\n   * Check if a value is a block `Element` object.\r\n   */\n  isBlock: function isBlock(editor, value) {\n    return !editor.isInline(value);\n  },\n\n  /**\r\n   * Check if a value is an `Editor` object.\r\n   */\n  isEditor: function isEditor(value) {\n    var cachedIsEditor = IS_EDITOR_CACHE.get(value);\n\n    if (cachedIsEditor !== undefined) {\n      return cachedIsEditor;\n    }\n\n    if (!isPlainObject.isPlainObject(value)) {\n      return false;\n    }\n\n    var isEditor = typeof value.addMark === 'function' && typeof value.apply === 'function' && typeof value.deleteBackward === 'function' && typeof value.deleteForward === 'function' && typeof value.deleteFragment === 'function' && typeof value.insertBreak === 'function' && typeof value.insertSoftBreak === 'function' && typeof value.insertFragment === 'function' && typeof value.insertNode === 'function' && typeof value.insertText === 'function' && typeof value.isInline === 'function' && typeof value.isVoid === 'function' && typeof value.normalizeNode === 'function' && typeof value.onChange === 'function' && typeof value.removeMark === 'function' && typeof value.getDirtyPaths === 'function' && (value.marks === null || isPlainObject.isPlainObject(value.marks)) && (value.selection === null || Range.isRange(value.selection)) && Node.isNodeList(value.children) && Operation.isOperationList(value.operations);\n    IS_EDITOR_CACHE.set(value, isEditor);\n    return isEditor;\n  },\n\n  /**\r\n   * Check if a point is the end point of a location.\r\n   */\n  isEnd: function isEnd(editor, point, at) {\n    var end = Editor.end(editor, at);\n    return Point.equals(point, end);\n  },\n\n  /**\r\n   * Check if a point is an edge of a location.\r\n   */\n  isEdge: function isEdge(editor, point, at) {\n    return Editor.isStart(editor, point, at) || Editor.isEnd(editor, point, at);\n  },\n\n  /**\r\n   * Check if an element is empty, accounting for void nodes.\r\n   */\n  isEmpty: function isEmpty(editor, element) {\n    var children = element.children;\n\n    var _children = _slicedToArray(children, 1),\n        first = _children[0];\n\n    return children.length === 0 || children.length === 1 && Text.isText(first) && first.text === '' && !editor.isVoid(element);\n  },\n\n  /**\r\n   * Check if a value is an inline `Element` object.\r\n   */\n  isInline: function isInline(editor, value) {\n    return editor.isInline(value);\n  },\n\n  /**\r\n   * Check if the editor is currently normalizing after each operation.\r\n   */\n  isNormalizing: function isNormalizing(editor) {\n    var isNormalizing = NORMALIZING.get(editor);\n    return isNormalizing === undefined ? true : isNormalizing;\n  },\n\n  /**\r\n   * Check if a point is the start point of a location.\r\n   */\n  isStart: function isStart(editor, point, at) {\n    // PERF: If the offset isn't `0` we know it's not the start.\n    if (point.offset !== 0) {\n      return false;\n    }\n\n    var start = Editor.start(editor, at);\n    return Point.equals(point, start);\n  },\n\n  /**\r\n   * Check if a value is a void `Element` object.\r\n   */\n  isVoid: function isVoid(editor, value) {\n    return editor.isVoid(value);\n  },\n\n  /**\r\n   * Get the last node at a location.\r\n   */\n  last: function last(editor, at) {\n    var path = Editor.path(editor, at, {\n      edge: 'end'\n    });\n    return Editor.node(editor, path);\n  },\n\n  /**\r\n   * Get the leaf text node at a location.\r\n   */\n  leaf: function leaf(editor, at) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var path = Editor.path(editor, at, options);\n    var node = Node.leaf(editor, path);\n    return [node, path];\n  },\n\n  /**\r\n   * Iterate through all of the levels at a location.\r\n   */\n  levels: function* levels(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var _options$at2 = options.at,\n        at = _options$at2 === void 0 ? editor.selection : _options$at2,\n        _options$reverse = options.reverse,\n        reverse = _options$reverse === void 0 ? false : _options$reverse,\n        _options$voids2 = options.voids,\n        voids = _options$voids2 === void 0 ? false : _options$voids2;\n    var match = options.match;\n\n    if (match == null) {\n      match = function match() {\n        return true;\n      };\n    }\n\n    if (!at) {\n      return;\n    }\n\n    var levels = [];\n    var path = Editor.path(editor, at);\n\n    var _iterator4 = _createForOfIteratorHelper$5(Node.levels(editor, path)),\n        _step4;\n\n    try {\n      for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n        var _step4$value = _slicedToArray(_step4.value, 2),\n            n = _step4$value[0],\n            p = _step4$value[1];\n\n        if (!match(n, p)) {\n          continue;\n        }\n\n        levels.push([n, p]);\n\n        if (!voids && Element.isElement(n) && Editor.isVoid(editor, n)) {\n          break;\n        }\n      }\n    } catch (err) {\n      _iterator4.e(err);\n    } finally {\n      _iterator4.f();\n    }\n\n    if (reverse) {\n      levels.reverse();\n    }\n\n    yield* levels;\n  },\n\n  /**\r\n   * Get the marks that would be added to text at the current selection.\r\n   */\n  marks: function marks(editor) {\n    var marks = editor.marks,\n        selection = editor.selection;\n\n    if (!selection) {\n      return null;\n    }\n\n    if (marks) {\n      return marks;\n    }\n\n    if (Range.isExpanded(selection)) {\n      var _Editor$nodes = Editor.nodes(editor, {\n        match: Text.isText\n      }),\n          _Editor$nodes2 = _slicedToArray(_Editor$nodes, 1),\n          match = _Editor$nodes2[0];\n\n      if (match) {\n        var _match = _slicedToArray(match, 1),\n            _node = _match[0];\n\n        _node.text;\n            var _rest = _objectWithoutProperties(_node, _excluded$4);\n\n        return _rest;\n      } else {\n        return {};\n      }\n    }\n\n    var anchor = selection.anchor;\n    var path = anchor.path;\n\n    var _Editor$leaf = Editor.leaf(editor, path),\n        _Editor$leaf2 = _slicedToArray(_Editor$leaf, 1),\n        node = _Editor$leaf2[0];\n\n    if (anchor.offset === 0) {\n      var prev = Editor.previous(editor, {\n        at: path,\n        match: Text.isText\n      });\n      var markedVoid = Editor.above(editor, {\n        match: function match(n) {\n          return Element.isElement(n) && Editor.isVoid(editor, n) && editor.markableVoid(n);\n        }\n      });\n\n      if (!markedVoid) {\n        var block = Editor.above(editor, {\n          match: function match(n) {\n            return Element.isElement(n) && Editor.isBlock(editor, n);\n          }\n        });\n\n        if (prev && block) {\n          var _prev = _slicedToArray(prev, 2),\n              prevNode = _prev[0],\n              prevPath = _prev[1];\n\n          var _block = _slicedToArray(block, 2),\n              blockPath = _block[1];\n\n          if (Path.isAncestor(blockPath, prevPath)) {\n            node = prevNode;\n          }\n        }\n      }\n    }\n\n    var _node2 = node;\n        _node2.text;\n        var rest = _objectWithoutProperties(_node2, _excluded2$3);\n\n    return rest;\n  },\n\n  /**\r\n   * Get the matching node in the branch of the document after a location.\r\n   */\n  next: function next(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var _options$mode2 = options.mode,\n        mode = _options$mode2 === void 0 ? 'lowest' : _options$mode2,\n        _options$voids3 = options.voids,\n        voids = _options$voids3 === void 0 ? false : _options$voids3;\n    var match = options.match,\n        _options$at3 = options.at,\n        at = _options$at3 === void 0 ? editor.selection : _options$at3;\n\n    if (!at) {\n      return;\n    }\n\n    var pointAfterLocation = Editor.after(editor, at, {\n      voids: voids\n    });\n    if (!pointAfterLocation) return;\n\n    var _Editor$last = Editor.last(editor, []),\n        _Editor$last2 = _slicedToArray(_Editor$last, 2),\n        to = _Editor$last2[1];\n\n    var span = [pointAfterLocation.path, to];\n\n    if (Path.isPath(at) && at.length === 0) {\n      throw new Error(\"Cannot get the next node from the root node!\");\n    }\n\n    if (match == null) {\n      if (Path.isPath(at)) {\n        var _Editor$parent = Editor.parent(editor, at),\n            _Editor$parent2 = _slicedToArray(_Editor$parent, 1),\n            parent = _Editor$parent2[0];\n\n        match = function match(n) {\n          return parent.children.includes(n);\n        };\n      } else {\n        match = function match() {\n          return true;\n        };\n      }\n    }\n\n    var _Editor$nodes3 = Editor.nodes(editor, {\n      at: span,\n      match: match,\n      mode: mode,\n      voids: voids\n    }),\n        _Editor$nodes4 = _slicedToArray(_Editor$nodes3, 1),\n        next = _Editor$nodes4[0];\n\n    return next;\n  },\n\n  /**\r\n   * Get the node at a location.\r\n   */\n  node: function node(editor, at) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var path = Editor.path(editor, at, options);\n    var node = Node.get(editor, path);\n    return [node, path];\n  },\n\n  /**\r\n   * Iterate through all of the nodes in the Editor.\r\n   */\n  nodes: function* nodes(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var _options$at4 = options.at,\n        at = _options$at4 === void 0 ? editor.selection : _options$at4,\n        _options$mode3 = options.mode,\n        mode = _options$mode3 === void 0 ? 'all' : _options$mode3,\n        _options$universal = options.universal,\n        universal = _options$universal === void 0 ? false : _options$universal,\n        _options$reverse2 = options.reverse,\n        reverse = _options$reverse2 === void 0 ? false : _options$reverse2,\n        _options$voids4 = options.voids,\n        voids = _options$voids4 === void 0 ? false : _options$voids4;\n    var match = options.match;\n\n    if (!match) {\n      match = function match() {\n        return true;\n      };\n    }\n\n    if (!at) {\n      return;\n    }\n\n    var from;\n    var to;\n\n    if (Span.isSpan(at)) {\n      from = at[0];\n      to = at[1];\n    } else {\n      var first = Editor.path(editor, at, {\n        edge: 'start'\n      });\n      var last = Editor.path(editor, at, {\n        edge: 'end'\n      });\n      from = reverse ? last : first;\n      to = reverse ? first : last;\n    }\n\n    var nodeEntries = Node.nodes(editor, {\n      reverse: reverse,\n      from: from,\n      to: to,\n      pass: function pass(_ref) {\n        var _ref2 = _slicedToArray(_ref, 1),\n            n = _ref2[0];\n\n        return voids ? false : Element.isElement(n) && Editor.isVoid(editor, n);\n      }\n    });\n    var matches = [];\n    var hit;\n\n    var _iterator5 = _createForOfIteratorHelper$5(nodeEntries),\n        _step5;\n\n    try {\n      for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n        var _step5$value = _slicedToArray(_step5.value, 2),\n            node = _step5$value[0],\n            path = _step5$value[1];\n\n        var isLower = hit && Path.compare(path, hit[1]) === 0; // In highest mode any node lower than the last hit is not a match.\n\n        if (mode === 'highest' && isLower) {\n          continue;\n        }\n\n        if (!match(node, path)) {\n          // If we've arrived at a leaf text node that is not lower than the last\n          // hit, then we've found a branch that doesn't include a match, which\n          // means the match is not universal.\n          if (universal && !isLower && Text.isText(node)) {\n            return;\n          } else {\n            continue;\n          }\n        } // If there's a match and it's lower than the last, update the hit.\n\n\n        if (mode === 'lowest' && isLower) {\n          hit = [node, path];\n          continue;\n        } // In lowest mode we emit the last hit, once it's guaranteed lowest.\n\n\n        var emit = mode === 'lowest' ? hit : [node, path];\n\n        if (emit) {\n          if (universal) {\n            matches.push(emit);\n          } else {\n            yield emit;\n          }\n        }\n\n        hit = [node, path];\n      } // Since lowest is always emitting one behind, catch up at the end.\n\n    } catch (err) {\n      _iterator5.e(err);\n    } finally {\n      _iterator5.f();\n    }\n\n    if (mode === 'lowest' && hit) {\n      if (universal) {\n        matches.push(hit);\n      } else {\n        yield hit;\n      }\n    } // Universal defers to ensure that the match occurs in every branch, so we\n    // yield all of the matches after iterating.\n\n\n    if (universal) {\n      yield* matches;\n    }\n  },\n\n  /**\r\n   * Normalize any dirty objects in the editor.\r\n   */\n  normalize: function normalize(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var _options$force = options.force,\n        force = _options$force === void 0 ? false : _options$force,\n        operation = options.operation;\n\n    var getDirtyPaths = function getDirtyPaths(editor) {\n      return DIRTY_PATHS.get(editor) || [];\n    };\n\n    var getDirtyPathKeys = function getDirtyPathKeys(editor) {\n      return DIRTY_PATH_KEYS.get(editor) || new Set();\n    };\n\n    var popDirtyPath = function popDirtyPath(editor) {\n      var path = getDirtyPaths(editor).pop();\n      var key = path.join(',');\n      getDirtyPathKeys(editor)[\"delete\"](key);\n      return path;\n    };\n\n    if (!Editor.isNormalizing(editor)) {\n      return;\n    }\n\n    if (force) {\n      var allPaths = Array.from(Node.nodes(editor), function (_ref3) {\n        var _ref4 = _slicedToArray(_ref3, 2),\n            p = _ref4[1];\n\n        return p;\n      });\n      var allPathKeys = new Set(allPaths.map(function (p) {\n        return p.join(',');\n      }));\n      DIRTY_PATHS.set(editor, allPaths);\n      DIRTY_PATH_KEYS.set(editor, allPathKeys);\n    }\n\n    if (getDirtyPaths(editor).length === 0) {\n      return;\n    }\n\n    Editor.withoutNormalizing(editor, function () {\n      /*\r\n        Fix dirty elements with no children.\r\n        editor.normalizeNode() does fix this, but some normalization fixes also require it to work.\r\n        Running an initial pass avoids the catch-22 race condition.\r\n      */\n      var _iterator6 = _createForOfIteratorHelper$5(getDirtyPaths(editor)),\n          _step6;\n\n      try {\n        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n          var _dirtyPath = _step6.value;\n\n          if (Node.has(editor, _dirtyPath)) {\n            var _entry = Editor.node(editor, _dirtyPath);\n\n            var _entry2 = _slicedToArray(_entry, 2),\n                node = _entry2[0],\n                _ = _entry2[1];\n            /*\r\n              The default normalizer inserts an empty text node in this scenario, but it can be customised.\r\n              So there is some risk here.\r\n                         As long as the normalizer only inserts child nodes for this case it is safe to do in any order;\r\n              by definition adding children to an empty node can't cause other paths to change.\r\n            */\n\n\n            if (Element.isElement(node) && node.children.length === 0) {\n              editor.normalizeNode(_entry, {\n                operation: operation\n              });\n            }\n          }\n        }\n      } catch (err) {\n        _iterator6.e(err);\n      } finally {\n        _iterator6.f();\n      }\n\n      var dirtyPaths = getDirtyPaths(editor);\n      var initialDirtyPathsLength = dirtyPaths.length;\n      var iteration = 0;\n\n      while (dirtyPaths.length !== 0) {\n        if (!editor.shouldNormalize({\n          dirtyPaths: dirtyPaths,\n          iteration: iteration,\n          initialDirtyPathsLength: initialDirtyPathsLength,\n          operation: operation\n        })) {\n          return;\n        }\n\n        var dirtyPath = popDirtyPath(editor); // If the node doesn't exist in the tree, it does not need to be normalized.\n\n        if (Node.has(editor, dirtyPath)) {\n          var entry = Editor.node(editor, dirtyPath);\n          editor.normalizeNode(entry, {\n            operation: operation\n          });\n        }\n\n        iteration++;\n        dirtyPaths = getDirtyPaths(editor);\n      }\n    });\n  },\n\n  /**\r\n   * Get the parent node of a location.\r\n   */\n  parent: function parent(editor, at) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var path = Editor.path(editor, at, options);\n    var parentPath = Path.parent(path);\n    var entry = Editor.node(editor, parentPath);\n    return entry;\n  },\n\n  /**\r\n   * Get the path of a location.\r\n   */\n  path: function path(editor, at) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var depth = options.depth,\n        edge = options.edge;\n\n    if (Path.isPath(at)) {\n      if (edge === 'start') {\n        var _Node$first = Node.first(editor, at),\n            _Node$first2 = _slicedToArray(_Node$first, 2),\n            firstPath = _Node$first2[1];\n\n        at = firstPath;\n      } else if (edge === 'end') {\n        var _Node$last = Node.last(editor, at),\n            _Node$last2 = _slicedToArray(_Node$last, 2),\n            lastPath = _Node$last2[1];\n\n        at = lastPath;\n      }\n    }\n\n    if (Range.isRange(at)) {\n      if (edge === 'start') {\n        at = Range.start(at);\n      } else if (edge === 'end') {\n        at = Range.end(at);\n      } else {\n        at = Path.common(at.anchor.path, at.focus.path);\n      }\n    }\n\n    if (Point.isPoint(at)) {\n      at = at.path;\n    }\n\n    if (depth != null) {\n      at = at.slice(0, depth);\n    }\n\n    return at;\n  },\n  hasPath: function hasPath(editor, path) {\n    return Node.has(editor, path);\n  },\n\n  /**\r\n   * Create a mutable ref for a `Path` object, which will stay in sync as new\r\n   * operations are applied to the editor.\r\n   */\n  pathRef: function pathRef(editor, path) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var _options$affinity = options.affinity,\n        affinity = _options$affinity === void 0 ? 'forward' : _options$affinity;\n    var ref = {\n      current: path,\n      affinity: affinity,\n      unref: function unref() {\n        var current = ref.current;\n        var pathRefs = Editor.pathRefs(editor);\n        pathRefs[\"delete\"](ref);\n        ref.current = null;\n        return current;\n      }\n    };\n    var refs = Editor.pathRefs(editor);\n    refs.add(ref);\n    return ref;\n  },\n\n  /**\r\n   * Get the set of currently tracked path refs of the editor.\r\n   */\n  pathRefs: function pathRefs(editor) {\n    var refs = PATH_REFS.get(editor);\n\n    if (!refs) {\n      refs = new Set();\n      PATH_REFS.set(editor, refs);\n    }\n\n    return refs;\n  },\n\n  /**\r\n   * Get the start or end point of a location.\r\n   */\n  point: function point(editor, at) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var _options$edge = options.edge,\n        edge = _options$edge === void 0 ? 'start' : _options$edge;\n\n    if (Path.isPath(at)) {\n      var path;\n\n      if (edge === 'end') {\n        var _Node$last3 = Node.last(editor, at),\n            _Node$last4 = _slicedToArray(_Node$last3, 2),\n            lastPath = _Node$last4[1];\n\n        path = lastPath;\n      } else {\n        var _Node$first3 = Node.first(editor, at),\n            _Node$first4 = _slicedToArray(_Node$first3, 2),\n            firstPath = _Node$first4[1];\n\n        path = firstPath;\n      }\n\n      var node = Node.get(editor, path);\n\n      if (!Text.isText(node)) {\n        throw new Error(\"Cannot get the \".concat(edge, \" point in the node at path [\").concat(at, \"] because it has no \").concat(edge, \" text node.\"));\n      }\n\n      return {\n        path: path,\n        offset: edge === 'end' ? node.text.length : 0\n      };\n    }\n\n    if (Range.isRange(at)) {\n      var _Range$edges = Range.edges(at),\n          _Range$edges2 = _slicedToArray(_Range$edges, 2),\n          start = _Range$edges2[0],\n          end = _Range$edges2[1];\n\n      return edge === 'start' ? start : end;\n    }\n\n    return at;\n  },\n\n  /**\r\n   * Create a mutable ref for a `Point` object, which will stay in sync as new\r\n   * operations are applied to the editor.\r\n   */\n  pointRef: function pointRef(editor, point) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var _options$affinity2 = options.affinity,\n        affinity = _options$affinity2 === void 0 ? 'forward' : _options$affinity2;\n    var ref = {\n      current: point,\n      affinity: affinity,\n      unref: function unref() {\n        var current = ref.current;\n        var pointRefs = Editor.pointRefs(editor);\n        pointRefs[\"delete\"](ref);\n        ref.current = null;\n        return current;\n      }\n    };\n    var refs = Editor.pointRefs(editor);\n    refs.add(ref);\n    return ref;\n  },\n\n  /**\r\n   * Get the set of currently tracked point refs of the editor.\r\n   */\n  pointRefs: function pointRefs(editor) {\n    var refs = POINT_REFS.get(editor);\n\n    if (!refs) {\n      refs = new Set();\n      POINT_REFS.set(editor, refs);\n    }\n\n    return refs;\n  },\n\n  /**\r\n   * Return all the positions in `at` range where a `Point` can be placed.\r\n   *\r\n   * By default, moves forward by individual offsets at a time, but\r\n   * the `unit` option can be used to to move by character, word, line, or block.\r\n   *\r\n   * The `reverse` option can be used to change iteration direction.\r\n   *\r\n   * Note: By default void nodes are treated as a single point and iteration\r\n   * will not happen inside their content unless you pass in true for the\r\n   * `voids` option, then iteration will occur.\r\n   */\n  positions: function* positions(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var _options$at5 = options.at,\n        at = _options$at5 === void 0 ? editor.selection : _options$at5,\n        _options$unit3 = options.unit,\n        unit = _options$unit3 === void 0 ? 'offset' : _options$unit3,\n        _options$reverse3 = options.reverse,\n        reverse = _options$reverse3 === void 0 ? false : _options$reverse3,\n        _options$voids5 = options.voids,\n        voids = _options$voids5 === void 0 ? false : _options$voids5;\n\n    if (!at) {\n      return;\n    }\n    /**\r\n     * Algorithm notes:\r\n     *\r\n     * Each step `distance` is dynamic depending on the underlying text\r\n     * and the `unit` specified.  Each step, e.g., a line or word, may\r\n     * span multiple text nodes, so we iterate through the text both on\r\n     * two levels in step-sync:\r\n     *\r\n     * `leafText` stores the text on a text leaf level, and is advanced\r\n     * through using the counters `leafTextOffset` and `leafTextRemaining`.\r\n     *\r\n     * `blockText` stores the text on a block level, and is shortened\r\n     * by `distance` every time it is advanced.\r\n     *\r\n     * We only maintain a window of one blockText and one leafText because\r\n     * a block node always appears before all of its leaf nodes.\r\n     */\n\n\n    var range = Editor.range(editor, at);\n\n    var _Range$edges3 = Range.edges(range),\n        _Range$edges4 = _slicedToArray(_Range$edges3, 2),\n        start = _Range$edges4[0],\n        end = _Range$edges4[1];\n\n    var first = reverse ? end : start;\n    var isNewBlock = false;\n    var blockText = '';\n    var distance = 0; // Distance for leafText to catch up to blockText.\n\n    var leafTextRemaining = 0;\n    var leafTextOffset = 0; // Iterate through all nodes in range, grabbing entire textual content\n    // of block nodes in blockText, and text nodes in leafText.\n    // Exploits the fact that nodes are sequenced in such a way that we first\n    // encounter the block node, then all of its text nodes, so when iterating\n    // through the blockText and leafText we just need to remember a window of\n    // one block node and leaf node, respectively.\n\n    var _iterator7 = _createForOfIteratorHelper$5(Editor.nodes(editor, {\n      at: at,\n      reverse: reverse,\n      voids: voids\n    })),\n        _step7;\n\n    try {\n      for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n        var _step7$value = _slicedToArray(_step7.value, 2),\n            node = _step7$value[0],\n            path = _step7$value[1];\n\n        /*\r\n         * ELEMENT NODE - Yield position(s) for voids, collect blockText for blocks\r\n         */\n        if (Element.isElement(node)) {\n          // Void nodes are a special case, so by default we will always\n          // yield their first point. If the `voids` option is set to true,\n          // then we will iterate over their content.\n          if (!voids && editor.isVoid(node)) {\n            yield Editor.start(editor, path);\n            continue;\n          } // Inline element nodes are ignored as they don't themselves\n          // contribute to `blockText` or `leafText` - their parent and\n          // children do.\n\n\n          if (editor.isInline(node)) continue; // Block element node - set `blockText` to its text content.\n\n          if (Editor.hasInlines(editor, node)) {\n            // We always exhaust block nodes before encountering a new one:\n            //   console.assert(blockText === '',\n            //     `blockText='${blockText}' - `+\n            //     `not exhausted before new block node`, path)\n            // Ensure range considered is capped to `range`, in the\n            // start/end edge cases where block extends beyond range.\n            // Equivalent to this, but presumably more performant:\n            //   blockRange = Editor.range(editor, ...Editor.edges(editor, path))\n            //   blockRange = Range.intersection(range, blockRange) // intersect\n            //   blockText = Editor.string(editor, blockRange, { voids })\n            var e = Path.isAncestor(path, end.path) ? end : Editor.end(editor, path);\n            var s = Path.isAncestor(path, start.path) ? start : Editor.start(editor, path);\n            blockText = Editor.string(editor, {\n              anchor: s,\n              focus: e\n            }, {\n              voids: voids\n            });\n            isNewBlock = true;\n          }\n        }\n        /*\r\n         * TEXT LEAF NODE - Iterate through text content, yielding\r\n         * positions every `distance` offset according to `unit`.\r\n         */\n\n\n        if (Text.isText(node)) {\n          var isFirst = Path.equals(path, first.path); // Proof that we always exhaust text nodes before encountering a new one:\n          //   console.assert(leafTextRemaining <= 0,\n          //     `leafTextRemaining=${leafTextRemaining} - `+\n          //     `not exhausted before new leaf text node`, path)\n          // Reset `leafText` counters for new text node.\n\n          if (isFirst) {\n            leafTextRemaining = reverse ? first.offset : node.text.length - first.offset;\n            leafTextOffset = first.offset; // Works for reverse too.\n          } else {\n            leafTextRemaining = node.text.length;\n            leafTextOffset = reverse ? leafTextRemaining : 0;\n          } // Yield position at the start of node (potentially).\n\n\n          if (isFirst || isNewBlock || unit === 'offset') {\n            yield {\n              path: path,\n              offset: leafTextOffset\n            };\n            isNewBlock = false;\n          } // Yield positions every (dynamically calculated) `distance` offset.\n\n\n          while (true) {\n            // If `leafText` has caught up with `blockText` (distance=0),\n            // and if blockText is exhausted, break to get another block node,\n            // otherwise advance blockText forward by the new `distance`.\n            if (distance === 0) {\n              if (blockText === '') break;\n              distance = calcDistance(blockText, unit, reverse); // Split the string at the previously found distance and use the\n              // remaining string for the next iteration.\n\n              blockText = splitByCharacterDistance(blockText, distance, reverse)[1];\n            } // Advance `leafText` by the current `distance`.\n\n\n            leafTextOffset = reverse ? leafTextOffset - distance : leafTextOffset + distance;\n            leafTextRemaining = leafTextRemaining - distance; // If `leafText` is exhausted, break to get a new leaf node\n            // and set distance to the overflow amount, so we'll (maybe)\n            // catch up to blockText in the next leaf text node.\n\n            if (leafTextRemaining < 0) {\n              distance = -leafTextRemaining;\n              break;\n            } // Successfully walked `distance` offsets through `leafText`\n            // to catch up with `blockText`, so we can reset `distance`\n            // and yield this position in this node.\n\n\n            distance = 0;\n            yield {\n              path: path,\n              offset: leafTextOffset\n            };\n          }\n        }\n      } // Proof that upon completion, we've exahusted both leaf and block text:\n      //   console.assert(leafTextRemaining <= 0, \"leafText wasn't exhausted\")\n      //   console.assert(blockText === '', \"blockText wasn't exhausted\")\n      // Helper:\n      // Return the distance in offsets for a step of size `unit` on given string.\n\n    } catch (err) {\n      _iterator7.e(err);\n    } finally {\n      _iterator7.f();\n    }\n\n    function calcDistance(text, unit, reverse) {\n      if (unit === 'character') {\n        return getCharacterDistance(text, reverse);\n      } else if (unit === 'word') {\n        return getWordDistance(text, reverse);\n      } else if (unit === 'line' || unit === 'block') {\n        return text.length;\n      }\n\n      return 1;\n    }\n  },\n\n  /**\r\n   * Get the matching node in the branch of the document before a location.\r\n   */\n  previous: function previous(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var _options$mode4 = options.mode,\n        mode = _options$mode4 === void 0 ? 'lowest' : _options$mode4,\n        _options$voids6 = options.voids,\n        voids = _options$voids6 === void 0 ? false : _options$voids6;\n    var match = options.match,\n        _options$at6 = options.at,\n        at = _options$at6 === void 0 ? editor.selection : _options$at6;\n\n    if (!at) {\n      return;\n    }\n\n    var pointBeforeLocation = Editor.before(editor, at, {\n      voids: voids\n    });\n\n    if (!pointBeforeLocation) {\n      return;\n    }\n\n    var _Editor$first = Editor.first(editor, []),\n        _Editor$first2 = _slicedToArray(_Editor$first, 2),\n        to = _Editor$first2[1]; // The search location is from the start of the document to the path of\n    // the point before the location passed in\n\n\n    var span = [pointBeforeLocation.path, to];\n\n    if (Path.isPath(at) && at.length === 0) {\n      throw new Error(\"Cannot get the previous node from the root node!\");\n    }\n\n    if (match == null) {\n      if (Path.isPath(at)) {\n        var _Editor$parent3 = Editor.parent(editor, at),\n            _Editor$parent4 = _slicedToArray(_Editor$parent3, 1),\n            parent = _Editor$parent4[0];\n\n        match = function match(n) {\n          return parent.children.includes(n);\n        };\n      } else {\n        match = function match() {\n          return true;\n        };\n      }\n    }\n\n    var _Editor$nodes5 = Editor.nodes(editor, {\n      reverse: true,\n      at: span,\n      match: match,\n      mode: mode,\n      voids: voids\n    }),\n        _Editor$nodes6 = _slicedToArray(_Editor$nodes5, 1),\n        previous = _Editor$nodes6[0];\n\n    return previous;\n  },\n\n  /**\r\n   * Get a range of a location.\r\n   */\n  range: function range(editor, at, to) {\n    if (Range.isRange(at) && !to) {\n      return at;\n    }\n\n    var start = Editor.start(editor, at);\n    var end = Editor.end(editor, to || at);\n    return {\n      anchor: start,\n      focus: end\n    };\n  },\n\n  /**\r\n   * Create a mutable ref for a `Range` object, which will stay in sync as new\r\n   * operations are applied to the editor.\r\n   */\n  rangeRef: function rangeRef(editor, range) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var _options$affinity3 = options.affinity,\n        affinity = _options$affinity3 === void 0 ? 'forward' : _options$affinity3;\n    var ref = {\n      current: range,\n      affinity: affinity,\n      unref: function unref() {\n        var current = ref.current;\n        var rangeRefs = Editor.rangeRefs(editor);\n        rangeRefs[\"delete\"](ref);\n        ref.current = null;\n        return current;\n      }\n    };\n    var refs = Editor.rangeRefs(editor);\n    refs.add(ref);\n    return ref;\n  },\n\n  /**\r\n   * Get the set of currently tracked range refs of the editor.\r\n   */\n  rangeRefs: function rangeRefs(editor) {\n    var refs = RANGE_REFS.get(editor);\n\n    if (!refs) {\n      refs = new Set();\n      RANGE_REFS.set(editor, refs);\n    }\n\n    return refs;\n  },\n\n  /**\r\n   * Remove a custom property from all of the leaf text nodes in the current\r\n   * selection.\r\n   *\r\n   * If the selection is currently collapsed, the removal will be stored on\r\n   * `editor.marks` and applied to the text inserted next.\r\n   */\n  removeMark: function removeMark(editor, key) {\n    editor.removeMark(key);\n  },\n\n  /**\r\n   * Manually set if the editor should currently be normalizing.\r\n   *\r\n   * Note: Using this incorrectly can leave the editor in an invalid state.\r\n   *\r\n   */\n  setNormalizing: function setNormalizing(editor, isNormalizing) {\n    NORMALIZING.set(editor, isNormalizing);\n  },\n\n  /**\r\n   * Get the start point of a location.\r\n   */\n  start: function start(editor, at) {\n    return Editor.point(editor, at, {\n      edge: 'start'\n    });\n  },\n\n  /**\r\n   * Get the text string content of a location.\r\n   *\r\n   * Note: by default the text of void nodes is considered to be an empty\r\n   * string, regardless of content, unless you pass in true for the voids option\r\n   */\n  string: function string(editor, at) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var _options$voids7 = options.voids,\n        voids = _options$voids7 === void 0 ? false : _options$voids7;\n    var range = Editor.range(editor, at);\n\n    var _Range$edges5 = Range.edges(range),\n        _Range$edges6 = _slicedToArray(_Range$edges5, 2),\n        start = _Range$edges6[0],\n        end = _Range$edges6[1];\n\n    var text = '';\n\n    var _iterator8 = _createForOfIteratorHelper$5(Editor.nodes(editor, {\n      at: range,\n      match: Text.isText,\n      voids: voids\n    })),\n        _step8;\n\n    try {\n      for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n        var _step8$value = _slicedToArray(_step8.value, 2),\n            node = _step8$value[0],\n            path = _step8$value[1];\n\n        var t = node.text;\n\n        if (Path.equals(path, end.path)) {\n          t = t.slice(0, end.offset);\n        }\n\n        if (Path.equals(path, start.path)) {\n          t = t.slice(start.offset);\n        }\n\n        text += t;\n      }\n    } catch (err) {\n      _iterator8.e(err);\n    } finally {\n      _iterator8.f();\n    }\n\n    return text;\n  },\n\n  /**\r\n   * Convert a range into a non-hanging one.\r\n   */\n  unhangRange: function unhangRange(editor, range) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var _options$voids8 = options.voids,\n        voids = _options$voids8 === void 0 ? false : _options$voids8;\n\n    var _Range$edges7 = Range.edges(range),\n        _Range$edges8 = _slicedToArray(_Range$edges7, 2),\n        start = _Range$edges8[0],\n        end = _Range$edges8[1]; // PERF: exit early if we can guarantee that the range isn't hanging.\n\n\n    if (start.offset !== 0 || end.offset !== 0 || Range.isCollapsed(range) || Path.hasPrevious(end.path)) {\n      return range;\n    }\n\n    var endBlock = Editor.above(editor, {\n      at: end,\n      match: function match(n) {\n        return Element.isElement(n) && Editor.isBlock(editor, n);\n      },\n      voids: voids\n    });\n    var blockPath = endBlock ? endBlock[1] : [];\n    var first = Editor.start(editor, start);\n    var before = {\n      anchor: first,\n      focus: end\n    };\n    var skip = true;\n\n    var _iterator9 = _createForOfIteratorHelper$5(Editor.nodes(editor, {\n      at: before,\n      match: Text.isText,\n      reverse: true,\n      voids: voids\n    })),\n        _step9;\n\n    try {\n      for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n        var _step9$value = _slicedToArray(_step9.value, 2),\n            node = _step9$value[0],\n            path = _step9$value[1];\n\n        if (skip) {\n          skip = false;\n          continue;\n        }\n\n        if (node.text !== '' || Path.isBefore(path, blockPath)) {\n          end = {\n            path: path,\n            offset: node.text.length\n          };\n          break;\n        }\n      }\n    } catch (err) {\n      _iterator9.e(err);\n    } finally {\n      _iterator9.f();\n    }\n\n    return {\n      anchor: start,\n      focus: end\n    };\n  },\n\n  /**\r\n   * Match a void node in the current branch of the editor.\r\n   */\n  \"void\": function _void(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return Editor.above(editor, _objectSpread$8(_objectSpread$8({}, options), {}, {\n      match: function match(n) {\n        return Element.isElement(n) && Editor.isVoid(editor, n);\n      }\n    }));\n  },\n\n  /**\r\n   * Call a function, deferring normalization until after it completes.\r\n   */\n  withoutNormalizing: function withoutNormalizing(editor, fn) {\n    var value = Editor.isNormalizing(editor);\n    Editor.setNormalizing(editor, false);\n\n    try {\n      fn();\n    } finally {\n      Editor.setNormalizing(editor, value);\n    }\n\n    Editor.normalize(editor);\n  }\n};\n\nvar Location = {\n  /**\r\n   * Check if a value implements the `Location` interface.\r\n   */\n  isLocation: function isLocation(value) {\n    return Path.isPath(value) || Point.isPoint(value) || Range.isRange(value);\n  }\n}; // eslint-disable-next-line no-redeclare\n\nvar Span = {\n  /**\r\n   * Check if a value implements the `Span` interface.\r\n   */\n  isSpan: function isSpan(value) {\n    return Array.isArray(value) && value.length === 2 && value.every(Path.isPath);\n  }\n};\n\nvar _excluded$3 = [\"children\"],\n    _excluded2$2 = [\"text\"];\n\nfunction _createForOfIteratorHelper$4(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$4(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray$4(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray$4(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$4(o, minLen); }\n\nfunction _arrayLikeToArray$4(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\nvar IS_NODE_LIST_CACHE = new WeakMap(); // eslint-disable-next-line no-redeclare\n\nvar Node = {\n  /**\r\n   * Get the node at a specific path, asserting that it's an ancestor node.\r\n   */\n  ancestor: function ancestor(root, path) {\n    var node = Node.get(root, path);\n\n    if (Text.isText(node)) {\n      throw new Error(\"Cannot get the ancestor node at path [\".concat(path, \"] because it refers to a text node instead: \").concat(Scrubber.stringify(node)));\n    }\n\n    return node;\n  },\n\n  /**\r\n   * Return a generator of all the ancestor nodes above a specific path.\r\n   *\r\n   * By default the order is top-down, from highest to lowest ancestor in\r\n   * the tree, but you can pass the `reverse: true` option to go bottom-up.\r\n   */\n  ancestors: function* ancestors(root, path) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    var _iterator = _createForOfIteratorHelper$4(Path.ancestors(path, options)),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var p = _step.value;\n        var n = Node.ancestor(root, p);\n        var entry = [n, p];\n        yield entry;\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n  },\n\n  /**\r\n   * Get the child of a node at a specific index.\r\n   */\n  child: function child(root, index) {\n    if (Text.isText(root)) {\n      throw new Error(\"Cannot get the child of a text node: \".concat(Scrubber.stringify(root)));\n    }\n\n    var c = root.children[index];\n\n    if (c == null) {\n      throw new Error(\"Cannot get child at index `\".concat(index, \"` in node: \").concat(Scrubber.stringify(root)));\n    }\n\n    return c;\n  },\n\n  /**\r\n   * Iterate over the children of a node at a specific path.\r\n   */\n  children: function* children(root, path) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var _options$reverse = options.reverse,\n        reverse = _options$reverse === void 0 ? false : _options$reverse;\n    var ancestor = Node.ancestor(root, path);\n    var children = ancestor.children;\n    var index = reverse ? children.length - 1 : 0;\n\n    while (reverse ? index >= 0 : index < children.length) {\n      var child = Node.child(ancestor, index);\n      var childPath = path.concat(index);\n      yield [child, childPath];\n      index = reverse ? index - 1 : index + 1;\n    }\n  },\n\n  /**\r\n   * Get an entry for the common ancesetor node of two paths.\r\n   */\n  common: function common(root, path, another) {\n    var p = Path.common(path, another);\n    var n = Node.get(root, p);\n    return [n, p];\n  },\n\n  /**\r\n   * Get the node at a specific path, asserting that it's a descendant node.\r\n   */\n  descendant: function descendant(root, path) {\n    var node = Node.get(root, path);\n\n    if (Editor.isEditor(node)) {\n      throw new Error(\"Cannot get the descendant node at path [\".concat(path, \"] because it refers to the root editor node instead: \").concat(Scrubber.stringify(node)));\n    }\n\n    return node;\n  },\n\n  /**\r\n   * Return a generator of all the descendant node entries inside a root node.\r\n   */\n  descendants: function* descendants(root) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    var _iterator2 = _createForOfIteratorHelper$4(Node.nodes(root, options)),\n        _step2;\n\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var _step2$value = _slicedToArray(_step2.value, 2),\n            node = _step2$value[0],\n            path = _step2$value[1];\n\n        if (path.length !== 0) {\n          // NOTE: we have to coerce here because checking the path's length does\n          // guarantee that `node` is not a `Editor`, but TypeScript doesn't know.\n          yield [node, path];\n        }\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n  },\n\n  /**\r\n   * Return a generator of all the element nodes inside a root node. Each iteration\r\n   * will return an `ElementEntry` tuple consisting of `[Element, Path]`. If the\r\n   * root node is an element it will be included in the iteration as well.\r\n   */\n  elements: function* elements(root) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    var _iterator3 = _createForOfIteratorHelper$4(Node.nodes(root, options)),\n        _step3;\n\n    try {\n      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n        var _step3$value = _slicedToArray(_step3.value, 2),\n            node = _step3$value[0],\n            path = _step3$value[1];\n\n        if (Element.isElement(node)) {\n          yield [node, path];\n        }\n      }\n    } catch (err) {\n      _iterator3.e(err);\n    } finally {\n      _iterator3.f();\n    }\n  },\n\n  /**\r\n   * Extract props from a Node.\r\n   */\n  extractProps: function extractProps(node) {\n    if (Element.isAncestor(node)) {\n      node.children;\n          var properties = _objectWithoutProperties(node, _excluded$3);\n\n      return properties;\n    } else {\n      node.text;\n          var _properties = _objectWithoutProperties(node, _excluded2$2);\n\n      return _properties;\n    }\n  },\n\n  /**\r\n   * Get the first node entry in a root node from a path.\r\n   */\n  first: function first(root, path) {\n    var p = path.slice();\n    var n = Node.get(root, p);\n\n    while (n) {\n      if (Text.isText(n) || n.children.length === 0) {\n        break;\n      } else {\n        n = n.children[0];\n        p.push(0);\n      }\n    }\n\n    return [n, p];\n  },\n\n  /**\r\n   * Get the sliced fragment represented by a range inside a root node.\r\n   */\n  fragment: function fragment(root, range) {\n    if (Text.isText(root)) {\n      throw new Error(\"Cannot get a fragment starting from a root text node: \".concat(Scrubber.stringify(root)));\n    }\n\n    var newRoot = immer.produce({\n      children: root.children\n    }, function (r) {\n      var _Range$edges = Range.edges(range),\n          _Range$edges2 = _slicedToArray(_Range$edges, 2),\n          start = _Range$edges2[0],\n          end = _Range$edges2[1];\n\n      var nodeEntries = Node.nodes(r, {\n        reverse: true,\n        pass: function pass(_ref) {\n          var _ref2 = _slicedToArray(_ref, 2),\n              path = _ref2[1];\n\n          return !Range.includes(range, path);\n        }\n      });\n\n      var _iterator4 = _createForOfIteratorHelper$4(nodeEntries),\n          _step4;\n\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var _step4$value = _slicedToArray(_step4.value, 2),\n              path = _step4$value[1];\n\n          if (!Range.includes(range, path)) {\n            var parent = Node.parent(r, path);\n            var index = path[path.length - 1];\n            parent.children.splice(index, 1);\n          }\n\n          if (Path.equals(path, end.path)) {\n            var leaf = Node.leaf(r, path);\n            leaf.text = leaf.text.slice(0, end.offset);\n          }\n\n          if (Path.equals(path, start.path)) {\n            var _leaf = Node.leaf(r, path);\n\n            _leaf.text = _leaf.text.slice(start.offset);\n          }\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n\n      if (Editor.isEditor(r)) {\n        r.selection = null;\n      }\n    });\n    return newRoot.children;\n  },\n\n  /**\r\n   * Get the descendant node referred to by a specific path. If the path is an\r\n   * empty array, it refers to the root node itself.\r\n   */\n  get: function get(root, path) {\n    var node = root;\n\n    for (var i = 0; i < path.length; i++) {\n      var p = path[i];\n\n      if (Text.isText(node) || !node.children[p]) {\n        throw new Error(\"Cannot find a descendant at path [\".concat(path, \"] in node: \").concat(Scrubber.stringify(root)));\n      }\n\n      node = node.children[p];\n    }\n\n    return node;\n  },\n\n  /**\r\n   * Check if a descendant node exists at a specific path.\r\n   */\n  has: function has(root, path) {\n    var node = root;\n\n    for (var i = 0; i < path.length; i++) {\n      var p = path[i];\n\n      if (Text.isText(node) || !node.children[p]) {\n        return false;\n      }\n\n      node = node.children[p];\n    }\n\n    return true;\n  },\n\n  /**\r\n   * Check if a value implements the `Node` interface.\r\n   */\n  isNode: function isNode(value) {\n    return Text.isText(value) || Element.isElement(value) || Editor.isEditor(value);\n  },\n\n  /**\r\n   * Check if a value is a list of `Node` objects.\r\n   */\n  isNodeList: function isNodeList(value) {\n    if (!Array.isArray(value)) {\n      return false;\n    }\n\n    var cachedResult = IS_NODE_LIST_CACHE.get(value);\n\n    if (cachedResult !== undefined) {\n      return cachedResult;\n    }\n\n    var isNodeList = value.every(function (val) {\n      return Node.isNode(val);\n    });\n    IS_NODE_LIST_CACHE.set(value, isNodeList);\n    return isNodeList;\n  },\n\n  /**\r\n   * Get the last node entry in a root node from a path.\r\n   */\n  last: function last(root, path) {\n    var p = path.slice();\n    var n = Node.get(root, p);\n\n    while (n) {\n      if (Text.isText(n) || n.children.length === 0) {\n        break;\n      } else {\n        var i = n.children.length - 1;\n        n = n.children[i];\n        p.push(i);\n      }\n    }\n\n    return [n, p];\n  },\n\n  /**\r\n   * Get the node at a specific path, ensuring it's a leaf text node.\r\n   */\n  leaf: function leaf(root, path) {\n    var node = Node.get(root, path);\n\n    if (!Text.isText(node)) {\n      throw new Error(\"Cannot get the leaf node at path [\".concat(path, \"] because it refers to a non-leaf node: \").concat(Scrubber.stringify(node)));\n    }\n\n    return node;\n  },\n\n  /**\r\n   * Return a generator of the in a branch of the tree, from a specific path.\r\n   *\r\n   * By default the order is top-down, from highest to lowest node in the tree,\r\n   * but you can pass the `reverse: true` option to go bottom-up.\r\n   */\n  levels: function* levels(root, path) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    var _iterator5 = _createForOfIteratorHelper$4(Path.levels(path, options)),\n        _step5;\n\n    try {\n      for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n        var p = _step5.value;\n        var n = Node.get(root, p);\n        yield [n, p];\n      }\n    } catch (err) {\n      _iterator5.e(err);\n    } finally {\n      _iterator5.f();\n    }\n  },\n\n  /**\r\n   * Check if a node matches a set of props.\r\n   */\n  matches: function matches(node, props) {\n    return Element.isElement(node) && Element.isElementProps(props) && Element.matches(node, props) || Text.isText(node) && Text.isTextProps(props) && Text.matches(node, props);\n  },\n\n  /**\r\n   * Return a generator of all the node entries of a root node. Each entry is\r\n   * returned as a `[Node, Path]` tuple, with the path referring to the node's\r\n   * position inside the root node.\r\n   */\n  nodes: function* nodes(root) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var pass = options.pass,\n        _options$reverse2 = options.reverse,\n        reverse = _options$reverse2 === void 0 ? false : _options$reverse2;\n    var _options$from = options.from,\n        from = _options$from === void 0 ? [] : _options$from,\n        to = options.to;\n    var visited = new Set();\n    var p = [];\n    var n = root;\n\n    while (true) {\n      if (to && (reverse ? Path.isBefore(p, to) : Path.isAfter(p, to))) {\n        break;\n      }\n\n      if (!visited.has(n)) {\n        yield [n, p];\n      } // If we're allowed to go downward and we haven't descended yet, do.\n\n\n      if (!visited.has(n) && !Text.isText(n) && n.children.length !== 0 && (pass == null || pass([n, p]) === false)) {\n        visited.add(n);\n        var nextIndex = reverse ? n.children.length - 1 : 0;\n\n        if (Path.isAncestor(p, from)) {\n          nextIndex = from[p.length];\n        }\n\n        p = p.concat(nextIndex);\n        n = Node.get(root, p);\n        continue;\n      } // If we're at the root and we can't go down, we're done.\n\n\n      if (p.length === 0) {\n        break;\n      } // If we're going forward...\n\n\n      if (!reverse) {\n        var newPath = Path.next(p);\n\n        if (Node.has(root, newPath)) {\n          p = newPath;\n          n = Node.get(root, p);\n          continue;\n        }\n      } // If we're going backward...\n\n\n      if (reverse && p[p.length - 1] !== 0) {\n        var _newPath = Path.previous(p);\n\n        p = _newPath;\n        n = Node.get(root, p);\n        continue;\n      } // Otherwise we're going upward...\n\n\n      p = Path.parent(p);\n      n = Node.get(root, p);\n      visited.add(n);\n    }\n  },\n\n  /**\r\n   * Get the parent of a node at a specific path.\r\n   */\n  parent: function parent(root, path) {\n    var parentPath = Path.parent(path);\n    var p = Node.get(root, parentPath);\n\n    if (Text.isText(p)) {\n      throw new Error(\"Cannot get the parent of path [\".concat(path, \"] because it does not exist in the root.\"));\n    }\n\n    return p;\n  },\n\n  /**\r\n   * Get the concatenated text string of a node's content.\r\n   *\r\n   * Note that this will not include spaces or line breaks between block nodes.\r\n   * It is not a user-facing string, but a string for performing offset-related\r\n   * computations for a node.\r\n   */\n  string: function string(node) {\n    if (Text.isText(node)) {\n      return node.text;\n    } else {\n      return node.children.map(Node.string).join('');\n    }\n  },\n\n  /**\r\n   * Return a generator of all leaf text nodes in a root node.\r\n   */\n  texts: function* texts(root) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    var _iterator6 = _createForOfIteratorHelper$4(Node.nodes(root, options)),\n        _step6;\n\n    try {\n      for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n        var _step6$value = _slicedToArray(_step6.value, 2),\n            node = _step6$value[0],\n            path = _step6$value[1];\n\n        if (Text.isText(node)) {\n          yield [node, path];\n        }\n      }\n    } catch (err) {\n      _iterator6.e(err);\n    } finally {\n      _iterator6.f();\n    }\n  }\n};\n\nfunction ownKeys$7(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread$7(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$7(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$7(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nvar Operation = {\n  /**\r\n   * Check if a value is a `NodeOperation` object.\r\n   */\n  isNodeOperation: function isNodeOperation(value) {\n    return Operation.isOperation(value) && value.type.endsWith('_node');\n  },\n\n  /**\r\n   * Check if a value is an `Operation` object.\r\n   */\n  isOperation: function isOperation(value) {\n    if (!isPlainObject.isPlainObject(value)) {\n      return false;\n    }\n\n    switch (value.type) {\n      case 'insert_node':\n        return Path.isPath(value.path) && Node.isNode(value.node);\n\n      case 'insert_text':\n        return typeof value.offset === 'number' && typeof value.text === 'string' && Path.isPath(value.path);\n\n      case 'merge_node':\n        return typeof value.position === 'number' && Path.isPath(value.path) && isPlainObject.isPlainObject(value.properties);\n\n      case 'move_node':\n        return Path.isPath(value.path) && Path.isPath(value.newPath);\n\n      case 'remove_node':\n        return Path.isPath(value.path) && Node.isNode(value.node);\n\n      case 'remove_text':\n        return typeof value.offset === 'number' && typeof value.text === 'string' && Path.isPath(value.path);\n\n      case 'set_node':\n        return Path.isPath(value.path) && isPlainObject.isPlainObject(value.properties) && isPlainObject.isPlainObject(value.newProperties);\n\n      case 'set_selection':\n        return value.properties === null && Range.isRange(value.newProperties) || value.newProperties === null && Range.isRange(value.properties) || isPlainObject.isPlainObject(value.properties) && isPlainObject.isPlainObject(value.newProperties);\n\n      case 'split_node':\n        return Path.isPath(value.path) && typeof value.position === 'number' && isPlainObject.isPlainObject(value.properties);\n\n      default:\n        return false;\n    }\n  },\n\n  /**\r\n   * Check if a value is a list of `Operation` objects.\r\n   */\n  isOperationList: function isOperationList(value) {\n    return Array.isArray(value) && value.every(function (val) {\n      return Operation.isOperation(val);\n    });\n  },\n\n  /**\r\n   * Check if a value is a `SelectionOperation` object.\r\n   */\n  isSelectionOperation: function isSelectionOperation(value) {\n    return Operation.isOperation(value) && value.type.endsWith('_selection');\n  },\n\n  /**\r\n   * Check if a value is a `TextOperation` object.\r\n   */\n  isTextOperation: function isTextOperation(value) {\n    return Operation.isOperation(value) && value.type.endsWith('_text');\n  },\n\n  /**\r\n   * Invert an operation, returning a new operation that will exactly undo the\r\n   * original when applied.\r\n   */\n  inverse: function inverse(op) {\n    switch (op.type) {\n      case 'insert_node':\n        {\n          return _objectSpread$7(_objectSpread$7({}, op), {}, {\n            type: 'remove_node'\n          });\n        }\n\n      case 'insert_text':\n        {\n          return _objectSpread$7(_objectSpread$7({}, op), {}, {\n            type: 'remove_text'\n          });\n        }\n\n      case 'merge_node':\n        {\n          return _objectSpread$7(_objectSpread$7({}, op), {}, {\n            type: 'split_node',\n            path: Path.previous(op.path)\n          });\n        }\n\n      case 'move_node':\n        {\n          var newPath = op.newPath,\n              path = op.path; // PERF: in this case the move operation is a no-op anyways.\n\n          if (Path.equals(newPath, path)) {\n            return op;\n          } // If the move happens completely within a single parent the path and\n          // newPath are stable with respect to each other.\n\n\n          if (Path.isSibling(path, newPath)) {\n            return _objectSpread$7(_objectSpread$7({}, op), {}, {\n              path: newPath,\n              newPath: path\n            });\n          } // If the move does not happen within a single parent it is possible\n          // for the move to impact the true path to the location where the node\n          // was removed from and where it was inserted. We have to adjust for this\n          // and find the original path. We can accomplish this (only in non-sibling)\n          // moves by looking at the impact of the move operation on the node\n          // after the original move path.\n\n\n          var inversePath = Path.transform(path, op);\n          var inverseNewPath = Path.transform(Path.next(path), op);\n          return _objectSpread$7(_objectSpread$7({}, op), {}, {\n            path: inversePath,\n            newPath: inverseNewPath\n          });\n        }\n\n      case 'remove_node':\n        {\n          return _objectSpread$7(_objectSpread$7({}, op), {}, {\n            type: 'insert_node'\n          });\n        }\n\n      case 'remove_text':\n        {\n          return _objectSpread$7(_objectSpread$7({}, op), {}, {\n            type: 'insert_text'\n          });\n        }\n\n      case 'set_node':\n        {\n          var properties = op.properties,\n              newProperties = op.newProperties;\n          return _objectSpread$7(_objectSpread$7({}, op), {}, {\n            properties: newProperties,\n            newProperties: properties\n          });\n        }\n\n      case 'set_selection':\n        {\n          var _properties = op.properties,\n              _newProperties = op.newProperties;\n\n          if (_properties == null) {\n            return _objectSpread$7(_objectSpread$7({}, op), {}, {\n              properties: _newProperties,\n              newProperties: null\n            });\n          } else if (_newProperties == null) {\n            return _objectSpread$7(_objectSpread$7({}, op), {}, {\n              properties: null,\n              newProperties: _properties\n            });\n          } else {\n            return _objectSpread$7(_objectSpread$7({}, op), {}, {\n              properties: _newProperties,\n              newProperties: _properties\n            });\n          }\n        }\n\n      case 'split_node':\n        {\n          return _objectSpread$7(_objectSpread$7({}, op), {}, {\n            type: 'merge_node',\n            path: Path.next(op.path)\n          });\n        }\n    }\n  }\n};\n\n// eslint-disable-next-line no-redeclare\nvar Path = {\n  /**\r\n   * Get a list of ancestor paths for a given path.\r\n   *\r\n   * The paths are sorted from shallowest to deepest ancestor. However, if the\r\n   * `reverse: true` option is passed, they are reversed.\r\n   */\n  ancestors: function ancestors(path) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var _options$reverse = options.reverse,\n        reverse = _options$reverse === void 0 ? false : _options$reverse;\n    var paths = Path.levels(path, options);\n\n    if (reverse) {\n      paths = paths.slice(1);\n    } else {\n      paths = paths.slice(0, -1);\n    }\n\n    return paths;\n  },\n\n  /**\r\n   * Get the common ancestor path of two paths.\r\n   */\n  common: function common(path, another) {\n    var common = [];\n\n    for (var i = 0; i < path.length && i < another.length; i++) {\n      var av = path[i];\n      var bv = another[i];\n\n      if (av !== bv) {\n        break;\n      }\n\n      common.push(av);\n    }\n\n    return common;\n  },\n\n  /**\r\n   * Compare a path to another, returning an integer indicating whether the path\r\n   * was before, at, or after the other.\r\n   *\r\n   * Note: Two paths of unequal length can still receive a `0` result if one is\r\n   * directly above or below the other. If you want exact matching, use\r\n   * [[Path.equals]] instead.\r\n   */\n  compare: function compare(path, another) {\n    var min = Math.min(path.length, another.length);\n\n    for (var i = 0; i < min; i++) {\n      if (path[i] < another[i]) return -1;\n      if (path[i] > another[i]) return 1;\n    }\n\n    return 0;\n  },\n\n  /**\r\n   * Check if a path ends after one of the indexes in another.\r\n   */\n  endsAfter: function endsAfter(path, another) {\n    var i = path.length - 1;\n    var as = path.slice(0, i);\n    var bs = another.slice(0, i);\n    var av = path[i];\n    var bv = another[i];\n    return Path.equals(as, bs) && av > bv;\n  },\n\n  /**\r\n   * Check if a path ends at one of the indexes in another.\r\n   */\n  endsAt: function endsAt(path, another) {\n    var i = path.length;\n    var as = path.slice(0, i);\n    var bs = another.slice(0, i);\n    return Path.equals(as, bs);\n  },\n\n  /**\r\n   * Check if a path ends before one of the indexes in another.\r\n   */\n  endsBefore: function endsBefore(path, another) {\n    var i = path.length - 1;\n    var as = path.slice(0, i);\n    var bs = another.slice(0, i);\n    var av = path[i];\n    var bv = another[i];\n    return Path.equals(as, bs) && av < bv;\n  },\n\n  /**\r\n   * Check if a path is exactly equal to another.\r\n   */\n  equals: function equals(path, another) {\n    return path.length === another.length && path.every(function (n, i) {\n      return n === another[i];\n    });\n  },\n\n  /**\r\n   * Check if the path of previous sibling node exists\r\n   */\n  hasPrevious: function hasPrevious(path) {\n    return path[path.length - 1] > 0;\n  },\n\n  /**\r\n   * Check if a path is after another.\r\n   */\n  isAfter: function isAfter(path, another) {\n    return Path.compare(path, another) === 1;\n  },\n\n  /**\r\n   * Check if a path is an ancestor of another.\r\n   */\n  isAncestor: function isAncestor(path, another) {\n    return path.length < another.length && Path.compare(path, another) === 0;\n  },\n\n  /**\r\n   * Check if a path is before another.\r\n   */\n  isBefore: function isBefore(path, another) {\n    return Path.compare(path, another) === -1;\n  },\n\n  /**\r\n   * Check if a path is a child of another.\r\n   */\n  isChild: function isChild(path, another) {\n    return path.length === another.length + 1 && Path.compare(path, another) === 0;\n  },\n\n  /**\r\n   * Check if a path is equal to or an ancestor of another.\r\n   */\n  isCommon: function isCommon(path, another) {\n    return path.length <= another.length && Path.compare(path, another) === 0;\n  },\n\n  /**\r\n   * Check if a path is a descendant of another.\r\n   */\n  isDescendant: function isDescendant(path, another) {\n    return path.length > another.length && Path.compare(path, another) === 0;\n  },\n\n  /**\r\n   * Check if a path is the parent of another.\r\n   */\n  isParent: function isParent(path, another) {\n    return path.length + 1 === another.length && Path.compare(path, another) === 0;\n  },\n\n  /**\r\n   * Check is a value implements the `Path` interface.\r\n   */\n  isPath: function isPath(value) {\n    return Array.isArray(value) && (value.length === 0 || typeof value[0] === 'number');\n  },\n\n  /**\r\n   * Check if a path is a sibling of another.\r\n   */\n  isSibling: function isSibling(path, another) {\n    if (path.length !== another.length) {\n      return false;\n    }\n\n    var as = path.slice(0, -1);\n    var bs = another.slice(0, -1);\n    var al = path[path.length - 1];\n    var bl = another[another.length - 1];\n    return al !== bl && Path.equals(as, bs);\n  },\n\n  /**\r\n   * Get a list of paths at every level down to a path. Note: this is the same\r\n   * as `Path.ancestors`, but including the path itself.\r\n   *\r\n   * The paths are sorted from shallowest to deepest. However, if the `reverse:\r\n   * true` option is passed, they are reversed.\r\n   */\n  levels: function levels(path) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var _options$reverse2 = options.reverse,\n        reverse = _options$reverse2 === void 0 ? false : _options$reverse2;\n    var list = [];\n\n    for (var i = 0; i <= path.length; i++) {\n      list.push(path.slice(0, i));\n    }\n\n    if (reverse) {\n      list.reverse();\n    }\n\n    return list;\n  },\n\n  /**\r\n   * Given a path, get the path to the next sibling node.\r\n   */\n  next: function next(path) {\n    if (path.length === 0) {\n      throw new Error(\"Cannot get the next path of a root path [\".concat(path, \"], because it has no next index.\"));\n    }\n\n    var last = path[path.length - 1];\n    return path.slice(0, -1).concat(last + 1);\n  },\n\n  /**\r\n   * Returns whether this operation can affect paths or not. Used as an\r\n   * optimization when updating dirty paths during normalization\r\n   *\r\n   * NOTE: This *must* be kept in sync with the implementation of 'transform'\r\n   * below\r\n   */\n  operationCanTransformPath: function operationCanTransformPath(operation) {\n    switch (operation.type) {\n      case 'insert_node':\n      case 'remove_node':\n      case 'merge_node':\n      case 'split_node':\n      case 'move_node':\n        return true;\n\n      default:\n        return false;\n    }\n  },\n\n  /**\r\n   * Given a path, return a new path referring to the parent node above it.\r\n   */\n  parent: function parent(path) {\n    if (path.length === 0) {\n      throw new Error(\"Cannot get the parent path of the root path [\".concat(path, \"].\"));\n    }\n\n    return path.slice(0, -1);\n  },\n\n  /**\r\n   * Given a path, get the path to the previous sibling node.\r\n   */\n  previous: function previous(path) {\n    if (path.length === 0) {\n      throw new Error(\"Cannot get the previous path of a root path [\".concat(path, \"], because it has no previous index.\"));\n    }\n\n    var last = path[path.length - 1];\n\n    if (last <= 0) {\n      throw new Error(\"Cannot get the previous path of a first child path [\".concat(path, \"] because it would result in a negative index.\"));\n    }\n\n    return path.slice(0, -1).concat(last - 1);\n  },\n\n  /**\r\n   * Get a path relative to an ancestor.\r\n   */\n  relative: function relative(path, ancestor) {\n    if (!Path.isAncestor(ancestor, path) && !Path.equals(path, ancestor)) {\n      throw new Error(\"Cannot get the relative path of [\".concat(path, \"] inside ancestor [\").concat(ancestor, \"], because it is not above or equal to the path.\"));\n    }\n\n    return path.slice(ancestor.length);\n  },\n\n  /**\r\n   * Transform a path by an operation.\r\n   */\n  transform: function transform(path, operation) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    if (!path) return null; // PERF: use destructing instead of immer\n\n    var p = _toConsumableArray(path);\n\n    var _options$affinity = options.affinity,\n        affinity = _options$affinity === void 0 ? 'forward' : _options$affinity; // PERF: Exit early if the operation is guaranteed not to have an effect.\n\n    if (path.length === 0) {\n      return p;\n    }\n\n    switch (operation.type) {\n      case 'insert_node':\n        {\n          var op = operation.path;\n\n          if (Path.equals(op, p) || Path.endsBefore(op, p) || Path.isAncestor(op, p)) {\n            p[op.length - 1] += 1;\n          }\n\n          break;\n        }\n\n      case 'remove_node':\n        {\n          var _op = operation.path;\n\n          if (Path.equals(_op, p) || Path.isAncestor(_op, p)) {\n            return null;\n          } else if (Path.endsBefore(_op, p)) {\n            p[_op.length - 1] -= 1;\n          }\n\n          break;\n        }\n\n      case 'merge_node':\n        {\n          var _op2 = operation.path,\n              position = operation.position;\n\n          if (Path.equals(_op2, p) || Path.endsBefore(_op2, p)) {\n            p[_op2.length - 1] -= 1;\n          } else if (Path.isAncestor(_op2, p)) {\n            p[_op2.length - 1] -= 1;\n            p[_op2.length] += position;\n          }\n\n          break;\n        }\n\n      case 'split_node':\n        {\n          var _op3 = operation.path,\n              _position = operation.position;\n\n          if (Path.equals(_op3, p)) {\n            if (affinity === 'forward') {\n              p[p.length - 1] += 1;\n            } else if (affinity === 'backward') ; else {\n              return null;\n            }\n          } else if (Path.endsBefore(_op3, p)) {\n            p[_op3.length - 1] += 1;\n          } else if (Path.isAncestor(_op3, p) && path[_op3.length] >= _position) {\n            p[_op3.length - 1] += 1;\n            p[_op3.length] -= _position;\n          }\n\n          break;\n        }\n\n      case 'move_node':\n        {\n          var _op4 = operation.path,\n              onp = operation.newPath; // If the old and new path are the same, it's a no-op.\n\n          if (Path.equals(_op4, onp)) {\n            return p;\n          }\n\n          if (Path.isAncestor(_op4, p) || Path.equals(_op4, p)) {\n            var copy = onp.slice();\n\n            if (Path.endsBefore(_op4, onp) && _op4.length < onp.length) {\n              copy[_op4.length - 1] -= 1;\n            }\n\n            return copy.concat(p.slice(_op4.length));\n          } else if (Path.isSibling(_op4, onp) && (Path.isAncestor(onp, p) || Path.equals(onp, p))) {\n            if (Path.endsBefore(_op4, p)) {\n              p[_op4.length - 1] -= 1;\n            } else {\n              p[_op4.length - 1] += 1;\n            }\n          } else if (Path.endsBefore(onp, p) || Path.equals(onp, p) || Path.isAncestor(onp, p)) {\n            if (Path.endsBefore(_op4, p)) {\n              p[_op4.length - 1] -= 1;\n            }\n\n            p[onp.length - 1] += 1;\n          } else if (Path.endsBefore(_op4, p)) {\n            if (Path.equals(onp, p)) {\n              p[onp.length - 1] += 1;\n            }\n\n            p[_op4.length - 1] -= 1;\n          }\n\n          break;\n        }\n    }\n\n    return p;\n  }\n};\n\nvar PathRef = {\n  /**\r\n   * Transform the path ref's current value by an operation.\r\n   */\n  transform: function transform(ref, op) {\n    var current = ref.current,\n        affinity = ref.affinity;\n\n    if (current == null) {\n      return;\n    }\n\n    var path = Path.transform(current, op, {\n      affinity: affinity\n    });\n    ref.current = path;\n\n    if (path == null) {\n      ref.unref();\n    }\n  }\n};\n\nfunction ownKeys$6(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread$6(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$6(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$6(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nvar Point = {\n  /**\r\n   * Compare a point to another, returning an integer indicating whether the\r\n   * point was before, at, or after the other.\r\n   */\n  compare: function compare(point, another) {\n    var result = Path.compare(point.path, another.path);\n\n    if (result === 0) {\n      if (point.offset < another.offset) return -1;\n      if (point.offset > another.offset) return 1;\n      return 0;\n    }\n\n    return result;\n  },\n\n  /**\r\n   * Check if a point is after another.\r\n   */\n  isAfter: function isAfter(point, another) {\n    return Point.compare(point, another) === 1;\n  },\n\n  /**\r\n   * Check if a point is before another.\r\n   */\n  isBefore: function isBefore(point, another) {\n    return Point.compare(point, another) === -1;\n  },\n\n  /**\r\n   * Check if a point is exactly equal to another.\r\n   */\n  equals: function equals(point, another) {\n    // PERF: ensure the offsets are equal first since they are cheaper to check.\n    return point.offset === another.offset && Path.equals(point.path, another.path);\n  },\n\n  /**\r\n   * Check if a value implements the `Point` interface.\r\n   */\n  isPoint: function isPoint(value) {\n    return isPlainObject.isPlainObject(value) && typeof value.offset === 'number' && Path.isPath(value.path);\n  },\n\n  /**\r\n   * Transform a point by an operation.\r\n   */\n  transform: function transform(point, op) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    return immer.produce(point, function (p) {\n      if (p === null) {\n        return null;\n      }\n\n      var _options$affinity = options.affinity,\n          affinity = _options$affinity === void 0 ? 'forward' : _options$affinity;\n      var path = p.path,\n          offset = p.offset;\n\n      switch (op.type) {\n        case 'insert_node':\n        case 'move_node':\n          {\n            p.path = Path.transform(path, op, options);\n            break;\n          }\n\n        case 'insert_text':\n          {\n            if (Path.equals(op.path, path) && (op.offset < offset || op.offset === offset && affinity === 'forward')) {\n              p.offset += op.text.length;\n            }\n\n            break;\n          }\n\n        case 'merge_node':\n          {\n            if (Path.equals(op.path, path)) {\n              p.offset += op.position;\n            }\n\n            p.path = Path.transform(path, op, options);\n            break;\n          }\n\n        case 'remove_text':\n          {\n            if (Path.equals(op.path, path) && op.offset <= offset) {\n              p.offset -= Math.min(offset - op.offset, op.text.length);\n            }\n\n            break;\n          }\n\n        case 'remove_node':\n          {\n            if (Path.equals(op.path, path) || Path.isAncestor(op.path, path)) {\n              return null;\n            }\n\n            p.path = Path.transform(path, op, options);\n            break;\n          }\n\n        case 'split_node':\n          {\n            if (Path.equals(op.path, path)) {\n              if (op.position === offset && affinity == null) {\n                return null;\n              } else if (op.position < offset || op.position === offset && affinity === 'forward') {\n                p.offset -= op.position;\n                p.path = Path.transform(path, op, _objectSpread$6(_objectSpread$6({}, options), {}, {\n                  affinity: 'forward'\n                }));\n              }\n            } else {\n              p.path = Path.transform(path, op, options);\n            }\n\n            break;\n          }\n      }\n    });\n  }\n};\n\nvar PointRef = {\n  /**\r\n   * Transform the point ref's current value by an operation.\r\n   */\n  transform: function transform(ref, op) {\n    var current = ref.current,\n        affinity = ref.affinity;\n\n    if (current == null) {\n      return;\n    }\n\n    var point = Point.transform(current, op, {\n      affinity: affinity\n    });\n    ref.current = point;\n\n    if (point == null) {\n      ref.unref();\n    }\n  }\n};\n\nvar _excluded$2 = [\"anchor\", \"focus\"];\n\nfunction ownKeys$5(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread$5(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$5(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$5(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nvar Range = {\n  /**\r\n   * Get the start and end points of a range, in the order in which they appear\r\n   * in the document.\r\n   */\n  edges: function edges(range) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var _options$reverse = options.reverse,\n        reverse = _options$reverse === void 0 ? false : _options$reverse;\n    var anchor = range.anchor,\n        focus = range.focus;\n    return Range.isBackward(range) === reverse ? [anchor, focus] : [focus, anchor];\n  },\n\n  /**\r\n   * Get the end point of a range.\r\n   */\n  end: function end(range) {\n    var _Range$edges = Range.edges(range),\n        _Range$edges2 = _slicedToArray(_Range$edges, 2),\n        end = _Range$edges2[1];\n\n    return end;\n  },\n\n  /**\r\n   * Check if a range is exactly equal to another.\r\n   */\n  equals: function equals(range, another) {\n    return Point.equals(range.anchor, another.anchor) && Point.equals(range.focus, another.focus);\n  },\n\n  /**\r\n   * Check if a range includes a path, a point or part of another range.\r\n   */\n  includes: function includes(range, target) {\n    if (Range.isRange(target)) {\n      if (Range.includes(range, target.anchor) || Range.includes(range, target.focus)) {\n        return true;\n      }\n\n      var _Range$edges3 = Range.edges(range),\n          _Range$edges4 = _slicedToArray(_Range$edges3, 2),\n          rs = _Range$edges4[0],\n          re = _Range$edges4[1];\n\n      var _Range$edges5 = Range.edges(target),\n          _Range$edges6 = _slicedToArray(_Range$edges5, 2),\n          ts = _Range$edges6[0],\n          te = _Range$edges6[1];\n\n      return Point.isBefore(rs, ts) && Point.isAfter(re, te);\n    }\n\n    var _Range$edges7 = Range.edges(range),\n        _Range$edges8 = _slicedToArray(_Range$edges7, 2),\n        start = _Range$edges8[0],\n        end = _Range$edges8[1];\n\n    var isAfterStart = false;\n    var isBeforeEnd = false;\n\n    if (Point.isPoint(target)) {\n      isAfterStart = Point.compare(target, start) >= 0;\n      isBeforeEnd = Point.compare(target, end) <= 0;\n    } else {\n      isAfterStart = Path.compare(target, start.path) >= 0;\n      isBeforeEnd = Path.compare(target, end.path) <= 0;\n    }\n\n    return isAfterStart && isBeforeEnd;\n  },\n\n  /**\r\n   * Get the intersection of a range with another.\r\n   */\n  intersection: function intersection(range, another) {\n    range.anchor;\n        range.focus;\n        var rest = _objectWithoutProperties(range, _excluded$2);\n\n    var _Range$edges9 = Range.edges(range),\n        _Range$edges10 = _slicedToArray(_Range$edges9, 2),\n        s1 = _Range$edges10[0],\n        e1 = _Range$edges10[1];\n\n    var _Range$edges11 = Range.edges(another),\n        _Range$edges12 = _slicedToArray(_Range$edges11, 2),\n        s2 = _Range$edges12[0],\n        e2 = _Range$edges12[1];\n\n    var start = Point.isBefore(s1, s2) ? s2 : s1;\n    var end = Point.isBefore(e1, e2) ? e1 : e2;\n\n    if (Point.isBefore(end, start)) {\n      return null;\n    } else {\n      return _objectSpread$5({\n        anchor: start,\n        focus: end\n      }, rest);\n    }\n  },\n\n  /**\r\n   * Check if a range is backward, meaning that its anchor point appears in the\r\n   * document _after_ its focus point.\r\n   */\n  isBackward: function isBackward(range) {\n    var anchor = range.anchor,\n        focus = range.focus;\n    return Point.isAfter(anchor, focus);\n  },\n\n  /**\r\n   * Check if a range is collapsed, meaning that both its anchor and focus\r\n   * points refer to the exact same position in the document.\r\n   */\n  isCollapsed: function isCollapsed(range) {\n    var anchor = range.anchor,\n        focus = range.focus;\n    return Point.equals(anchor, focus);\n  },\n\n  /**\r\n   * Check if a range is expanded.\r\n   *\r\n   * This is the opposite of [[Range.isCollapsed]] and is provided for legibility.\r\n   */\n  isExpanded: function isExpanded(range) {\n    return !Range.isCollapsed(range);\n  },\n\n  /**\r\n   * Check if a range is forward.\r\n   *\r\n   * This is the opposite of [[Range.isBackward]] and is provided for legibility.\r\n   */\n  isForward: function isForward(range) {\n    return !Range.isBackward(range);\n  },\n\n  /**\r\n   * Check if a value implements the [[Range]] interface.\r\n   */\n  isRange: function isRange(value) {\n    return isPlainObject.isPlainObject(value) && Point.isPoint(value.anchor) && Point.isPoint(value.focus);\n  },\n\n  /**\r\n   * Iterate through all of the point entries in a range.\r\n   */\n  points: function* points(range) {\n    yield [range.anchor, 'anchor'];\n    yield [range.focus, 'focus'];\n  },\n\n  /**\r\n   * Get the start point of a range.\r\n   */\n  start: function start(range) {\n    var _Range$edges13 = Range.edges(range),\n        _Range$edges14 = _slicedToArray(_Range$edges13, 1),\n        start = _Range$edges14[0];\n\n    return start;\n  },\n\n  /**\r\n   * Transform a range by an operation.\r\n   */\n  transform: function transform(range, op) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    return immer.produce(range, function (r) {\n      if (r === null) {\n        return null;\n      }\n\n      var _options$affinity = options.affinity,\n          affinity = _options$affinity === void 0 ? 'inward' : _options$affinity;\n      var affinityAnchor;\n      var affinityFocus;\n\n      if (affinity === 'inward') {\n        // If the range is collapsed, make sure to use the same affinity to\n        // avoid the two points passing each other and expanding in the opposite\n        // direction\n        var isCollapsed = Range.isCollapsed(r);\n\n        if (Range.isForward(r)) {\n          affinityAnchor = 'forward';\n          affinityFocus = isCollapsed ? affinityAnchor : 'backward';\n        } else {\n          affinityAnchor = 'backward';\n          affinityFocus = isCollapsed ? affinityAnchor : 'forward';\n        }\n      } else if (affinity === 'outward') {\n        if (Range.isForward(r)) {\n          affinityAnchor = 'backward';\n          affinityFocus = 'forward';\n        } else {\n          affinityAnchor = 'forward';\n          affinityFocus = 'backward';\n        }\n      } else {\n        affinityAnchor = affinity;\n        affinityFocus = affinity;\n      }\n\n      var anchor = Point.transform(r.anchor, op, {\n        affinity: affinityAnchor\n      });\n      var focus = Point.transform(r.focus, op, {\n        affinity: affinityFocus\n      });\n\n      if (!anchor || !focus) {\n        return null;\n      }\n\n      r.anchor = anchor;\n      r.focus = focus;\n    });\n  }\n};\n\nvar RangeRef = {\n  /**\r\n   * Transform the range ref's current value by an operation.\r\n   */\n  transform: function transform(ref, op) {\n    var current = ref.current,\n        affinity = ref.affinity;\n\n    if (current == null) {\n      return;\n    }\n\n    var path = Range.transform(current, op, {\n      affinity: affinity\n    });\n    ref.current = path;\n\n    if (path == null) {\n      ref.unref();\n    }\n  }\n};\n\nvar _scrubber = undefined;\n/**\r\n * This interface implements a stringify() function, which is used by Slate\r\n * internally when generating exceptions containing end user data. Developers\r\n * using Slate may call Scrubber.setScrubber() to alter the behavior of this\r\n * stringify() function.\r\n *\r\n * For example, to prevent the cleartext logging of 'text' fields within Nodes:\r\n *\r\n *    import { Scrubber } from 'slate';\r\n *    Scrubber.setScrubber((key, val) => {\r\n *      if (key === 'text') return '...scrubbed...'\r\n *      return val\r\n *    });\r\n *\r\n */\n// eslint-disable-next-line no-redeclare\n\nvar Scrubber = {\n  setScrubber: function setScrubber(scrubber) {\n    _scrubber = scrubber;\n  },\n  stringify: function stringify(value) {\n    return JSON.stringify(value, _scrubber);\n  }\n};\n\n/*\r\n  Custom deep equal comparison for Slate nodes.\r\n\n  We don't need general purpose deep equality;\r\n  Slate only supports plain values, Arrays, and nested objects.\r\n  Complex values nested inside Arrays are not supported.\r\n\n  Slate objects are designed to be serialised, so\r\n  missing keys are deliberately normalised to undefined.\r\n */\n\nvar isDeepEqual = function isDeepEqual(node, another) {\n  for (var key in node) {\n    var a = node[key];\n    var b = another[key];\n\n    if (isPlainObject.isPlainObject(a) && isPlainObject.isPlainObject(b)) {\n      if (!isDeepEqual(a, b)) return false;\n    } else if (Array.isArray(a) && Array.isArray(b)) {\n      if (a.length !== b.length) return false;\n\n      for (var i = 0; i < a.length; i++) {\n        if (a[i] !== b[i]) return false;\n      }\n    } else if (a !== b) {\n      return false;\n    }\n  }\n  /*\r\n    Deep object equality is only necessary in one direction; in the reverse direction\r\n    we are only looking for keys that are missing.\r\n    As above, undefined keys are normalised to missing.\r\n  */\n\n\n  for (var _key in another) {\n    if (node[_key] === undefined && another[_key] !== undefined) {\n      return false;\n    }\n  }\n\n  return true;\n};\n\nvar _excluded$1 = [\"text\"],\n    _excluded2$1 = [\"anchor\", \"focus\"];\n\nfunction _createForOfIteratorHelper$3(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$3(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray$3(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray$3(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$3(o, minLen); }\n\nfunction _arrayLikeToArray$3(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction ownKeys$4(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread$4(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$4(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$4(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nvar Text = {\n  /**\r\n   * Check if two text nodes are equal.\r\n   *\r\n   * When loose is set, the text is not compared. This is\r\n   * used to check whether sibling text nodes can be merged.\r\n   */\n  equals: function equals(text, another) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var _options$loose = options.loose,\n        loose = _options$loose === void 0 ? false : _options$loose;\n\n    function omitText(obj) {\n      obj.text;\n          var rest = _objectWithoutProperties(obj, _excluded$1);\n\n      return rest;\n    }\n\n    return isDeepEqual(loose ? omitText(text) : text, loose ? omitText(another) : another);\n  },\n\n  /**\r\n   * Check if a value implements the `Text` interface.\r\n   */\n  isText: function isText(value) {\n    return isPlainObject.isPlainObject(value) && typeof value.text === 'string';\n  },\n\n  /**\r\n   * Check if a value is a list of `Text` objects.\r\n   */\n  isTextList: function isTextList(value) {\n    return Array.isArray(value) && value.every(function (val) {\n      return Text.isText(val);\n    });\n  },\n\n  /**\r\n   * Check if some props are a partial of Text.\r\n   */\n  isTextProps: function isTextProps(props) {\n    return props.text !== undefined;\n  },\n\n  /**\r\n   * Check if an text matches set of properties.\r\n   *\r\n   * Note: this is for matching custom properties, and it does not ensure that\r\n   * the `text` property are two nodes equal.\r\n   */\n  matches: function matches(text, props) {\n    for (var key in props) {\n      if (key === 'text') {\n        continue;\n      }\n\n      if (!text.hasOwnProperty(key) || text[key] !== props[key]) {\n        return false;\n      }\n    }\n\n    return true;\n  },\n\n  /**\r\n   * Get the leaves for a text node given decorations.\r\n   */\n  decorations: function decorations(node, _decorations) {\n    var leaves = [_objectSpread$4({}, node)];\n\n    var _iterator = _createForOfIteratorHelper$3(_decorations),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var dec = _step.value;\n\n        var anchor = dec.anchor,\n            focus = dec.focus,\n            rest = _objectWithoutProperties(dec, _excluded2$1);\n\n        var _Range$edges = Range.edges(dec),\n            _Range$edges2 = _slicedToArray(_Range$edges, 2),\n            start = _Range$edges2[0],\n            end = _Range$edges2[1];\n\n        var next = [];\n        var leafEnd = 0;\n        var decorationStart = start.offset;\n        var decorationEnd = end.offset;\n\n        var _iterator2 = _createForOfIteratorHelper$3(leaves),\n            _step2;\n\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var leaf = _step2.value;\n            var length = leaf.text.length;\n            var leafStart = leafEnd;\n            leafEnd += length; // If the range encompasses the entire leaf, add the range.\n\n            if (decorationStart <= leafStart && leafEnd <= decorationEnd) {\n              Object.assign(leaf, rest);\n              next.push(leaf);\n              continue;\n            } // If the range expanded and match the leaf, or starts after, or ends before it, continue.\n\n\n            if (decorationStart !== decorationEnd && (decorationStart === leafEnd || decorationEnd === leafStart) || decorationStart > leafEnd || decorationEnd < leafStart || decorationEnd === leafStart && leafStart !== 0) {\n              next.push(leaf);\n              continue;\n            } // Otherwise we need to split the leaf, at the start, end, or both,\n            // and add the range to the middle intersecting section. Do the end\n            // split first since we don't need to update the offset that way.\n\n\n            var middle = leaf;\n            var before = void 0;\n            var after = void 0;\n\n            if (decorationEnd < leafEnd) {\n              var off = decorationEnd - leafStart;\n              after = _objectSpread$4(_objectSpread$4({}, middle), {}, {\n                text: middle.text.slice(off)\n              });\n              middle = _objectSpread$4(_objectSpread$4({}, middle), {}, {\n                text: middle.text.slice(0, off)\n              });\n            }\n\n            if (decorationStart > leafStart) {\n              var _off = decorationStart - leafStart;\n\n              before = _objectSpread$4(_objectSpread$4({}, middle), {}, {\n                text: middle.text.slice(0, _off)\n              });\n              middle = _objectSpread$4(_objectSpread$4({}, middle), {}, {\n                text: middle.text.slice(_off)\n              });\n            }\n\n            Object.assign(middle, rest);\n\n            if (before) {\n              next.push(before);\n            }\n\n            next.push(middle);\n\n            if (after) {\n              next.push(after);\n            }\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n\n        leaves = next;\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n\n    return leaves;\n  }\n};\n\nfunction ownKeys$3(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread$3(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$3(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$3(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _createForOfIteratorHelper$2(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$2(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray$2(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray$2(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$2(o, minLen); }\n\nfunction _arrayLikeToArray$2(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nvar applyToDraft = function applyToDraft(editor, selection, op) {\n  switch (op.type) {\n    case 'insert_node':\n      {\n        var path = op.path,\n            node = op.node;\n        var parent = Node.parent(editor, path);\n        var index = path[path.length - 1];\n\n        if (index > parent.children.length) {\n          throw new Error(\"Cannot apply an \\\"insert_node\\\" operation at path [\".concat(path, \"] because the destination is past the end of the node.\"));\n        }\n\n        parent.children.splice(index, 0, node);\n\n        if (selection) {\n          var _iterator = _createForOfIteratorHelper$2(Range.points(selection)),\n              _step;\n\n          try {\n            for (_iterator.s(); !(_step = _iterator.n()).done;) {\n              var _step$value = _slicedToArray(_step.value, 2),\n                  point = _step$value[0],\n                  key = _step$value[1];\n\n              selection[key] = Point.transform(point, op);\n            }\n          } catch (err) {\n            _iterator.e(err);\n          } finally {\n            _iterator.f();\n          }\n        }\n\n        break;\n      }\n\n    case 'insert_text':\n      {\n        var _path = op.path,\n            offset = op.offset,\n            text = op.text;\n        if (text.length === 0) break;\n\n        var _node = Node.leaf(editor, _path);\n\n        var before = _node.text.slice(0, offset);\n\n        var after = _node.text.slice(offset);\n\n        _node.text = before + text + after;\n\n        if (selection) {\n          var _iterator2 = _createForOfIteratorHelper$2(Range.points(selection)),\n              _step2;\n\n          try {\n            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n              var _step2$value = _slicedToArray(_step2.value, 2),\n                  _point = _step2$value[0],\n                  _key = _step2$value[1];\n\n              selection[_key] = Point.transform(_point, op);\n            }\n          } catch (err) {\n            _iterator2.e(err);\n          } finally {\n            _iterator2.f();\n          }\n        }\n\n        break;\n      }\n\n    case 'merge_node':\n      {\n        var _path2 = op.path;\n\n        var _node2 = Node.get(editor, _path2);\n\n        var prevPath = Path.previous(_path2);\n        var prev = Node.get(editor, prevPath);\n\n        var _parent = Node.parent(editor, _path2);\n\n        var _index = _path2[_path2.length - 1];\n\n        if (Text.isText(_node2) && Text.isText(prev)) {\n          prev.text += _node2.text;\n        } else if (!Text.isText(_node2) && !Text.isText(prev)) {\n          var _prev$children;\n\n          (_prev$children = prev.children).push.apply(_prev$children, _toConsumableArray(_node2.children));\n        } else {\n          throw new Error(\"Cannot apply a \\\"merge_node\\\" operation at path [\".concat(_path2, \"] to nodes of different interfaces: \").concat(Scrubber.stringify(_node2), \" \").concat(Scrubber.stringify(prev)));\n        }\n\n        _parent.children.splice(_index, 1);\n\n        if (selection) {\n          var _iterator3 = _createForOfIteratorHelper$2(Range.points(selection)),\n              _step3;\n\n          try {\n            for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n              var _step3$value = _slicedToArray(_step3.value, 2),\n                  _point2 = _step3$value[0],\n                  _key2 = _step3$value[1];\n\n              selection[_key2] = Point.transform(_point2, op);\n            }\n          } catch (err) {\n            _iterator3.e(err);\n          } finally {\n            _iterator3.f();\n          }\n        }\n\n        break;\n      }\n\n    case 'move_node':\n      {\n        var _path3 = op.path,\n            newPath = op.newPath;\n\n        if (Path.isAncestor(_path3, newPath)) {\n          throw new Error(\"Cannot move a path [\".concat(_path3, \"] to new path [\").concat(newPath, \"] because the destination is inside itself.\"));\n        }\n\n        var _node3 = Node.get(editor, _path3);\n\n        var _parent2 = Node.parent(editor, _path3);\n\n        var _index2 = _path3[_path3.length - 1]; // This is tricky, but since the `path` and `newPath` both refer to\n        // the same snapshot in time, there's a mismatch. After either\n        // removing the original position, the second step's path can be out\n        // of date. So instead of using the `op.newPath` directly, we\n        // transform `op.path` to ascertain what the `newPath` would be after\n        // the operation was applied.\n\n        _parent2.children.splice(_index2, 1);\n\n        var truePath = Path.transform(_path3, op);\n        var newParent = Node.get(editor, Path.parent(truePath));\n        var newIndex = truePath[truePath.length - 1];\n        newParent.children.splice(newIndex, 0, _node3);\n\n        if (selection) {\n          var _iterator4 = _createForOfIteratorHelper$2(Range.points(selection)),\n              _step4;\n\n          try {\n            for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n              var _step4$value = _slicedToArray(_step4.value, 2),\n                  _point3 = _step4$value[0],\n                  _key3 = _step4$value[1];\n\n              selection[_key3] = Point.transform(_point3, op);\n            }\n          } catch (err) {\n            _iterator4.e(err);\n          } finally {\n            _iterator4.f();\n          }\n        }\n\n        break;\n      }\n\n    case 'remove_node':\n      {\n        var _path4 = op.path;\n        var _index3 = _path4[_path4.length - 1];\n\n        var _parent3 = Node.parent(editor, _path4);\n\n        _parent3.children.splice(_index3, 1); // Transform all of the points in the value, but if the point was in the\n        // node that was removed we need to update the range or remove it.\n\n\n        if (selection) {\n          var _iterator5 = _createForOfIteratorHelper$2(Range.points(selection)),\n              _step5;\n\n          try {\n            for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n              var _step5$value = _slicedToArray(_step5.value, 2),\n                  _point4 = _step5$value[0],\n                  _key4 = _step5$value[1];\n\n              var result = Point.transform(_point4, op);\n\n              if (selection != null && result != null) {\n                selection[_key4] = result;\n              } else {\n                var _prev = void 0;\n\n                var next = void 0;\n\n                var _iterator6 = _createForOfIteratorHelper$2(Node.texts(editor)),\n                    _step6;\n\n                try {\n                  for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n                    var _step6$value = _slicedToArray(_step6.value, 2),\n                        n = _step6$value[0],\n                        p = _step6$value[1];\n\n                    if (Path.compare(p, _path4) === -1) {\n                      _prev = [n, p];\n                    } else {\n                      next = [n, p];\n                      break;\n                    }\n                  }\n                } catch (err) {\n                  _iterator6.e(err);\n                } finally {\n                  _iterator6.f();\n                }\n\n                var preferNext = false;\n\n                if (_prev && next) {\n                  if (Path.equals(next[1], _path4)) {\n                    preferNext = !Path.hasPrevious(next[1]);\n                  } else {\n                    preferNext = Path.common(_prev[1], _path4).length < Path.common(next[1], _path4).length;\n                  }\n                }\n\n                if (_prev && !preferNext) {\n                  _point4.path = _prev[1];\n                  _point4.offset = _prev[0].text.length;\n                } else if (next) {\n                  _point4.path = next[1];\n                  _point4.offset = 0;\n                } else {\n                  selection = null;\n                }\n              }\n            }\n          } catch (err) {\n            _iterator5.e(err);\n          } finally {\n            _iterator5.f();\n          }\n        }\n\n        break;\n      }\n\n    case 'remove_text':\n      {\n        var _path5 = op.path,\n            _offset = op.offset,\n            _text = op.text;\n        if (_text.length === 0) break;\n\n        var _node4 = Node.leaf(editor, _path5);\n\n        var _before = _node4.text.slice(0, _offset);\n\n        var _after = _node4.text.slice(_offset + _text.length);\n\n        _node4.text = _before + _after;\n\n        if (selection) {\n          var _iterator7 = _createForOfIteratorHelper$2(Range.points(selection)),\n              _step7;\n\n          try {\n            for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n              var _step7$value = _slicedToArray(_step7.value, 2),\n                  _point5 = _step7$value[0],\n                  _key5 = _step7$value[1];\n\n              selection[_key5] = Point.transform(_point5, op);\n            }\n          } catch (err) {\n            _iterator7.e(err);\n          } finally {\n            _iterator7.f();\n          }\n        }\n\n        break;\n      }\n\n    case 'set_node':\n      {\n        var _path6 = op.path,\n            properties = op.properties,\n            newProperties = op.newProperties;\n\n        if (_path6.length === 0) {\n          throw new Error(\"Cannot set properties on the root node!\");\n        }\n\n        var _node5 = Node.get(editor, _path6);\n\n        for (var _key6 in newProperties) {\n          if (_key6 === 'children' || _key6 === 'text') {\n            throw new Error(\"Cannot set the \\\"\".concat(_key6, \"\\\" property of nodes!\"));\n          }\n\n          var value = newProperties[_key6];\n\n          if (value == null) {\n            delete _node5[_key6];\n          } else {\n            _node5[_key6] = value;\n          }\n        } // properties that were previously defined, but are now missing, must be deleted\n\n\n        for (var _key7 in properties) {\n          if (!newProperties.hasOwnProperty(_key7)) {\n            delete _node5[_key7];\n          }\n        }\n\n        break;\n      }\n\n    case 'set_selection':\n      {\n        var _newProperties = op.newProperties;\n\n        if (_newProperties == null) {\n          selection = _newProperties;\n        } else {\n          if (selection == null) {\n            if (!Range.isRange(_newProperties)) {\n              throw new Error(\"Cannot apply an incomplete \\\"set_selection\\\" operation properties \".concat(Scrubber.stringify(_newProperties), \" when there is no current selection.\"));\n            }\n\n            selection = _objectSpread$3({}, _newProperties);\n          }\n\n          for (var _key8 in _newProperties) {\n            var _value = _newProperties[_key8];\n\n            if (_value == null) {\n              if (_key8 === 'anchor' || _key8 === 'focus') {\n                throw new Error(\"Cannot remove the \\\"\".concat(_key8, \"\\\" selection property\"));\n              }\n\n              delete selection[_key8];\n            } else {\n              selection[_key8] = _value;\n            }\n          }\n        }\n\n        break;\n      }\n\n    case 'split_node':\n      {\n        var _path7 = op.path,\n            position = op.position,\n            _properties = op.properties;\n\n        if (_path7.length === 0) {\n          throw new Error(\"Cannot apply a \\\"split_node\\\" operation at path [\".concat(_path7, \"] because the root node cannot be split.\"));\n        }\n\n        var _node6 = Node.get(editor, _path7);\n\n        var _parent4 = Node.parent(editor, _path7);\n\n        var _index4 = _path7[_path7.length - 1];\n        var newNode;\n\n        if (Text.isText(_node6)) {\n          var _before2 = _node6.text.slice(0, position);\n\n          var _after2 = _node6.text.slice(position);\n\n          _node6.text = _before2;\n          newNode = _objectSpread$3(_objectSpread$3({}, _properties), {}, {\n            text: _after2\n          });\n        } else {\n          var _before3 = _node6.children.slice(0, position);\n\n          var _after3 = _node6.children.slice(position);\n\n          _node6.children = _before3;\n          newNode = _objectSpread$3(_objectSpread$3({}, _properties), {}, {\n            children: _after3\n          });\n        }\n\n        _parent4.children.splice(_index4 + 1, 0, newNode);\n\n        if (selection) {\n          var _iterator8 = _createForOfIteratorHelper$2(Range.points(selection)),\n              _step8;\n\n          try {\n            for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n              var _step8$value = _slicedToArray(_step8.value, 2),\n                  _point6 = _step8$value[0],\n                  _key9 = _step8$value[1];\n\n              selection[_key9] = Point.transform(_point6, op);\n            }\n          } catch (err) {\n            _iterator8.e(err);\n          } finally {\n            _iterator8.f();\n          }\n        }\n\n        break;\n      }\n  }\n\n  return selection;\n}; // eslint-disable-next-line no-redeclare\n\n\nvar GeneralTransforms = {\n  /**\r\n   * Transform the editor by an operation.\r\n   */\n  transform: function transform(editor, op) {\n    editor.children = immer.createDraft(editor.children);\n    var selection = editor.selection && immer.createDraft(editor.selection);\n\n    try {\n      selection = applyToDraft(editor, selection, op);\n    } finally {\n      editor.children = immer.finishDraft(editor.children);\n\n      if (selection) {\n        editor.selection = immer.isDraft(selection) ? immer.finishDraft(selection) : selection;\n      } else {\n        editor.selection = null;\n      }\n    }\n  }\n};\n\nvar _excluded = [\"text\"],\n    _excluded2 = [\"children\"];\n\nfunction ownKeys$2(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread$2(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$2(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$2(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _createForOfIteratorHelper$1(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$1(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray$1(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray$1(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$1(o, minLen); }\n\nfunction _arrayLikeToArray$1(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nvar NodeTransforms = {\n  /**\r\n   * Insert nodes at a specific location in the Editor.\r\n   */\n  insertNodes: function insertNodes(editor, nodes) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    Editor.withoutNormalizing(editor, function () {\n      var _options$hanging = options.hanging,\n          hanging = _options$hanging === void 0 ? false : _options$hanging,\n          _options$voids = options.voids,\n          voids = _options$voids === void 0 ? false : _options$voids,\n          _options$mode = options.mode,\n          mode = _options$mode === void 0 ? 'lowest' : _options$mode;\n      var at = options.at,\n          match = options.match,\n          select = options.select;\n\n      if (Node.isNode(nodes)) {\n        nodes = [nodes];\n      }\n\n      if (nodes.length === 0) {\n        return;\n      }\n\n      var _nodes = nodes,\n          _nodes2 = _slicedToArray(_nodes, 1),\n          node = _nodes2[0]; // By default, use the selection as the target location. But if there is\n      // no selection, insert at the end of the document since that is such a\n      // common use case when inserting from a non-selected state.\n\n\n      if (!at) {\n        if (editor.selection) {\n          at = editor.selection;\n        } else if (editor.children.length > 0) {\n          at = Editor.end(editor, []);\n        } else {\n          at = [0];\n        }\n\n        select = true;\n      }\n\n      if (select == null) {\n        select = false;\n      }\n\n      if (Range.isRange(at)) {\n        if (!hanging) {\n          at = Editor.unhangRange(editor, at, {\n            voids: voids\n          });\n        }\n\n        if (Range.isCollapsed(at)) {\n          at = at.anchor;\n        } else {\n          var _Range$edges = Range.edges(at),\n              _Range$edges2 = _slicedToArray(_Range$edges, 2),\n              end = _Range$edges2[1];\n\n          var pointRef = Editor.pointRef(editor, end);\n          Transforms[\"delete\"](editor, {\n            at: at\n          });\n          at = pointRef.unref();\n        }\n      }\n\n      if (Point.isPoint(at)) {\n        if (match == null) {\n          if (Text.isText(node)) {\n            match = function match(n) {\n              return Text.isText(n);\n            };\n          } else if (editor.isInline(node)) {\n            match = function match(n) {\n              return Text.isText(n) || Editor.isInline(editor, n);\n            };\n          } else {\n            match = function match(n) {\n              return Element.isElement(n) && Editor.isBlock(editor, n);\n            };\n          }\n        }\n\n        var _Editor$nodes = Editor.nodes(editor, {\n          at: at.path,\n          match: match,\n          mode: mode,\n          voids: voids\n        }),\n            _Editor$nodes2 = _slicedToArray(_Editor$nodes, 1),\n            entry = _Editor$nodes2[0];\n\n        if (entry) {\n          var _entry = _slicedToArray(entry, 2),\n              _matchPath = _entry[1];\n\n          var pathRef = Editor.pathRef(editor, _matchPath);\n          var isAtEnd = Editor.isEnd(editor, at, _matchPath);\n          Transforms.splitNodes(editor, {\n            at: at,\n            match: match,\n            mode: mode,\n            voids: voids\n          });\n          var path = pathRef.unref();\n          at = isAtEnd ? Path.next(path) : path;\n        } else {\n          return;\n        }\n      }\n\n      var parentPath = Path.parent(at);\n      var index = at[at.length - 1];\n\n      if (!voids && Editor[\"void\"](editor, {\n        at: parentPath\n      })) {\n        return;\n      }\n\n      var _iterator = _createForOfIteratorHelper$1(nodes),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var _node = _step.value;\n\n          var _path = parentPath.concat(index);\n\n          index++;\n          editor.apply({\n            type: 'insert_node',\n            path: _path,\n            node: _node\n          });\n          at = Path.next(at);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      at = Path.previous(at);\n\n      if (select) {\n        var point = Editor.end(editor, at);\n\n        if (point) {\n          Transforms.select(editor, point);\n        }\n      }\n    });\n  },\n\n  /**\r\n   * Lift nodes at a specific location upwards in the document tree, splitting\r\n   * their parent in two if necessary.\r\n   */\n  liftNodes: function liftNodes(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    Editor.withoutNormalizing(editor, function () {\n      var _options$at = options.at,\n          at = _options$at === void 0 ? editor.selection : _options$at,\n          _options$mode2 = options.mode,\n          mode = _options$mode2 === void 0 ? 'lowest' : _options$mode2,\n          _options$voids2 = options.voids,\n          voids = _options$voids2 === void 0 ? false : _options$voids2;\n      var match = options.match;\n\n      if (match == null) {\n        match = Path.isPath(at) ? matchPath(editor, at) : function (n) {\n          return Element.isElement(n) && Editor.isBlock(editor, n);\n        };\n      }\n\n      if (!at) {\n        return;\n      }\n\n      var matches = Editor.nodes(editor, {\n        at: at,\n        match: match,\n        mode: mode,\n        voids: voids\n      });\n      var pathRefs = Array.from(matches, function (_ref) {\n        var _ref2 = _slicedToArray(_ref, 2),\n            p = _ref2[1];\n\n        return Editor.pathRef(editor, p);\n      });\n\n      for (var _i = 0, _pathRefs = pathRefs; _i < _pathRefs.length; _i++) {\n        var pathRef = _pathRefs[_i];\n        var path = pathRef.unref();\n\n        if (path.length < 2) {\n          throw new Error(\"Cannot lift node at a path [\".concat(path, \"] because it has a depth of less than `2`.\"));\n        }\n\n        var parentNodeEntry = Editor.node(editor, Path.parent(path));\n\n        var _parentNodeEntry = _slicedToArray(parentNodeEntry, 2),\n            parent = _parentNodeEntry[0],\n            parentPath = _parentNodeEntry[1];\n\n        var index = path[path.length - 1];\n        var length = parent.children.length;\n\n        if (length === 1) {\n          var toPath = Path.next(parentPath);\n          Transforms.moveNodes(editor, {\n            at: path,\n            to: toPath,\n            voids: voids\n          });\n          Transforms.removeNodes(editor, {\n            at: parentPath,\n            voids: voids\n          });\n        } else if (index === 0) {\n          Transforms.moveNodes(editor, {\n            at: path,\n            to: parentPath,\n            voids: voids\n          });\n        } else if (index === length - 1) {\n          var _toPath = Path.next(parentPath);\n\n          Transforms.moveNodes(editor, {\n            at: path,\n            to: _toPath,\n            voids: voids\n          });\n        } else {\n          var splitPath = Path.next(path);\n\n          var _toPath2 = Path.next(parentPath);\n\n          Transforms.splitNodes(editor, {\n            at: splitPath,\n            voids: voids\n          });\n          Transforms.moveNodes(editor, {\n            at: path,\n            to: _toPath2,\n            voids: voids\n          });\n        }\n      }\n    });\n  },\n\n  /**\r\n   * Merge a node at a location with the previous node of the same depth,\r\n   * removing any empty containing nodes after the merge if necessary.\r\n   */\n  mergeNodes: function mergeNodes(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    Editor.withoutNormalizing(editor, function () {\n      var match = options.match,\n          _options$at2 = options.at,\n          at = _options$at2 === void 0 ? editor.selection : _options$at2;\n      var _options$hanging2 = options.hanging,\n          hanging = _options$hanging2 === void 0 ? false : _options$hanging2,\n          _options$voids3 = options.voids,\n          voids = _options$voids3 === void 0 ? false : _options$voids3,\n          _options$mode3 = options.mode,\n          mode = _options$mode3 === void 0 ? 'lowest' : _options$mode3;\n\n      if (!at) {\n        return;\n      }\n\n      if (match == null) {\n        if (Path.isPath(at)) {\n          var _Editor$parent = Editor.parent(editor, at),\n              _Editor$parent2 = _slicedToArray(_Editor$parent, 1),\n              parent = _Editor$parent2[0];\n\n          match = function match(n) {\n            return parent.children.includes(n);\n          };\n        } else {\n          match = function match(n) {\n            return Element.isElement(n) && Editor.isBlock(editor, n);\n          };\n        }\n      }\n\n      if (!hanging && Range.isRange(at)) {\n        at = Editor.unhangRange(editor, at, {\n          voids: voids\n        });\n      }\n\n      if (Range.isRange(at)) {\n        if (Range.isCollapsed(at)) {\n          at = at.anchor;\n        } else {\n          var _Range$edges3 = Range.edges(at),\n              _Range$edges4 = _slicedToArray(_Range$edges3, 2),\n              end = _Range$edges4[1];\n\n          var pointRef = Editor.pointRef(editor, end);\n          Transforms[\"delete\"](editor, {\n            at: at\n          });\n          at = pointRef.unref();\n\n          if (options.at == null) {\n            Transforms.select(editor, at);\n          }\n        }\n      }\n\n      var _Editor$nodes3 = Editor.nodes(editor, {\n        at: at,\n        match: match,\n        voids: voids,\n        mode: mode\n      }),\n          _Editor$nodes4 = _slicedToArray(_Editor$nodes3, 1),\n          current = _Editor$nodes4[0];\n\n      var prev = Editor.previous(editor, {\n        at: at,\n        match: match,\n        voids: voids,\n        mode: mode\n      });\n\n      if (!current || !prev) {\n        return;\n      }\n\n      var _current = _slicedToArray(current, 2),\n          node = _current[0],\n          path = _current[1];\n\n      var _prev = _slicedToArray(prev, 2),\n          prevNode = _prev[0],\n          prevPath = _prev[1];\n\n      if (path.length === 0 || prevPath.length === 0) {\n        return;\n      }\n\n      var newPath = Path.next(prevPath);\n      var commonPath = Path.common(path, prevPath);\n      var isPreviousSibling = Path.isSibling(path, prevPath);\n      var levels = Array.from(Editor.levels(editor, {\n        at: path\n      }), function (_ref3) {\n        var _ref4 = _slicedToArray(_ref3, 1),\n            n = _ref4[0];\n\n        return n;\n      }).slice(commonPath.length).slice(0, -1); // Determine if the merge will leave an ancestor of the path empty as a\n      // result, in which case we'll want to remove it after merging.\n\n      var emptyAncestor = Editor.above(editor, {\n        at: path,\n        mode: 'highest',\n        match: function match(n) {\n          return levels.includes(n) && hasSingleChildNest(editor, n);\n        }\n      });\n      var emptyRef = emptyAncestor && Editor.pathRef(editor, emptyAncestor[1]);\n      var properties;\n      var position; // Ensure that the nodes are equivalent, and figure out what the position\n      // and extra properties of the merge will be.\n\n      if (Text.isText(node) && Text.isText(prevNode)) {\n        node.text;\n            var rest = _objectWithoutProperties(node, _excluded);\n\n        position = prevNode.text.length;\n        properties = rest;\n      } else if (Element.isElement(node) && Element.isElement(prevNode)) {\n        node.children;\n            var _rest = _objectWithoutProperties(node, _excluded2);\n\n        position = prevNode.children.length;\n        properties = _rest;\n      } else {\n        throw new Error(\"Cannot merge the node at path [\".concat(path, \"] with the previous sibling because it is not the same kind: \").concat(Scrubber.stringify(node), \" \").concat(Scrubber.stringify(prevNode)));\n      } // If the node isn't already the next sibling of the previous node, move\n      // it so that it is before merging.\n\n\n      if (!isPreviousSibling) {\n        Transforms.moveNodes(editor, {\n          at: path,\n          to: newPath,\n          voids: voids\n        });\n      } // If there was going to be an empty ancestor of the node that was merged,\n      // we remove it from the tree.\n\n\n      if (emptyRef) {\n        Transforms.removeNodes(editor, {\n          at: emptyRef.current,\n          voids: voids\n        });\n      } // If the target node that we're merging with is empty, remove it instead\n      // of merging the two. This is a common rich text editor behavior to\n      // prevent losing formatting when deleting entire nodes when you have a\n      // hanging selection.\n      // if prevNode is first child in parent,don't remove it.\n\n\n      if (Element.isElement(prevNode) && Editor.isEmpty(editor, prevNode) || Text.isText(prevNode) && prevNode.text === '' && prevPath[prevPath.length - 1] !== 0) {\n        Transforms.removeNodes(editor, {\n          at: prevPath,\n          voids: voids\n        });\n      } else {\n        editor.apply({\n          type: 'merge_node',\n          path: newPath,\n          position: position,\n          properties: properties\n        });\n      }\n\n      if (emptyRef) {\n        emptyRef.unref();\n      }\n    });\n  },\n\n  /**\r\n   * Move the nodes at a location to a new location.\r\n   */\n  moveNodes: function moveNodes(editor, options) {\n    Editor.withoutNormalizing(editor, function () {\n      var to = options.to,\n          _options$at3 = options.at,\n          at = _options$at3 === void 0 ? editor.selection : _options$at3,\n          _options$mode4 = options.mode,\n          mode = _options$mode4 === void 0 ? 'lowest' : _options$mode4,\n          _options$voids4 = options.voids,\n          voids = _options$voids4 === void 0 ? false : _options$voids4;\n      var match = options.match;\n\n      if (!at) {\n        return;\n      }\n\n      if (match == null) {\n        match = Path.isPath(at) ? matchPath(editor, at) : function (n) {\n          return Element.isElement(n) && Editor.isBlock(editor, n);\n        };\n      }\n\n      var toRef = Editor.pathRef(editor, to);\n      var targets = Editor.nodes(editor, {\n        at: at,\n        match: match,\n        mode: mode,\n        voids: voids\n      });\n      var pathRefs = Array.from(targets, function (_ref5) {\n        var _ref6 = _slicedToArray(_ref5, 2),\n            p = _ref6[1];\n\n        return Editor.pathRef(editor, p);\n      });\n\n      for (var _i2 = 0, _pathRefs2 = pathRefs; _i2 < _pathRefs2.length; _i2++) {\n        var pathRef = _pathRefs2[_i2];\n        var path = pathRef.unref();\n        var newPath = toRef.current;\n\n        if (path.length !== 0) {\n          editor.apply({\n            type: 'move_node',\n            path: path,\n            newPath: newPath\n          });\n        }\n\n        if (toRef.current && Path.isSibling(newPath, path) && Path.isAfter(newPath, path)) {\n          // When performing a sibling move to a later index, the path at the destination is shifted\n          // to before the insertion point instead of after. To ensure our group of nodes are inserted\n          // in the correct order we increment toRef to account for that\n          toRef.current = Path.next(toRef.current);\n        }\n      }\n\n      toRef.unref();\n    });\n  },\n\n  /**\r\n   * Remove the nodes at a specific location in the document.\r\n   */\n  removeNodes: function removeNodes(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    Editor.withoutNormalizing(editor, function () {\n      var _options$hanging3 = options.hanging,\n          hanging = _options$hanging3 === void 0 ? false : _options$hanging3,\n          _options$voids5 = options.voids,\n          voids = _options$voids5 === void 0 ? false : _options$voids5,\n          _options$mode5 = options.mode,\n          mode = _options$mode5 === void 0 ? 'lowest' : _options$mode5;\n      var _options$at4 = options.at,\n          at = _options$at4 === void 0 ? editor.selection : _options$at4,\n          match = options.match;\n\n      if (!at) {\n        return;\n      }\n\n      if (match == null) {\n        match = Path.isPath(at) ? matchPath(editor, at) : function (n) {\n          return Element.isElement(n) && Editor.isBlock(editor, n);\n        };\n      }\n\n      if (!hanging && Range.isRange(at)) {\n        at = Editor.unhangRange(editor, at, {\n          voids: voids\n        });\n      }\n\n      var depths = Editor.nodes(editor, {\n        at: at,\n        match: match,\n        mode: mode,\n        voids: voids\n      });\n      var pathRefs = Array.from(depths, function (_ref7) {\n        var _ref8 = _slicedToArray(_ref7, 2),\n            p = _ref8[1];\n\n        return Editor.pathRef(editor, p);\n      });\n\n      for (var _i3 = 0, _pathRefs3 = pathRefs; _i3 < _pathRefs3.length; _i3++) {\n        var pathRef = _pathRefs3[_i3];\n        var path = pathRef.unref();\n\n        if (path) {\n          var _Editor$node = Editor.node(editor, path),\n              _Editor$node2 = _slicedToArray(_Editor$node, 1),\n              node = _Editor$node2[0];\n\n          editor.apply({\n            type: 'remove_node',\n            path: path,\n            node: node\n          });\n        }\n      }\n    });\n  },\n\n  /**\r\n   * Set new properties on the nodes at a location.\r\n   */\n  setNodes: function setNodes(editor, props) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    Editor.withoutNormalizing(editor, function () {\n      var match = options.match,\n          _options$at5 = options.at,\n          at = _options$at5 === void 0 ? editor.selection : _options$at5,\n          compare = options.compare,\n          merge = options.merge;\n      var _options$hanging4 = options.hanging,\n          hanging = _options$hanging4 === void 0 ? false : _options$hanging4,\n          _options$mode6 = options.mode,\n          mode = _options$mode6 === void 0 ? 'lowest' : _options$mode6,\n          _options$split = options.split,\n          split = _options$split === void 0 ? false : _options$split,\n          _options$voids6 = options.voids,\n          voids = _options$voids6 === void 0 ? false : _options$voids6;\n\n      if (!at) {\n        return;\n      }\n\n      if (match == null) {\n        match = Path.isPath(at) ? matchPath(editor, at) : function (n) {\n          return Element.isElement(n) && Editor.isBlock(editor, n);\n        };\n      }\n\n      if (!hanging && Range.isRange(at)) {\n        at = Editor.unhangRange(editor, at, {\n          voids: voids\n        });\n      }\n\n      if (split && Range.isRange(at)) {\n        if (Range.isCollapsed(at) && Editor.leaf(editor, at.anchor)[0].text.length > 0) {\n          // If the range is collapsed in a non-empty node and 'split' is true, there's nothing to\n          // set that won't get normalized away\n          return;\n        }\n\n        var rangeRef = Editor.rangeRef(editor, at, {\n          affinity: 'inward'\n        });\n\n        var _Range$edges5 = Range.edges(at),\n            _Range$edges6 = _slicedToArray(_Range$edges5, 2),\n            start = _Range$edges6[0],\n            end = _Range$edges6[1];\n\n        var splitMode = mode === 'lowest' ? 'lowest' : 'highest';\n        var endAtEndOfNode = Editor.isEnd(editor, end, end.path);\n        Transforms.splitNodes(editor, {\n          at: end,\n          match: match,\n          mode: splitMode,\n          voids: voids,\n          always: !endAtEndOfNode\n        });\n        var startAtStartOfNode = Editor.isStart(editor, start, start.path);\n        Transforms.splitNodes(editor, {\n          at: start,\n          match: match,\n          mode: splitMode,\n          voids: voids,\n          always: !startAtStartOfNode\n        });\n        at = rangeRef.unref();\n\n        if (options.at == null) {\n          Transforms.select(editor, at);\n        }\n      }\n\n      if (!compare) {\n        compare = function compare(prop, nodeProp) {\n          return prop !== nodeProp;\n        };\n      }\n\n      var _iterator2 = _createForOfIteratorHelper$1(Editor.nodes(editor, {\n        at: at,\n        match: match,\n        mode: mode,\n        voids: voids\n      })),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var _step2$value = _slicedToArray(_step2.value, 2),\n              node = _step2$value[0],\n              path = _step2$value[1];\n\n          var properties = {};\n          var newProperties = {}; // You can't set properties on the editor node.\n\n          if (path.length === 0) {\n            continue;\n          }\n\n          var hasChanges = false;\n\n          for (var k in props) {\n            if (k === 'children' || k === 'text') {\n              continue;\n            }\n\n            if (compare(props[k], node[k])) {\n              hasChanges = true; // Omit new properties from the old properties list\n\n              if (node.hasOwnProperty(k)) properties[k] = node[k]; // Omit properties that have been removed from the new properties list\n\n              if (merge) {\n                if (props[k] != null) newProperties[k] = merge(node[k], props[k]);\n              } else {\n                if (props[k] != null) newProperties[k] = props[k];\n              }\n            }\n          }\n\n          if (hasChanges) {\n            editor.apply({\n              type: 'set_node',\n              path: path,\n              properties: properties,\n              newProperties: newProperties\n            });\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n    });\n  },\n\n  /**\r\n   * Split the nodes at a specific location.\r\n   */\n  splitNodes: function splitNodes(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    Editor.withoutNormalizing(editor, function () {\n      var _options$mode7 = options.mode,\n          mode = _options$mode7 === void 0 ? 'lowest' : _options$mode7,\n          _options$voids7 = options.voids,\n          voids = _options$voids7 === void 0 ? false : _options$voids7;\n      var match = options.match,\n          _options$at6 = options.at,\n          at = _options$at6 === void 0 ? editor.selection : _options$at6,\n          _options$height = options.height,\n          height = _options$height === void 0 ? 0 : _options$height,\n          _options$always = options.always,\n          always = _options$always === void 0 ? false : _options$always;\n\n      if (match == null) {\n        match = function match(n) {\n          return Element.isElement(n) && Editor.isBlock(editor, n);\n        };\n      }\n\n      if (Range.isRange(at)) {\n        at = deleteRange(editor, at);\n      } // If the target is a path, the default height-skipping and position\n      // counters need to account for us potentially splitting at a non-leaf.\n\n\n      if (Path.isPath(at)) {\n        var path = at;\n        var point = Editor.point(editor, path);\n\n        var _Editor$parent3 = Editor.parent(editor, path),\n            _Editor$parent4 = _slicedToArray(_Editor$parent3, 1),\n            parent = _Editor$parent4[0];\n\n        match = function match(n) {\n          return n === parent;\n        };\n\n        height = point.path.length - path.length + 1;\n        at = point;\n        always = true;\n      }\n\n      if (!at) {\n        return;\n      }\n\n      var beforeRef = Editor.pointRef(editor, at, {\n        affinity: 'backward'\n      });\n      var afterRef;\n\n      try {\n        var _Editor$nodes5 = Editor.nodes(editor, {\n          at: at,\n          match: match,\n          mode: mode,\n          voids: voids\n        }),\n            _Editor$nodes6 = _slicedToArray(_Editor$nodes5, 1),\n            highest = _Editor$nodes6[0];\n\n        if (!highest) {\n          return;\n        }\n\n        var voidMatch = Editor[\"void\"](editor, {\n          at: at,\n          mode: 'highest'\n        });\n        var nudge = 0;\n\n        if (!voids && voidMatch) {\n          var _voidMatch = _slicedToArray(voidMatch, 2),\n              voidNode = _voidMatch[0],\n              voidPath = _voidMatch[1];\n\n          if (Element.isElement(voidNode) && editor.isInline(voidNode)) {\n            var after = Editor.after(editor, voidPath);\n\n            if (!after) {\n              var text = {\n                text: ''\n              };\n              var afterPath = Path.next(voidPath);\n              Transforms.insertNodes(editor, text, {\n                at: afterPath,\n                voids: voids\n              });\n              after = Editor.point(editor, afterPath);\n            }\n\n            at = after;\n            always = true;\n          }\n\n          var siblingHeight = at.path.length - voidPath.length;\n          height = siblingHeight + 1;\n          always = true;\n        }\n\n        afterRef = Editor.pointRef(editor, at);\n        var depth = at.path.length - height;\n\n        var _highest = _slicedToArray(highest, 2),\n            highestPath = _highest[1];\n\n        var lowestPath = at.path.slice(0, depth);\n        var position = height === 0 ? at.offset : at.path[depth] + nudge;\n\n        var _iterator3 = _createForOfIteratorHelper$1(Editor.levels(editor, {\n          at: lowestPath,\n          reverse: true,\n          voids: voids\n        })),\n            _step3;\n\n        try {\n          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n            var _step3$value = _slicedToArray(_step3.value, 2),\n                node = _step3$value[0],\n                _path2 = _step3$value[1];\n\n            var split = false;\n\n            if (_path2.length < highestPath.length || _path2.length === 0 || !voids && Element.isElement(node) && Editor.isVoid(editor, node)) {\n              break;\n            }\n\n            var _point2 = beforeRef.current;\n            var isEnd = Editor.isEnd(editor, _point2, _path2);\n\n            if (always || !beforeRef || !Editor.isEdge(editor, _point2, _path2)) {\n              split = true;\n              var properties = Node.extractProps(node);\n              editor.apply({\n                type: 'split_node',\n                path: _path2,\n                position: position,\n                properties: properties\n              });\n            }\n\n            position = _path2[_path2.length - 1] + (split || isEnd ? 1 : 0);\n          }\n        } catch (err) {\n          _iterator3.e(err);\n        } finally {\n          _iterator3.f();\n        }\n\n        if (options.at == null) {\n          var _point = afterRef.current || Editor.end(editor, []);\n\n          Transforms.select(editor, _point);\n        }\n      } finally {\n        var _afterRef;\n\n        beforeRef.unref();\n        (_afterRef = afterRef) === null || _afterRef === void 0 ? void 0 : _afterRef.unref();\n      }\n    });\n  },\n\n  /**\r\n   * Unset properties on the nodes at a location.\r\n   */\n  unsetNodes: function unsetNodes(editor, props) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    if (!Array.isArray(props)) {\n      props = [props];\n    }\n\n    var obj = {};\n\n    var _iterator4 = _createForOfIteratorHelper$1(props),\n        _step4;\n\n    try {\n      for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n        var key = _step4.value;\n        obj[key] = null;\n      }\n    } catch (err) {\n      _iterator4.e(err);\n    } finally {\n      _iterator4.f();\n    }\n\n    Transforms.setNodes(editor, obj, options);\n  },\n\n  /**\r\n   * Unwrap the nodes at a location from a parent node, splitting the parent if\r\n   * necessary to ensure that only the content in the range is unwrapped.\r\n   */\n  unwrapNodes: function unwrapNodes(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    Editor.withoutNormalizing(editor, function () {\n      var _options$mode8 = options.mode,\n          mode = _options$mode8 === void 0 ? 'lowest' : _options$mode8,\n          _options$split2 = options.split,\n          split = _options$split2 === void 0 ? false : _options$split2,\n          _options$voids8 = options.voids,\n          voids = _options$voids8 === void 0 ? false : _options$voids8;\n      var _options$at7 = options.at,\n          at = _options$at7 === void 0 ? editor.selection : _options$at7,\n          match = options.match;\n\n      if (!at) {\n        return;\n      }\n\n      if (match == null) {\n        match = Path.isPath(at) ? matchPath(editor, at) : function (n) {\n          return Element.isElement(n) && Editor.isBlock(editor, n);\n        };\n      }\n\n      if (Path.isPath(at)) {\n        at = Editor.range(editor, at);\n      }\n\n      var rangeRef = Range.isRange(at) ? Editor.rangeRef(editor, at) : null;\n      var matches = Editor.nodes(editor, {\n        at: at,\n        match: match,\n        mode: mode,\n        voids: voids\n      });\n      var pathRefs = Array.from(matches, function (_ref9) {\n        var _ref10 = _slicedToArray(_ref9, 2),\n            p = _ref10[1];\n\n        return Editor.pathRef(editor, p);\n      } // unwrapNode will call liftNode which does not support splitting the node when nested.\n      // If we do not reverse the order and call it from top to the bottom, it will remove all blocks\n      // that wrap target node. So we reverse the order.\n      ).reverse();\n\n      var _iterator5 = _createForOfIteratorHelper$1(pathRefs),\n          _step5;\n\n      try {\n        var _loop = function _loop() {\n          var pathRef = _step5.value;\n          var path = pathRef.unref();\n\n          var _Editor$node3 = Editor.node(editor, path),\n              _Editor$node4 = _slicedToArray(_Editor$node3, 1),\n              node = _Editor$node4[0];\n\n          var range = Editor.range(editor, path);\n\n          if (split && rangeRef) {\n            range = Range.intersection(rangeRef.current, range);\n          }\n\n          Transforms.liftNodes(editor, {\n            at: range,\n            match: function match(n) {\n              return Element.isAncestor(node) && node.children.includes(n);\n            },\n            voids: voids\n          });\n        };\n\n        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n          _loop();\n        }\n      } catch (err) {\n        _iterator5.e(err);\n      } finally {\n        _iterator5.f();\n      }\n\n      if (rangeRef) {\n        rangeRef.unref();\n      }\n    });\n  },\n\n  /**\r\n   * Wrap the nodes at a location in a new container node, splitting the edges\r\n   * of the range first to ensure that only the content in the range is wrapped.\r\n   */\n  wrapNodes: function wrapNodes(editor, element) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    Editor.withoutNormalizing(editor, function () {\n      var _options$mode9 = options.mode,\n          mode = _options$mode9 === void 0 ? 'lowest' : _options$mode9,\n          _options$split3 = options.split,\n          split = _options$split3 === void 0 ? false : _options$split3,\n          _options$voids9 = options.voids,\n          voids = _options$voids9 === void 0 ? false : _options$voids9;\n      var match = options.match,\n          _options$at8 = options.at,\n          at = _options$at8 === void 0 ? editor.selection : _options$at8;\n\n      if (!at) {\n        return;\n      }\n\n      if (match == null) {\n        if (Path.isPath(at)) {\n          match = matchPath(editor, at);\n        } else if (editor.isInline(element)) {\n          match = function match(n) {\n            return Element.isElement(n) && Editor.isInline(editor, n) || Text.isText(n);\n          };\n        } else {\n          match = function match(n) {\n            return Element.isElement(n) && Editor.isBlock(editor, n);\n          };\n        }\n      }\n\n      if (split && Range.isRange(at)) {\n        var _Range$edges7 = Range.edges(at),\n            _Range$edges8 = _slicedToArray(_Range$edges7, 2),\n            start = _Range$edges8[0],\n            end = _Range$edges8[1];\n\n        var rangeRef = Editor.rangeRef(editor, at, {\n          affinity: 'inward'\n        });\n        Transforms.splitNodes(editor, {\n          at: end,\n          match: match,\n          voids: voids\n        });\n        Transforms.splitNodes(editor, {\n          at: start,\n          match: match,\n          voids: voids\n        });\n        at = rangeRef.unref();\n\n        if (options.at == null) {\n          Transforms.select(editor, at);\n        }\n      }\n\n      var roots = Array.from(Editor.nodes(editor, {\n        at: at,\n        match: editor.isInline(element) ? function (n) {\n          return Element.isElement(n) && Editor.isBlock(editor, n);\n        } : function (n) {\n          return Editor.isEditor(n);\n        },\n        mode: 'lowest',\n        voids: voids\n      }));\n\n      for (var _i4 = 0, _roots = roots; _i4 < _roots.length; _i4++) {\n        var _roots$_i = _slicedToArray(_roots[_i4], 2),\n            rootPath = _roots$_i[1];\n\n        var a = Range.isRange(at) ? Range.intersection(at, Editor.range(editor, rootPath)) : at;\n\n        if (!a) {\n          continue;\n        }\n\n        var matches = Array.from(Editor.nodes(editor, {\n          at: a,\n          match: match,\n          mode: mode,\n          voids: voids\n        }));\n\n        if (matches.length > 0) {\n          var _ret = function () {\n            var _matches = _slicedToArray(matches, 1),\n                first = _matches[0];\n\n            var last = matches[matches.length - 1];\n\n            var _first = _slicedToArray(first, 2),\n                firstPath = _first[1];\n\n            var _last = _slicedToArray(last, 2),\n                lastPath = _last[1];\n\n            if (firstPath.length === 0 && lastPath.length === 0) {\n              // if there's no matching parent - usually means the node is an editor - don't do anything\n              return \"continue\";\n            }\n\n            var commonPath = Path.equals(firstPath, lastPath) ? Path.parent(firstPath) : Path.common(firstPath, lastPath);\n            var range = Editor.range(editor, firstPath, lastPath);\n            var commonNodeEntry = Editor.node(editor, commonPath);\n\n            var _commonNodeEntry = _slicedToArray(commonNodeEntry, 1),\n                commonNode = _commonNodeEntry[0];\n\n            var depth = commonPath.length + 1;\n            var wrapperPath = Path.next(lastPath.slice(0, depth));\n\n            var wrapper = _objectSpread$2(_objectSpread$2({}, element), {}, {\n              children: []\n            });\n\n            Transforms.insertNodes(editor, wrapper, {\n              at: wrapperPath,\n              voids: voids\n            });\n            Transforms.moveNodes(editor, {\n              at: range,\n              match: function match(n) {\n                return Element.isAncestor(commonNode) && commonNode.children.includes(n);\n              },\n              to: wrapperPath.concat(0),\n              voids: voids\n            });\n          }();\n\n          if (_ret === \"continue\") continue;\n        }\n      }\n    });\n  }\n};\n\nvar hasSingleChildNest = function hasSingleChildNest(editor, node) {\n  if (Element.isElement(node)) {\n    var element = node;\n\n    if (Editor.isVoid(editor, node)) {\n      return true;\n    } else if (element.children.length === 1) {\n      return hasSingleChildNest(editor, element.children[0]);\n    } else {\n      return false;\n    }\n  } else if (Editor.isEditor(node)) {\n    return false;\n  } else {\n    return true;\n  }\n};\n/**\r\n * Convert a range into a point by deleting it's content.\r\n */\n\n\nvar deleteRange = function deleteRange(editor, range) {\n  if (Range.isCollapsed(range)) {\n    return range.anchor;\n  } else {\n    var _Range$edges9 = Range.edges(range),\n        _Range$edges10 = _slicedToArray(_Range$edges9, 2),\n        end = _Range$edges10[1];\n\n    var pointRef = Editor.pointRef(editor, end);\n    Transforms[\"delete\"](editor, {\n      at: range\n    });\n    return pointRef.unref();\n  }\n};\n\nvar matchPath = function matchPath(editor, path) {\n  var _Editor$node5 = Editor.node(editor, path),\n      _Editor$node6 = _slicedToArray(_Editor$node5, 1),\n      node = _Editor$node6[0];\n\n  return function (n) {\n    return n === node;\n  };\n};\n\nfunction ownKeys$1(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread$1(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$1(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$1(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nvar SelectionTransforms = {\n  /**\r\n   * Collapse the selection.\r\n   */\n  collapse: function collapse(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var _options$edge = options.edge,\n        edge = _options$edge === void 0 ? 'anchor' : _options$edge;\n    var selection = editor.selection;\n\n    if (!selection) {\n      return;\n    } else if (edge === 'anchor') {\n      Transforms.select(editor, selection.anchor);\n    } else if (edge === 'focus') {\n      Transforms.select(editor, selection.focus);\n    } else if (edge === 'start') {\n      var _Range$edges = Range.edges(selection),\n          _Range$edges2 = _slicedToArray(_Range$edges, 1),\n          start = _Range$edges2[0];\n\n      Transforms.select(editor, start);\n    } else if (edge === 'end') {\n      var _Range$edges3 = Range.edges(selection),\n          _Range$edges4 = _slicedToArray(_Range$edges3, 2),\n          end = _Range$edges4[1];\n\n      Transforms.select(editor, end);\n    }\n  },\n\n  /**\r\n   * Unset the selection.\r\n   */\n  deselect: function deselect(editor) {\n    var selection = editor.selection;\n\n    if (selection) {\n      editor.apply({\n        type: 'set_selection',\n        properties: selection,\n        newProperties: null\n      });\n    }\n  },\n\n  /**\r\n   * Move the selection's point forward or backward.\r\n   */\n  move: function move(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var selection = editor.selection;\n    var _options$distance = options.distance,\n        distance = _options$distance === void 0 ? 1 : _options$distance,\n        _options$unit = options.unit,\n        unit = _options$unit === void 0 ? 'character' : _options$unit,\n        _options$reverse = options.reverse,\n        reverse = _options$reverse === void 0 ? false : _options$reverse;\n    var _options$edge2 = options.edge,\n        edge = _options$edge2 === void 0 ? null : _options$edge2;\n\n    if (!selection) {\n      return;\n    }\n\n    if (edge === 'start') {\n      edge = Range.isBackward(selection) ? 'focus' : 'anchor';\n    }\n\n    if (edge === 'end') {\n      edge = Range.isBackward(selection) ? 'anchor' : 'focus';\n    }\n\n    var anchor = selection.anchor,\n        focus = selection.focus;\n    var opts = {\n      distance: distance,\n      unit: unit\n    };\n    var props = {};\n\n    if (edge == null || edge === 'anchor') {\n      var point = reverse ? Editor.before(editor, anchor, opts) : Editor.after(editor, anchor, opts);\n\n      if (point) {\n        props.anchor = point;\n      }\n    }\n\n    if (edge == null || edge === 'focus') {\n      var _point = reverse ? Editor.before(editor, focus, opts) : Editor.after(editor, focus, opts);\n\n      if (_point) {\n        props.focus = _point;\n      }\n    }\n\n    Transforms.setSelection(editor, props);\n  },\n\n  /**\r\n   * Set the selection to a new value.\r\n   */\n  select: function select(editor, target) {\n    var selection = editor.selection;\n    target = Editor.range(editor, target);\n\n    if (selection) {\n      Transforms.setSelection(editor, target);\n      return;\n    }\n\n    if (!Range.isRange(target)) {\n      throw new Error(\"When setting the selection and the current selection is `null` you must provide at least an `anchor` and `focus`, but you passed: \".concat(Scrubber.stringify(target)));\n    }\n\n    editor.apply({\n      type: 'set_selection',\n      properties: selection,\n      newProperties: target\n    });\n  },\n\n  /**\r\n   * Set new properties on one of the selection's points.\r\n   */\n  setPoint: function setPoint(editor, props) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var selection = editor.selection;\n    var _options$edge3 = options.edge,\n        edge = _options$edge3 === void 0 ? 'both' : _options$edge3;\n\n    if (!selection) {\n      return;\n    }\n\n    if (edge === 'start') {\n      edge = Range.isBackward(selection) ? 'focus' : 'anchor';\n    }\n\n    if (edge === 'end') {\n      edge = Range.isBackward(selection) ? 'anchor' : 'focus';\n    }\n\n    var anchor = selection.anchor,\n        focus = selection.focus;\n    var point = edge === 'anchor' ? anchor : focus;\n    Transforms.setSelection(editor, _defineProperty({}, edge === 'anchor' ? 'anchor' : 'focus', _objectSpread$1(_objectSpread$1({}, point), props)));\n  },\n\n  /**\r\n   * Set new properties on the selection.\r\n   */\n  setSelection: function setSelection(editor, props) {\n    var selection = editor.selection;\n    var oldProps = {};\n    var newProps = {};\n\n    if (!selection) {\n      return;\n    }\n\n    for (var k in props) {\n      if (k === 'anchor' && props.anchor != null && !Point.equals(props.anchor, selection.anchor) || k === 'focus' && props.focus != null && !Point.equals(props.focus, selection.focus) || k !== 'anchor' && k !== 'focus' && props[k] !== selection[k]) {\n        oldProps[k] = selection[k];\n        newProps[k] = props[k];\n      }\n    }\n\n    if (Object.keys(oldProps).length > 0) {\n      editor.apply({\n        type: 'set_selection',\n        properties: oldProps,\n        newProperties: newProps\n      });\n    }\n  }\n};\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nvar TextTransforms = {\n  /**\r\n   * Delete content in the editor.\r\n   */\n  \"delete\": function _delete(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    Editor.withoutNormalizing(editor, function () {\n      var _options$reverse = options.reverse,\n          reverse = _options$reverse === void 0 ? false : _options$reverse,\n          _options$unit = options.unit,\n          unit = _options$unit === void 0 ? 'character' : _options$unit,\n          _options$distance = options.distance,\n          distance = _options$distance === void 0 ? 1 : _options$distance,\n          _options$voids = options.voids,\n          voids = _options$voids === void 0 ? false : _options$voids;\n      var _options$at = options.at,\n          at = _options$at === void 0 ? editor.selection : _options$at,\n          _options$hanging = options.hanging,\n          hanging = _options$hanging === void 0 ? false : _options$hanging;\n\n      if (!at) {\n        return;\n      }\n\n      var isCollapsed = false;\n\n      if (Range.isRange(at) && Range.isCollapsed(at)) {\n        isCollapsed = true;\n        at = at.anchor;\n      }\n\n      if (Point.isPoint(at)) {\n        var furthestVoid = Editor[\"void\"](editor, {\n          at: at,\n          mode: 'highest'\n        });\n\n        if (!voids && furthestVoid) {\n          var _furthestVoid = _slicedToArray(furthestVoid, 2),\n              voidPath = _furthestVoid[1];\n\n          at = voidPath;\n        } else {\n          var opts = {\n            unit: unit,\n            distance: distance\n          };\n          var target = reverse ? Editor.before(editor, at, opts) || Editor.start(editor, []) : Editor.after(editor, at, opts) || Editor.end(editor, []);\n          at = {\n            anchor: at,\n            focus: target\n          };\n          hanging = true;\n        }\n      }\n\n      if (Path.isPath(at)) {\n        Transforms.removeNodes(editor, {\n          at: at,\n          voids: voids\n        });\n        return;\n      }\n\n      if (Range.isCollapsed(at)) {\n        return;\n      }\n\n      if (!hanging) {\n        var _Range$edges = Range.edges(at),\n            _Range$edges2 = _slicedToArray(_Range$edges, 2),\n            _end = _Range$edges2[1];\n\n        var endOfDoc = Editor.end(editor, []);\n\n        if (!Point.equals(_end, endOfDoc)) {\n          at = Editor.unhangRange(editor, at, {\n            voids: voids\n          });\n        }\n      }\n\n      var _Range$edges3 = Range.edges(at),\n          _Range$edges4 = _slicedToArray(_Range$edges3, 2),\n          start = _Range$edges4[0],\n          end = _Range$edges4[1];\n\n      var startBlock = Editor.above(editor, {\n        match: function match(n) {\n          return Element.isElement(n) && Editor.isBlock(editor, n);\n        },\n        at: start,\n        voids: voids\n      });\n      var endBlock = Editor.above(editor, {\n        match: function match(n) {\n          return Element.isElement(n) && Editor.isBlock(editor, n);\n        },\n        at: end,\n        voids: voids\n      });\n      var isAcrossBlocks = startBlock && endBlock && !Path.equals(startBlock[1], endBlock[1]);\n      var isSingleText = Path.equals(start.path, end.path);\n      var startVoid = voids ? null : Editor[\"void\"](editor, {\n        at: start,\n        mode: 'highest'\n      });\n      var endVoid = voids ? null : Editor[\"void\"](editor, {\n        at: end,\n        mode: 'highest'\n      }); // If the start or end points are inside an inline void, nudge them out.\n\n      if (startVoid) {\n        var before = Editor.before(editor, start);\n\n        if (before && startBlock && Path.isAncestor(startBlock[1], before.path)) {\n          start = before;\n        }\n      }\n\n      if (endVoid) {\n        var after = Editor.after(editor, end);\n\n        if (after && endBlock && Path.isAncestor(endBlock[1], after.path)) {\n          end = after;\n        }\n      } // Get the highest nodes that are completely inside the range, as well as\n      // the start and end nodes.\n\n\n      var matches = [];\n      var lastPath;\n\n      var _iterator = _createForOfIteratorHelper(Editor.nodes(editor, {\n        at: at,\n        voids: voids\n      })),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var entry = _step.value;\n\n          var _entry = _slicedToArray(entry, 2),\n              _node2 = _entry[0],\n              _path2 = _entry[1];\n\n          if (lastPath && Path.compare(_path2, lastPath) === 0) {\n            continue;\n          }\n\n          if (!voids && Element.isElement(_node2) && Editor.isVoid(editor, _node2) || !Path.isCommon(_path2, start.path) && !Path.isCommon(_path2, end.path)) {\n            matches.push(entry);\n            lastPath = _path2;\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      var pathRefs = Array.from(matches, function (_ref) {\n        var _ref2 = _slicedToArray(_ref, 2),\n            p = _ref2[1];\n\n        return Editor.pathRef(editor, p);\n      });\n      var startRef = Editor.pointRef(editor, start);\n      var endRef = Editor.pointRef(editor, end);\n      var removedText = '';\n\n      if (!isSingleText && !startVoid) {\n        var _point = startRef.current;\n\n        var _Editor$leaf = Editor.leaf(editor, _point),\n            _Editor$leaf2 = _slicedToArray(_Editor$leaf, 1),\n            node = _Editor$leaf2[0];\n\n        var path = _point.path;\n        var _start = start,\n            offset = _start.offset;\n        var text = node.text.slice(offset);\n\n        if (text.length > 0) {\n          editor.apply({\n            type: 'remove_text',\n            path: path,\n            offset: offset,\n            text: text\n          });\n          removedText = text;\n        }\n      }\n\n      pathRefs.reverse().map(function (r) {\n        return r.unref();\n      }).filter(function (r) {\n        return r !== null;\n      }).forEach(function (p) {\n        return Transforms.removeNodes(editor, {\n          at: p,\n          voids: voids\n        });\n      });\n\n      if (!endVoid) {\n        var _point2 = endRef.current;\n\n        var _Editor$leaf3 = Editor.leaf(editor, _point2),\n            _Editor$leaf4 = _slicedToArray(_Editor$leaf3, 1),\n            _node = _Editor$leaf4[0];\n\n        var _path = _point2.path;\n\n        var _offset = isSingleText ? start.offset : 0;\n\n        var _text = _node.text.slice(_offset, end.offset);\n\n        if (_text.length > 0) {\n          editor.apply({\n            type: 'remove_text',\n            path: _path,\n            offset: _offset,\n            text: _text\n          });\n          removedText = _text;\n        }\n      }\n\n      if (!isSingleText && isAcrossBlocks && endRef.current && startRef.current) {\n        Transforms.mergeNodes(editor, {\n          at: endRef.current,\n          hanging: true,\n          voids: voids\n        });\n      } // For Thai script, deleting N character(s) backward should delete\n      // N code point(s) instead of an entire grapheme cluster.\n      // Therefore, the remaining code points should be inserted back.\n\n\n      if (isCollapsed && reverse && unit === 'character' && removedText.length > 1 && removedText.match(/[\\u0E00-\\u0E7F]+/)) {\n        Transforms.insertText(editor, removedText.slice(0, removedText.length - distance));\n      }\n\n      var startUnref = startRef.unref();\n      var endUnref = endRef.unref();\n      var point = reverse ? startUnref || endUnref : endUnref || startUnref;\n\n      if (options.at == null && point) {\n        Transforms.select(editor, point);\n      }\n    });\n  },\n\n  /**\r\n   * Insert a fragment at a specific location in the editor.\r\n   */\n  insertFragment: function insertFragment(editor, fragment) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    Editor.withoutNormalizing(editor, function () {\n      var _options$hanging2 = options.hanging,\n          hanging = _options$hanging2 === void 0 ? false : _options$hanging2,\n          _options$voids2 = options.voids,\n          voids = _options$voids2 === void 0 ? false : _options$voids2;\n      var _options$at2 = options.at,\n          at = _options$at2 === void 0 ? editor.selection : _options$at2;\n\n      if (!fragment.length) {\n        return;\n      }\n\n      if (!at) {\n        return;\n      } else if (Range.isRange(at)) {\n        if (!hanging) {\n          at = Editor.unhangRange(editor, at, {\n            voids: voids\n          });\n        }\n\n        if (Range.isCollapsed(at)) {\n          at = at.anchor;\n        } else {\n          var _Range$edges5 = Range.edges(at),\n              _Range$edges6 = _slicedToArray(_Range$edges5, 2),\n              end = _Range$edges6[1];\n\n          if (!voids && Editor[\"void\"](editor, {\n            at: end\n          })) {\n            return;\n          }\n\n          var pointRef = Editor.pointRef(editor, end);\n          Transforms[\"delete\"](editor, {\n            at: at\n          });\n          at = pointRef.unref();\n        }\n      } else if (Path.isPath(at)) {\n        at = Editor.start(editor, at);\n      }\n\n      if (!voids && Editor[\"void\"](editor, {\n        at: at\n      })) {\n        return;\n      } // If the insert point is at the edge of an inline node, move it outside\n      // instead since it will need to be split otherwise.\n\n\n      var inlineElementMatch = Editor.above(editor, {\n        at: at,\n        match: function match(n) {\n          return Element.isElement(n) && Editor.isInline(editor, n);\n        },\n        mode: 'highest',\n        voids: voids\n      });\n\n      if (inlineElementMatch) {\n        var _inlineElementMatch = _slicedToArray(inlineElementMatch, 2),\n            _inlinePath = _inlineElementMatch[1];\n\n        if (Editor.isEnd(editor, at, _inlinePath)) {\n          var after = Editor.after(editor, _inlinePath);\n          at = after;\n        } else if (Editor.isStart(editor, at, _inlinePath)) {\n          var before = Editor.before(editor, _inlinePath);\n          at = before;\n        }\n      }\n\n      var blockMatch = Editor.above(editor, {\n        match: function match(n) {\n          return Element.isElement(n) && Editor.isBlock(editor, n);\n        },\n        at: at,\n        voids: voids\n      });\n\n      var _blockMatch = _slicedToArray(blockMatch, 2),\n          blockPath = _blockMatch[1];\n\n      var isBlockStart = Editor.isStart(editor, at, blockPath);\n      var isBlockEnd = Editor.isEnd(editor, at, blockPath);\n      var isBlockEmpty = isBlockStart && isBlockEnd;\n      var mergeStart = !isBlockStart || isBlockStart && isBlockEnd;\n      var mergeEnd = !isBlockEnd;\n\n      var _Node$first = Node.first({\n        children: fragment\n      }, []),\n          _Node$first2 = _slicedToArray(_Node$first, 2),\n          firstPath = _Node$first2[1];\n\n      var _Node$last = Node.last({\n        children: fragment\n      }, []),\n          _Node$last2 = _slicedToArray(_Node$last, 2),\n          lastPath = _Node$last2[1];\n\n      var matches = [];\n\n      var matcher = function matcher(_ref3) {\n        var _ref4 = _slicedToArray(_ref3, 2),\n            n = _ref4[0],\n            p = _ref4[1];\n\n        var isRoot = p.length === 0;\n\n        if (isRoot) {\n          return false;\n        }\n\n        if (isBlockEmpty) {\n          return true;\n        }\n\n        if (mergeStart && Path.isAncestor(p, firstPath) && Element.isElement(n) && !editor.isVoid(n) && !editor.isInline(n)) {\n          return false;\n        }\n\n        if (mergeEnd && Path.isAncestor(p, lastPath) && Element.isElement(n) && !editor.isVoid(n) && !editor.isInline(n)) {\n          return false;\n        }\n\n        return true;\n      };\n\n      var _iterator2 = _createForOfIteratorHelper(Node.nodes({\n        children: fragment\n      }, {\n        pass: matcher\n      })),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var entry = _step2.value;\n\n          if (matcher(entry)) {\n            matches.push(entry);\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      var starts = [];\n      var middles = [];\n      var ends = [];\n      var starting = true;\n      var hasBlocks = false;\n\n      for (var _i = 0, _matches = matches; _i < _matches.length; _i++) {\n        var _matches$_i = _slicedToArray(_matches[_i], 1),\n            node = _matches$_i[0];\n\n        if (Element.isElement(node) && !editor.isInline(node)) {\n          starting = false;\n          hasBlocks = true;\n          middles.push(node);\n        } else if (starting) {\n          starts.push(node);\n        } else {\n          ends.push(node);\n        }\n      }\n\n      var _Editor$nodes = Editor.nodes(editor, {\n        at: at,\n        match: function match(n) {\n          return Text.isText(n) || Editor.isInline(editor, n);\n        },\n        mode: 'highest',\n        voids: voids\n      }),\n          _Editor$nodes2 = _slicedToArray(_Editor$nodes, 1),\n          inlineMatch = _Editor$nodes2[0];\n\n      var _inlineMatch = _slicedToArray(inlineMatch, 2),\n          inlinePath = _inlineMatch[1];\n\n      var isInlineStart = Editor.isStart(editor, at, inlinePath);\n      var isInlineEnd = Editor.isEnd(editor, at, inlinePath);\n      var middleRef = Editor.pathRef(editor, isBlockEnd && !ends.length ? Path.next(blockPath) : blockPath);\n      var endRef = Editor.pathRef(editor, isInlineEnd ? Path.next(inlinePath) : inlinePath);\n      Transforms.splitNodes(editor, {\n        at: at,\n        match: function match(n) {\n          return hasBlocks ? Element.isElement(n) && Editor.isBlock(editor, n) : Text.isText(n) || Editor.isInline(editor, n);\n        },\n        mode: hasBlocks ? 'lowest' : 'highest',\n        always: hasBlocks && (!isBlockStart || starts.length > 0) && (!isBlockEnd || ends.length > 0),\n        voids: voids\n      });\n      var startRef = Editor.pathRef(editor, !isInlineStart || isInlineStart && isInlineEnd ? Path.next(inlinePath) : inlinePath);\n      Transforms.insertNodes(editor, starts, {\n        at: startRef.current,\n        match: function match(n) {\n          return Text.isText(n) || Editor.isInline(editor, n);\n        },\n        mode: 'highest',\n        voids: voids\n      });\n\n      if (isBlockEmpty && !starts.length && middles.length && !ends.length) {\n        Transforms[\"delete\"](editor, {\n          at: blockPath,\n          voids: voids\n        });\n      }\n\n      Transforms.insertNodes(editor, middles, {\n        at: middleRef.current,\n        match: function match(n) {\n          return Element.isElement(n) && Editor.isBlock(editor, n);\n        },\n        mode: 'lowest',\n        voids: voids\n      });\n      Transforms.insertNodes(editor, ends, {\n        at: endRef.current,\n        match: function match(n) {\n          return Text.isText(n) || Editor.isInline(editor, n);\n        },\n        mode: 'highest',\n        voids: voids\n      });\n\n      if (!options.at) {\n        var path;\n\n        if (ends.length > 0 && endRef.current) {\n          path = Path.previous(endRef.current);\n        } else if (middles.length > 0 && middleRef.current) {\n          path = Path.previous(middleRef.current);\n        } else if (startRef.current) {\n          path = Path.previous(startRef.current);\n        }\n\n        if (path) {\n          var _end2 = Editor.end(editor, path);\n\n          Transforms.select(editor, _end2);\n        }\n      }\n\n      startRef.unref();\n      middleRef.unref();\n      endRef.unref();\n    });\n  },\n\n  /**\r\n   * Insert a string of text in the Editor.\r\n   */\n  insertText: function insertText(editor, text) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    Editor.withoutNormalizing(editor, function () {\n      var _options$voids3 = options.voids,\n          voids = _options$voids3 === void 0 ? false : _options$voids3;\n      var _options$at3 = options.at,\n          at = _options$at3 === void 0 ? editor.selection : _options$at3;\n\n      if (!at) {\n        return;\n      }\n\n      if (Path.isPath(at)) {\n        at = Editor.range(editor, at);\n      }\n\n      if (Range.isRange(at)) {\n        if (Range.isCollapsed(at)) {\n          at = at.anchor;\n        } else {\n          var end = Range.end(at);\n\n          if (!voids && Editor[\"void\"](editor, {\n            at: end\n          })) {\n            return;\n          }\n\n          var start = Range.start(at);\n          var startRef = Editor.pointRef(editor, start);\n          var endRef = Editor.pointRef(editor, end);\n          Transforms[\"delete\"](editor, {\n            at: at,\n            voids: voids\n          });\n          var startPoint = startRef.unref();\n          var endPoint = endRef.unref();\n          at = startPoint || endPoint;\n          Transforms.setSelection(editor, {\n            anchor: at,\n            focus: at\n          });\n        }\n      }\n\n      if (!voids && Editor[\"void\"](editor, {\n        at: at\n      })) {\n        return;\n      }\n\n      var _at = at,\n          path = _at.path,\n          offset = _at.offset;\n      if (text.length > 0) editor.apply({\n        type: 'insert_text',\n        path: path,\n        offset: offset,\n        text: text\n      });\n    });\n  }\n};\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\nvar Transforms = _objectSpread(_objectSpread(_objectSpread(_objectSpread({}, GeneralTransforms), NodeTransforms), SelectionTransforms), TextTransforms);\n\nexports.Editor = Editor;\nexports.Element = Element;\nexports.Location = Location;\nexports.Node = Node;\nexports.Operation = Operation;\nexports.Path = Path;\nexports.PathRef = PathRef;\nexports.Point = Point;\nexports.PointRef = PointRef;\nexports.Range = Range;\nexports.RangeRef = RangeRef;\nexports.Scrubber = Scrubber;\nexports.Span = Span;\nexports.Text = Text;\nexports.Transforms = Transforms;\nexports.createEditor = createEditor;\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc2xhdGUvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7O0FBRTdELG9CQUFvQixtQkFBTyxDQUFDLHFGQUFpQjtBQUM3QyxZQUFZLG1CQUFPLENBQUMsdURBQU87O0FBRTNCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQixhQUFhO0FBQ2hDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx5Q0FBeUMsU0FBUztBQUNsRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSw0QkFBNEIsK0JBQStCO0FBQzNEOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFD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QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQSxrQkFBa0IsZ0JBQWdCO0FBQ2xDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHNDQUFzQzs7QUFFdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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LEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQixnQ0FBZ0M7QUFDM0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCLGdDQUFnQztBQUMzRDtBQUNBO0FBQ0E7O0FBRUEsK0RBQStEOztBQUUvRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxVQUFVOzs7QUFHVjtBQUNBO0FBQ0E7QUFDQSxVQUFVOzs7QUFHVjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUTs7QUFFUixNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZCQUE2QixnQ0FBZ0M7QUFDN0Q7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUEsOENBQThDOztBQUU5QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCOztBQUV0QjtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0EsMkJBQTJCLGdDQUFnQztBQUMzRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7O0FBR0EsK0NBQStDOztBQUUvQztBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsVUFBVTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsT0FBTztBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBLHVEQUF1RDtBQUN2RDtBQUNBLHNDQUFzQyxtQkFBbUI7QUFDekQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDLFlBQVk7QUFDWjtBQUNBO0FBQ0EsWUFBWTs7O0FBR1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTs7O0FBR1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFO0FBQ2pFOztBQUVBO0FBQ0EsY0FBYzs7O0FBR2Q7QUFDQSw4REFBOEQ7QUFDOUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdDQUFnQztBQUNoQzs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBLDJCQUEyQixnQ0FBZ0M7QUFDM0Q7QUFDQTtBQUNB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QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCLGdDQUFnQztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTs7O0FBR1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFROzs7QUFHUjtBQUNBO0FBQ0EsUUFBUTs7O0FBR1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7O0FBR1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFROzs7QUFHUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCLGdDQUFnQztBQUMzRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FB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LEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qjs7QUFFNUI7O0FBRUE7QUFDQSxpRkFBaUY7O0FBRWpGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLG9DQUFvQztBQUNsRDtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qzs7QUFFdkM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDZDQUE2QyxnQ0FBZ0Msb0NBQW9DLG9EQUFvRCxzQkFBc0IsMENBQTBDLGlFQUFpRSxLQUFLLGtDQUFrQzs7QUFFN1UsbUNBQW1DLGdCQUFnQixzQkFBc0IsT0FBTyx1REFBdUQsYUFBYSx5REFBeUQsNENBQTRDLEtBQUssNkNBQTZDLDZFQUE2RSxPQUFPLG1EQUFtRCxtRkFBbUYsT0FBTzs7QUFFNWdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBLG9GQUFvRixjQUFjO0FBQ2xHO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSw2Q0FBNkMsZ0NBQWdDLG9DQUFvQyxvREFBb0Qsc0JBQXNCLDBDQUEwQyxpRUFBaUUsS0FBSyxrQ0FBa0M7O0FBRTdVLG1DQUFtQyxnQkFBZ0Isc0JBQXNCLE9BQU8sdURBQXVELGFBQWEseURBQXlELDRDQUE0QyxLQUFLLDZDQUE2Qyw2RUFBNkUsT0FBTyxtREFBbUQsbUZBQW1GLE9BQU87O0FBRTVnQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxR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Q0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0EsK0JBQStCLGdDQUFnQztBQUMvRDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMkIsZ0NBQWdDO0FBQzNEO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsV0FBVztBQUNYOztBQUVBLDZCQUE2QixnQ0FBZ0M7QUFDN0Q7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPOztBQUVQLHdDQUF3QyxxQkFBcUI7QUFDN0Q7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsNERBQTRELGNBQWM7QUFDMUU7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FB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O0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU8sR0FBRzs7QUFFVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBLDRCQUE0Qiw4QkFBOEI7QUFDMUQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87O0FBRVA7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLFFBQVE7QUFDUjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBLDZCQUE2QixnQ0FBZ0M7QUFDN0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJDQUEyQyxzQkFBc0I7QUFDakU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWOztBQUVBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7O0FBRUEsMkNBQTJDLGdDQUFnQyxvQ0FBb0Msb0RBQW9ELHNCQUFzQiwwQ0FBMEMsaUVBQWlFLEtBQUssa0NBQWtDOztBQUUzVSxpQ0FBaUMsZ0JBQWdCLHNCQUFzQixPQUFPLHVEQUF1RCxhQUFhLHVEQUF1RCw0Q0FBNEMsS0FBSyw2Q0FBNkMsNkVBQTZFLE9BQU8saURBQWlELG1GQUFtRixPQUFPO0FBQ3RnQiwyRUFBMkU7O0FBRTNFLGNBQWM7QUFDZCxlQUFlO0FBQ2YsZ0JBQWdCO0FBQ2hCLFlBQVk7QUFDWixpQkFBaUI7QUFDakIsWUFBWTtBQUNaLGVBQWU7QUFDZixhQUFhO0FBQ2IsZ0JBQWdCO0FBQ2hCLGFBQWE7QUFDYixnQkFBZ0I7QUFDaEIsZ0JBQWdCO0FBQ2hCLFlBQVk7QUFDWixZQUFZO0FBQ1osa0JBQWtCO0FBQ2xCLG9CQUFvQjtBQUNwQiIsInNvdXJjZXMiOlsid2VicGFjazovL3BheWxvYWQvLi9ub2RlX21vZHVsZXMvc2xhdGUvZGlzdC9pbmRleC5qcz83OThiIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxudmFyIGlzUGxhaW5PYmplY3QgPSByZXF1aXJlKCdpcy1wbGFpbi1vYmplY3QnKTtcbnZhciBpbW1lciA9IHJlcXVpcmUoJ2ltbWVyJyk7XG5cbmZ1bmN0aW9uIHVud3JhcEV4cG9ydHMgKHgpIHtcblx0cmV0dXJuIHggJiYgeC5fX2VzTW9kdWxlICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh4LCAnZGVmYXVsdCcpID8geFsnZGVmYXVsdCddIDogeDtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ29tbW9uanNNb2R1bGUoZm4sIG1vZHVsZSkge1xuXHRyZXR1cm4gbW9kdWxlID0geyBleHBvcnRzOiB7fSB9LCBmbihtb2R1bGUsIG1vZHVsZS5leHBvcnRzKSwgbW9kdWxlLmV4cG9ydHM7XG59XG5cbnZhciBhcnJheUxpa2VUb0FycmF5ID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSkge1xuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHtcbiAgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7XG4gICAgYXJyMltpXSA9IGFycltpXTtcbiAgfVxuXG4gIHJldHVybiBhcnIyO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9hcnJheUxpa2VUb0FycmF5O1xubW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHMsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xufSk7XG5cbnVud3JhcEV4cG9ydHMoYXJyYXlMaWtlVG9BcnJheSk7XG5cbnZhciBhcnJheVdpdGhvdXRIb2xlcyA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUpIHtcbmZ1bmN0aW9uIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIGFycmF5TGlrZVRvQXJyYXkoYXJyKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfYXJyYXlXaXRob3V0SG9sZXM7XG5tb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG59KTtcblxudW53cmFwRXhwb3J0cyhhcnJheVdpdGhvdXRIb2xlcyk7XG5cbnZhciBpdGVyYWJsZVRvQXJyYXkgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlKSB7XG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5KGl0ZXIpIHtcbiAgaWYgKHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgaXRlcltTeW1ib2wuaXRlcmF0b3JdICE9IG51bGwgfHwgaXRlcltcIkBAaXRlcmF0b3JcIl0gIT0gbnVsbCkgcmV0dXJuIEFycmF5LmZyb20oaXRlcik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2l0ZXJhYmxlVG9BcnJheTtcbm1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbn0pO1xuXG51bndyYXBFeHBvcnRzKGl0ZXJhYmxlVG9BcnJheSk7XG5cbnZhciB1bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUpIHtcbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHtcbiAgaWYgKCFvKSByZXR1cm47XG4gIGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIGFycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbiAgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpO1xuICBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lO1xuICBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTtcbiAgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBhcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5O1xubW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHMsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xufSk7XG5cbnVud3JhcEV4cG9ydHModW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkpO1xuXG52YXIgbm9uSXRlcmFibGVTcHJlYWQgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlKSB7XG5mdW5jdGlvbiBfbm9uSXRlcmFibGVTcHJlYWQoKSB7XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gc3ByZWFkIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9ub25JdGVyYWJsZVNwcmVhZDtcbm1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbn0pO1xuXG51bndyYXBFeHBvcnRzKG5vbkl0ZXJhYmxlU3ByZWFkKTtcblxudmFyIHRvQ29uc3VtYWJsZUFycmF5ID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSkge1xuZnVuY3Rpb24gX3RvQ29uc3VtYWJsZUFycmF5KGFycikge1xuICByZXR1cm4gYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB8fCBpdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCB1bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIpIHx8IG5vbkl0ZXJhYmxlU3ByZWFkKCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX3RvQ29uc3VtYWJsZUFycmF5O1xubW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHMsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xufSk7XG5cbnZhciBfdG9Db25zdW1hYmxlQXJyYXkgPSB1bndyYXBFeHBvcnRzKHRvQ29uc3VtYWJsZUFycmF5KTtcblxudmFyIGRlZmluZVByb3BlcnR5ID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSkge1xuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkge1xuICBpZiAoa2V5IGluIG9iaikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgfVxuXG4gIHJldHVybiBvYmo7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2RlZmluZVByb3BlcnR5O1xubW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHMsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xufSk7XG5cbnZhciBfZGVmaW5lUHJvcGVydHkgPSB1bndyYXBFeHBvcnRzKGRlZmluZVByb3BlcnR5KTtcblxudmFyIGFycmF5V2l0aEhvbGVzID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSkge1xuZnVuY3Rpb24gX2FycmF5V2l0aEhvbGVzKGFycikge1xuICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gYXJyO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9hcnJheVdpdGhIb2xlcztcbm1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbn0pO1xuXG51bndyYXBFeHBvcnRzKGFycmF5V2l0aEhvbGVzKTtcblxudmFyIGl0ZXJhYmxlVG9BcnJheUxpbWl0ID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSkge1xuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkge1xuICB2YXIgX2kgPSBhcnIgPT0gbnVsbCA/IG51bGwgOiB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIGFycltTeW1ib2wuaXRlcmF0b3JdIHx8IGFycltcIkBAaXRlcmF0b3JcIl07XG5cbiAgaWYgKF9pID09IG51bGwpIHJldHVybjtcbiAgdmFyIF9hcnIgPSBbXTtcbiAgdmFyIF9uID0gdHJ1ZTtcbiAgdmFyIF9kID0gZmFsc2U7XG5cbiAgdmFyIF9zLCBfZTtcblxuICB0cnkge1xuICAgIGZvciAoX2kgPSBfaS5jYWxsKGFycik7ICEoX24gPSAoX3MgPSBfaS5uZXh0KCkpLmRvbmUpOyBfbiA9IHRydWUpIHtcbiAgICAgIF9hcnIucHVzaChfcy52YWx1ZSk7XG5cbiAgICAgIGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhaztcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIF9kID0gdHJ1ZTtcbiAgICBfZSA9IGVycjtcbiAgfSBmaW5hbGx5IHtcbiAgICB0cnkge1xuICAgICAgaWYgKCFfbiAmJiBfaVtcInJldHVyblwiXSAhPSBudWxsKSBfaVtcInJldHVyblwiXSgpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBpZiAoX2QpIHRocm93IF9lO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBfYXJyO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9pdGVyYWJsZVRvQXJyYXlMaW1pdDtcbm1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbn0pO1xuXG51bndyYXBFeHBvcnRzKGl0ZXJhYmxlVG9BcnJheUxpbWl0KTtcblxudmFyIG5vbkl0ZXJhYmxlUmVzdCA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUpIHtcbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVJlc3QoKSB7XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX25vbkl0ZXJhYmxlUmVzdDtcbm1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbn0pO1xuXG51bndyYXBFeHBvcnRzKG5vbkl0ZXJhYmxlUmVzdCk7XG5cbnZhciBzbGljZWRUb0FycmF5ID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSkge1xuZnVuY3Rpb24gX3NsaWNlZFRvQXJyYXkoYXJyLCBpKSB7XG4gIHJldHVybiBhcnJheVdpdGhIb2xlcyhhcnIpIHx8IGl0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgfHwgdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyLCBpKSB8fCBub25JdGVyYWJsZVJlc3QoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfc2xpY2VkVG9BcnJheTtcbm1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbn0pO1xuXG52YXIgX3NsaWNlZFRvQXJyYXkgPSB1bndyYXBFeHBvcnRzKHNsaWNlZFRvQXJyYXkpO1xuXG52YXIgRElSVFlfUEFUSFMgPSBuZXcgV2Vha01hcCgpO1xudmFyIERJUlRZX1BBVEhfS0VZUyA9IG5ldyBXZWFrTWFwKCk7XG52YXIgRkxVU0hJTkcgPSBuZXcgV2Vha01hcCgpO1xudmFyIE5PUk1BTElaSU5HID0gbmV3IFdlYWtNYXAoKTtcbnZhciBQQVRIX1JFRlMgPSBuZXcgV2Vha01hcCgpO1xudmFyIFBPSU5UX1JFRlMgPSBuZXcgV2Vha01hcCgpO1xudmFyIFJBTkdFX1JFRlMgPSBuZXcgV2Vha01hcCgpO1xuXG5mdW5jdGlvbiBvd25LZXlzJDkob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBpZiAoZW51bWVyYWJsZU9ubHkpIHsgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyB9IGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkJDkodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgb3duS2V5cyQ5KE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pOyB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7IH0gZWxzZSB7IG93bktleXMkOShPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkNyhvLCBhbGxvd0FycmF5TGlrZSkgeyB2YXIgaXQgPSB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXSB8fCBvW1wiQEBpdGVyYXRvclwiXTsgaWYgKCFpdCkgeyBpZiAoQXJyYXkuaXNBcnJheShvKSB8fCAoaXQgPSBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkkNyhvKSkgfHwgYWxsb3dBcnJheUxpa2UgJiYgbyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHsgaWYgKGl0KSBvID0gaXQ7IHZhciBpID0gMDsgdmFyIEYgPSBmdW5jdGlvbiBGKCkge307IHJldHVybiB7IHM6IEYsIG46IGZ1bmN0aW9uIG4oKSB7IGlmIChpID49IG8ubGVuZ3RoKSByZXR1cm4geyBkb25lOiB0cnVlIH07IHJldHVybiB7IGRvbmU6IGZhbHNlLCB2YWx1ZTogb1tpKytdIH07IH0sIGU6IGZ1bmN0aW9uIGUoX2UpIHsgdGhyb3cgX2U7IH0sIGY6IEYgfTsgfSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGl0ZXJhdGUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH0gdmFyIG5vcm1hbENvbXBsZXRpb24gPSB0cnVlLCBkaWRFcnIgPSBmYWxzZSwgZXJyOyByZXR1cm4geyBzOiBmdW5jdGlvbiBzKCkgeyBpdCA9IGl0LmNhbGwobyk7IH0sIG46IGZ1bmN0aW9uIG4oKSB7IHZhciBzdGVwID0gaXQubmV4dCgpOyBub3JtYWxDb21wbGV0aW9uID0gc3RlcC5kb25lOyByZXR1cm4gc3RlcDsgfSwgZTogZnVuY3Rpb24gZShfZTIpIHsgZGlkRXJyID0gdHJ1ZTsgZXJyID0gX2UyOyB9LCBmOiBmdW5jdGlvbiBmKCkgeyB0cnkgeyBpZiAoIW5vcm1hbENvbXBsZXRpb24gJiYgaXRbXCJyZXR1cm5cIl0gIT0gbnVsbCkgaXRbXCJyZXR1cm5cIl0oKTsgfSBmaW5hbGx5IHsgaWYgKGRpZEVycikgdGhyb3cgZXJyOyB9IH0gfTsgfVxuXG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkkNyhvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5JDcobywgbWluTGVuKTsgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheSQ3KG8sIG1pbkxlbik7IH1cblxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkkNyhhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH1cbi8qKlxyXG4gKiBDcmVhdGUgYSBuZXcgU2xhdGUgYEVkaXRvcmAgb2JqZWN0LlxyXG4gKi9cblxudmFyIGNyZWF0ZUVkaXRvciA9IGZ1bmN0aW9uIGNyZWF0ZUVkaXRvcigpIHtcbiAgdmFyIGVkaXRvciA9IHtcbiAgICBjaGlsZHJlbjogW10sXG4gICAgb3BlcmF0aW9uczogW10sXG4gICAgc2VsZWN0aW9uOiBudWxsLFxuICAgIG1hcmtzOiBudWxsLFxuICAgIGlzSW5saW5lOiBmdW5jdGlvbiBpc0lubGluZSgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuICAgIGlzVm9pZDogZnVuY3Rpb24gaXNWb2lkKCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG4gICAgbWFya2FibGVWb2lkOiBmdW5jdGlvbiBtYXJrYWJsZVZvaWQoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcbiAgICBvbkNoYW5nZTogZnVuY3Rpb24gb25DaGFuZ2UoKSB7fSxcbiAgICBhcHBseTogZnVuY3Rpb24gYXBwbHkob3ApIHtcbiAgICAgIHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciQ3KEVkaXRvci5wYXRoUmVmcyhlZGl0b3IpKSxcbiAgICAgICAgICBfc3RlcDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChfaXRlcmF0b3IucygpOyAhKF9zdGVwID0gX2l0ZXJhdG9yLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICB2YXIgcmVmID0gX3N0ZXAudmFsdWU7XG4gICAgICAgICAgUGF0aFJlZi50cmFuc2Zvcm0ocmVmLCBvcCk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3IuZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yLmYoKTtcbiAgICAgIH1cblxuICAgICAgdmFyIF9pdGVyYXRvcjIgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciQ3KEVkaXRvci5wb2ludFJlZnMoZWRpdG9yKSksXG4gICAgICAgICAgX3N0ZXAyO1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKF9pdGVyYXRvcjIucygpOyAhKF9zdGVwMiA9IF9pdGVyYXRvcjIubigpKS5kb25lOykge1xuICAgICAgICAgIHZhciBfcmVmID0gX3N0ZXAyLnZhbHVlO1xuICAgICAgICAgIFBvaW50UmVmLnRyYW5zZm9ybShfcmVmLCBvcCk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3IyLmUoZXJyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIF9pdGVyYXRvcjIuZigpO1xuICAgICAgfVxuXG4gICAgICB2YXIgX2l0ZXJhdG9yMyA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDcoRWRpdG9yLnJhbmdlUmVmcyhlZGl0b3IpKSxcbiAgICAgICAgICBfc3RlcDM7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoX2l0ZXJhdG9yMy5zKCk7ICEoX3N0ZXAzID0gX2l0ZXJhdG9yMy5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgdmFyIF9yZWYyID0gX3N0ZXAzLnZhbHVlO1xuICAgICAgICAgIFJhbmdlUmVmLnRyYW5zZm9ybShfcmVmMiwgb3ApO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2l0ZXJhdG9yMy5lKGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBfaXRlcmF0b3IzLmYoKTtcbiAgICAgIH1cblxuICAgICAgdmFyIG9sZERpcnR5UGF0aHMgPSBESVJUWV9QQVRIUy5nZXQoZWRpdG9yKSB8fCBbXTtcbiAgICAgIHZhciBvbGREaXJ0eVBhdGhLZXlzID0gRElSVFlfUEFUSF9LRVlTLmdldChlZGl0b3IpIHx8IG5ldyBTZXQoKTtcbiAgICAgIHZhciBkaXJ0eVBhdGhzO1xuICAgICAgdmFyIGRpcnR5UGF0aEtleXM7XG5cbiAgICAgIHZhciBhZGQgPSBmdW5jdGlvbiBhZGQocGF0aCkge1xuICAgICAgICBpZiAocGF0aCkge1xuICAgICAgICAgIHZhciBrZXkgPSBwYXRoLmpvaW4oJywnKTtcblxuICAgICAgICAgIGlmICghZGlydHlQYXRoS2V5cy5oYXMoa2V5KSkge1xuICAgICAgICAgICAgZGlydHlQYXRoS2V5cy5hZGQoa2V5KTtcbiAgICAgICAgICAgIGRpcnR5UGF0aHMucHVzaChwYXRoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGlmIChQYXRoLm9wZXJhdGlvbkNhblRyYW5zZm9ybVBhdGgob3ApKSB7XG4gICAgICAgIGRpcnR5UGF0aHMgPSBbXTtcbiAgICAgICAgZGlydHlQYXRoS2V5cyA9IG5ldyBTZXQoKTtcblxuICAgICAgICB2YXIgX2l0ZXJhdG9yNCA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDcob2xkRGlydHlQYXRocyksXG4gICAgICAgICAgICBfc3RlcDQ7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBmb3IgKF9pdGVyYXRvcjQucygpOyAhKF9zdGVwNCA9IF9pdGVyYXRvcjQubigpKS5kb25lOykge1xuICAgICAgICAgICAgdmFyIHBhdGggPSBfc3RlcDQudmFsdWU7XG4gICAgICAgICAgICB2YXIgbmV3UGF0aCA9IFBhdGgudHJhbnNmb3JtKHBhdGgsIG9wKTtcbiAgICAgICAgICAgIGFkZChuZXdQYXRoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIF9pdGVyYXRvcjQuZShlcnIpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIF9pdGVyYXRvcjQuZigpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkaXJ0eVBhdGhzID0gb2xkRGlydHlQYXRocztcbiAgICAgICAgZGlydHlQYXRoS2V5cyA9IG9sZERpcnR5UGF0aEtleXM7XG4gICAgICB9XG5cbiAgICAgIHZhciBuZXdEaXJ0eVBhdGhzID0gZWRpdG9yLmdldERpcnR5UGF0aHMob3ApO1xuXG4gICAgICB2YXIgX2l0ZXJhdG9yNSA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDcobmV3RGlydHlQYXRocyksXG4gICAgICAgICAgX3N0ZXA1O1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKF9pdGVyYXRvcjUucygpOyAhKF9zdGVwNSA9IF9pdGVyYXRvcjUubigpKS5kb25lOykge1xuICAgICAgICAgIHZhciBfcGF0aCA9IF9zdGVwNS52YWx1ZTtcbiAgICAgICAgICBhZGQoX3BhdGgpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2l0ZXJhdG9yNS5lKGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBfaXRlcmF0b3I1LmYoKTtcbiAgICAgIH1cblxuICAgICAgRElSVFlfUEFUSFMuc2V0KGVkaXRvciwgZGlydHlQYXRocyk7XG4gICAgICBESVJUWV9QQVRIX0tFWVMuc2V0KGVkaXRvciwgZGlydHlQYXRoS2V5cyk7XG4gICAgICBUcmFuc2Zvcm1zLnRyYW5zZm9ybShlZGl0b3IsIG9wKTtcbiAgICAgIGVkaXRvci5vcGVyYXRpb25zLnB1c2gob3ApO1xuICAgICAgRWRpdG9yLm5vcm1hbGl6ZShlZGl0b3IsIHtcbiAgICAgICAgb3BlcmF0aW9uOiBvcFxuICAgICAgfSk7IC8vIENsZWFyIGFueSBmb3JtYXRzIGFwcGxpZWQgdG8gdGhlIGN1cnNvciBpZiB0aGUgc2VsZWN0aW9uIGNoYW5nZXMuXG5cbiAgICAgIGlmIChvcC50eXBlID09PSAnc2V0X3NlbGVjdGlvbicpIHtcbiAgICAgICAgZWRpdG9yLm1hcmtzID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgaWYgKCFGTFVTSElORy5nZXQoZWRpdG9yKSkge1xuICAgICAgICBGTFVTSElORy5zZXQoZWRpdG9yLCB0cnVlKTtcbiAgICAgICAgUHJvbWlzZS5yZXNvbHZlKCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgRkxVU0hJTkcuc2V0KGVkaXRvciwgZmFsc2UpO1xuICAgICAgICAgIGVkaXRvci5vbkNoYW5nZSh7XG4gICAgICAgICAgICBvcGVyYXRpb246IG9wXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZWRpdG9yLm9wZXJhdGlvbnMgPSBbXTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBhZGRNYXJrOiBmdW5jdGlvbiBhZGRNYXJrKGtleSwgdmFsdWUpIHtcbiAgICAgIHZhciBzZWxlY3Rpb24gPSBlZGl0b3Iuc2VsZWN0aW9uO1xuICAgICAgICAgIGVkaXRvci5tYXJrYWJsZVZvaWQ7XG5cbiAgICAgIGlmIChzZWxlY3Rpb24pIHtcbiAgICAgICAgdmFyIG1hdGNoID0gZnVuY3Rpb24gbWF0Y2gobm9kZSwgcGF0aCkge1xuICAgICAgICAgIGlmICghVGV4dC5pc1RleHQobm9kZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gbWFya3MgY2FuIG9ubHkgYmUgYXBwbGllZCB0byB0ZXh0XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIF9FZGl0b3IkcGFyZW50ID0gRWRpdG9yLnBhcmVudChlZGl0b3IsIHBhdGgpLFxuICAgICAgICAgICAgICBfRWRpdG9yJHBhcmVudDIgPSBfc2xpY2VkVG9BcnJheShfRWRpdG9yJHBhcmVudCwgMiksXG4gICAgICAgICAgICAgIHBhcmVudE5vZGUgPSBfRWRpdG9yJHBhcmVudDJbMF07XG4gICAgICAgICAgICAgIF9FZGl0b3IkcGFyZW50MlsxXTtcblxuICAgICAgICAgIHJldHVybiAhZWRpdG9yLmlzVm9pZChwYXJlbnROb2RlKSB8fCBlZGl0b3IubWFya2FibGVWb2lkKHBhcmVudE5vZGUpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBleHBhbmRlZFNlbGVjdGlvbiA9IFJhbmdlLmlzRXhwYW5kZWQoc2VsZWN0aW9uKTtcbiAgICAgICAgdmFyIG1hcmtBY2NlcHRpbmdWb2lkU2VsZWN0ZWQgPSBmYWxzZTtcblxuICAgICAgICBpZiAoIWV4cGFuZGVkU2VsZWN0aW9uKSB7XG4gICAgICAgICAgdmFyIF9FZGl0b3Ikbm9kZSA9IEVkaXRvci5ub2RlKGVkaXRvciwgc2VsZWN0aW9uKSxcbiAgICAgICAgICAgICAgX0VkaXRvciRub2RlMiA9IF9zbGljZWRUb0FycmF5KF9FZGl0b3Ikbm9kZSwgMiksXG4gICAgICAgICAgICAgIHNlbGVjdGVkTm9kZSA9IF9FZGl0b3Ikbm9kZTJbMF0sXG4gICAgICAgICAgICAgIHNlbGVjdGVkUGF0aCA9IF9FZGl0b3Ikbm9kZTJbMV07XG5cbiAgICAgICAgICBpZiAoc2VsZWN0ZWROb2RlICYmIG1hdGNoKHNlbGVjdGVkTm9kZSwgc2VsZWN0ZWRQYXRoKSkge1xuICAgICAgICAgICAgdmFyIF9FZGl0b3IkcGFyZW50MyA9IEVkaXRvci5wYXJlbnQoZWRpdG9yLCBzZWxlY3RlZFBhdGgpLFxuICAgICAgICAgICAgICAgIF9FZGl0b3IkcGFyZW50NCA9IF9zbGljZWRUb0FycmF5KF9FZGl0b3IkcGFyZW50MywgMSksXG4gICAgICAgICAgICAgICAgcGFyZW50Tm9kZSA9IF9FZGl0b3IkcGFyZW50NFswXTtcblxuICAgICAgICAgICAgbWFya0FjY2VwdGluZ1ZvaWRTZWxlY3RlZCA9IHBhcmVudE5vZGUgJiYgZWRpdG9yLm1hcmthYmxlVm9pZChwYXJlbnROb2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXhwYW5kZWRTZWxlY3Rpb24gfHwgbWFya0FjY2VwdGluZ1ZvaWRTZWxlY3RlZCkge1xuICAgICAgICAgIFRyYW5zZm9ybXMuc2V0Tm9kZXMoZWRpdG9yLCBfZGVmaW5lUHJvcGVydHkoe30sIGtleSwgdmFsdWUpLCB7XG4gICAgICAgICAgICBtYXRjaDogbWF0Y2gsXG4gICAgICAgICAgICBzcGxpdDogdHJ1ZSxcbiAgICAgICAgICAgIHZvaWRzOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIG1hcmtzID0gX29iamVjdFNwcmVhZCQ5KF9vYmplY3RTcHJlYWQkOSh7fSwgRWRpdG9yLm1hcmtzKGVkaXRvcikgfHwge30pLCB7fSwgX2RlZmluZVByb3BlcnR5KHt9LCBrZXksIHZhbHVlKSk7XG5cbiAgICAgICAgICBlZGl0b3IubWFya3MgPSBtYXJrcztcblxuICAgICAgICAgIGlmICghRkxVU0hJTkcuZ2V0KGVkaXRvcikpIHtcbiAgICAgICAgICAgIGVkaXRvci5vbkNoYW5nZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgZGVsZXRlQmFja3dhcmQ6IGZ1bmN0aW9uIGRlbGV0ZUJhY2t3YXJkKHVuaXQpIHtcbiAgICAgIHZhciBzZWxlY3Rpb24gPSBlZGl0b3Iuc2VsZWN0aW9uO1xuXG4gICAgICBpZiAoc2VsZWN0aW9uICYmIFJhbmdlLmlzQ29sbGFwc2VkKHNlbGVjdGlvbikpIHtcbiAgICAgICAgVHJhbnNmb3Jtc1tcImRlbGV0ZVwiXShlZGl0b3IsIHtcbiAgICAgICAgICB1bml0OiB1bml0LFxuICAgICAgICAgIHJldmVyc2U6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBkZWxldGVGb3J3YXJkOiBmdW5jdGlvbiBkZWxldGVGb3J3YXJkKHVuaXQpIHtcbiAgICAgIHZhciBzZWxlY3Rpb24gPSBlZGl0b3Iuc2VsZWN0aW9uO1xuXG4gICAgICBpZiAoc2VsZWN0aW9uICYmIFJhbmdlLmlzQ29sbGFwc2VkKHNlbGVjdGlvbikpIHtcbiAgICAgICAgVHJhbnNmb3Jtc1tcImRlbGV0ZVwiXShlZGl0b3IsIHtcbiAgICAgICAgICB1bml0OiB1bml0XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sXG4gICAgZGVsZXRlRnJhZ21lbnQ6IGZ1bmN0aW9uIGRlbGV0ZUZyYWdtZW50KGRpcmVjdGlvbikge1xuICAgICAgdmFyIHNlbGVjdGlvbiA9IGVkaXRvci5zZWxlY3Rpb247XG5cbiAgICAgIGlmIChzZWxlY3Rpb24gJiYgUmFuZ2UuaXNFeHBhbmRlZChzZWxlY3Rpb24pKSB7XG4gICAgICAgIFRyYW5zZm9ybXNbXCJkZWxldGVcIl0oZWRpdG9yLCB7XG4gICAgICAgICAgcmV2ZXJzZTogZGlyZWN0aW9uID09PSAnYmFja3dhcmQnXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sXG4gICAgZ2V0RnJhZ21lbnQ6IGZ1bmN0aW9uIGdldEZyYWdtZW50KCkge1xuICAgICAgdmFyIHNlbGVjdGlvbiA9IGVkaXRvci5zZWxlY3Rpb247XG5cbiAgICAgIGlmIChzZWxlY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIE5vZGUuZnJhZ21lbnQoZWRpdG9yLCBzZWxlY3Rpb24pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gW107XG4gICAgfSxcbiAgICBpbnNlcnRCcmVhazogZnVuY3Rpb24gaW5zZXJ0QnJlYWsoKSB7XG4gICAgICBUcmFuc2Zvcm1zLnNwbGl0Tm9kZXMoZWRpdG9yLCB7XG4gICAgICAgIGFsd2F5czogdHJ1ZVxuICAgICAgfSk7XG4gICAgfSxcbiAgICBpbnNlcnRTb2Z0QnJlYWs6IGZ1bmN0aW9uIGluc2VydFNvZnRCcmVhaygpIHtcbiAgICAgIFRyYW5zZm9ybXMuc3BsaXROb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgYWx3YXlzOiB0cnVlXG4gICAgICB9KTtcbiAgICB9LFxuICAgIGluc2VydEZyYWdtZW50OiBmdW5jdGlvbiBpbnNlcnRGcmFnbWVudChmcmFnbWVudCkge1xuICAgICAgVHJhbnNmb3Jtcy5pbnNlcnRGcmFnbWVudChlZGl0b3IsIGZyYWdtZW50KTtcbiAgICB9LFxuICAgIGluc2VydE5vZGU6IGZ1bmN0aW9uIGluc2VydE5vZGUobm9kZSkge1xuICAgICAgVHJhbnNmb3Jtcy5pbnNlcnROb2RlcyhlZGl0b3IsIG5vZGUpO1xuICAgIH0sXG4gICAgaW5zZXJ0VGV4dDogZnVuY3Rpb24gaW5zZXJ0VGV4dCh0ZXh0KSB7XG4gICAgICB2YXIgc2VsZWN0aW9uID0gZWRpdG9yLnNlbGVjdGlvbixcbiAgICAgICAgICBtYXJrcyA9IGVkaXRvci5tYXJrcztcblxuICAgICAgaWYgKHNlbGVjdGlvbikge1xuICAgICAgICBpZiAobWFya3MpIHtcbiAgICAgICAgICB2YXIgbm9kZSA9IF9vYmplY3RTcHJlYWQkOSh7XG4gICAgICAgICAgICB0ZXh0OiB0ZXh0XG4gICAgICAgICAgfSwgbWFya3MpO1xuXG4gICAgICAgICAgVHJhbnNmb3Jtcy5pbnNlcnROb2RlcyhlZGl0b3IsIG5vZGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIFRyYW5zZm9ybXMuaW5zZXJ0VGV4dChlZGl0b3IsIHRleHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgZWRpdG9yLm1hcmtzID0gbnVsbDtcbiAgICAgIH1cbiAgICB9LFxuICAgIG5vcm1hbGl6ZU5vZGU6IGZ1bmN0aW9uIG5vcm1hbGl6ZU5vZGUoZW50cnkpIHtcbiAgICAgIHZhciBfZW50cnkgPSBfc2xpY2VkVG9BcnJheShlbnRyeSwgMiksXG4gICAgICAgICAgbm9kZSA9IF9lbnRyeVswXSxcbiAgICAgICAgICBwYXRoID0gX2VudHJ5WzFdOyAvLyBUaGVyZSBhcmUgbm8gY29yZSBub3JtYWxpemF0aW9ucyBmb3IgdGV4dCBub2Rlcy5cblxuXG4gICAgICBpZiAoVGV4dC5pc1RleHQobm9kZSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyBFbnN1cmUgdGhhdCBibG9jayBhbmQgaW5saW5lIG5vZGVzIGhhdmUgYXQgbGVhc3Qgb25lIHRleHQgY2hpbGQuXG5cblxuICAgICAgaWYgKEVsZW1lbnQuaXNFbGVtZW50KG5vZGUpICYmIG5vZGUuY2hpbGRyZW4ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHZhciBjaGlsZCA9IHtcbiAgICAgICAgICB0ZXh0OiAnJ1xuICAgICAgICB9O1xuICAgICAgICBUcmFuc2Zvcm1zLmluc2VydE5vZGVzKGVkaXRvciwgY2hpbGQsIHtcbiAgICAgICAgICBhdDogcGF0aC5jb25jYXQoMCksXG4gICAgICAgICAgdm9pZHM6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gRGV0ZXJtaW5lIHdoZXRoZXIgdGhlIG5vZGUgc2hvdWxkIGhhdmUgYmxvY2sgb3IgaW5saW5lIGNoaWxkcmVuLlxuXG5cbiAgICAgIHZhciBzaG91bGRIYXZlSW5saW5lcyA9IEVkaXRvci5pc0VkaXRvcihub2RlKSA/IGZhbHNlIDogRWxlbWVudC5pc0VsZW1lbnQobm9kZSkgJiYgKGVkaXRvci5pc0lubGluZShub2RlKSB8fCBub2RlLmNoaWxkcmVuLmxlbmd0aCA9PT0gMCB8fCBUZXh0LmlzVGV4dChub2RlLmNoaWxkcmVuWzBdKSB8fCBlZGl0b3IuaXNJbmxpbmUobm9kZS5jaGlsZHJlblswXSkpOyAvLyBTaW5jZSB3ZSdsbCBiZSBhcHBseWluZyBvcGVyYXRpb25zIHdoaWxlIGl0ZXJhdGluZywga2VlcCB0cmFjayBvZiBhblxuICAgICAgLy8gaW5kZXggdGhhdCBhY2NvdW50cyBmb3IgYW55IGFkZGVkL3JlbW92ZWQgbm9kZXMuXG5cbiAgICAgIHZhciBuID0gMDtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSsrLCBuKyspIHtcbiAgICAgICAgdmFyIGN1cnJlbnROb2RlID0gTm9kZS5nZXQoZWRpdG9yLCBwYXRoKTtcbiAgICAgICAgaWYgKFRleHQuaXNUZXh0KGN1cnJlbnROb2RlKSkgY29udGludWU7XG4gICAgICAgIHZhciBfY2hpbGQgPSBub2RlLmNoaWxkcmVuW2ldO1xuICAgICAgICB2YXIgcHJldiA9IGN1cnJlbnROb2RlLmNoaWxkcmVuW24gLSAxXTtcbiAgICAgICAgdmFyIGlzTGFzdCA9IGkgPT09IG5vZGUuY2hpbGRyZW4ubGVuZ3RoIC0gMTtcbiAgICAgICAgdmFyIGlzSW5saW5lT3JUZXh0ID0gVGV4dC5pc1RleHQoX2NoaWxkKSB8fCBFbGVtZW50LmlzRWxlbWVudChfY2hpbGQpICYmIGVkaXRvci5pc0lubGluZShfY2hpbGQpOyAvLyBPbmx5IGFsbG93IGJsb2NrIG5vZGVzIGluIHRoZSB0b3AtbGV2ZWwgY2hpbGRyZW4gYW5kIHBhcmVudCBibG9ja3NcbiAgICAgICAgLy8gdGhhdCBvbmx5IGNvbnRhaW4gYmxvY2sgbm9kZXMuIFNpbWlsYXJseSwgb25seSBhbGxvdyBpbmxpbmUgbm9kZXMgaW5cbiAgICAgICAgLy8gb3RoZXIgaW5saW5lIG5vZGVzLCBvciBwYXJlbnQgYmxvY2tzIHRoYXQgb25seSBjb250YWluIGlubGluZXMgYW5kXG4gICAgICAgIC8vIHRleHQuXG5cbiAgICAgICAgaWYgKGlzSW5saW5lT3JUZXh0ICE9PSBzaG91bGRIYXZlSW5saW5lcykge1xuICAgICAgICAgIFRyYW5zZm9ybXMucmVtb3ZlTm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICBhdDogcGF0aC5jb25jYXQobiksXG4gICAgICAgICAgICB2b2lkczogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIG4tLTtcbiAgICAgICAgfSBlbHNlIGlmIChFbGVtZW50LmlzRWxlbWVudChfY2hpbGQpKSB7XG4gICAgICAgICAgLy8gRW5zdXJlIHRoYXQgaW5saW5lIG5vZGVzIGFyZSBzdXJyb3VuZGVkIGJ5IHRleHQgbm9kZXMuXG4gICAgICAgICAgaWYgKGVkaXRvci5pc0lubGluZShfY2hpbGQpKSB7XG4gICAgICAgICAgICBpZiAocHJldiA9PSBudWxsIHx8ICFUZXh0LmlzVGV4dChwcmV2KSkge1xuICAgICAgICAgICAgICB2YXIgbmV3Q2hpbGQgPSB7XG4gICAgICAgICAgICAgICAgdGV4dDogJydcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgVHJhbnNmb3Jtcy5pbnNlcnROb2RlcyhlZGl0b3IsIG5ld0NoaWxkLCB7XG4gICAgICAgICAgICAgICAgYXQ6IHBhdGguY29uY2F0KG4pLFxuICAgICAgICAgICAgICAgIHZvaWRzOiB0cnVlXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBuKys7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzTGFzdCkge1xuICAgICAgICAgICAgICB2YXIgX25ld0NoaWxkID0ge1xuICAgICAgICAgICAgICAgIHRleHQ6ICcnXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIFRyYW5zZm9ybXMuaW5zZXJ0Tm9kZXMoZWRpdG9yLCBfbmV3Q2hpbGQsIHtcbiAgICAgICAgICAgICAgICBhdDogcGF0aC5jb25jYXQobiArIDEpLFxuICAgICAgICAgICAgICAgIHZvaWRzOiB0cnVlXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBuKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIE1lcmdlIGFkamFjZW50IHRleHQgbm9kZXMgdGhhdCBhcmUgZW1wdHkgb3IgbWF0Y2guXG4gICAgICAgICAgaWYgKHByZXYgIT0gbnVsbCAmJiBUZXh0LmlzVGV4dChwcmV2KSkge1xuICAgICAgICAgICAgaWYgKFRleHQuZXF1YWxzKF9jaGlsZCwgcHJldiwge1xuICAgICAgICAgICAgICBsb29zZTogdHJ1ZVxuICAgICAgICAgICAgfSkpIHtcbiAgICAgICAgICAgICAgVHJhbnNmb3Jtcy5tZXJnZU5vZGVzKGVkaXRvciwge1xuICAgICAgICAgICAgICAgIGF0OiBwYXRoLmNvbmNhdChuKSxcbiAgICAgICAgICAgICAgICB2b2lkczogdHJ1ZVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgbi0tO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwcmV2LnRleHQgPT09ICcnKSB7XG4gICAgICAgICAgICAgIFRyYW5zZm9ybXMucmVtb3ZlTm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICAgICAgYXQ6IHBhdGguY29uY2F0KG4gLSAxKSxcbiAgICAgICAgICAgICAgICB2b2lkczogdHJ1ZVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgbi0tO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChfY2hpbGQudGV4dCA9PT0gJycpIHtcbiAgICAgICAgICAgICAgVHJhbnNmb3Jtcy5yZW1vdmVOb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAgICAgICBhdDogcGF0aC5jb25jYXQobiksXG4gICAgICAgICAgICAgICAgdm9pZHM6IHRydWVcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIG4tLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIHJlbW92ZU1hcms6IGZ1bmN0aW9uIHJlbW92ZU1hcmsoa2V5KSB7XG4gICAgICB2YXIgc2VsZWN0aW9uID0gZWRpdG9yLnNlbGVjdGlvbjtcblxuICAgICAgaWYgKHNlbGVjdGlvbikge1xuICAgICAgICB2YXIgbWF0Y2ggPSBmdW5jdGlvbiBtYXRjaChub2RlLCBwYXRoKSB7XG4gICAgICAgICAgaWYgKCFUZXh0LmlzVGV4dChub2RlKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBtYXJrcyBjYW4gb25seSBiZSBhcHBsaWVkIHRvIHRleHRcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgX0VkaXRvciRwYXJlbnQ1ID0gRWRpdG9yLnBhcmVudChlZGl0b3IsIHBhdGgpLFxuICAgICAgICAgICAgICBfRWRpdG9yJHBhcmVudDYgPSBfc2xpY2VkVG9BcnJheShfRWRpdG9yJHBhcmVudDUsIDIpLFxuICAgICAgICAgICAgICBwYXJlbnROb2RlID0gX0VkaXRvciRwYXJlbnQ2WzBdO1xuICAgICAgICAgICAgICBfRWRpdG9yJHBhcmVudDZbMV07XG5cbiAgICAgICAgICByZXR1cm4gIWVkaXRvci5pc1ZvaWQocGFyZW50Tm9kZSkgfHwgZWRpdG9yLm1hcmthYmxlVm9pZChwYXJlbnROb2RlKTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgZXhwYW5kZWRTZWxlY3Rpb24gPSBSYW5nZS5pc0V4cGFuZGVkKHNlbGVjdGlvbik7XG4gICAgICAgIHZhciBtYXJrQWNjZXB0aW5nVm9pZFNlbGVjdGVkID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKCFleHBhbmRlZFNlbGVjdGlvbikge1xuICAgICAgICAgIHZhciBfRWRpdG9yJG5vZGUzID0gRWRpdG9yLm5vZGUoZWRpdG9yLCBzZWxlY3Rpb24pLFxuICAgICAgICAgICAgICBfRWRpdG9yJG5vZGU0ID0gX3NsaWNlZFRvQXJyYXkoX0VkaXRvciRub2RlMywgMiksXG4gICAgICAgICAgICAgIHNlbGVjdGVkTm9kZSA9IF9FZGl0b3Ikbm9kZTRbMF0sXG4gICAgICAgICAgICAgIHNlbGVjdGVkUGF0aCA9IF9FZGl0b3Ikbm9kZTRbMV07XG5cbiAgICAgICAgICBpZiAoc2VsZWN0ZWROb2RlICYmIG1hdGNoKHNlbGVjdGVkTm9kZSwgc2VsZWN0ZWRQYXRoKSkge1xuICAgICAgICAgICAgdmFyIF9FZGl0b3IkcGFyZW50NyA9IEVkaXRvci5wYXJlbnQoZWRpdG9yLCBzZWxlY3RlZFBhdGgpLFxuICAgICAgICAgICAgICAgIF9FZGl0b3IkcGFyZW50OCA9IF9zbGljZWRUb0FycmF5KF9FZGl0b3IkcGFyZW50NywgMSksXG4gICAgICAgICAgICAgICAgcGFyZW50Tm9kZSA9IF9FZGl0b3IkcGFyZW50OFswXTtcblxuICAgICAgICAgICAgbWFya0FjY2VwdGluZ1ZvaWRTZWxlY3RlZCA9IHBhcmVudE5vZGUgJiYgZWRpdG9yLm1hcmthYmxlVm9pZChwYXJlbnROb2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXhwYW5kZWRTZWxlY3Rpb24gfHwgbWFya0FjY2VwdGluZ1ZvaWRTZWxlY3RlZCkge1xuICAgICAgICAgIFRyYW5zZm9ybXMudW5zZXROb2RlcyhlZGl0b3IsIGtleSwge1xuICAgICAgICAgICAgbWF0Y2g6IG1hdGNoLFxuICAgICAgICAgICAgc3BsaXQ6IHRydWUsXG4gICAgICAgICAgICB2b2lkczogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBtYXJrcyA9IF9vYmplY3RTcHJlYWQkOSh7fSwgRWRpdG9yLm1hcmtzKGVkaXRvcikgfHwge30pO1xuXG4gICAgICAgICAgZGVsZXRlIG1hcmtzW2tleV07XG4gICAgICAgICAgZWRpdG9yLm1hcmtzID0gbWFya3M7XG5cbiAgICAgICAgICBpZiAoIUZMVVNISU5HLmdldChlZGl0b3IpKSB7XG4gICAgICAgICAgICBlZGl0b3Iub25DaGFuZ2UoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGhlIFwiZGlydHlcIiBwYXRocyBnZW5lcmF0ZWQgZnJvbSBhbiBvcGVyYXRpb24uXHJcbiAgICAgKi9cbiAgICBnZXREaXJ0eVBhdGhzOiBmdW5jdGlvbiBnZXREaXJ0eVBhdGhzKG9wKSB7XG4gICAgICBzd2l0Y2ggKG9wLnR5cGUpIHtcbiAgICAgICAgY2FzZSAnaW5zZXJ0X3RleHQnOlxuICAgICAgICBjYXNlICdyZW1vdmVfdGV4dCc6XG4gICAgICAgIGNhc2UgJ3NldF9ub2RlJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgcGF0aCA9IG9wLnBhdGg7XG4gICAgICAgICAgICByZXR1cm4gUGF0aC5sZXZlbHMocGF0aCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgJ2luc2VydF9ub2RlJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgbm9kZSA9IG9wLm5vZGUsXG4gICAgICAgICAgICAgICAgX3BhdGgyID0gb3AucGF0aDtcbiAgICAgICAgICAgIHZhciBsZXZlbHMgPSBQYXRoLmxldmVscyhfcGF0aDIpO1xuICAgICAgICAgICAgdmFyIGRlc2NlbmRhbnRzID0gVGV4dC5pc1RleHQobm9kZSkgPyBbXSA6IEFycmF5LmZyb20oTm9kZS5ub2Rlcyhub2RlKSwgZnVuY3Rpb24gKF9yZWYzKSB7XG4gICAgICAgICAgICAgIHZhciBfcmVmNCA9IF9zbGljZWRUb0FycmF5KF9yZWYzLCAyKSxcbiAgICAgICAgICAgICAgICAgIHAgPSBfcmVmNFsxXTtcblxuICAgICAgICAgICAgICByZXR1cm4gX3BhdGgyLmNvbmNhdChwKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIFtdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkobGV2ZWxzKSwgX3RvQ29uc3VtYWJsZUFycmF5KGRlc2NlbmRhbnRzKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgJ21lcmdlX25vZGUnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBfcGF0aDMgPSBvcC5wYXRoO1xuICAgICAgICAgICAgdmFyIGFuY2VzdG9ycyA9IFBhdGguYW5jZXN0b3JzKF9wYXRoMyk7XG4gICAgICAgICAgICB2YXIgcHJldmlvdXNQYXRoID0gUGF0aC5wcmV2aW91cyhfcGF0aDMpO1xuICAgICAgICAgICAgcmV0dXJuIFtdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkoYW5jZXN0b3JzKSwgW3ByZXZpb3VzUGF0aF0pO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlICdtb3ZlX25vZGUnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBfcGF0aDQgPSBvcC5wYXRoLFxuICAgICAgICAgICAgICAgIG5ld1BhdGggPSBvcC5uZXdQYXRoO1xuXG4gICAgICAgICAgICBpZiAoUGF0aC5lcXVhbHMoX3BhdGg0LCBuZXdQYXRoKSkge1xuICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBvbGRBbmNlc3RvcnMgPSBbXTtcbiAgICAgICAgICAgIHZhciBuZXdBbmNlc3RvcnMgPSBbXTtcblxuICAgICAgICAgICAgdmFyIF9pdGVyYXRvcjYgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciQ3KFBhdGguYW5jZXN0b3JzKF9wYXRoNCkpLFxuICAgICAgICAgICAgICAgIF9zdGVwNjtcblxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgZm9yIChfaXRlcmF0b3I2LnMoKTsgIShfc3RlcDYgPSBfaXRlcmF0b3I2Lm4oKSkuZG9uZTspIHtcbiAgICAgICAgICAgICAgICB2YXIgYW5jZXN0b3IgPSBfc3RlcDYudmFsdWU7XG4gICAgICAgICAgICAgICAgdmFyIHAgPSBQYXRoLnRyYW5zZm9ybShhbmNlc3Rvciwgb3ApO1xuICAgICAgICAgICAgICAgIG9sZEFuY2VzdG9ycy5wdXNoKHApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgX2l0ZXJhdG9yNi5lKGVycik7XG4gICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICBfaXRlcmF0b3I2LmYoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIF9pdGVyYXRvcjcgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciQ3KFBhdGguYW5jZXN0b3JzKG5ld1BhdGgpKSxcbiAgICAgICAgICAgICAgICBfc3RlcDc7XG5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGZvciAoX2l0ZXJhdG9yNy5zKCk7ICEoX3N0ZXA3ID0gX2l0ZXJhdG9yNy5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgICAgICAgdmFyIF9hbmNlc3RvciA9IF9zdGVwNy52YWx1ZTtcblxuICAgICAgICAgICAgICAgIHZhciBfcCA9IFBhdGgudHJhbnNmb3JtKF9hbmNlc3Rvciwgb3ApO1xuXG4gICAgICAgICAgICAgICAgbmV3QW5jZXN0b3JzLnB1c2goX3ApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgX2l0ZXJhdG9yNy5lKGVycik7XG4gICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICBfaXRlcmF0b3I3LmYoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIG5ld1BhcmVudCA9IG5ld0FuY2VzdG9yc1tuZXdBbmNlc3RvcnMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICB2YXIgbmV3SW5kZXggPSBuZXdQYXRoW25ld1BhdGgubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICB2YXIgcmVzdWx0UGF0aCA9IG5ld1BhcmVudC5jb25jYXQobmV3SW5kZXgpO1xuICAgICAgICAgICAgcmV0dXJuIFtdLmNvbmNhdChvbGRBbmNlc3RvcnMsIG5ld0FuY2VzdG9ycywgW3Jlc3VsdFBhdGhdKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSAncmVtb3ZlX25vZGUnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBfcGF0aDUgPSBvcC5wYXRoO1xuXG4gICAgICAgICAgICB2YXIgX2FuY2VzdG9ycyA9IFBhdGguYW5jZXN0b3JzKF9wYXRoNSk7XG5cbiAgICAgICAgICAgIHJldHVybiBfdG9Db25zdW1hYmxlQXJyYXkoX2FuY2VzdG9ycyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgJ3NwbGl0X25vZGUnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBfcGF0aDYgPSBvcC5wYXRoO1xuXG4gICAgICAgICAgICB2YXIgX2xldmVscyA9IFBhdGgubGV2ZWxzKF9wYXRoNik7XG5cbiAgICAgICAgICAgIHZhciBuZXh0UGF0aCA9IFBhdGgubmV4dChfcGF0aDYpO1xuICAgICAgICAgICAgcmV0dXJuIFtdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkoX2xldmVscyksIFtuZXh0UGF0aF0pO1xuICAgICAgICAgIH1cblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBzaG91bGROb3JtYWxpemU6IGZ1bmN0aW9uIHNob3VsZE5vcm1hbGl6ZShfcmVmNSkge1xuICAgICAgdmFyIGl0ZXJhdGlvbiA9IF9yZWY1Lml0ZXJhdGlvbixcbiAgICAgICAgICBpbml0aWFsRGlydHlQYXRoc0xlbmd0aCA9IF9yZWY1LmluaXRpYWxEaXJ0eVBhdGhzTGVuZ3RoO1xuICAgICAgdmFyIG1heEl0ZXJhdGlvbnMgPSBpbml0aWFsRGlydHlQYXRoc0xlbmd0aCAqIDQyOyAvLyBIQUNLOiBiZXR0ZXIgd2F5P1xuXG4gICAgICBpZiAoaXRlcmF0aW9uID4gbWF4SXRlcmF0aW9ucykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgY29tcGxldGVseSBub3JtYWxpemUgdGhlIGVkaXRvciBhZnRlciBcIi5jb25jYXQobWF4SXRlcmF0aW9ucywgXCIgaXRlcmF0aW9ucyEgVGhpcyBpcyB1c3VhbGx5IGR1ZSB0byBpbmNvcnJlY3Qgbm9ybWFsaXphdGlvbiBsb2dpYyB0aGF0IGxlYXZlcyBhIG5vZGUgaW4gYW4gaW52YWxpZCBzdGF0ZS5cIikpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH07XG4gIHJldHVybiBlZGl0b3I7XG59O1xuXG52YXIgb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZSA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUpIHtcbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpIHtcbiAgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307XG4gIHZhciB0YXJnZXQgPSB7fTtcbiAgdmFyIHNvdXJjZUtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xuICB2YXIga2V5LCBpO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBzb3VyY2VLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAga2V5ID0gc291cmNlS2V5c1tpXTtcbiAgICBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlO1xuICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlO1xubW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHMsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xufSk7XG5cbnVud3JhcEV4cG9ydHMob2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZSk7XG5cbnZhciBvYmplY3RXaXRob3V0UHJvcGVydGllcyA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUpIHtcbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhzb3VyY2UsIGV4Y2x1ZGVkKSB7XG4gIGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9O1xuICB2YXIgdGFyZ2V0ID0gb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKTtcbiAgdmFyIGtleSwgaTtcblxuICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgIHZhciBzb3VyY2VTeW1ib2xLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzb3VyY2UpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IHNvdXJjZVN5bWJvbEtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGtleSA9IHNvdXJjZVN5bWJvbEtleXNbaV07XG4gICAgICBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlO1xuICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoc291cmNlLCBrZXkpKSBjb250aW51ZTtcbiAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXM7XG5tb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG59KTtcblxudmFyIF9vYmplY3RXaXRob3V0UHJvcGVydGllcyA9IHVud3JhcEV4cG9ydHMob2JqZWN0V2l0aG91dFByb3BlcnRpZXMpO1xuXG5mdW5jdGlvbiBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciQ2KG8sIGFsbG93QXJyYXlMaWtlKSB7IHZhciBpdCA9IHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdIHx8IG9bXCJAQGl0ZXJhdG9yXCJdOyBpZiAoIWl0KSB7IGlmIChBcnJheS5pc0FycmF5KG8pIHx8IChpdCA9IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSQ2KG8pKSB8fCBhbGxvd0FycmF5TGlrZSAmJiBvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgeyBpZiAoaXQpIG8gPSBpdDsgdmFyIGkgPSAwOyB2YXIgRiA9IGZ1bmN0aW9uIEYoKSB7fTsgcmV0dXJuIHsgczogRiwgbjogZnVuY3Rpb24gbigpIHsgaWYgKGkgPj0gby5sZW5ndGgpIHJldHVybiB7IGRvbmU6IHRydWUgfTsgcmV0dXJuIHsgZG9uZTogZmFsc2UsIHZhbHVlOiBvW2krK10gfTsgfSwgZTogZnVuY3Rpb24gZShfZSkgeyB0aHJvdyBfZTsgfSwgZjogRiB9OyB9IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfSB2YXIgbm9ybWFsQ29tcGxldGlvbiA9IHRydWUsIGRpZEVyciA9IGZhbHNlLCBlcnI7IHJldHVybiB7IHM6IGZ1bmN0aW9uIHMoKSB7IGl0ID0gaXQuY2FsbChvKTsgfSwgbjogZnVuY3Rpb24gbigpIHsgdmFyIHN0ZXAgPSBpdC5uZXh0KCk7IG5vcm1hbENvbXBsZXRpb24gPSBzdGVwLmRvbmU7IHJldHVybiBzdGVwOyB9LCBlOiBmdW5jdGlvbiBlKF9lMikgeyBkaWRFcnIgPSB0cnVlOyBlcnIgPSBfZTI7IH0sIGY6IGZ1bmN0aW9uIGYoKSB7IHRyeSB7IGlmICghbm9ybWFsQ29tcGxldGlvbiAmJiBpdFtcInJldHVyblwiXSAhPSBudWxsKSBpdFtcInJldHVyblwiXSgpOyB9IGZpbmFsbHkgeyBpZiAoZGlkRXJyKSB0aHJvdyBlcnI7IH0gfSB9OyB9XG5cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSQ2KG8sIG1pbkxlbikgeyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkkNihvLCBtaW5MZW4pOyB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5JDYobywgbWluTGVuKTsgfVxuXG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheSQ2KGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfVxuXG4vLyBDaGFyYWN0ZXIgKGdyYXBoZW1lIGNsdXN0ZXIpIGJvdW5kYXJpZXMgYXJlIGRldGVybWluZWQgYWNjb3JkaW5nIHRvXG4vLyB0aGUgZGVmYXVsdCBncmFwaGVtZSBjbHVzdGVyIGJvdW5kYXJ5IHNwZWNpZmljYXRpb24sIGV4dGVuZGVkIGdyYXBoZW1lIGNsdXN0ZXJzIHZhcmlhbnRbMV0uXG4vL1xuLy8gUmVmZXJlbmNlczpcbi8vXG4vLyBbMV0gaHR0cHM6Ly93d3cudW5pY29kZS5vcmcvcmVwb3J0cy90cjI5LyNEZWZhdWx0X0dyYXBoZW1lX0NsdXN0ZXJfVGFibGVcbi8vIFsyXSBodHRwczovL3d3dy51bmljb2RlLm9yZy9QdWJsaWMvVUNEL2xhdGVzdC91Y2QvYXV4aWxpYXJ5L0dyYXBoZW1lQnJlYWtQcm9wZXJ0eS50eHRcbi8vIFszXSBodHRwczovL3d3dy51bmljb2RlLm9yZy9QdWJsaWMvVUNEL2xhdGVzdC91Y2QvYXV4aWxpYXJ5L0dyYXBoZW1lQnJlYWtUZXN0Lmh0bWxcbi8vIFs0XSBodHRwczovL3d3dy51bmljb2RlLm9yZy9QdWJsaWMvVUNEL2xhdGVzdC91Y2QvYXV4aWxpYXJ5L0dyYXBoZW1lQnJlYWtUZXN0LnR4dFxuXG4vKipcclxuICogR2V0IHRoZSBkaXN0YW5jZSB0byB0aGUgZW5kIG9mIHRoZSBmaXJzdCBjaGFyYWN0ZXIgaW4gYSBzdHJpbmcgb2YgdGV4dC5cclxuICovXG52YXIgZ2V0Q2hhcmFjdGVyRGlzdGFuY2UgPSBmdW5jdGlvbiBnZXRDaGFyYWN0ZXJEaXN0YW5jZShzdHIpIHtcbiAgdmFyIGlzUlRMID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcbiAgdmFyIGlzTFRSID0gIWlzUlRMO1xuICB2YXIgY29kZXBvaW50cyA9IGlzUlRMID8gY29kZXBvaW50c0l0ZXJhdG9yUlRMKHN0cikgOiBzdHI7XG4gIHZhciBsZWZ0ID0gQ29kZXBvaW50VHlwZS5Ob25lO1xuICB2YXIgcmlnaHQgPSBDb2RlcG9pbnRUeXBlLk5vbmU7XG4gIHZhciBkaXN0YW5jZSA9IDA7IC8vIEV2YWx1YXRpb24gb2YgdGhlc2UgY29uZGl0aW9ucyBhcmUgZGVmZXJyZWQuXG5cbiAgdmFyIGdiMTEgPSBudWxsOyAvLyBJcyBHQjExIGFwcGxpY2FibGU/XG5cbiAgdmFyIGdiMTJPcjEzID0gbnVsbDsgLy8gSXMgR0IxMiBvciBHQjEzIGFwcGxpY2FibGU/XG5cbiAgdmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDYoY29kZXBvaW50cyksXG4gICAgICBfc3RlcDtcblxuICB0cnkge1xuICAgIGZvciAoX2l0ZXJhdG9yLnMoKTsgIShfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmU7KSB7XG4gICAgICB2YXIgX2NoYXIgPSBfc3RlcC52YWx1ZTtcblxuICAgICAgdmFyIGNvZGUgPSBfY2hhci5jb2RlUG9pbnRBdCgwKTtcblxuICAgICAgaWYgKCFjb2RlKSBicmVhaztcbiAgICAgIHZhciB0eXBlID0gZ2V0Q29kZXBvaW50VHlwZShfY2hhciwgY29kZSk7XG5cbiAgICAgIHZhciBfcmVmID0gaXNMVFIgPyBbcmlnaHQsIHR5cGVdIDogW3R5cGUsIGxlZnRdO1xuXG4gICAgICB2YXIgX3JlZjIgPSBfc2xpY2VkVG9BcnJheShfcmVmLCAyKTtcblxuICAgICAgbGVmdCA9IF9yZWYyWzBdO1xuICAgICAgcmlnaHQgPSBfcmVmMlsxXTtcblxuICAgICAgaWYgKGludGVyc2VjdHMobGVmdCwgQ29kZXBvaW50VHlwZS5aV0opICYmIGludGVyc2VjdHMocmlnaHQsIENvZGVwb2ludFR5cGUuRXh0UGljdCkpIHtcbiAgICAgICAgaWYgKGlzTFRSKSB7XG4gICAgICAgICAgZ2IxMSA9IGVuZHNXaXRoRW1vamlaV0ooc3RyLnN1YnN0cmluZygwLCBkaXN0YW5jZSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGdiMTEgPSBlbmRzV2l0aEVtb2ppWldKKHN0ci5zdWJzdHJpbmcoMCwgc3RyLmxlbmd0aCAtIGRpc3RhbmNlKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWdiMTEpIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBpZiAoaW50ZXJzZWN0cyhsZWZ0LCBDb2RlcG9pbnRUeXBlLlJJKSAmJiBpbnRlcnNlY3RzKHJpZ2h0LCBDb2RlcG9pbnRUeXBlLlJJKSkge1xuICAgICAgICBpZiAoZ2IxMk9yMTMgIT09IG51bGwpIHtcbiAgICAgICAgICBnYjEyT3IxMyA9ICFnYjEyT3IxMztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoaXNMVFIpIHtcbiAgICAgICAgICAgIGdiMTJPcjEzID0gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ2IxMk9yMTMgPSBlbmRzV2l0aE9kZE51bWJlck9mUklzKHN0ci5zdWJzdHJpbmcoMCwgc3RyLmxlbmd0aCAtIGRpc3RhbmNlKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFnYjEyT3IxMykgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGlmIChsZWZ0ICE9PSBDb2RlcG9pbnRUeXBlLk5vbmUgJiYgcmlnaHQgIT09IENvZGVwb2ludFR5cGUuTm9uZSAmJiBpc0JvdW5kYXJ5UGFpcihsZWZ0LCByaWdodCkpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGRpc3RhbmNlICs9IF9jaGFyLmxlbmd0aDtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIF9pdGVyYXRvci5lKGVycik7XG4gIH0gZmluYWxseSB7XG4gICAgX2l0ZXJhdG9yLmYoKTtcbiAgfVxuXG4gIHJldHVybiBkaXN0YW5jZSB8fCAxO1xufTtcbnZhciBTUEFDRSA9IC9cXHMvO1xudmFyIFBVTkNUVUFUSU9OID0gL1tcXHUwMDIxLVxcdTAwMjNcXHUwMDI1LVxcdTAwMkFcXHUwMDJDLVxcdTAwMkZcXHUwMDNBXFx1MDAzQlxcdTAwM0ZcXHUwMDQwXFx1MDA1Qi1cXHUwMDVEXFx1MDA1RlxcdTAwN0JcXHUwMDdEXFx1MDBBMVxcdTAwQTdcXHUwMEFCXFx1MDBCNlxcdTAwQjdcXHUwMEJCXFx1MDBCRlxcdTAzN0VcXHUwMzg3XFx1MDU1QS1cXHUwNTVGXFx1MDU4OVxcdTA1OEFcXHUwNUJFXFx1MDVDMFxcdTA1QzNcXHUwNUM2XFx1MDVGM1xcdTA1RjRcXHUwNjA5XFx1MDYwQVxcdTA2MENcXHUwNjBEXFx1MDYxQlxcdTA2MUVcXHUwNjFGXFx1MDY2QS1cXHUwNjZEXFx1MDZENFxcdTA3MDAtXFx1MDcwRFxcdTA3RjctXFx1MDdGOVxcdTA4MzAtXFx1MDgzRVxcdTA4NUVcXHUwOTY0XFx1MDk2NVxcdTA5NzBcXHUwQUYwXFx1MERGNFxcdTBFNEZcXHUwRTVBXFx1MEU1QlxcdTBGMDQtXFx1MEYxMlxcdTBGMTRcXHUwRjNBLVxcdTBGM0RcXHUwRjg1XFx1MEZEMC1cXHUwRkQ0XFx1MEZEOVxcdTBGREFcXHUxMDRBLVxcdTEwNEZcXHUxMEZCXFx1MTM2MC1cXHUxMzY4XFx1MTQwMFxcdTE2NkRcXHUxNjZFXFx1MTY5QlxcdTE2OUNcXHUxNkVCLVxcdTE2RURcXHUxNzM1XFx1MTczNlxcdTE3RDQtXFx1MTdENlxcdTE3RDgtXFx1MTdEQVxcdTE4MDAtXFx1MTgwQVxcdTE5NDRcXHUxOTQ1XFx1MUExRVxcdTFBMUZcXHUxQUEwLVxcdTFBQTZcXHUxQUE4LVxcdTFBQURcXHUxQjVBLVxcdTFCNjBcXHUxQkZDLVxcdTFCRkZcXHUxQzNCLVxcdTFDM0ZcXHUxQzdFXFx1MUM3RlxcdTFDQzAtXFx1MUNDN1xcdTFDRDNcXHUyMDEwLVxcdTIwMjdcXHUyMDMwLVxcdTIwNDNcXHUyMDQ1LVxcdTIwNTFcXHUyMDUzLVxcdTIwNUVcXHUyMDdEXFx1MjA3RVxcdTIwOERcXHUyMDhFXFx1MjMyOVxcdTIzMkFcXHUyNzY4LVxcdTI3NzVcXHUyN0M1XFx1MjdDNlxcdTI3RTYtXFx1MjdFRlxcdTI5ODMtXFx1Mjk5OFxcdTI5RDgtXFx1MjlEQlxcdTI5RkNcXHUyOUZEXFx1MkNGOS1cXHUyQ0ZDXFx1MkNGRVxcdTJDRkZcXHUyRDcwXFx1MkUwMC1cXHUyRTJFXFx1MkUzMC1cXHUyRTNCXFx1MzAwMS1cXHUzMDAzXFx1MzAwOC1cXHUzMDExXFx1MzAxNC1cXHUzMDFGXFx1MzAzMFxcdTMwM0RcXHUzMEEwXFx1MzBGQlxcdUE0RkVcXHVBNEZGXFx1QTYwRC1cXHVBNjBGXFx1QTY3M1xcdUE2N0VcXHVBNkYyLVxcdUE2RjdcXHVBODc0LVxcdUE4NzdcXHVBOENFXFx1QThDRlxcdUE4RjgtXFx1QThGQVxcdUE5MkVcXHVBOTJGXFx1QTk1RlxcdUE5QzEtXFx1QTlDRFxcdUE5REVcXHVBOURGXFx1QUE1Qy1cXHVBQTVGXFx1QUFERVxcdUFBREZcXHVBQUYwXFx1QUFGMVxcdUFCRUJcXHVGRDNFXFx1RkQzRlxcdUZFMTAtXFx1RkUxOVxcdUZFMzAtXFx1RkU1MlxcdUZFNTQtXFx1RkU2MVxcdUZFNjNcXHVGRTY4XFx1RkU2QVxcdUZFNkJcXHVGRjAxLVxcdUZGMDNcXHVGRjA1LVxcdUZGMEFcXHVGRjBDLVxcdUZGMEZcXHVGRjFBXFx1RkYxQlxcdUZGMUZcXHVGRjIwXFx1RkYzQi1cXHVGRjNEXFx1RkYzRlxcdUZGNUJcXHVGRjVEXFx1RkY1Ri1cXHVGRjY1XS87XG52YXIgQ0hBTUVMRU9OID0gL1snXFx1MjAxOFxcdTIwMTldLztcbi8qKlxyXG4gKiBHZXQgdGhlIGRpc3RhbmNlIHRvIHRoZSBlbmQgb2YgdGhlIGZpcnN0IHdvcmQgaW4gYSBzdHJpbmcgb2YgdGV4dC5cclxuICovXG5cbnZhciBnZXRXb3JkRGlzdGFuY2UgPSBmdW5jdGlvbiBnZXRXb3JkRGlzdGFuY2UodGV4dCkge1xuICB2YXIgaXNSVEwgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuICB2YXIgZGlzdCA9IDA7XG4gIHZhciBzdGFydGVkID0gZmFsc2U7XG5cbiAgd2hpbGUgKHRleHQubGVuZ3RoID4gMCkge1xuICAgIHZhciBjaGFyRGlzdCA9IGdldENoYXJhY3RlckRpc3RhbmNlKHRleHQsIGlzUlRMKTtcblxuICAgIHZhciBfc3BsaXRCeUNoYXJhY3RlckRpc3QgPSBzcGxpdEJ5Q2hhcmFjdGVyRGlzdGFuY2UodGV4dCwgY2hhckRpc3QsIGlzUlRMKSxcbiAgICAgICAgX3NwbGl0QnlDaGFyYWN0ZXJEaXN0MiA9IF9zbGljZWRUb0FycmF5KF9zcGxpdEJ5Q2hhcmFjdGVyRGlzdCwgMiksXG4gICAgICAgIF9jaGFyMiA9IF9zcGxpdEJ5Q2hhcmFjdGVyRGlzdDJbMF0sXG4gICAgICAgIHJlbWFpbmluZyA9IF9zcGxpdEJ5Q2hhcmFjdGVyRGlzdDJbMV07XG5cbiAgICBpZiAoaXNXb3JkQ2hhcmFjdGVyKF9jaGFyMiwgcmVtYWluaW5nLCBpc1JUTCkpIHtcbiAgICAgIHN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgZGlzdCArPSBjaGFyRGlzdDtcbiAgICB9IGVsc2UgaWYgKCFzdGFydGVkKSB7XG4gICAgICBkaXN0ICs9IGNoYXJEaXN0O1xuICAgIH0gZWxzZSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICB0ZXh0ID0gcmVtYWluaW5nO1xuICB9XG5cbiAgcmV0dXJuIGRpc3Q7XG59O1xuLyoqXHJcbiAqIFNwbGl0IGEgc3RyaW5nIGluIHR3byBwYXJ0cyBhdCBhIGdpdmVuIGRpc3RhbmNlIHN0YXJ0aW5nIGZyb20gdGhlIGVuZCB3aGVuXHJcbiAqIGBpc1JUTGAgaXMgc2V0IHRvIGB0cnVlYC5cclxuICovXG5cbnZhciBzcGxpdEJ5Q2hhcmFjdGVyRGlzdGFuY2UgPSBmdW5jdGlvbiBzcGxpdEJ5Q2hhcmFjdGVyRGlzdGFuY2Uoc3RyLCBkaXN0LCBpc1JUTCkge1xuICBpZiAoaXNSVEwpIHtcbiAgICB2YXIgYXQgPSBzdHIubGVuZ3RoIC0gZGlzdDtcbiAgICByZXR1cm4gW3N0ci5zbGljZShhdCwgc3RyLmxlbmd0aCksIHN0ci5zbGljZSgwLCBhdCldO1xuICB9XG5cbiAgcmV0dXJuIFtzdHIuc2xpY2UoMCwgZGlzdCksIHN0ci5zbGljZShkaXN0KV07XG59O1xuLyoqXHJcbiAqIENoZWNrIGlmIGEgY2hhcmFjdGVyIGlzIGEgd29yZCBjaGFyYWN0ZXIuIFRoZSBgcmVtYWluaW5nYCBhcmd1bWVudCBpcyB1c2VkXHJcbiAqIGJlY2F1c2Ugc29tZXRpbWVzIHlvdSBtdXN0IHJlYWQgc3Vic2VxdWVudCBjaGFyYWN0ZXJzIHRvIHRydWx5IGRldGVybWluZSBpdC5cclxuICovXG5cbnZhciBpc1dvcmRDaGFyYWN0ZXIgPSBmdW5jdGlvbiBpc1dvcmRDaGFyYWN0ZXIoX2NoYXIzLCByZW1haW5pbmcpIHtcbiAgdmFyIGlzUlRMID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBmYWxzZTtcblxuICBpZiAoU1BBQ0UudGVzdChfY2hhcjMpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IC8vIENoYW1lbGVvbnMgY291bnQgYXMgd29yZCBjaGFyYWN0ZXJzIGFzIGxvbmcgYXMgdGhleSdyZSBpbiBhIHdvcmQsIHNvXG4gIC8vIHJlY3Vyc2UgdG8gc2VlIGlmIHRoZSBuZXh0IG9uZSBpcyBhIHdvcmQgY2hhcmFjdGVyIG9yIG5vdC5cblxuXG4gIGlmIChDSEFNRUxFT04udGVzdChfY2hhcjMpKSB7XG4gICAgdmFyIGNoYXJEaXN0ID0gZ2V0Q2hhcmFjdGVyRGlzdGFuY2UocmVtYWluaW5nLCBpc1JUTCk7XG5cbiAgICB2YXIgX3NwbGl0QnlDaGFyYWN0ZXJEaXN0MyA9IHNwbGl0QnlDaGFyYWN0ZXJEaXN0YW5jZShyZW1haW5pbmcsIGNoYXJEaXN0LCBpc1JUTCksXG4gICAgICAgIF9zcGxpdEJ5Q2hhcmFjdGVyRGlzdDQgPSBfc2xpY2VkVG9BcnJheShfc3BsaXRCeUNoYXJhY3RlckRpc3QzLCAyKSxcbiAgICAgICAgbmV4dENoYXIgPSBfc3BsaXRCeUNoYXJhY3RlckRpc3Q0WzBdLFxuICAgICAgICBuZXh0UmVtYWluaW5nID0gX3NwbGl0QnlDaGFyYWN0ZXJEaXN0NFsxXTtcblxuICAgIGlmIChpc1dvcmRDaGFyYWN0ZXIobmV4dENoYXIsIG5leHRSZW1haW5pbmcsIGlzUlRMKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgaWYgKFBVTkNUVUFUSU9OLnRlc3QoX2NoYXIzKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcbi8qKlxyXG4gKiBJdGVyYXRlIG9uIGNvZGVwb2ludHMgZnJvbSByaWdodCB0byBsZWZ0LlxyXG4gKi9cblxuXG52YXIgY29kZXBvaW50c0l0ZXJhdG9yUlRMID0gZnVuY3Rpb24qIGNvZGVwb2ludHNJdGVyYXRvclJUTChzdHIpIHtcbiAgdmFyIGVuZCA9IHN0ci5sZW5ndGggLSAxO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGNoYXIxID0gc3RyLmNoYXJBdChlbmQgLSBpKTtcblxuICAgIGlmIChpc0xvd1N1cnJvZ2F0ZShjaGFyMS5jaGFyQ29kZUF0KDApKSkge1xuICAgICAgdmFyIGNoYXIyID0gc3RyLmNoYXJBdChlbmQgLSBpIC0gMSk7XG5cbiAgICAgIGlmIChpc0hpZ2hTdXJyb2dhdGUoY2hhcjIuY2hhckNvZGVBdCgwKSkpIHtcbiAgICAgICAgeWllbGQgY2hhcjIgKyBjaGFyMTtcbiAgICAgICAgaSsrO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB5aWVsZCBjaGFyMTtcbiAgfVxufTtcbi8qKlxyXG4gKiBJcyBgY2hhckNvZGVgIGEgaGlnaCBzdXJyb2dhdGUuXHJcbiAqXHJcbiAqIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1VuaXZlcnNhbF9DaGFyYWN0ZXJfU2V0X2NoYXJhY3RlcnMjU3Vycm9nYXRlc1xyXG4gKi9cblxudmFyIGlzSGlnaFN1cnJvZ2F0ZSA9IGZ1bmN0aW9uIGlzSGlnaFN1cnJvZ2F0ZShjaGFyQ29kZSkge1xuICByZXR1cm4gY2hhckNvZGUgPj0gMHhkODAwICYmIGNoYXJDb2RlIDw9IDB4ZGJmZjtcbn07XG4vKipcclxuICogSXMgYGNoYXJDb2RlYCBhIGxvdyBzdXJyb2dhdGUuXHJcbiAqXHJcbiAqIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1VuaXZlcnNhbF9DaGFyYWN0ZXJfU2V0X2NoYXJhY3RlcnMjU3Vycm9nYXRlc1xyXG4gKi9cblxuXG52YXIgaXNMb3dTdXJyb2dhdGUgPSBmdW5jdGlvbiBpc0xvd1N1cnJvZ2F0ZShjaGFyQ29kZSkge1xuICByZXR1cm4gY2hhckNvZGUgPj0gMHhkYzAwICYmIGNoYXJDb2RlIDw9IDB4ZGZmZjtcbn07XG5cbnZhciBDb2RlcG9pbnRUeXBlO1xuXG4oZnVuY3Rpb24gKENvZGVwb2ludFR5cGUpIHtcbiAgQ29kZXBvaW50VHlwZVtDb2RlcG9pbnRUeXBlW1wiTm9uZVwiXSA9IDBdID0gXCJOb25lXCI7XG4gIENvZGVwb2ludFR5cGVbQ29kZXBvaW50VHlwZVtcIkV4dGVuZFwiXSA9IDFdID0gXCJFeHRlbmRcIjtcbiAgQ29kZXBvaW50VHlwZVtDb2RlcG9pbnRUeXBlW1wiWldKXCJdID0gMl0gPSBcIlpXSlwiO1xuICBDb2RlcG9pbnRUeXBlW0NvZGVwb2ludFR5cGVbXCJSSVwiXSA9IDRdID0gXCJSSVwiO1xuICBDb2RlcG9pbnRUeXBlW0NvZGVwb2ludFR5cGVbXCJQcmVwZW5kXCJdID0gOF0gPSBcIlByZXBlbmRcIjtcbiAgQ29kZXBvaW50VHlwZVtDb2RlcG9pbnRUeXBlW1wiU3BhY2luZ01hcmtcIl0gPSAxNl0gPSBcIlNwYWNpbmdNYXJrXCI7XG4gIENvZGVwb2ludFR5cGVbQ29kZXBvaW50VHlwZVtcIkxcIl0gPSAzMl0gPSBcIkxcIjtcbiAgQ29kZXBvaW50VHlwZVtDb2RlcG9pbnRUeXBlW1wiVlwiXSA9IDY0XSA9IFwiVlwiO1xuICBDb2RlcG9pbnRUeXBlW0NvZGVwb2ludFR5cGVbXCJUXCJdID0gMTI4XSA9IFwiVFwiO1xuICBDb2RlcG9pbnRUeXBlW0NvZGVwb2ludFR5cGVbXCJMVlwiXSA9IDI1Nl0gPSBcIkxWXCI7XG4gIENvZGVwb2ludFR5cGVbQ29kZXBvaW50VHlwZVtcIkxWVFwiXSA9IDUxMl0gPSBcIkxWVFwiO1xuICBDb2RlcG9pbnRUeXBlW0NvZGVwb2ludFR5cGVbXCJFeHRQaWN0XCJdID0gMTAyNF0gPSBcIkV4dFBpY3RcIjtcbiAgQ29kZXBvaW50VHlwZVtDb2RlcG9pbnRUeXBlW1wiQW55XCJdID0gMjA0OF0gPSBcIkFueVwiO1xufSkoQ29kZXBvaW50VHlwZSB8fCAoQ29kZXBvaW50VHlwZSA9IHt9KSk7XG5cbnZhciByZUV4dGVuZCA9IC9eKD86W1xcdTAzMDAtXFx1MDM2RlxcdTA0ODMtXFx1MDQ4OVxcdTA1OTEtXFx1MDVCRFxcdTA1QkZcXHUwNUMxXFx1MDVDMlxcdTA1QzRcXHUwNUM1XFx1MDVDN1xcdTA2MTAtXFx1MDYxQVxcdTA2NEItXFx1MDY1RlxcdTA2NzBcXHUwNkQ2LVxcdTA2RENcXHUwNkRGLVxcdTA2RTRcXHUwNkU3XFx1MDZFOFxcdTA2RUEtXFx1MDZFRFxcdTA3MTFcXHUwNzMwLVxcdTA3NEFcXHUwN0E2LVxcdTA3QjBcXHUwN0VCLVxcdTA3RjNcXHUwN0ZEXFx1MDgxNi1cXHUwODE5XFx1MDgxQi1cXHUwODIzXFx1MDgyNS1cXHUwODI3XFx1MDgyOS1cXHUwODJEXFx1MDg1OS1cXHUwODVCXFx1MDhEMy1cXHUwOEUxXFx1MDhFMy1cXHUwOTAyXFx1MDkzQVxcdTA5M0NcXHUwOTQxLVxcdTA5NDhcXHUwOTREXFx1MDk1MS1cXHUwOTU3XFx1MDk2MlxcdTA5NjNcXHUwOTgxXFx1MDlCQ1xcdTA5QkVcXHUwOUMxLVxcdTA5QzRcXHUwOUNEXFx1MDlEN1xcdTA5RTJcXHUwOUUzXFx1MDlGRVxcdTBBMDFcXHUwQTAyXFx1MEEzQ1xcdTBBNDFcXHUwQTQyXFx1MEE0N1xcdTBBNDhcXHUwQTRCLVxcdTBBNERcXHUwQTUxXFx1MEE3MFxcdTBBNzFcXHUwQTc1XFx1MEE4MVxcdTBBODJcXHUwQUJDXFx1MEFDMS1cXHUwQUM1XFx1MEFDN1xcdTBBQzhcXHUwQUNEXFx1MEFFMlxcdTBBRTNcXHUwQUZBLVxcdTBBRkZcXHUwQjAxXFx1MEIzQ1xcdTBCM0VcXHUwQjNGXFx1MEI0MS1cXHUwQjQ0XFx1MEI0RFxcdTBCNTUtXFx1MEI1N1xcdTBCNjJcXHUwQjYzXFx1MEI4MlxcdTBCQkVcXHUwQkMwXFx1MEJDRFxcdTBCRDdcXHUwQzAwXFx1MEMwNFxcdTBDM0UtXFx1MEM0MFxcdTBDNDYtXFx1MEM0OFxcdTBDNEEtXFx1MEM0RFxcdTBDNTVcXHUwQzU2XFx1MEM2MlxcdTBDNjNcXHUwQzgxXFx1MENCQ1xcdTBDQkZcXHUwQ0MyXFx1MENDNlxcdTBDQ0NcXHUwQ0NEXFx1MENENVxcdTBDRDZcXHUwQ0UyXFx1MENFM1xcdTBEMDBcXHUwRDAxXFx1MEQzQlxcdTBEM0NcXHUwRDNFXFx1MEQ0MS1cXHUwRDQ0XFx1MEQ0RFxcdTBENTdcXHUwRDYyXFx1MEQ2M1xcdTBEODFcXHUwRENBXFx1MERDRlxcdTBERDItXFx1MERENFxcdTBERDZcXHUwRERGXFx1MEUzMVxcdTBFMzQtXFx1MEUzQVxcdTBFNDctXFx1MEU0RVxcdTBFQjFcXHUwRUI0LVxcdTBFQkNcXHUwRUM4LVxcdTBFQ0RcXHUwRjE4XFx1MEYxOVxcdTBGMzVcXHUwRjM3XFx1MEYzOVxcdTBGNzEtXFx1MEY3RVxcdTBGODAtXFx1MEY4NFxcdTBGODZcXHUwRjg3XFx1MEY4RC1cXHUwRjk3XFx1MEY5OS1cXHUwRkJDXFx1MEZDNlxcdTEwMkQtXFx1MTAzMFxcdTEwMzItXFx1MTAzN1xcdTEwMzlcXHUxMDNBXFx1MTAzRFxcdTEwM0VcXHUxMDU4XFx1MTA1OVxcdTEwNUUtXFx1MTA2MFxcdTEwNzEtXFx1MTA3NFxcdTEwODJcXHUxMDg1XFx1MTA4NlxcdTEwOERcXHUxMDlEXFx1MTM1RC1cXHUxMzVGXFx1MTcxMi1cXHUxNzE0XFx1MTczMi1cXHUxNzM0XFx1MTc1MlxcdTE3NTNcXHUxNzcyXFx1MTc3M1xcdTE3QjRcXHUxN0I1XFx1MTdCNy1cXHUxN0JEXFx1MTdDNlxcdTE3QzktXFx1MTdEM1xcdTE3RERcXHUxODBCLVxcdTE4MERcXHUxODg1XFx1MTg4NlxcdTE4QTlcXHUxOTIwLVxcdTE5MjJcXHUxOTI3XFx1MTkyOFxcdTE5MzJcXHUxOTM5LVxcdTE5M0JcXHUxQTE3XFx1MUExOFxcdTFBMUJcXHUxQTU2XFx1MUE1OC1cXHUxQTVFXFx1MUE2MFxcdTFBNjJcXHUxQTY1LVxcdTFBNkNcXHUxQTczLVxcdTFBN0NcXHUxQTdGXFx1MUFCMC1cXHUxQUMwXFx1MUIwMC1cXHUxQjAzXFx1MUIzNC1cXHUxQjNBXFx1MUIzQ1xcdTFCNDJcXHUxQjZCLVxcdTFCNzNcXHUxQjgwXFx1MUI4MVxcdTFCQTItXFx1MUJBNVxcdTFCQThcXHUxQkE5XFx1MUJBQi1cXHUxQkFEXFx1MUJFNlxcdTFCRThcXHUxQkU5XFx1MUJFRFxcdTFCRUYtXFx1MUJGMVxcdTFDMkMtXFx1MUMzM1xcdTFDMzZcXHUxQzM3XFx1MUNEMC1cXHUxQ0QyXFx1MUNENC1cXHUxQ0UwXFx1MUNFMi1cXHUxQ0U4XFx1MUNFRFxcdTFDRjRcXHUxQ0Y4XFx1MUNGOVxcdTFEQzAtXFx1MURGOVxcdTFERkItXFx1MURGRlxcdTIwMENcXHUyMEQwLVxcdTIwRjBcXHUyQ0VGLVxcdTJDRjFcXHUyRDdGXFx1MkRFMC1cXHUyREZGXFx1MzAyQS1cXHUzMDJGXFx1MzA5OVxcdTMwOUFcXHVBNjZGLVxcdUE2NzJcXHVBNjc0LVxcdUE2N0RcXHVBNjlFXFx1QTY5RlxcdUE2RjBcXHVBNkYxXFx1QTgwMlxcdUE4MDZcXHVBODBCXFx1QTgyNVxcdUE4MjZcXHVBODJDXFx1QThDNFxcdUE4QzVcXHVBOEUwLVxcdUE4RjFcXHVBOEZGXFx1QTkyNi1cXHVBOTJEXFx1QTk0Ny1cXHVBOTUxXFx1QTk4MC1cXHVBOTgyXFx1QTlCM1xcdUE5QjYtXFx1QTlCOVxcdUE5QkNcXHVBOUJEXFx1QTlFNVxcdUFBMjktXFx1QUEyRVxcdUFBMzFcXHVBQTMyXFx1QUEzNVxcdUFBMzZcXHVBQTQzXFx1QUE0Q1xcdUFBN0NcXHVBQUIwXFx1QUFCMi1cXHVBQUI0XFx1QUFCN1xcdUFBQjhcXHVBQUJFXFx1QUFCRlxcdUFBQzFcXHVBQUVDXFx1QUFFRFxcdUFBRjZcXHVBQkU1XFx1QUJFOFxcdUFCRURcXHVGQjFFXFx1RkUwMC1cXHVGRTBGXFx1RkUyMC1cXHVGRTJGXFx1RkY5RVxcdUZGOUZdfFxcdUQ4MDBbXFx1RERGRFxcdURFRTBcXHVERjc2LVxcdURGN0FdfFxcdUQ4MDJbXFx1REUwMS1cXHVERTAzXFx1REUwNVxcdURFMDZcXHVERTBDLVxcdURFMEZcXHVERTM4LVxcdURFM0FcXHVERTNGXFx1REVFNVxcdURFRTZdfFxcdUQ4MDNbXFx1REQyNC1cXHVERDI3XFx1REVBQlxcdURFQUNcXHVERjQ2LVxcdURGNTBdfFxcdUQ4MDRbXFx1REMwMVxcdURDMzgtXFx1REM0NlxcdURDN0YtXFx1REM4MVxcdURDQjMtXFx1RENCNlxcdURDQjlcXHVEQ0JBXFx1REQwMC1cXHVERDAyXFx1REQyNy1cXHVERDJCXFx1REQyRC1cXHVERDM0XFx1REQ3M1xcdUREODBcXHVERDgxXFx1RERCNi1cXHVEREJFXFx1RERDOS1cXHVERENDXFx1RERDRlxcdURFMkYtXFx1REUzMVxcdURFMzRcXHVERTM2XFx1REUzN1xcdURFM0VcXHVERURGXFx1REVFMy1cXHVERUVBXFx1REYwMFxcdURGMDFcXHVERjNCXFx1REYzQ1xcdURGM0VcXHVERjQwXFx1REY1N1xcdURGNjYtXFx1REY2Q1xcdURGNzAtXFx1REY3NF18XFx1RDgwNVtcXHVEQzM4LVxcdURDM0ZcXHVEQzQyLVxcdURDNDRcXHVEQzQ2XFx1REM1RVxcdURDQjBcXHVEQ0IzLVxcdURDQjhcXHVEQ0JBXFx1RENCRFxcdURDQkZcXHVEQ0MwXFx1RENDMlxcdURDQzNcXHVEREFGXFx1RERCMi1cXHVEREI1XFx1RERCQ1xcdUREQkRcXHVEREJGXFx1RERDMFxcdURERENcXHVEREREXFx1REUzMy1cXHVERTNBXFx1REUzRFxcdURFM0ZcXHVERTQwXFx1REVBQlxcdURFQURcXHVERUIwLVxcdURFQjVcXHVERUI3XFx1REYxRC1cXHVERjFGXFx1REYyMi1cXHVERjI1XFx1REYyNy1cXHVERjJCXXxcXHVEODA2W1xcdURDMkYtXFx1REMzN1xcdURDMzlcXHVEQzNBXFx1REQzMFxcdUREM0JcXHVERDNDXFx1REQzRVxcdURENDNcXHVEREQ0LVxcdURERDdcXHVERERBXFx1REREQlxcdURERTBcXHVERTAxLVxcdURFMEFcXHVERTMzLVxcdURFMzhcXHVERTNCLVxcdURFM0VcXHVERTQ3XFx1REU1MS1cXHVERTU2XFx1REU1OS1cXHVERTVCXFx1REU4QS1cXHVERTk2XFx1REU5OFxcdURFOTldfFxcdUQ4MDdbXFx1REMzMC1cXHVEQzM2XFx1REMzOC1cXHVEQzNEXFx1REMzRlxcdURDOTItXFx1RENBN1xcdURDQUEtXFx1RENCMFxcdURDQjJcXHVEQ0IzXFx1RENCNVxcdURDQjZcXHVERDMxLVxcdUREMzZcXHVERDNBXFx1REQzQ1xcdUREM0RcXHVERDNGLVxcdURENDVcXHVERDQ3XFx1REQ5MFxcdUREOTFcXHVERDk1XFx1REQ5N1xcdURFRjNcXHVERUY0XXxcXHVEODFBW1xcdURFRjAtXFx1REVGNFxcdURGMzAtXFx1REYzNl18XFx1RDgxQltcXHVERjRGXFx1REY4Ri1cXHVERjkyXFx1REZFNF18XFx1RDgyRltcXHVEQzlEXFx1REM5RV18XFx1RDgzNFtcXHVERDY1XFx1REQ2Ny1cXHVERDY5XFx1REQ2RS1cXHVERDcyXFx1REQ3Qi1cXHVERDgyXFx1REQ4NS1cXHVERDhCXFx1RERBQS1cXHVEREFEXFx1REU0Mi1cXHVERTQ0XXxcXHVEODM2W1xcdURFMDAtXFx1REUzNlxcdURFM0ItXFx1REU2Q1xcdURFNzVcXHVERTg0XFx1REU5Qi1cXHVERTlGXFx1REVBMS1cXHVERUFGXXxcXHVEODM4W1xcdURDMDAtXFx1REMwNlxcdURDMDgtXFx1REMxOFxcdURDMUItXFx1REMyMVxcdURDMjNcXHVEQzI0XFx1REMyNi1cXHVEQzJBXFx1REQzMC1cXHVERDM2XFx1REVFQy1cXHVERUVGXXxcXHVEODNBW1xcdURDRDAtXFx1RENENlxcdURENDQtXFx1REQ0QV18XFx1RDgzQ1tcXHVERkZCLVxcdURGRkZdfFxcdURCNDBbXFx1REMyMC1cXHVEQzdGXFx1REQwMC1cXHVEREVGXSkkLztcbnZhciByZVByZXBlbmQgPSAvXig/OltcXHUwNjAwLVxcdTA2MDVcXHUwNkREXFx1MDcwRlxcdTA4OTBcXHUwODkxXFx1MDhFMlxcdTBENEVdfFxcdUQ4MDRbXFx1RENCRFxcdURDQ0RcXHVEREMyXFx1RERDM118XFx1RDgwNltcXHVERDNGXFx1REQ0MVxcdURFM0FcXHVERTg0LVxcdURFODldfFxcdUQ4MDdcXHVERDQ2KSQvO1xudmFyIHJlU3BhY2luZ01hcmsgPSAvXig/OltcXHUwOTAzXFx1MDkzQlxcdTA5M0UtXFx1MDk0MFxcdTA5NDktXFx1MDk0Q1xcdTA5NEVcXHUwOTRGXFx1MDk4MlxcdTA5ODNcXHUwOUJGXFx1MDlDMFxcdTA5QzdcXHUwOUM4XFx1MDlDQlxcdTA5Q0NcXHUwQTAzXFx1MEEzRS1cXHUwQTQwXFx1MEE4M1xcdTBBQkUtXFx1MEFDMFxcdTBBQzlcXHUwQUNCXFx1MEFDQ1xcdTBCMDJcXHUwQjAzXFx1MEI0MFxcdTBCNDdcXHUwQjQ4XFx1MEI0QlxcdTBCNENcXHUwQkJGXFx1MEJDMVxcdTBCQzJcXHUwQkM2LVxcdTBCQzhcXHUwQkNBLVxcdTBCQ0NcXHUwQzAxLVxcdTBDMDNcXHUwQzQxLVxcdTBDNDRcXHUwQzgyXFx1MEM4M1xcdTBDQkVcXHUwQ0MwXFx1MENDMVxcdTBDQzNcXHUwQ0M0XFx1MENDN1xcdTBDQzhcXHUwQ0NBXFx1MENDQlxcdTBEMDJcXHUwRDAzXFx1MEQzRlxcdTBENDBcXHUwRDQ2LVxcdTBENDhcXHUwRDRBLVxcdTBENENcXHUwRDgyXFx1MEQ4M1xcdTBERDBcXHUwREQxXFx1MEREOC1cXHUwRERFXFx1MERGMlxcdTBERjNcXHUwRTMzXFx1MEVCM1xcdTBGM0VcXHUwRjNGXFx1MEY3RlxcdTEwMzFcXHUxMDNCXFx1MTAzQ1xcdTEwNTZcXHUxMDU3XFx1MTA4NFxcdTE3MTVcXHUxNzM0XFx1MTdCNlxcdTE3QkUtXFx1MTdDNVxcdTE3QzdcXHUxN0M4XFx1MTkyMy1cXHUxOTI2XFx1MTkyOS1cXHUxOTJCXFx1MTkzMFxcdTE5MzFcXHUxOTMzLVxcdTE5MzhcXHUxQTE5XFx1MUExQVxcdTFBNTVcXHUxQTU3XFx1MUE2RC1cXHUxQTcyXFx1MUIwNFxcdTFCM0JcXHUxQjNELVxcdTFCNDFcXHUxQjQzXFx1MUI0NFxcdTFCODJcXHUxQkExXFx1MUJBNlxcdTFCQTdcXHUxQkFBXFx1MUJFN1xcdTFCRUEtXFx1MUJFQ1xcdTFCRUVcXHUxQkYyXFx1MUJGM1xcdTFDMjQtXFx1MUMyQlxcdTFDMzRcXHUxQzM1XFx1MUNFMVxcdTFDRjdcXHVBODIzXFx1QTgyNFxcdUE4MjdcXHVBODgwXFx1QTg4MVxcdUE4QjQtXFx1QThDM1xcdUE5NTJcXHVBOTUzXFx1QTk4M1xcdUE5QjRcXHVBOUI1XFx1QTlCQVxcdUE5QkJcXHVBOUJFLVxcdUE5QzBcXHVBQTJGXFx1QUEzMFxcdUFBMzNcXHVBQTM0XFx1QUE0RFxcdUFBRUJcXHVBQUVFXFx1QUFFRlxcdUFBRjVcXHVBQkUzXFx1QUJFNFxcdUFCRTZcXHVBQkU3XFx1QUJFOVxcdUFCRUFcXHVBQkVDXXxcXHVEODA0W1xcdURDMDBcXHVEQzAyXFx1REM4MlxcdURDQjAtXFx1RENCMlxcdURDQjdcXHVEQ0I4XFx1REQyQ1xcdURENDVcXHVERDQ2XFx1REQ4MlxcdUREQjMtXFx1RERCNVxcdUREQkZcXHVEREMwXFx1RERDRVxcdURFMkMtXFx1REUyRVxcdURFMzJcXHVERTMzXFx1REUzNVxcdURFRTAtXFx1REVFMlxcdURGMDJcXHVERjAzXFx1REYzRlxcdURGNDEtXFx1REY0NFxcdURGNDdcXHVERjQ4XFx1REY0Qi1cXHVERjREXFx1REY2MlxcdURGNjNdfFxcdUQ4MDVbXFx1REMzNS1cXHVEQzM3XFx1REM0MFxcdURDNDFcXHVEQzQ1XFx1RENCMVxcdURDQjJcXHVEQ0I5XFx1RENCQlxcdURDQkNcXHVEQ0JFXFx1RENDMVxcdUREQjBcXHVEREIxXFx1RERCOC1cXHVEREJCXFx1RERCRVxcdURFMzAtXFx1REUzMlxcdURFM0JcXHVERTNDXFx1REUzRVxcdURFQUNcXHVERUFFXFx1REVBRlxcdURFQjZcXHVERjI2XXxcXHVEODA2W1xcdURDMkMtXFx1REMyRVxcdURDMzhcXHVERDMxLVxcdUREMzVcXHVERDM3XFx1REQzOFxcdUREM0RcXHVERDQwXFx1REQ0MlxcdURERDEtXFx1REREM1xcdUREREMtXFx1RERERlxcdURERTRcXHVERTM5XFx1REU1N1xcdURFNThcXHVERTk3XXxcXHVEODA3W1xcdURDMkZcXHVEQzNFXFx1RENBOVxcdURDQjFcXHVEQ0I0XFx1REQ4QS1cXHVERDhFXFx1REQ5M1xcdUREOTRcXHVERDk2XFx1REVGNVxcdURFRjZdfFxcdUQ4MUJbXFx1REY1MS1cXHVERjg3XFx1REZGMFxcdURGRjFdfFxcdUQ4MzRbXFx1REQ2NlxcdURENkRdKSQvO1xudmFyIHJlTCA9IC9eW1xcdTExMDAtXFx1MTE1RlxcdUE5NjAtXFx1QTk3Q10kLztcbnZhciByZVYgPSAvXltcXHUxMTYwLVxcdTExQTdcXHVEN0IwLVxcdUQ3QzZdJC87XG52YXIgcmVUID0gL15bXFx1MTFBOC1cXHUxMUZGXFx1RDdDQi1cXHVEN0ZCXSQvO1xudmFyIHJlTFYgPSAvXltcXHVBQzAwXFx1QUMxQ1xcdUFDMzhcXHVBQzU0XFx1QUM3MFxcdUFDOENcXHVBQ0E4XFx1QUNDNFxcdUFDRTBcXHVBQ0ZDXFx1QUQxOFxcdUFEMzRcXHVBRDUwXFx1QUQ2Q1xcdUFEODhcXHVBREE0XFx1QURDMFxcdUFERENcXHVBREY4XFx1QUUxNFxcdUFFMzBcXHVBRTRDXFx1QUU2OFxcdUFFODRcXHVBRUEwXFx1QUVCQ1xcdUFFRDhcXHVBRUY0XFx1QUYxMFxcdUFGMkNcXHVBRjQ4XFx1QUY2NFxcdUFGODBcXHVBRjlDXFx1QUZCOFxcdUFGRDRcXHVBRkYwXFx1QjAwQ1xcdUIwMjhcXHVCMDQ0XFx1QjA2MFxcdUIwN0NcXHVCMDk4XFx1QjBCNFxcdUIwRDBcXHVCMEVDXFx1QjEwOFxcdUIxMjRcXHVCMTQwXFx1QjE1Q1xcdUIxNzhcXHVCMTk0XFx1QjFCMFxcdUIxQ0NcXHVCMUU4XFx1QjIwNFxcdUIyMjBcXHVCMjNDXFx1QjI1OFxcdUIyNzRcXHVCMjkwXFx1QjJBQ1xcdUIyQzhcXHVCMkU0XFx1QjMwMFxcdUIzMUNcXHVCMzM4XFx1QjM1NFxcdUIzNzBcXHVCMzhDXFx1QjNBOFxcdUIzQzRcXHVCM0UwXFx1QjNGQ1xcdUI0MThcXHVCNDM0XFx1QjQ1MFxcdUI0NkNcXHVCNDg4XFx1QjRBNFxcdUI0QzBcXHVCNERDXFx1QjRGOFxcdUI1MTRcXHVCNTMwXFx1QjU0Q1xcdUI1NjhcXHVCNTg0XFx1QjVBMFxcdUI1QkNcXHVCNUQ4XFx1QjVGNFxcdUI2MTBcXHVCNjJDXFx1QjY0OFxcdUI2NjRcXHVCNjgwXFx1QjY5Q1xcdUI2QjhcXHVCNkQ0XFx1QjZGMFxcdUI3MENcXHVCNzI4XFx1Qjc0NFxcdUI3NjBcXHVCNzdDXFx1Qjc5OFxcdUI3QjRcXHVCN0QwXFx1QjdFQ1xcdUI4MDhcXHVCODI0XFx1Qjg0MFxcdUI4NUNcXHVCODc4XFx1Qjg5NFxcdUI4QjBcXHVCOENDXFx1QjhFOFxcdUI5MDRcXHVCOTIwXFx1QjkzQ1xcdUI5NThcXHVCOTc0XFx1Qjk5MFxcdUI5QUNcXHVCOUM4XFx1QjlFNFxcdUJBMDBcXHVCQTFDXFx1QkEzOFxcdUJBNTRcXHVCQTcwXFx1QkE4Q1xcdUJBQThcXHVCQUM0XFx1QkFFMFxcdUJBRkNcXHVCQjE4XFx1QkIzNFxcdUJCNTBcXHVCQjZDXFx1QkI4OFxcdUJCQTRcXHVCQkMwXFx1QkJEQ1xcdUJCRjhcXHVCQzE0XFx1QkMzMFxcdUJDNENcXHVCQzY4XFx1QkM4NFxcdUJDQTBcXHVCQ0JDXFx1QkNEOFxcdUJDRjRcXHVCRDEwXFx1QkQyQ1xcdUJENDhcXHVCRDY0XFx1QkQ4MFxcdUJEOUNcXHVCREI4XFx1QkRENFxcdUJERjBcXHVCRTBDXFx1QkUyOFxcdUJFNDRcXHVCRTYwXFx1QkU3Q1xcdUJFOThcXHVCRUI0XFx1QkVEMFxcdUJFRUNcXHVCRjA4XFx1QkYyNFxcdUJGNDBcXHVCRjVDXFx1QkY3OFxcdUJGOTRcXHVCRkIwXFx1QkZDQ1xcdUJGRThcXHVDMDA0XFx1QzAyMFxcdUMwM0NcXHVDMDU4XFx1QzA3NFxcdUMwOTBcXHVDMEFDXFx1QzBDOFxcdUMwRTRcXHVDMTAwXFx1QzExQ1xcdUMxMzhcXHVDMTU0XFx1QzE3MFxcdUMxOENcXHVDMUE4XFx1QzFDNFxcdUMxRTBcXHVDMUZDXFx1QzIxOFxcdUMyMzRcXHVDMjUwXFx1QzI2Q1xcdUMyODhcXHVDMkE0XFx1QzJDMFxcdUMyRENcXHVDMkY4XFx1QzMxNFxcdUMzMzBcXHVDMzRDXFx1QzM2OFxcdUMzODRcXHVDM0EwXFx1QzNCQ1xcdUMzRDhcXHVDM0Y0XFx1QzQxMFxcdUM0MkNcXHVDNDQ4XFx1QzQ2NFxcdUM0ODBcXHVDNDlDXFx1QzRCOFxcdUM0RDRcXHVDNEYwXFx1QzUwQ1xcdUM1MjhcXHVDNTQ0XFx1QzU2MFxcdUM1N0NcXHVDNTk4XFx1QzVCNFxcdUM1RDBcXHVDNUVDXFx1QzYwOFxcdUM2MjRcXHVDNjQwXFx1QzY1Q1xcdUM2NzhcXHVDNjk0XFx1QzZCMFxcdUM2Q0NcXHVDNkU4XFx1QzcwNFxcdUM3MjBcXHVDNzNDXFx1Qzc1OFxcdUM3NzRcXHVDNzkwXFx1QzdBQ1xcdUM3QzhcXHVDN0U0XFx1QzgwMFxcdUM4MUNcXHVDODM4XFx1Qzg1NFxcdUM4NzBcXHVDODhDXFx1QzhBOFxcdUM4QzRcXHVDOEUwXFx1QzhGQ1xcdUM5MThcXHVDOTM0XFx1Qzk1MFxcdUM5NkNcXHVDOTg4XFx1QzlBNFxcdUM5QzBcXHVDOURDXFx1QzlGOFxcdUNBMTRcXHVDQTMwXFx1Q0E0Q1xcdUNBNjhcXHVDQTg0XFx1Q0FBMFxcdUNBQkNcXHVDQUQ4XFx1Q0FGNFxcdUNCMTBcXHVDQjJDXFx1Q0I0OFxcdUNCNjRcXHVDQjgwXFx1Q0I5Q1xcdUNCQjhcXHVDQkQ0XFx1Q0JGMFxcdUNDMENcXHVDQzI4XFx1Q0M0NFxcdUNDNjBcXHVDQzdDXFx1Q0M5OFxcdUNDQjRcXHVDQ0QwXFx1Q0NFQ1xcdUNEMDhcXHVDRDI0XFx1Q0Q0MFxcdUNENUNcXHVDRDc4XFx1Q0Q5NFxcdUNEQjBcXHVDRENDXFx1Q0RFOFxcdUNFMDRcXHVDRTIwXFx1Q0UzQ1xcdUNFNThcXHVDRTc0XFx1Q0U5MFxcdUNFQUNcXHVDRUM4XFx1Q0VFNFxcdUNGMDBcXHVDRjFDXFx1Q0YzOFxcdUNGNTRcXHVDRjcwXFx1Q0Y4Q1xcdUNGQThcXHVDRkM0XFx1Q0ZFMFxcdUNGRkNcXHVEMDE4XFx1RDAzNFxcdUQwNTBcXHVEMDZDXFx1RDA4OFxcdUQwQTRcXHVEMEMwXFx1RDBEQ1xcdUQwRjhcXHVEMTE0XFx1RDEzMFxcdUQxNENcXHVEMTY4XFx1RDE4NFxcdUQxQTBcXHVEMUJDXFx1RDFEOFxcdUQxRjRcXHVEMjEwXFx1RDIyQ1xcdUQyNDhcXHVEMjY0XFx1RDI4MFxcdUQyOUNcXHVEMkI4XFx1RDJENFxcdUQyRjBcXHVEMzBDXFx1RDMyOFxcdUQzNDRcXHVEMzYwXFx1RDM3Q1xcdUQzOThcXHVEM0I0XFx1RDNEMFxcdUQzRUNcXHVENDA4XFx1RDQyNFxcdUQ0NDBcXHVENDVDXFx1RDQ3OFxcdUQ0OTRcXHVENEIwXFx1RDRDQ1xcdUQ0RThcXHVENTA0XFx1RDUyMFxcdUQ1M0NcXHVENTU4XFx1RDU3NFxcdUQ1OTBcXHVENUFDXFx1RDVDOFxcdUQ1RTRcXHVENjAwXFx1RDYxQ1xcdUQ2MzhcXHVENjU0XFx1RDY3MFxcdUQ2OENcXHVENkE4XFx1RDZDNFxcdUQ2RTBcXHVENkZDXFx1RDcxOFxcdUQ3MzRcXHVENzUwXFx1RDc2Q1xcdUQ3ODhdJC87XG52YXIgcmVMVlQgPSAvXltcXHVBQzAxLVxcdUFDMUJcXHVBQzFELVxcdUFDMzdcXHVBQzM5LVxcdUFDNTNcXHVBQzU1LVxcdUFDNkZcXHVBQzcxLVxcdUFDOEJcXHVBQzhELVxcdUFDQTdcXHVBQ0E5LVxcdUFDQzNcXHVBQ0M1LVxcdUFDREZcXHVBQ0UxLVxcdUFDRkJcXHVBQ0ZELVxcdUFEMTdcXHVBRDE5LVxcdUFEMzNcXHVBRDM1LVxcdUFENEZcXHVBRDUxLVxcdUFENkJcXHVBRDZELVxcdUFEODdcXHVBRDg5LVxcdUFEQTNcXHVBREE1LVxcdUFEQkZcXHVBREMxLVxcdUFEREJcXHVBRERELVxcdUFERjdcXHVBREY5LVxcdUFFMTNcXHVBRTE1LVxcdUFFMkZcXHVBRTMxLVxcdUFFNEJcXHVBRTRELVxcdUFFNjdcXHVBRTY5LVxcdUFFODNcXHVBRTg1LVxcdUFFOUZcXHVBRUExLVxcdUFFQkJcXHVBRUJELVxcdUFFRDdcXHVBRUQ5LVxcdUFFRjNcXHVBRUY1LVxcdUFGMEZcXHVBRjExLVxcdUFGMkJcXHVBRjJELVxcdUFGNDdcXHVBRjQ5LVxcdUFGNjNcXHVBRjY1LVxcdUFGN0ZcXHVBRjgxLVxcdUFGOUJcXHVBRjlELVxcdUFGQjdcXHVBRkI5LVxcdUFGRDNcXHVBRkQ1LVxcdUFGRUZcXHVBRkYxLVxcdUIwMEJcXHVCMDBELVxcdUIwMjdcXHVCMDI5LVxcdUIwNDNcXHVCMDQ1LVxcdUIwNUZcXHVCMDYxLVxcdUIwN0JcXHVCMDdELVxcdUIwOTdcXHVCMDk5LVxcdUIwQjNcXHVCMEI1LVxcdUIwQ0ZcXHVCMEQxLVxcdUIwRUJcXHVCMEVELVxcdUIxMDdcXHVCMTA5LVxcdUIxMjNcXHVCMTI1LVxcdUIxM0ZcXHVCMTQxLVxcdUIxNUJcXHVCMTVELVxcdUIxNzdcXHVCMTc5LVxcdUIxOTNcXHVCMTk1LVxcdUIxQUZcXHVCMUIxLVxcdUIxQ0JcXHVCMUNELVxcdUIxRTdcXHVCMUU5LVxcdUIyMDNcXHVCMjA1LVxcdUIyMUZcXHVCMjIxLVxcdUIyM0JcXHVCMjNELVxcdUIyNTdcXHVCMjU5LVxcdUIyNzNcXHVCMjc1LVxcdUIyOEZcXHVCMjkxLVxcdUIyQUJcXHVCMkFELVxcdUIyQzdcXHVCMkM5LVxcdUIyRTNcXHVCMkU1LVxcdUIyRkZcXHVCMzAxLVxcdUIzMUJcXHVCMzFELVxcdUIzMzdcXHVCMzM5LVxcdUIzNTNcXHVCMzU1LVxcdUIzNkZcXHVCMzcxLVxcdUIzOEJcXHVCMzhELVxcdUIzQTdcXHVCM0E5LVxcdUIzQzNcXHVCM0M1LVxcdUIzREZcXHVCM0UxLVxcdUIzRkJcXHVCM0ZELVxcdUI0MTdcXHVCNDE5LVxcdUI0MzNcXHVCNDM1LVxcdUI0NEZcXHVCNDUxLVxcdUI0NkJcXHVCNDZELVxcdUI0ODdcXHVCNDg5LVxcdUI0QTNcXHVCNEE1LVxcdUI0QkZcXHVCNEMxLVxcdUI0REJcXHVCNERELVxcdUI0RjdcXHVCNEY5LVxcdUI1MTNcXHVCNTE1LVxcdUI1MkZcXHVCNTMxLVxcdUI1NEJcXHVCNTRELVxcdUI1NjdcXHVCNTY5LVxcdUI1ODNcXHVCNTg1LVxcdUI1OUZcXHVCNUExLVxcdUI1QkJcXHVCNUJELVxcdUI1RDdcXHVCNUQ5LVxcdUI1RjNcXHVCNUY1LVxcdUI2MEZcXHVCNjExLVxcdUI2MkJcXHVCNjJELVxcdUI2NDdcXHVCNjQ5LVxcdUI2NjNcXHVCNjY1LVxcdUI2N0ZcXHVCNjgxLVxcdUI2OUJcXHVCNjlELVxcdUI2QjdcXHVCNkI5LVxcdUI2RDNcXHVCNkQ1LVxcdUI2RUZcXHVCNkYxLVxcdUI3MEJcXHVCNzBELVxcdUI3MjdcXHVCNzI5LVxcdUI3NDNcXHVCNzQ1LVxcdUI3NUZcXHVCNzYxLVxcdUI3N0JcXHVCNzdELVxcdUI3OTdcXHVCNzk5LVxcdUI3QjNcXHVCN0I1LVxcdUI3Q0ZcXHVCN0QxLVxcdUI3RUJcXHVCN0VELVxcdUI4MDdcXHVCODA5LVxcdUI4MjNcXHVCODI1LVxcdUI4M0ZcXHVCODQxLVxcdUI4NUJcXHVCODVELVxcdUI4NzdcXHVCODc5LVxcdUI4OTNcXHVCODk1LVxcdUI4QUZcXHVCOEIxLVxcdUI4Q0JcXHVCOENELVxcdUI4RTdcXHVCOEU5LVxcdUI5MDNcXHVCOTA1LVxcdUI5MUZcXHVCOTIxLVxcdUI5M0JcXHVCOTNELVxcdUI5NTdcXHVCOTU5LVxcdUI5NzNcXHVCOTc1LVxcdUI5OEZcXHVCOTkxLVxcdUI5QUJcXHVCOUFELVxcdUI5QzdcXHVCOUM5LVxcdUI5RTNcXHVCOUU1LVxcdUI5RkZcXHVCQTAxLVxcdUJBMUJcXHVCQTFELVxcdUJBMzdcXHVCQTM5LVxcdUJBNTNcXHVCQTU1LVxcdUJBNkZcXHVCQTcxLVxcdUJBOEJcXHVCQThELVxcdUJBQTdcXHVCQUE5LVxcdUJBQzNcXHVCQUM1LVxcdUJBREZcXHVCQUUxLVxcdUJBRkJcXHVCQUZELVxcdUJCMTdcXHVCQjE5LVxcdUJCMzNcXHVCQjM1LVxcdUJCNEZcXHVCQjUxLVxcdUJCNkJcXHVCQjZELVxcdUJCODdcXHVCQjg5LVxcdUJCQTNcXHVCQkE1LVxcdUJCQkZcXHVCQkMxLVxcdUJCREJcXHVCQkRELVxcdUJCRjdcXHVCQkY5LVxcdUJDMTNcXHVCQzE1LVxcdUJDMkZcXHVCQzMxLVxcdUJDNEJcXHVCQzRELVxcdUJDNjdcXHVCQzY5LVxcdUJDODNcXHVCQzg1LVxcdUJDOUZcXHVCQ0ExLVxcdUJDQkJcXHVCQ0JELVxcdUJDRDdcXHVCQ0Q5LVxcdUJDRjNcXHVCQ0Y1LVxcdUJEMEZcXHVCRDExLVxcdUJEMkJcXHVCRDJELVxcdUJENDdcXHVCRDQ5LVxcdUJENjNcXHVCRDY1LVxcdUJEN0ZcXHVCRDgxLVxcdUJEOUJcXHVCRDlELVxcdUJEQjdcXHVCREI5LVxcdUJERDNcXHVCREQ1LVxcdUJERUZcXHVCREYxLVxcdUJFMEJcXHVCRTBELVxcdUJFMjdcXHVCRTI5LVxcdUJFNDNcXHVCRTQ1LVxcdUJFNUZcXHVCRTYxLVxcdUJFN0JcXHVCRTdELVxcdUJFOTdcXHVCRTk5LVxcdUJFQjNcXHVCRUI1LVxcdUJFQ0ZcXHVCRUQxLVxcdUJFRUJcXHVCRUVELVxcdUJGMDdcXHVCRjA5LVxcdUJGMjNcXHVCRjI1LVxcdUJGM0ZcXHVCRjQxLVxcdUJGNUJcXHVCRjVELVxcdUJGNzdcXHVCRjc5LVxcdUJGOTNcXHVCRjk1LVxcdUJGQUZcXHVCRkIxLVxcdUJGQ0JcXHVCRkNELVxcdUJGRTdcXHVCRkU5LVxcdUMwMDNcXHVDMDA1LVxcdUMwMUZcXHVDMDIxLVxcdUMwM0JcXHVDMDNELVxcdUMwNTdcXHVDMDU5LVxcdUMwNzNcXHVDMDc1LVxcdUMwOEZcXHVDMDkxLVxcdUMwQUJcXHVDMEFELVxcdUMwQzdcXHVDMEM5LVxcdUMwRTNcXHVDMEU1LVxcdUMwRkZcXHVDMTAxLVxcdUMxMUJcXHVDMTFELVxcdUMxMzdcXHVDMTM5LVxcdUMxNTNcXHVDMTU1LVxcdUMxNkZcXHVDMTcxLVxcdUMxOEJcXHVDMThELVxcdUMxQTdcXHVDMUE5LVxcdUMxQzNcXHVDMUM1LVxcdUMxREZcXHVDMUUxLVxcdUMxRkJcXHVDMUZELVxcdUMyMTdcXHVDMjE5LVxcdUMyMzNcXHVDMjM1LVxcdUMyNEZcXHVDMjUxLVxcdUMyNkJcXHVDMjZELVxcdUMyODdcXHVDMjg5LVxcdUMyQTNcXHVDMkE1LVxcdUMyQkZcXHVDMkMxLVxcdUMyREJcXHVDMkRELVxcdUMyRjdcXHVDMkY5LVxcdUMzMTNcXHVDMzE1LVxcdUMzMkZcXHVDMzMxLVxcdUMzNEJcXHVDMzRELVxcdUMzNjdcXHVDMzY5LVxcdUMzODNcXHVDMzg1LVxcdUMzOUZcXHVDM0ExLVxcdUMzQkJcXHVDM0JELVxcdUMzRDdcXHVDM0Q5LVxcdUMzRjNcXHVDM0Y1LVxcdUM0MEZcXHVDNDExLVxcdUM0MkJcXHVDNDJELVxcdUM0NDdcXHVDNDQ5LVxcdUM0NjNcXHVDNDY1LVxcdUM0N0ZcXHVDNDgxLVxcdUM0OUJcXHVDNDlELVxcdUM0QjdcXHVDNEI5LVxcdUM0RDNcXHVDNEQ1LVxcdUM0RUZcXHVDNEYxLVxcdUM1MEJcXHVDNTBELVxcdUM1MjdcXHVDNTI5LVxcdUM1NDNcXHVDNTQ1LVxcdUM1NUZcXHVDNTYxLVxcdUM1N0JcXHVDNTdELVxcdUM1OTdcXHVDNTk5LVxcdUM1QjNcXHVDNUI1LVxcdUM1Q0ZcXHVDNUQxLVxcdUM1RUJcXHVDNUVELVxcdUM2MDdcXHVDNjA5LVxcdUM2MjNcXHVDNjI1LVxcdUM2M0ZcXHVDNjQxLVxcdUM2NUJcXHVDNjVELVxcdUM2NzdcXHVDNjc5LVxcdUM2OTNcXHVDNjk1LVxcdUM2QUZcXHVDNkIxLVxcdUM2Q0JcXHVDNkNELVxcdUM2RTdcXHVDNkU5LVxcdUM3MDNcXHVDNzA1LVxcdUM3MUZcXHVDNzIxLVxcdUM3M0JcXHVDNzNELVxcdUM3NTdcXHVDNzU5LVxcdUM3NzNcXHVDNzc1LVxcdUM3OEZcXHVDNzkxLVxcdUM3QUJcXHVDN0FELVxcdUM3QzdcXHVDN0M5LVxcdUM3RTNcXHVDN0U1LVxcdUM3RkZcXHVDODAxLVxcdUM4MUJcXHVDODFELVxcdUM4MzdcXHVDODM5LVxcdUM4NTNcXHVDODU1LVxcdUM4NkZcXHVDODcxLVxcdUM4OEJcXHVDODhELVxcdUM4QTdcXHVDOEE5LVxcdUM4QzNcXHVDOEM1LVxcdUM4REZcXHVDOEUxLVxcdUM4RkJcXHVDOEZELVxcdUM5MTdcXHVDOTE5LVxcdUM5MzNcXHVDOTM1LVxcdUM5NEZcXHVDOTUxLVxcdUM5NkJcXHVDOTZELVxcdUM5ODdcXHVDOTg5LVxcdUM5QTNcXHVDOUE1LVxcdUM5QkZcXHVDOUMxLVxcdUM5REJcXHVDOURELVxcdUM5RjdcXHVDOUY5LVxcdUNBMTNcXHVDQTE1LVxcdUNBMkZcXHVDQTMxLVxcdUNBNEJcXHVDQTRELVxcdUNBNjdcXHVDQTY5LVxcdUNBODNcXHVDQTg1LVxcdUNBOUZcXHVDQUExLVxcdUNBQkJcXHVDQUJELVxcdUNBRDdcXHVDQUQ5LVxcdUNBRjNcXHVDQUY1LVxcdUNCMEZcXHVDQjExLVxcdUNCMkJcXHVDQjJELVxcdUNCNDdcXHVDQjQ5LVxcdUNCNjNcXHVDQjY1LVxcdUNCN0ZcXHVDQjgxLVxcdUNCOUJcXHVDQjlELVxcdUNCQjdcXHVDQkI5LVxcdUNCRDNcXHVDQkQ1LVxcdUNCRUZcXHVDQkYxLVxcdUNDMEJcXHVDQzBELVxcdUNDMjdcXHVDQzI5LVxcdUNDNDNcXHVDQzQ1LVxcdUNDNUZcXHVDQzYxLVxcdUNDN0JcXHVDQzdELVxcdUNDOTdcXHVDQzk5LVxcdUNDQjNcXHVDQ0I1LVxcdUNDQ0ZcXHVDQ0QxLVxcdUNDRUJcXHVDQ0VELVxcdUNEMDdcXHVDRDA5LVxcdUNEMjNcXHVDRDI1LVxcdUNEM0ZcXHVDRDQxLVxcdUNENUJcXHVDRDVELVxcdUNENzdcXHVDRDc5LVxcdUNEOTNcXHVDRDk1LVxcdUNEQUZcXHVDREIxLVxcdUNEQ0JcXHVDRENELVxcdUNERTdcXHVDREU5LVxcdUNFMDNcXHVDRTA1LVxcdUNFMUZcXHVDRTIxLVxcdUNFM0JcXHVDRTNELVxcdUNFNTdcXHVDRTU5LVxcdUNFNzNcXHVDRTc1LVxcdUNFOEZcXHVDRTkxLVxcdUNFQUJcXHVDRUFELVxcdUNFQzdcXHVDRUM5LVxcdUNFRTNcXHVDRUU1LVxcdUNFRkZcXHVDRjAxLVxcdUNGMUJcXHVDRjFELVxcdUNGMzdcXHVDRjM5LVxcdUNGNTNcXHVDRjU1LVxcdUNGNkZcXHVDRjcxLVxcdUNGOEJcXHVDRjhELVxcdUNGQTdcXHVDRkE5LVxcdUNGQzNcXHVDRkM1LVxcdUNGREZcXHVDRkUxLVxcdUNGRkJcXHVDRkZELVxcdUQwMTdcXHVEMDE5LVxcdUQwMzNcXHVEMDM1LVxcdUQwNEZcXHVEMDUxLVxcdUQwNkJcXHVEMDZELVxcdUQwODdcXHVEMDg5LVxcdUQwQTNcXHVEMEE1LVxcdUQwQkZcXHVEMEMxLVxcdUQwREJcXHVEMERELVxcdUQwRjdcXHVEMEY5LVxcdUQxMTNcXHVEMTE1LVxcdUQxMkZcXHVEMTMxLVxcdUQxNEJcXHVEMTRELVxcdUQxNjdcXHVEMTY5LVxcdUQxODNcXHVEMTg1LVxcdUQxOUZcXHVEMUExLVxcdUQxQkJcXHVEMUJELVxcdUQxRDdcXHVEMUQ5LVxcdUQxRjNcXHVEMUY1LVxcdUQyMEZcXHVEMjExLVxcdUQyMkJcXHVEMjJELVxcdUQyNDdcXHVEMjQ5LVxcdUQyNjNcXHVEMjY1LVxcdUQyN0ZcXHVEMjgxLVxcdUQyOUJcXHVEMjlELVxcdUQyQjdcXHVEMkI5LVxcdUQyRDNcXHVEMkQ1LVxcdUQyRUZcXHVEMkYxLVxcdUQzMEJcXHVEMzBELVxcdUQzMjdcXHVEMzI5LVxcdUQzNDNcXHVEMzQ1LVxcdUQzNUZcXHVEMzYxLVxcdUQzN0JcXHVEMzdELVxcdUQzOTdcXHVEMzk5LVxcdUQzQjNcXHVEM0I1LVxcdUQzQ0ZcXHVEM0QxLVxcdUQzRUJcXHVEM0VELVxcdUQ0MDdcXHVENDA5LVxcdUQ0MjNcXHVENDI1LVxcdUQ0M0ZcXHVENDQxLVxcdUQ0NUJcXHVENDVELVxcdUQ0NzdcXHVENDc5LVxcdUQ0OTNcXHVENDk1LVxcdUQ0QUZcXHVENEIxLVxcdUQ0Q0JcXHVENENELVxcdUQ0RTdcXHVENEU5LVxcdUQ1MDNcXHVENTA1LVxcdUQ1MUZcXHVENTIxLVxcdUQ1M0JcXHVENTNELVxcdUQ1NTdcXHVENTU5LVxcdUQ1NzNcXHVENTc1LVxcdUQ1OEZcXHVENTkxLVxcdUQ1QUJcXHVENUFELVxcdUQ1QzdcXHVENUM5LVxcdUQ1RTNcXHVENUU1LVxcdUQ1RkZcXHVENjAxLVxcdUQ2MUJcXHVENjFELVxcdUQ2MzdcXHVENjM5LVxcdUQ2NTNcXHVENjU1LVxcdUQ2NkZcXHVENjcxLVxcdUQ2OEJcXHVENjhELVxcdUQ2QTdcXHVENkE5LVxcdUQ2QzNcXHVENkM1LVxcdUQ2REZcXHVENkUxLVxcdUQ2RkJcXHVENkZELVxcdUQ3MTdcXHVENzE5LVxcdUQ3MzNcXHVENzM1LVxcdUQ3NEZcXHVENzUxLVxcdUQ3NkJcXHVENzZELVxcdUQ3ODdcXHVENzg5LVxcdUQ3QTNdJC87XG52YXIgcmVFeHRQaWN0ID0gL14oPzpbXFx4QTlcXHhBRVxcdTIwM0NcXHUyMDQ5XFx1MjEyMlxcdTIxMzlcXHUyMTk0LVxcdTIxOTlcXHUyMUE5XFx1MjFBQVxcdTIzMUFcXHUyMzFCXFx1MjMyOFxcdTIzODhcXHUyM0NGXFx1MjNFOS1cXHUyM0YzXFx1MjNGOC1cXHUyM0ZBXFx1MjRDMlxcdTI1QUFcXHUyNUFCXFx1MjVCNlxcdTI1QzBcXHUyNUZCLVxcdTI1RkVcXHUyNjAwLVxcdTI2MDVcXHUyNjA3LVxcdTI2MTJcXHUyNjE0LVxcdTI2ODVcXHUyNjkwLVxcdTI3MDVcXHUyNzA4LVxcdTI3MTJcXHUyNzE0XFx1MjcxNlxcdTI3MURcXHUyNzIxXFx1MjcyOFxcdTI3MzNcXHUyNzM0XFx1Mjc0NFxcdTI3NDdcXHUyNzRDXFx1Mjc0RVxcdTI3NTMtXFx1Mjc1NVxcdTI3NTdcXHUyNzYzLVxcdTI3NjdcXHUyNzk1LVxcdTI3OTdcXHUyN0ExXFx1MjdCMFxcdTI3QkZcXHUyOTM0XFx1MjkzNVxcdTJCMDUtXFx1MkIwN1xcdTJCMUJcXHUyQjFDXFx1MkI1MFxcdTJCNTVcXHUzMDMwXFx1MzAzRFxcdTMyOTdcXHUzMjk5XXxcXHVEODNDW1xcdURDMDAtXFx1RENGRlxcdUREMEQtXFx1REQwRlxcdUREMkZcXHVERDZDLVxcdURENzFcXHVERDdFXFx1REQ3RlxcdUREOEVcXHVERDkxLVxcdUREOUFcXHVEREFELVxcdURERTVcXHVERTAxLVxcdURFMEZcXHVERTFBXFx1REUyRlxcdURFMzItXFx1REUzQVxcdURFM0MtXFx1REUzRlxcdURFNDktXFx1REZGQV18XFx1RDgzRFtcXHVEQzAwLVxcdUREM0RcXHVERDQ2LVxcdURFNEZcXHVERTgwLVxcdURFRkZcXHVERjc0LVxcdURGN0ZcXHVERkQ1LVxcdURGRkZdfFxcdUQ4M0VbXFx1REMwQy1cXHVEQzBGXFx1REM0OC1cXHVEQzRGXFx1REM1QS1cXHVEQzVGXFx1REM4OC1cXHVEQzhGXFx1RENBRS1cXHVEQ0ZGXFx1REQwQy1cXHVERDNBXFx1REQzQy1cXHVERDQ1XFx1REQ0Ny1cXHVERUZGXXxcXHVEODNGW1xcdURDMDAtXFx1REZGRF0pJC87XG5cbnZhciBnZXRDb2RlcG9pbnRUeXBlID0gZnVuY3Rpb24gZ2V0Q29kZXBvaW50VHlwZShfY2hhcjQsIGNvZGUpIHtcbiAgdmFyIHR5cGUgPSBDb2RlcG9pbnRUeXBlLkFueTtcblxuICBpZiAoX2NoYXI0LnNlYXJjaChyZUV4dGVuZCkgIT09IC0xKSB7XG4gICAgdHlwZSB8PSBDb2RlcG9pbnRUeXBlLkV4dGVuZDtcbiAgfVxuXG4gIGlmIChjb2RlID09PSAweDIwMGQpIHtcbiAgICB0eXBlIHw9IENvZGVwb2ludFR5cGUuWldKO1xuICB9XG5cbiAgaWYgKGNvZGUgPj0gMHgxZjFlNiAmJiBjb2RlIDw9IDB4MWYxZmYpIHtcbiAgICB0eXBlIHw9IENvZGVwb2ludFR5cGUuUkk7XG4gIH1cblxuICBpZiAoX2NoYXI0LnNlYXJjaChyZVByZXBlbmQpICE9PSAtMSkge1xuICAgIHR5cGUgfD0gQ29kZXBvaW50VHlwZS5QcmVwZW5kO1xuICB9XG5cbiAgaWYgKF9jaGFyNC5zZWFyY2gocmVTcGFjaW5nTWFyaykgIT09IC0xKSB7XG4gICAgdHlwZSB8PSBDb2RlcG9pbnRUeXBlLlNwYWNpbmdNYXJrO1xuICB9XG5cbiAgaWYgKF9jaGFyNC5zZWFyY2gocmVMKSAhPT0gLTEpIHtcbiAgICB0eXBlIHw9IENvZGVwb2ludFR5cGUuTDtcbiAgfVxuXG4gIGlmIChfY2hhcjQuc2VhcmNoKHJlVikgIT09IC0xKSB7XG4gICAgdHlwZSB8PSBDb2RlcG9pbnRUeXBlLlY7XG4gIH1cblxuICBpZiAoX2NoYXI0LnNlYXJjaChyZVQpICE9PSAtMSkge1xuICAgIHR5cGUgfD0gQ29kZXBvaW50VHlwZS5UO1xuICB9XG5cbiAgaWYgKF9jaGFyNC5zZWFyY2gocmVMVikgIT09IC0xKSB7XG4gICAgdHlwZSB8PSBDb2RlcG9pbnRUeXBlLkxWO1xuICB9XG5cbiAgaWYgKF9jaGFyNC5zZWFyY2gocmVMVlQpICE9PSAtMSkge1xuICAgIHR5cGUgfD0gQ29kZXBvaW50VHlwZS5MVlQ7XG4gIH1cblxuICBpZiAoX2NoYXI0LnNlYXJjaChyZUV4dFBpY3QpICE9PSAtMSkge1xuICAgIHR5cGUgfD0gQ29kZXBvaW50VHlwZS5FeHRQaWN0O1xuICB9XG5cbiAgcmV0dXJuIHR5cGU7XG59O1xuXG5mdW5jdGlvbiBpbnRlcnNlY3RzKHgsIHkpIHtcbiAgcmV0dXJuICh4ICYgeSkgIT09IDA7XG59XG5cbnZhciBOb25Cb3VuZGFyeVBhaXJzID0gWy8vIEdCNlxuW0NvZGVwb2ludFR5cGUuTCwgQ29kZXBvaW50VHlwZS5MIHwgQ29kZXBvaW50VHlwZS5WIHwgQ29kZXBvaW50VHlwZS5MViB8IENvZGVwb2ludFR5cGUuTFZUXSwgLy8gR0I3XG5bQ29kZXBvaW50VHlwZS5MViB8IENvZGVwb2ludFR5cGUuViwgQ29kZXBvaW50VHlwZS5WIHwgQ29kZXBvaW50VHlwZS5UXSwgLy8gR0I4XG5bQ29kZXBvaW50VHlwZS5MVlQgfCBDb2RlcG9pbnRUeXBlLlQsIENvZGVwb2ludFR5cGUuVF0sIC8vIEdCOVxuW0NvZGVwb2ludFR5cGUuQW55LCBDb2RlcG9pbnRUeXBlLkV4dGVuZCB8IENvZGVwb2ludFR5cGUuWldKXSwgLy8gR0I5YVxuW0NvZGVwb2ludFR5cGUuQW55LCBDb2RlcG9pbnRUeXBlLlNwYWNpbmdNYXJrXSwgLy8gR0I5YlxuW0NvZGVwb2ludFR5cGUuUHJlcGVuZCwgQ29kZXBvaW50VHlwZS5BbnldLCAvLyBHQjExXG5bQ29kZXBvaW50VHlwZS5aV0osIENvZGVwb2ludFR5cGUuRXh0UGljdF0sIC8vIEdCMTIgYW5kIEdCMTNcbltDb2RlcG9pbnRUeXBlLlJJLCBDb2RlcG9pbnRUeXBlLlJJXV07XG5cbmZ1bmN0aW9uIGlzQm91bmRhcnlQYWlyKGxlZnQsIHJpZ2h0KSB7XG4gIHJldHVybiBOb25Cb3VuZGFyeVBhaXJzLmZpbmRJbmRleChmdW5jdGlvbiAocikge1xuICAgIHJldHVybiBpbnRlcnNlY3RzKGxlZnQsIHJbMF0pICYmIGludGVyc2VjdHMocmlnaHQsIHJbMV0pO1xuICB9KSA9PT0gLTE7XG59XG5cbnZhciBlbmRpbmdFbW9qaVpXSiA9IC8oPzpbXFx4QTlcXHhBRVxcdTIwM0NcXHUyMDQ5XFx1MjEyMlxcdTIxMzlcXHUyMTk0LVxcdTIxOTlcXHUyMUE5XFx1MjFBQVxcdTIzMUFcXHUyMzFCXFx1MjMyOFxcdTIzODhcXHUyM0NGXFx1MjNFOS1cXHUyM0YzXFx1MjNGOC1cXHUyM0ZBXFx1MjRDMlxcdTI1QUFcXHUyNUFCXFx1MjVCNlxcdTI1QzBcXHUyNUZCLVxcdTI1RkVcXHUyNjAwLVxcdTI2MDVcXHUyNjA3LVxcdTI2MTJcXHUyNjE0LVxcdTI2ODVcXHUyNjkwLVxcdTI3MDVcXHUyNzA4LVxcdTI3MTJcXHUyNzE0XFx1MjcxNlxcdTI3MURcXHUyNzIxXFx1MjcyOFxcdTI3MzNcXHUyNzM0XFx1Mjc0NFxcdTI3NDdcXHUyNzRDXFx1Mjc0RVxcdTI3NTMtXFx1Mjc1NVxcdTI3NTdcXHUyNzYzLVxcdTI3NjdcXHUyNzk1LVxcdTI3OTdcXHUyN0ExXFx1MjdCMFxcdTI3QkZcXHUyOTM0XFx1MjkzNVxcdTJCMDUtXFx1MkIwN1xcdTJCMUJcXHUyQjFDXFx1MkI1MFxcdTJCNTVcXHUzMDMwXFx1MzAzRFxcdTMyOTdcXHUzMjk5XXxcXHVEODNDW1xcdURDMDAtXFx1RENGRlxcdUREMEQtXFx1REQwRlxcdUREMkZcXHVERDZDLVxcdURENzFcXHVERDdFXFx1REQ3RlxcdUREOEVcXHVERDkxLVxcdUREOUFcXHVEREFELVxcdURERTVcXHVERTAxLVxcdURFMEZcXHVERTFBXFx1REUyRlxcdURFMzItXFx1REUzQVxcdURFM0MtXFx1REUzRlxcdURFNDktXFx1REZGQV18XFx1RDgzRFtcXHVEQzAwLVxcdUREM0RcXHVERDQ2LVxcdURFNEZcXHVERTgwLVxcdURFRkZcXHVERjc0LVxcdURGN0ZcXHVERkQ1LVxcdURGRkZdfFxcdUQ4M0VbXFx1REMwQy1cXHVEQzBGXFx1REM0OC1cXHVEQzRGXFx1REM1QS1cXHVEQzVGXFx1REM4OC1cXHVEQzhGXFx1RENBRS1cXHVEQ0ZGXFx1REQwQy1cXHVERDNBXFx1REQzQy1cXHVERDQ1XFx1REQ0Ny1cXHVERUZGXXxcXHVEODNGW1xcdURDMDAtXFx1REZGRF0pKD86W1xcdTAzMDAtXFx1MDM2RlxcdTA0ODMtXFx1MDQ4OVxcdTA1OTEtXFx1MDVCRFxcdTA1QkZcXHUwNUMxXFx1MDVDMlxcdTA1QzRcXHUwNUM1XFx1MDVDN1xcdTA2MTAtXFx1MDYxQVxcdTA2NEItXFx1MDY1RlxcdTA2NzBcXHUwNkQ2LVxcdTA2RENcXHUwNkRGLVxcdTA2RTRcXHUwNkU3XFx1MDZFOFxcdTA2RUEtXFx1MDZFRFxcdTA3MTFcXHUwNzMwLVxcdTA3NEFcXHUwN0E2LVxcdTA3QjBcXHUwN0VCLVxcdTA3RjNcXHUwN0ZEXFx1MDgxNi1cXHUwODE5XFx1MDgxQi1cXHUwODIzXFx1MDgyNS1cXHUwODI3XFx1MDgyOS1cXHUwODJEXFx1MDg1OS1cXHUwODVCXFx1MDhEMy1cXHUwOEUxXFx1MDhFMy1cXHUwOTAyXFx1MDkzQVxcdTA5M0NcXHUwOTQxLVxcdTA5NDhcXHUwOTREXFx1MDk1MS1cXHUwOTU3XFx1MDk2MlxcdTA5NjNcXHUwOTgxXFx1MDlCQ1xcdTA5QkVcXHUwOUMxLVxcdTA5QzRcXHUwOUNEXFx1MDlEN1xcdTA5RTJcXHUwOUUzXFx1MDlGRVxcdTBBMDFcXHUwQTAyXFx1MEEzQ1xcdTBBNDFcXHUwQTQyXFx1MEE0N1xcdTBBNDhcXHUwQTRCLVxcdTBBNERcXHUwQTUxXFx1MEE3MFxcdTBBNzFcXHUwQTc1XFx1MEE4MVxcdTBBODJcXHUwQUJDXFx1MEFDMS1cXHUwQUM1XFx1MEFDN1xcdTBBQzhcXHUwQUNEXFx1MEFFMlxcdTBBRTNcXHUwQUZBLVxcdTBBRkZcXHUwQjAxXFx1MEIzQ1xcdTBCM0VcXHUwQjNGXFx1MEI0MS1cXHUwQjQ0XFx1MEI0RFxcdTBCNTUtXFx1MEI1N1xcdTBCNjJcXHUwQjYzXFx1MEI4MlxcdTBCQkVcXHUwQkMwXFx1MEJDRFxcdTBCRDdcXHUwQzAwXFx1MEMwNFxcdTBDM0UtXFx1MEM0MFxcdTBDNDYtXFx1MEM0OFxcdTBDNEEtXFx1MEM0RFxcdTBDNTVcXHUwQzU2XFx1MEM2MlxcdTBDNjNcXHUwQzgxXFx1MENCQ1xcdTBDQkZcXHUwQ0MyXFx1MENDNlxcdTBDQ0NcXHUwQ0NEXFx1MENENVxcdTBDRDZcXHUwQ0UyXFx1MENFM1xcdTBEMDBcXHUwRDAxXFx1MEQzQlxcdTBEM0NcXHUwRDNFXFx1MEQ0MS1cXHUwRDQ0XFx1MEQ0RFxcdTBENTdcXHUwRDYyXFx1MEQ2M1xcdTBEODFcXHUwRENBXFx1MERDRlxcdTBERDItXFx1MERENFxcdTBERDZcXHUwRERGXFx1MEUzMVxcdTBFMzQtXFx1MEUzQVxcdTBFNDctXFx1MEU0RVxcdTBFQjFcXHUwRUI0LVxcdTBFQkNcXHUwRUM4LVxcdTBFQ0RcXHUwRjE4XFx1MEYxOVxcdTBGMzVcXHUwRjM3XFx1MEYzOVxcdTBGNzEtXFx1MEY3RVxcdTBGODAtXFx1MEY4NFxcdTBGODZcXHUwRjg3XFx1MEY4RC1cXHUwRjk3XFx1MEY5OS1cXHUwRkJDXFx1MEZDNlxcdTEwMkQtXFx1MTAzMFxcdTEwMzItXFx1MTAzN1xcdTEwMzlcXHUxMDNBXFx1MTAzRFxcdTEwM0VcXHUxMDU4XFx1MTA1OVxcdTEwNUUtXFx1MTA2MFxcdTEwNzEtXFx1MTA3NFxcdTEwODJcXHUxMDg1XFx1MTA4NlxcdTEwOERcXHUxMDlEXFx1MTM1RC1cXHUxMzVGXFx1MTcxMi1cXHUxNzE0XFx1MTczMi1cXHUxNzM0XFx1MTc1MlxcdTE3NTNcXHUxNzcyXFx1MTc3M1xcdTE3QjRcXHUxN0I1XFx1MTdCNy1cXHUxN0JEXFx1MTdDNlxcdTE3QzktXFx1MTdEM1xcdTE3RERcXHUxODBCLVxcdTE4MERcXHUxODg1XFx1MTg4NlxcdTE4QTlcXHUxOTIwLVxcdTE5MjJcXHUxOTI3XFx1MTkyOFxcdTE5MzJcXHUxOTM5LVxcdTE5M0JcXHUxQTE3XFx1MUExOFxcdTFBMUJcXHUxQTU2XFx1MUE1OC1cXHUxQTVFXFx1MUE2MFxcdTFBNjJcXHUxQTY1LVxcdTFBNkNcXHUxQTczLVxcdTFBN0NcXHUxQTdGXFx1MUFCMC1cXHUxQUMwXFx1MUIwMC1cXHUxQjAzXFx1MUIzNC1cXHUxQjNBXFx1MUIzQ1xcdTFCNDJcXHUxQjZCLVxcdTFCNzNcXHUxQjgwXFx1MUI4MVxcdTFCQTItXFx1MUJBNVxcdTFCQThcXHUxQkE5XFx1MUJBQi1cXHUxQkFEXFx1MUJFNlxcdTFCRThcXHUxQkU5XFx1MUJFRFxcdTFCRUYtXFx1MUJGMVxcdTFDMkMtXFx1MUMzM1xcdTFDMzZcXHUxQzM3XFx1MUNEMC1cXHUxQ0QyXFx1MUNENC1cXHUxQ0UwXFx1MUNFMi1cXHUxQ0U4XFx1MUNFRFxcdTFDRjRcXHUxQ0Y4XFx1MUNGOVxcdTFEQzAtXFx1MURGOVxcdTFERkItXFx1MURGRlxcdTIwMENcXHUyMEQwLVxcdTIwRjBcXHUyQ0VGLVxcdTJDRjFcXHUyRDdGXFx1MkRFMC1cXHUyREZGXFx1MzAyQS1cXHUzMDJGXFx1MzA5OVxcdTMwOUFcXHVBNjZGLVxcdUE2NzJcXHVBNjc0LVxcdUE2N0RcXHVBNjlFXFx1QTY5RlxcdUE2RjBcXHVBNkYxXFx1QTgwMlxcdUE4MDZcXHVBODBCXFx1QTgyNVxcdUE4MjZcXHVBODJDXFx1QThDNFxcdUE4QzVcXHVBOEUwLVxcdUE4RjFcXHVBOEZGXFx1QTkyNi1cXHVBOTJEXFx1QTk0Ny1cXHVBOTUxXFx1QTk4MC1cXHVBOTgyXFx1QTlCM1xcdUE5QjYtXFx1QTlCOVxcdUE5QkNcXHVBOUJEXFx1QTlFNVxcdUFBMjktXFx1QUEyRVxcdUFBMzFcXHVBQTMyXFx1QUEzNVxcdUFBMzZcXHVBQTQzXFx1QUE0Q1xcdUFBN0NcXHVBQUIwXFx1QUFCMi1cXHVBQUI0XFx1QUFCN1xcdUFBQjhcXHVBQUJFXFx1QUFCRlxcdUFBQzFcXHVBQUVDXFx1QUFFRFxcdUFBRjZcXHVBQkU1XFx1QUJFOFxcdUFCRURcXHVGQjFFXFx1RkUwMC1cXHVGRTBGXFx1RkUyMC1cXHVGRTJGXFx1RkY5RVxcdUZGOUZdfFxcdUQ4MDBbXFx1RERGRFxcdURFRTBcXHVERjc2LVxcdURGN0FdfFxcdUQ4MDJbXFx1REUwMS1cXHVERTAzXFx1REUwNVxcdURFMDZcXHVERTBDLVxcdURFMEZcXHVERTM4LVxcdURFM0FcXHVERTNGXFx1REVFNVxcdURFRTZdfFxcdUQ4MDNbXFx1REQyNC1cXHVERDI3XFx1REVBQlxcdURFQUNcXHVERjQ2LVxcdURGNTBdfFxcdUQ4MDRbXFx1REMwMVxcdURDMzgtXFx1REM0NlxcdURDN0YtXFx1REM4MVxcdURDQjMtXFx1RENCNlxcdURDQjlcXHVEQ0JBXFx1REQwMC1cXHVERDAyXFx1REQyNy1cXHVERDJCXFx1REQyRC1cXHVERDM0XFx1REQ3M1xcdUREODBcXHVERDgxXFx1RERCNi1cXHVEREJFXFx1RERDOS1cXHVERENDXFx1RERDRlxcdURFMkYtXFx1REUzMVxcdURFMzRcXHVERTM2XFx1REUzN1xcdURFM0VcXHVERURGXFx1REVFMy1cXHVERUVBXFx1REYwMFxcdURGMDFcXHVERjNCXFx1REYzQ1xcdURGM0VcXHVERjQwXFx1REY1N1xcdURGNjYtXFx1REY2Q1xcdURGNzAtXFx1REY3NF18XFx1RDgwNVtcXHVEQzM4LVxcdURDM0ZcXHVEQzQyLVxcdURDNDRcXHVEQzQ2XFx1REM1RVxcdURDQjBcXHVEQ0IzLVxcdURDQjhcXHVEQ0JBXFx1RENCRFxcdURDQkZcXHVEQ0MwXFx1RENDMlxcdURDQzNcXHVEREFGXFx1RERCMi1cXHVEREI1XFx1RERCQ1xcdUREQkRcXHVEREJGXFx1RERDMFxcdURERENcXHVEREREXFx1REUzMy1cXHVERTNBXFx1REUzRFxcdURFM0ZcXHVERTQwXFx1REVBQlxcdURFQURcXHVERUIwLVxcdURFQjVcXHVERUI3XFx1REYxRC1cXHVERjFGXFx1REYyMi1cXHVERjI1XFx1REYyNy1cXHVERjJCXXxcXHVEODA2W1xcdURDMkYtXFx1REMzN1xcdURDMzlcXHVEQzNBXFx1REQzMFxcdUREM0JcXHVERDNDXFx1REQzRVxcdURENDNcXHVEREQ0LVxcdURERDdcXHVERERBXFx1REREQlxcdURERTBcXHVERTAxLVxcdURFMEFcXHVERTMzLVxcdURFMzhcXHVERTNCLVxcdURFM0VcXHVERTQ3XFx1REU1MS1cXHVERTU2XFx1REU1OS1cXHVERTVCXFx1REU4QS1cXHVERTk2XFx1REU5OFxcdURFOTldfFxcdUQ4MDdbXFx1REMzMC1cXHVEQzM2XFx1REMzOC1cXHVEQzNEXFx1REMzRlxcdURDOTItXFx1RENBN1xcdURDQUEtXFx1RENCMFxcdURDQjJcXHVEQ0IzXFx1RENCNVxcdURDQjZcXHVERDMxLVxcdUREMzZcXHVERDNBXFx1REQzQ1xcdUREM0RcXHVERDNGLVxcdURENDVcXHVERDQ3XFx1REQ5MFxcdUREOTFcXHVERDk1XFx1REQ5N1xcdURFRjNcXHVERUY0XXxcXHVEODFBW1xcdURFRjAtXFx1REVGNFxcdURGMzAtXFx1REYzNl18XFx1RDgxQltcXHVERjRGXFx1REY4Ri1cXHVERjkyXFx1REZFNF18XFx1RDgyRltcXHVEQzlEXFx1REM5RV18XFx1RDgzNFtcXHVERDY1XFx1REQ2Ny1cXHVERDY5XFx1REQ2RS1cXHVERDcyXFx1REQ3Qi1cXHVERDgyXFx1REQ4NS1cXHVERDhCXFx1RERBQS1cXHVEREFEXFx1REU0Mi1cXHVERTQ0XXxcXHVEODM2W1xcdURFMDAtXFx1REUzNlxcdURFM0ItXFx1REU2Q1xcdURFNzVcXHVERTg0XFx1REU5Qi1cXHVERTlGXFx1REVBMS1cXHVERUFGXXxcXHVEODM4W1xcdURDMDAtXFx1REMwNlxcdURDMDgtXFx1REMxOFxcdURDMUItXFx1REMyMVxcdURDMjNcXHVEQzI0XFx1REMyNi1cXHVEQzJBXFx1REQzMC1cXHVERDM2XFx1REVFQy1cXHVERUVGXXxcXHVEODNBW1xcdURDRDAtXFx1RENENlxcdURENDQtXFx1REQ0QV18XFx1RDgzQ1tcXHVERkZCLVxcdURGRkZdfFxcdURCNDBbXFx1REMyMC1cXHVEQzdGXFx1REQwMC1cXHVEREVGXSkqXFx1MjAwRCQvO1xuXG52YXIgZW5kc1dpdGhFbW9qaVpXSiA9IGZ1bmN0aW9uIGVuZHNXaXRoRW1vamlaV0ooc3RyKSB7XG4gIHJldHVybiBzdHIuc2VhcmNoKGVuZGluZ0Vtb2ppWldKKSAhPT0gLTE7XG59O1xuXG52YXIgZW5kaW5nUklzID0gLyg/OlxcdUQ4M0NbXFx1RERFNi1cXHVEREZGXSkrJC9nO1xuXG52YXIgZW5kc1dpdGhPZGROdW1iZXJPZlJJcyA9IGZ1bmN0aW9uIGVuZHNXaXRoT2RkTnVtYmVyT2ZSSXMoc3RyKSB7XG4gIHZhciBtYXRjaCA9IHN0ci5tYXRjaChlbmRpbmdSSXMpO1xuXG4gIGlmIChtYXRjaCA9PT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSBlbHNlIHtcbiAgICAvLyBBIFJJIGlzIHJlcHJlc2VudGVkIGJ5IGEgc3Vycm9nYXRlIHBhaXIuXG4gICAgdmFyIG51bVJJcyA9IG1hdGNoWzBdLmxlbmd0aCAvIDI7XG4gICAgcmV0dXJuIG51bVJJcyAlIDIgPT09IDE7XG4gIH1cbn07XG5cbi8qKlxyXG4gKiBTaGFyZWQgdGhlIGZ1bmN0aW9uIHdpdGggaXNFbGVtZW50VHlwZSB1dGlsaXR5XHJcbiAqL1xuXG52YXIgaXNFbGVtZW50ID0gZnVuY3Rpb24gaXNFbGVtZW50KHZhbHVlKSB7XG4gIHJldHVybiBpc1BsYWluT2JqZWN0LmlzUGxhaW5PYmplY3QodmFsdWUpICYmIE5vZGUuaXNOb2RlTGlzdCh2YWx1ZS5jaGlsZHJlbikgJiYgIUVkaXRvci5pc0VkaXRvcih2YWx1ZSk7XG59OyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVkZWNsYXJlXG5cblxudmFyIEVsZW1lbnQgPSB7XG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgdmFsdWUgaW1wbGVtZW50cyB0aGUgJ0FuY2VzdG9yJyBpbnRlcmZhY2UuXHJcbiAgICovXG4gIGlzQW5jZXN0b3I6IGZ1bmN0aW9uIGlzQW5jZXN0b3IodmFsdWUpIHtcbiAgICByZXR1cm4gaXNQbGFpbk9iamVjdC5pc1BsYWluT2JqZWN0KHZhbHVlKSAmJiBOb2RlLmlzTm9kZUxpc3QodmFsdWUuY2hpbGRyZW4pO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgdmFsdWUgaW1wbGVtZW50cyB0aGUgYEVsZW1lbnRgIGludGVyZmFjZS5cclxuICAgKi9cbiAgaXNFbGVtZW50OiBpc0VsZW1lbnQsXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSB2YWx1ZSBpcyBhbiBhcnJheSBvZiBgRWxlbWVudGAgb2JqZWN0cy5cclxuICAgKi9cbiAgaXNFbGVtZW50TGlzdDogZnVuY3Rpb24gaXNFbGVtZW50TGlzdCh2YWx1ZSkge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKSAmJiB2YWx1ZS5ldmVyeShmdW5jdGlvbiAodmFsKSB7XG4gICAgICByZXR1cm4gRWxlbWVudC5pc0VsZW1lbnQodmFsKTtcbiAgICB9KTtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhIHNldCBvZiBwcm9wcyBpcyBhIHBhcnRpYWwgb2YgRWxlbWVudC5cclxuICAgKi9cbiAgaXNFbGVtZW50UHJvcHM6IGZ1bmN0aW9uIGlzRWxlbWVudFByb3BzKHByb3BzKSB7XG4gICAgcmV0dXJuIHByb3BzLmNoaWxkcmVuICE9PSB1bmRlZmluZWQ7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSB2YWx1ZSBpbXBsZW1lbnRzIHRoZSBgRWxlbWVudGAgaW50ZXJmYWNlIGFuZCBoYXMgZWxlbWVudEtleSB3aXRoIHNlbGVjdGVkIHZhbHVlLlxyXG4gICAqIERlZmF1bHQgaXQgY2hlY2sgdG8gYHR5cGVgIGtleSB2YWx1ZVxyXG4gICAqL1xuICBpc0VsZW1lbnRUeXBlOiBmdW5jdGlvbiBpc0VsZW1lbnRUeXBlKHZhbHVlLCBlbGVtZW50VmFsKSB7XG4gICAgdmFyIGVsZW1lbnRLZXkgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6ICd0eXBlJztcbiAgICByZXR1cm4gaXNFbGVtZW50KHZhbHVlKSAmJiB2YWx1ZVtlbGVtZW50S2V5XSA9PT0gZWxlbWVudFZhbDtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhbiBlbGVtZW50IG1hdGNoZXMgc2V0IG9mIHByb3BlcnRpZXMuXHJcbiAgICpcclxuICAgKiBOb3RlOiB0aGlzIGNoZWNrcyBjdXN0b20gcHJvcGVydGllcywgYW5kIGl0IGRvZXMgbm90IGVuc3VyZSB0aGF0IGFueVxyXG4gICAqIGNoaWxkcmVuIGFyZSBlcXVpdmFsZW50LlxyXG4gICAqL1xuICBtYXRjaGVzOiBmdW5jdGlvbiBtYXRjaGVzKGVsZW1lbnQsIHByb3BzKSB7XG4gICAgZm9yICh2YXIga2V5IGluIHByb3BzKSB7XG4gICAgICBpZiAoa2V5ID09PSAnY2hpbGRyZW4nKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoZWxlbWVudFtrZXldICE9PSBwcm9wc1trZXldKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTtcblxudmFyIF9leGNsdWRlZCQ0ID0gW1widGV4dFwiXSxcbiAgICBfZXhjbHVkZWQyJDMgPSBbXCJ0ZXh0XCJdO1xuXG5mdW5jdGlvbiBvd25LZXlzJDgob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBpZiAoZW51bWVyYWJsZU9ubHkpIHsgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyB9IGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkJDgodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgb3duS2V5cyQ4KE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pOyB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7IH0gZWxzZSB7IG93bktleXMkOChPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkNShvLCBhbGxvd0FycmF5TGlrZSkgeyB2YXIgaXQgPSB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXSB8fCBvW1wiQEBpdGVyYXRvclwiXTsgaWYgKCFpdCkgeyBpZiAoQXJyYXkuaXNBcnJheShvKSB8fCAoaXQgPSBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkkNShvKSkgfHwgYWxsb3dBcnJheUxpa2UgJiYgbyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHsgaWYgKGl0KSBvID0gaXQ7IHZhciBpID0gMDsgdmFyIEYgPSBmdW5jdGlvbiBGKCkge307IHJldHVybiB7IHM6IEYsIG46IGZ1bmN0aW9uIG4oKSB7IGlmIChpID49IG8ubGVuZ3RoKSByZXR1cm4geyBkb25lOiB0cnVlIH07IHJldHVybiB7IGRvbmU6IGZhbHNlLCB2YWx1ZTogb1tpKytdIH07IH0sIGU6IGZ1bmN0aW9uIGUoX2UpIHsgdGhyb3cgX2U7IH0sIGY6IEYgfTsgfSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGl0ZXJhdGUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH0gdmFyIG5vcm1hbENvbXBsZXRpb24gPSB0cnVlLCBkaWRFcnIgPSBmYWxzZSwgZXJyOyByZXR1cm4geyBzOiBmdW5jdGlvbiBzKCkgeyBpdCA9IGl0LmNhbGwobyk7IH0sIG46IGZ1bmN0aW9uIG4oKSB7IHZhciBzdGVwID0gaXQubmV4dCgpOyBub3JtYWxDb21wbGV0aW9uID0gc3RlcC5kb25lOyByZXR1cm4gc3RlcDsgfSwgZTogZnVuY3Rpb24gZShfZTIpIHsgZGlkRXJyID0gdHJ1ZTsgZXJyID0gX2UyOyB9LCBmOiBmdW5jdGlvbiBmKCkgeyB0cnkgeyBpZiAoIW5vcm1hbENvbXBsZXRpb24gJiYgaXRbXCJyZXR1cm5cIl0gIT0gbnVsbCkgaXRbXCJyZXR1cm5cIl0oKTsgfSBmaW5hbGx5IHsgaWYgKGRpZEVycikgdGhyb3cgZXJyOyB9IH0gfTsgfVxuXG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkkNShvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5JDUobywgbWluTGVuKTsgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheSQ1KG8sIG1pbkxlbik7IH1cblxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkkNShhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH1cbnZhciBJU19FRElUT1JfQ0FDSEUgPSBuZXcgV2Vha01hcCgpOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVkZWNsYXJlXG5cbnZhciBFZGl0b3IgPSB7XG4gIC8qKlxyXG4gICAqIEdldCB0aGUgYW5jZXN0b3IgYWJvdmUgYSBsb2NhdGlvbiBpbiB0aGUgZG9jdW1lbnQuXHJcbiAgICovXG4gIGFib3ZlOiBmdW5jdGlvbiBhYm92ZShlZGl0b3IpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgdmFyIF9vcHRpb25zJHZvaWRzID0gb3B0aW9ucy52b2lkcyxcbiAgICAgICAgdm9pZHMgPSBfb3B0aW9ucyR2b2lkcyA9PT0gdm9pZCAwID8gZmFsc2UgOiBfb3B0aW9ucyR2b2lkcyxcbiAgICAgICAgX29wdGlvbnMkbW9kZSA9IG9wdGlvbnMubW9kZSxcbiAgICAgICAgbW9kZSA9IF9vcHRpb25zJG1vZGUgPT09IHZvaWQgMCA/ICdsb3dlc3QnIDogX29wdGlvbnMkbW9kZSxcbiAgICAgICAgX29wdGlvbnMkYXQgPSBvcHRpb25zLmF0LFxuICAgICAgICBhdCA9IF9vcHRpb25zJGF0ID09PSB2b2lkIDAgPyBlZGl0b3Iuc2VsZWN0aW9uIDogX29wdGlvbnMkYXQsXG4gICAgICAgIG1hdGNoID0gb3B0aW9ucy5tYXRjaDtcblxuICAgIGlmICghYXQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgcGF0aCA9IEVkaXRvci5wYXRoKGVkaXRvciwgYXQpO1xuICAgIHZhciByZXZlcnNlID0gbW9kZSA9PT0gJ2xvd2VzdCc7XG5cbiAgICB2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkNShFZGl0b3IubGV2ZWxzKGVkaXRvciwge1xuICAgICAgYXQ6IHBhdGgsXG4gICAgICB2b2lkczogdm9pZHMsXG4gICAgICBtYXRjaDogbWF0Y2gsXG4gICAgICByZXZlcnNlOiByZXZlcnNlXG4gICAgfSkpLFxuICAgICAgICBfc3RlcDtcblxuICAgIHRyeSB7XG4gICAgICBmb3IgKF9pdGVyYXRvci5zKCk7ICEoX3N0ZXAgPSBfaXRlcmF0b3IubigpKS5kb25lOykge1xuICAgICAgICB2YXIgX3N0ZXAkdmFsdWUgPSBfc2xpY2VkVG9BcnJheShfc3RlcC52YWx1ZSwgMiksXG4gICAgICAgICAgICBuID0gX3N0ZXAkdmFsdWVbMF0sXG4gICAgICAgICAgICBwID0gX3N0ZXAkdmFsdWVbMV07XG5cbiAgICAgICAgaWYgKFRleHQuaXNUZXh0KG4pKSBjb250aW51ZTtcblxuICAgICAgICBpZiAoUmFuZ2UuaXNSYW5nZShhdCkpIHtcbiAgICAgICAgICBpZiAoUGF0aC5pc0FuY2VzdG9yKHAsIGF0LmFuY2hvci5wYXRoKSAmJiBQYXRoLmlzQW5jZXN0b3IocCwgYXQuZm9jdXMucGF0aCkpIHtcbiAgICAgICAgICAgIHJldHVybiBbbiwgcF07XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICghUGF0aC5lcXVhbHMocGF0aCwgcCkpIHtcbiAgICAgICAgICAgIHJldHVybiBbbiwgcF07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBfaXRlcmF0b3IuZShlcnIpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBfaXRlcmF0b3IuZigpO1xuICAgIH1cbiAgfSxcblxuICAvKipcclxuICAgKiBBZGQgYSBjdXN0b20gcHJvcGVydHkgdG8gdGhlIGxlYWYgdGV4dCBub2RlcyBpbiB0aGUgY3VycmVudCBzZWxlY3Rpb24uXHJcbiAgICpcclxuICAgKiBJZiB0aGUgc2VsZWN0aW9uIGlzIGN1cnJlbnRseSBjb2xsYXBzZWQsIHRoZSBtYXJrcyB3aWxsIGJlIGFkZGVkIHRvIHRoZVxyXG4gICAqIGBlZGl0b3IubWFya3NgIHByb3BlcnR5IGluc3RlYWQsIGFuZCBhcHBsaWVkIHdoZW4gdGV4dCBpcyBpbnNlcnRlZCBuZXh0LlxyXG4gICAqL1xuICBhZGRNYXJrOiBmdW5jdGlvbiBhZGRNYXJrKGVkaXRvciwga2V5LCB2YWx1ZSkge1xuICAgIGVkaXRvci5hZGRNYXJrKGtleSwgdmFsdWUpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgcG9pbnQgYWZ0ZXIgYSBsb2NhdGlvbi5cclxuICAgKi9cbiAgYWZ0ZXI6IGZ1bmN0aW9uIGFmdGVyKGVkaXRvciwgYXQpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgdmFyIGFuY2hvciA9IEVkaXRvci5wb2ludChlZGl0b3IsIGF0LCB7XG4gICAgICBlZGdlOiAnZW5kJ1xuICAgIH0pO1xuICAgIHZhciBmb2N1cyA9IEVkaXRvci5lbmQoZWRpdG9yLCBbXSk7XG4gICAgdmFyIHJhbmdlID0ge1xuICAgICAgYW5jaG9yOiBhbmNob3IsXG4gICAgICBmb2N1czogZm9jdXNcbiAgICB9O1xuICAgIHZhciBfb3B0aW9ucyRkaXN0YW5jZSA9IG9wdGlvbnMuZGlzdGFuY2UsXG4gICAgICAgIGRpc3RhbmNlID0gX29wdGlvbnMkZGlzdGFuY2UgPT09IHZvaWQgMCA/IDEgOiBfb3B0aW9ucyRkaXN0YW5jZTtcbiAgICB2YXIgZCA9IDA7XG4gICAgdmFyIHRhcmdldDtcblxuICAgIHZhciBfaXRlcmF0b3IyID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkNShFZGl0b3IucG9zaXRpb25zKGVkaXRvciwgX29iamVjdFNwcmVhZCQ4KF9vYmplY3RTcHJlYWQkOCh7fSwgb3B0aW9ucyksIHt9LCB7XG4gICAgICBhdDogcmFuZ2VcbiAgICB9KSkpLFxuICAgICAgICBfc3RlcDI7XG5cbiAgICB0cnkge1xuICAgICAgZm9yIChfaXRlcmF0b3IyLnMoKTsgIShfc3RlcDIgPSBfaXRlcmF0b3IyLm4oKSkuZG9uZTspIHtcbiAgICAgICAgdmFyIHAgPSBfc3RlcDIudmFsdWU7XG5cbiAgICAgICAgaWYgKGQgPiBkaXN0YW5jZSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGQgIT09IDApIHtcbiAgICAgICAgICB0YXJnZXQgPSBwO1xuICAgICAgICB9XG5cbiAgICAgICAgZCsrO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgX2l0ZXJhdG9yMi5lKGVycik7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIF9pdGVyYXRvcjIuZigpO1xuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXQ7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogR2V0IHRoZSBwb2ludCBiZWZvcmUgYSBsb2NhdGlvbi5cclxuICAgKi9cbiAgYmVmb3JlOiBmdW5jdGlvbiBiZWZvcmUoZWRpdG9yLCBhdCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICB2YXIgYW5jaG9yID0gRWRpdG9yLnN0YXJ0KGVkaXRvciwgW10pO1xuICAgIHZhciBmb2N1cyA9IEVkaXRvci5wb2ludChlZGl0b3IsIGF0LCB7XG4gICAgICBlZGdlOiAnc3RhcnQnXG4gICAgfSk7XG4gICAgdmFyIHJhbmdlID0ge1xuICAgICAgYW5jaG9yOiBhbmNob3IsXG4gICAgICBmb2N1czogZm9jdXNcbiAgICB9O1xuICAgIHZhciBfb3B0aW9ucyRkaXN0YW5jZTIgPSBvcHRpb25zLmRpc3RhbmNlLFxuICAgICAgICBkaXN0YW5jZSA9IF9vcHRpb25zJGRpc3RhbmNlMiA9PT0gdm9pZCAwID8gMSA6IF9vcHRpb25zJGRpc3RhbmNlMjtcbiAgICB2YXIgZCA9IDA7XG4gICAgdmFyIHRhcmdldDtcblxuICAgIHZhciBfaXRlcmF0b3IzID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkNShFZGl0b3IucG9zaXRpb25zKGVkaXRvciwgX29iamVjdFNwcmVhZCQ4KF9vYmplY3RTcHJlYWQkOCh7fSwgb3B0aW9ucyksIHt9LCB7XG4gICAgICBhdDogcmFuZ2UsXG4gICAgICByZXZlcnNlOiB0cnVlXG4gICAgfSkpKSxcbiAgICAgICAgX3N0ZXAzO1xuXG4gICAgdHJ5IHtcbiAgICAgIGZvciAoX2l0ZXJhdG9yMy5zKCk7ICEoX3N0ZXAzID0gX2l0ZXJhdG9yMy5uKCkpLmRvbmU7KSB7XG4gICAgICAgIHZhciBwID0gX3N0ZXAzLnZhbHVlO1xuXG4gICAgICAgIGlmIChkID4gZGlzdGFuY2UpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkICE9PSAwKSB7XG4gICAgICAgICAgdGFyZ2V0ID0gcDtcbiAgICAgICAgfVxuXG4gICAgICAgIGQrKztcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIF9pdGVyYXRvcjMuZShlcnIpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBfaXRlcmF0b3IzLmYoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIERlbGV0ZSBjb250ZW50IGluIHRoZSBlZGl0b3IgYmFja3dhcmQgZnJvbSB0aGUgY3VycmVudCBzZWxlY3Rpb24uXHJcbiAgICovXG4gIGRlbGV0ZUJhY2t3YXJkOiBmdW5jdGlvbiBkZWxldGVCYWNrd2FyZChlZGl0b3IpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgdmFyIF9vcHRpb25zJHVuaXQgPSBvcHRpb25zLnVuaXQsXG4gICAgICAgIHVuaXQgPSBfb3B0aW9ucyR1bml0ID09PSB2b2lkIDAgPyAnY2hhcmFjdGVyJyA6IF9vcHRpb25zJHVuaXQ7XG4gICAgZWRpdG9yLmRlbGV0ZUJhY2t3YXJkKHVuaXQpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIERlbGV0ZSBjb250ZW50IGluIHRoZSBlZGl0b3IgZm9yd2FyZCBmcm9tIHRoZSBjdXJyZW50IHNlbGVjdGlvbi5cclxuICAgKi9cbiAgZGVsZXRlRm9yd2FyZDogZnVuY3Rpb24gZGVsZXRlRm9yd2FyZChlZGl0b3IpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgdmFyIF9vcHRpb25zJHVuaXQyID0gb3B0aW9ucy51bml0LFxuICAgICAgICB1bml0ID0gX29wdGlvbnMkdW5pdDIgPT09IHZvaWQgMCA/ICdjaGFyYWN0ZXInIDogX29wdGlvbnMkdW5pdDI7XG4gICAgZWRpdG9yLmRlbGV0ZUZvcndhcmQodW5pdCk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogRGVsZXRlIHRoZSBjb250ZW50IGluIHRoZSBjdXJyZW50IHNlbGVjdGlvbi5cclxuICAgKi9cbiAgZGVsZXRlRnJhZ21lbnQ6IGZ1bmN0aW9uIGRlbGV0ZUZyYWdtZW50KGVkaXRvcikge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICB2YXIgX29wdGlvbnMkZGlyZWN0aW9uID0gb3B0aW9ucy5kaXJlY3Rpb24sXG4gICAgICAgIGRpcmVjdGlvbiA9IF9vcHRpb25zJGRpcmVjdGlvbiA9PT0gdm9pZCAwID8gJ2ZvcndhcmQnIDogX29wdGlvbnMkZGlyZWN0aW9uO1xuICAgIGVkaXRvci5kZWxldGVGcmFnbWVudChkaXJlY3Rpb24pO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgc3RhcnQgYW5kIGVuZCBwb2ludHMgb2YgYSBsb2NhdGlvbi5cclxuICAgKi9cbiAgZWRnZXM6IGZ1bmN0aW9uIGVkZ2VzKGVkaXRvciwgYXQpIHtcbiAgICByZXR1cm4gW0VkaXRvci5zdGFydChlZGl0b3IsIGF0KSwgRWRpdG9yLmVuZChlZGl0b3IsIGF0KV07XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogR2V0IHRoZSBlbmQgcG9pbnQgb2YgYSBsb2NhdGlvbi5cclxuICAgKi9cbiAgZW5kOiBmdW5jdGlvbiBlbmQoZWRpdG9yLCBhdCkge1xuICAgIHJldHVybiBFZGl0b3IucG9pbnQoZWRpdG9yLCBhdCwge1xuICAgICAgZWRnZTogJ2VuZCdcbiAgICB9KTtcbiAgfSxcblxuICAvKipcclxuICAgKiBHZXQgdGhlIGZpcnN0IG5vZGUgYXQgYSBsb2NhdGlvbi5cclxuICAgKi9cbiAgZmlyc3Q6IGZ1bmN0aW9uIGZpcnN0KGVkaXRvciwgYXQpIHtcbiAgICB2YXIgcGF0aCA9IEVkaXRvci5wYXRoKGVkaXRvciwgYXQsIHtcbiAgICAgIGVkZ2U6ICdzdGFydCdcbiAgICB9KTtcbiAgICByZXR1cm4gRWRpdG9yLm5vZGUoZWRpdG9yLCBwYXRoKTtcbiAgfSxcblxuICAvKipcclxuICAgKiBHZXQgdGhlIGZyYWdtZW50IGF0IGEgbG9jYXRpb24uXHJcbiAgICovXG4gIGZyYWdtZW50OiBmdW5jdGlvbiBmcmFnbWVudChlZGl0b3IsIGF0KSB7XG4gICAgdmFyIHJhbmdlID0gRWRpdG9yLnJhbmdlKGVkaXRvciwgYXQpO1xuICAgIHZhciBmcmFnbWVudCA9IE5vZGUuZnJhZ21lbnQoZWRpdG9yLCByYW5nZSk7XG4gICAgcmV0dXJuIGZyYWdtZW50O1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgbm9kZSBoYXMgYmxvY2sgY2hpbGRyZW4uXHJcbiAgICovXG4gIGhhc0Jsb2NrczogZnVuY3Rpb24gaGFzQmxvY2tzKGVkaXRvciwgZWxlbWVudCkge1xuICAgIHJldHVybiBlbGVtZW50LmNoaWxkcmVuLnNvbWUoZnVuY3Rpb24gKG4pIHtcbiAgICAgIHJldHVybiBFbGVtZW50LmlzRWxlbWVudChuKSAmJiBFZGl0b3IuaXNCbG9jayhlZGl0b3IsIG4pO1xuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgbm9kZSBoYXMgaW5saW5lIGFuZCB0ZXh0IGNoaWxkcmVuLlxyXG4gICAqL1xuICBoYXNJbmxpbmVzOiBmdW5jdGlvbiBoYXNJbmxpbmVzKGVkaXRvciwgZWxlbWVudCkge1xuICAgIHJldHVybiBlbGVtZW50LmNoaWxkcmVuLnNvbWUoZnVuY3Rpb24gKG4pIHtcbiAgICAgIHJldHVybiBUZXh0LmlzVGV4dChuKSB8fCBFZGl0b3IuaXNJbmxpbmUoZWRpdG9yLCBuKTtcbiAgICB9KTtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhIG5vZGUgaGFzIHRleHQgY2hpbGRyZW4uXHJcbiAgICovXG4gIGhhc1RleHRzOiBmdW5jdGlvbiBoYXNUZXh0cyhlZGl0b3IsIGVsZW1lbnQpIHtcbiAgICByZXR1cm4gZWxlbWVudC5jaGlsZHJlbi5ldmVyeShmdW5jdGlvbiAobikge1xuICAgICAgcmV0dXJuIFRleHQuaXNUZXh0KG4pO1xuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEluc2VydCBhIGJsb2NrIGJyZWFrIGF0IHRoZSBjdXJyZW50IHNlbGVjdGlvbi5cclxuICAgKlxyXG4gICAqIElmIHRoZSBzZWxlY3Rpb24gaXMgY3VycmVudGx5IGV4cGFuZGVkLCBpdCB3aWxsIGJlIGRlbGV0ZWQgZmlyc3QuXHJcbiAgICovXG4gIGluc2VydEJyZWFrOiBmdW5jdGlvbiBpbnNlcnRCcmVhayhlZGl0b3IpIHtcbiAgICBlZGl0b3IuaW5zZXJ0QnJlYWsoKTtcbiAgfSxcblxuICAvKipcclxuICAgKiBJbnNlcnQgYSBzb2Z0IGJyZWFrIGF0IHRoZSBjdXJyZW50IHNlbGVjdGlvbi5cclxuICAgKlxyXG4gICAqIElmIHRoZSBzZWxlY3Rpb24gaXMgY3VycmVudGx5IGV4cGFuZGVkLCBpdCB3aWxsIGJlIGRlbGV0ZWQgZmlyc3QuXHJcbiAgICovXG4gIGluc2VydFNvZnRCcmVhazogZnVuY3Rpb24gaW5zZXJ0U29mdEJyZWFrKGVkaXRvcikge1xuICAgIGVkaXRvci5pbnNlcnRTb2Z0QnJlYWsoKTtcbiAgfSxcblxuICAvKipcclxuICAgKiBJbnNlcnQgYSBmcmFnbWVudCBhdCB0aGUgY3VycmVudCBzZWxlY3Rpb24uXHJcbiAgICpcclxuICAgKiBJZiB0aGUgc2VsZWN0aW9uIGlzIGN1cnJlbnRseSBleHBhbmRlZCwgaXQgd2lsbCBiZSBkZWxldGVkIGZpcnN0LlxyXG4gICAqL1xuICBpbnNlcnRGcmFnbWVudDogZnVuY3Rpb24gaW5zZXJ0RnJhZ21lbnQoZWRpdG9yLCBmcmFnbWVudCkge1xuICAgIGVkaXRvci5pbnNlcnRGcmFnbWVudChmcmFnbWVudCk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogSW5zZXJ0IGEgbm9kZSBhdCB0aGUgY3VycmVudCBzZWxlY3Rpb24uXHJcbiAgICpcclxuICAgKiBJZiB0aGUgc2VsZWN0aW9uIGlzIGN1cnJlbnRseSBleHBhbmRlZCwgaXQgd2lsbCBiZSBkZWxldGVkIGZpcnN0LlxyXG4gICAqL1xuICBpbnNlcnROb2RlOiBmdW5jdGlvbiBpbnNlcnROb2RlKGVkaXRvciwgbm9kZSkge1xuICAgIGVkaXRvci5pbnNlcnROb2RlKG5vZGUpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEluc2VydCB0ZXh0IGF0IHRoZSBjdXJyZW50IHNlbGVjdGlvbi5cclxuICAgKlxyXG4gICAqIElmIHRoZSBzZWxlY3Rpb24gaXMgY3VycmVudGx5IGV4cGFuZGVkLCBpdCB3aWxsIGJlIGRlbGV0ZWQgZmlyc3QuXHJcbiAgICovXG4gIGluc2VydFRleHQ6IGZ1bmN0aW9uIGluc2VydFRleHQoZWRpdG9yLCB0ZXh0KSB7XG4gICAgZWRpdG9yLmluc2VydFRleHQodGV4dCk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSB2YWx1ZSBpcyBhIGJsb2NrIGBFbGVtZW50YCBvYmplY3QuXHJcbiAgICovXG4gIGlzQmxvY2s6IGZ1bmN0aW9uIGlzQmxvY2soZWRpdG9yLCB2YWx1ZSkge1xuICAgIHJldHVybiAhZWRpdG9yLmlzSW5saW5lKHZhbHVlKTtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhIHZhbHVlIGlzIGFuIGBFZGl0b3JgIG9iamVjdC5cclxuICAgKi9cbiAgaXNFZGl0b3I6IGZ1bmN0aW9uIGlzRWRpdG9yKHZhbHVlKSB7XG4gICAgdmFyIGNhY2hlZElzRWRpdG9yID0gSVNfRURJVE9SX0NBQ0hFLmdldCh2YWx1ZSk7XG5cbiAgICBpZiAoY2FjaGVkSXNFZGl0b3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGNhY2hlZElzRWRpdG9yO1xuICAgIH1cblxuICAgIGlmICghaXNQbGFpbk9iamVjdC5pc1BsYWluT2JqZWN0KHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBpc0VkaXRvciA9IHR5cGVvZiB2YWx1ZS5hZGRNYXJrID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB2YWx1ZS5hcHBseSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdmFsdWUuZGVsZXRlQmFja3dhcmQgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlLmRlbGV0ZUZvcndhcmQgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlLmRlbGV0ZUZyYWdtZW50ID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB2YWx1ZS5pbnNlcnRCcmVhayA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdmFsdWUuaW5zZXJ0U29mdEJyZWFrID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB2YWx1ZS5pbnNlcnRGcmFnbWVudCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdmFsdWUuaW5zZXJ0Tm9kZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdmFsdWUuaW5zZXJ0VGV4dCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdmFsdWUuaXNJbmxpbmUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlLmlzVm9pZCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdmFsdWUubm9ybWFsaXplTm9kZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdmFsdWUub25DaGFuZ2UgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlLnJlbW92ZU1hcmsgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlLmdldERpcnR5UGF0aHMgPT09ICdmdW5jdGlvbicgJiYgKHZhbHVlLm1hcmtzID09PSBudWxsIHx8IGlzUGxhaW5PYmplY3QuaXNQbGFpbk9iamVjdCh2YWx1ZS5tYXJrcykpICYmICh2YWx1ZS5zZWxlY3Rpb24gPT09IG51bGwgfHwgUmFuZ2UuaXNSYW5nZSh2YWx1ZS5zZWxlY3Rpb24pKSAmJiBOb2RlLmlzTm9kZUxpc3QodmFsdWUuY2hpbGRyZW4pICYmIE9wZXJhdGlvbi5pc09wZXJhdGlvbkxpc3QodmFsdWUub3BlcmF0aW9ucyk7XG4gICAgSVNfRURJVE9SX0NBQ0hFLnNldCh2YWx1ZSwgaXNFZGl0b3IpO1xuICAgIHJldHVybiBpc0VkaXRvcjtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhIHBvaW50IGlzIHRoZSBlbmQgcG9pbnQgb2YgYSBsb2NhdGlvbi5cclxuICAgKi9cbiAgaXNFbmQ6IGZ1bmN0aW9uIGlzRW5kKGVkaXRvciwgcG9pbnQsIGF0KSB7XG4gICAgdmFyIGVuZCA9IEVkaXRvci5lbmQoZWRpdG9yLCBhdCk7XG4gICAgcmV0dXJuIFBvaW50LmVxdWFscyhwb2ludCwgZW5kKTtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhIHBvaW50IGlzIGFuIGVkZ2Ugb2YgYSBsb2NhdGlvbi5cclxuICAgKi9cbiAgaXNFZGdlOiBmdW5jdGlvbiBpc0VkZ2UoZWRpdG9yLCBwb2ludCwgYXQpIHtcbiAgICByZXR1cm4gRWRpdG9yLmlzU3RhcnQoZWRpdG9yLCBwb2ludCwgYXQpIHx8IEVkaXRvci5pc0VuZChlZGl0b3IsIHBvaW50LCBhdCk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYW4gZWxlbWVudCBpcyBlbXB0eSwgYWNjb3VudGluZyBmb3Igdm9pZCBub2Rlcy5cclxuICAgKi9cbiAgaXNFbXB0eTogZnVuY3Rpb24gaXNFbXB0eShlZGl0b3IsIGVsZW1lbnQpIHtcbiAgICB2YXIgY2hpbGRyZW4gPSBlbGVtZW50LmNoaWxkcmVuO1xuXG4gICAgdmFyIF9jaGlsZHJlbiA9IF9zbGljZWRUb0FycmF5KGNoaWxkcmVuLCAxKSxcbiAgICAgICAgZmlyc3QgPSBfY2hpbGRyZW5bMF07XG5cbiAgICByZXR1cm4gY2hpbGRyZW4ubGVuZ3RoID09PSAwIHx8IGNoaWxkcmVuLmxlbmd0aCA9PT0gMSAmJiBUZXh0LmlzVGV4dChmaXJzdCkgJiYgZmlyc3QudGV4dCA9PT0gJycgJiYgIWVkaXRvci5pc1ZvaWQoZWxlbWVudCk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSB2YWx1ZSBpcyBhbiBpbmxpbmUgYEVsZW1lbnRgIG9iamVjdC5cclxuICAgKi9cbiAgaXNJbmxpbmU6IGZ1bmN0aW9uIGlzSW5saW5lKGVkaXRvciwgdmFsdWUpIHtcbiAgICByZXR1cm4gZWRpdG9yLmlzSW5saW5lKHZhbHVlKTtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiB0aGUgZWRpdG9yIGlzIGN1cnJlbnRseSBub3JtYWxpemluZyBhZnRlciBlYWNoIG9wZXJhdGlvbi5cclxuICAgKi9cbiAgaXNOb3JtYWxpemluZzogZnVuY3Rpb24gaXNOb3JtYWxpemluZyhlZGl0b3IpIHtcbiAgICB2YXIgaXNOb3JtYWxpemluZyA9IE5PUk1BTElaSU5HLmdldChlZGl0b3IpO1xuICAgIHJldHVybiBpc05vcm1hbGl6aW5nID09PSB1bmRlZmluZWQgPyB0cnVlIDogaXNOb3JtYWxpemluZztcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhIHBvaW50IGlzIHRoZSBzdGFydCBwb2ludCBvZiBhIGxvY2F0aW9uLlxyXG4gICAqL1xuICBpc1N0YXJ0OiBmdW5jdGlvbiBpc1N0YXJ0KGVkaXRvciwgcG9pbnQsIGF0KSB7XG4gICAgLy8gUEVSRjogSWYgdGhlIG9mZnNldCBpc24ndCBgMGAgd2Uga25vdyBpdCdzIG5vdCB0aGUgc3RhcnQuXG4gICAgaWYgKHBvaW50Lm9mZnNldCAhPT0gMCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBzdGFydCA9IEVkaXRvci5zdGFydChlZGl0b3IsIGF0KTtcbiAgICByZXR1cm4gUG9pbnQuZXF1YWxzKHBvaW50LCBzdGFydCk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSB2YWx1ZSBpcyBhIHZvaWQgYEVsZW1lbnRgIG9iamVjdC5cclxuICAgKi9cbiAgaXNWb2lkOiBmdW5jdGlvbiBpc1ZvaWQoZWRpdG9yLCB2YWx1ZSkge1xuICAgIHJldHVybiBlZGl0b3IuaXNWb2lkKHZhbHVlKTtcbiAgfSxcblxuICAvKipcclxuICAgKiBHZXQgdGhlIGxhc3Qgbm9kZSBhdCBhIGxvY2F0aW9uLlxyXG4gICAqL1xuICBsYXN0OiBmdW5jdGlvbiBsYXN0KGVkaXRvciwgYXQpIHtcbiAgICB2YXIgcGF0aCA9IEVkaXRvci5wYXRoKGVkaXRvciwgYXQsIHtcbiAgICAgIGVkZ2U6ICdlbmQnXG4gICAgfSk7XG4gICAgcmV0dXJuIEVkaXRvci5ub2RlKGVkaXRvciwgcGF0aCk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogR2V0IHRoZSBsZWFmIHRleHQgbm9kZSBhdCBhIGxvY2F0aW9uLlxyXG4gICAqL1xuICBsZWFmOiBmdW5jdGlvbiBsZWFmKGVkaXRvciwgYXQpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgdmFyIHBhdGggPSBFZGl0b3IucGF0aChlZGl0b3IsIGF0LCBvcHRpb25zKTtcbiAgICB2YXIgbm9kZSA9IE5vZGUubGVhZihlZGl0b3IsIHBhdGgpO1xuICAgIHJldHVybiBbbm9kZSwgcGF0aF07XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogSXRlcmF0ZSB0aHJvdWdoIGFsbCBvZiB0aGUgbGV2ZWxzIGF0IGEgbG9jYXRpb24uXHJcbiAgICovXG4gIGxldmVsczogZnVuY3Rpb24qIGxldmVscyhlZGl0b3IpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgdmFyIF9vcHRpb25zJGF0MiA9IG9wdGlvbnMuYXQsXG4gICAgICAgIGF0ID0gX29wdGlvbnMkYXQyID09PSB2b2lkIDAgPyBlZGl0b3Iuc2VsZWN0aW9uIDogX29wdGlvbnMkYXQyLFxuICAgICAgICBfb3B0aW9ucyRyZXZlcnNlID0gb3B0aW9ucy5yZXZlcnNlLFxuICAgICAgICByZXZlcnNlID0gX29wdGlvbnMkcmV2ZXJzZSA9PT0gdm9pZCAwID8gZmFsc2UgOiBfb3B0aW9ucyRyZXZlcnNlLFxuICAgICAgICBfb3B0aW9ucyR2b2lkczIgPSBvcHRpb25zLnZvaWRzLFxuICAgICAgICB2b2lkcyA9IF9vcHRpb25zJHZvaWRzMiA9PT0gdm9pZCAwID8gZmFsc2UgOiBfb3B0aW9ucyR2b2lkczI7XG4gICAgdmFyIG1hdGNoID0gb3B0aW9ucy5tYXRjaDtcblxuICAgIGlmIChtYXRjaCA9PSBudWxsKSB7XG4gICAgICBtYXRjaCA9IGZ1bmN0aW9uIG1hdGNoKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKCFhdCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBsZXZlbHMgPSBbXTtcbiAgICB2YXIgcGF0aCA9IEVkaXRvci5wYXRoKGVkaXRvciwgYXQpO1xuXG4gICAgdmFyIF9pdGVyYXRvcjQgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciQ1KE5vZGUubGV2ZWxzKGVkaXRvciwgcGF0aCkpLFxuICAgICAgICBfc3RlcDQ7XG5cbiAgICB0cnkge1xuICAgICAgZm9yIChfaXRlcmF0b3I0LnMoKTsgIShfc3RlcDQgPSBfaXRlcmF0b3I0Lm4oKSkuZG9uZTspIHtcbiAgICAgICAgdmFyIF9zdGVwNCR2YWx1ZSA9IF9zbGljZWRUb0FycmF5KF9zdGVwNC52YWx1ZSwgMiksXG4gICAgICAgICAgICBuID0gX3N0ZXA0JHZhbHVlWzBdLFxuICAgICAgICAgICAgcCA9IF9zdGVwNCR2YWx1ZVsxXTtcblxuICAgICAgICBpZiAoIW1hdGNoKG4sIHApKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBsZXZlbHMucHVzaChbbiwgcF0pO1xuXG4gICAgICAgIGlmICghdm9pZHMgJiYgRWxlbWVudC5pc0VsZW1lbnQobikgJiYgRWRpdG9yLmlzVm9pZChlZGl0b3IsIG4pKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIF9pdGVyYXRvcjQuZShlcnIpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBfaXRlcmF0b3I0LmYoKTtcbiAgICB9XG5cbiAgICBpZiAocmV2ZXJzZSkge1xuICAgICAgbGV2ZWxzLnJldmVyc2UoKTtcbiAgICB9XG5cbiAgICB5aWVsZCogbGV2ZWxzO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgbWFya3MgdGhhdCB3b3VsZCBiZSBhZGRlZCB0byB0ZXh0IGF0IHRoZSBjdXJyZW50IHNlbGVjdGlvbi5cclxuICAgKi9cbiAgbWFya3M6IGZ1bmN0aW9uIG1hcmtzKGVkaXRvcikge1xuICAgIHZhciBtYXJrcyA9IGVkaXRvci5tYXJrcyxcbiAgICAgICAgc2VsZWN0aW9uID0gZWRpdG9yLnNlbGVjdGlvbjtcblxuICAgIGlmICghc2VsZWN0aW9uKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAobWFya3MpIHtcbiAgICAgIHJldHVybiBtYXJrcztcbiAgICB9XG5cbiAgICBpZiAoUmFuZ2UuaXNFeHBhbmRlZChzZWxlY3Rpb24pKSB7XG4gICAgICB2YXIgX0VkaXRvciRub2RlcyA9IEVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICAgICAgbWF0Y2g6IFRleHQuaXNUZXh0XG4gICAgICB9KSxcbiAgICAgICAgICBfRWRpdG9yJG5vZGVzMiA9IF9zbGljZWRUb0FycmF5KF9FZGl0b3Ikbm9kZXMsIDEpLFxuICAgICAgICAgIG1hdGNoID0gX0VkaXRvciRub2RlczJbMF07XG5cbiAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICB2YXIgX21hdGNoID0gX3NsaWNlZFRvQXJyYXkobWF0Y2gsIDEpLFxuICAgICAgICAgICAgX25vZGUgPSBfbWF0Y2hbMF07XG5cbiAgICAgICAgX25vZGUudGV4dDtcbiAgICAgICAgICAgIHZhciBfcmVzdCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfbm9kZSwgX2V4Y2x1ZGVkJDQpO1xuXG4gICAgICAgIHJldHVybiBfcmVzdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgYW5jaG9yID0gc2VsZWN0aW9uLmFuY2hvcjtcbiAgICB2YXIgcGF0aCA9IGFuY2hvci5wYXRoO1xuXG4gICAgdmFyIF9FZGl0b3IkbGVhZiA9IEVkaXRvci5sZWFmKGVkaXRvciwgcGF0aCksXG4gICAgICAgIF9FZGl0b3IkbGVhZjIgPSBfc2xpY2VkVG9BcnJheShfRWRpdG9yJGxlYWYsIDEpLFxuICAgICAgICBub2RlID0gX0VkaXRvciRsZWFmMlswXTtcblxuICAgIGlmIChhbmNob3Iub2Zmc2V0ID09PSAwKSB7XG4gICAgICB2YXIgcHJldiA9IEVkaXRvci5wcmV2aW91cyhlZGl0b3IsIHtcbiAgICAgICAgYXQ6IHBhdGgsXG4gICAgICAgIG1hdGNoOiBUZXh0LmlzVGV4dFxuICAgICAgfSk7XG4gICAgICB2YXIgbWFya2VkVm9pZCA9IEVkaXRvci5hYm92ZShlZGl0b3IsIHtcbiAgICAgICAgbWF0Y2g6IGZ1bmN0aW9uIG1hdGNoKG4pIHtcbiAgICAgICAgICByZXR1cm4gRWxlbWVudC5pc0VsZW1lbnQobikgJiYgRWRpdG9yLmlzVm9pZChlZGl0b3IsIG4pICYmIGVkaXRvci5tYXJrYWJsZVZvaWQobik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBpZiAoIW1hcmtlZFZvaWQpIHtcbiAgICAgICAgdmFyIGJsb2NrID0gRWRpdG9yLmFib3ZlKGVkaXRvciwge1xuICAgICAgICAgIG1hdGNoOiBmdW5jdGlvbiBtYXRjaChuKSB7XG4gICAgICAgICAgICByZXR1cm4gRWxlbWVudC5pc0VsZW1lbnQobikgJiYgRWRpdG9yLmlzQmxvY2soZWRpdG9yLCBuKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChwcmV2ICYmIGJsb2NrKSB7XG4gICAgICAgICAgdmFyIF9wcmV2ID0gX3NsaWNlZFRvQXJyYXkocHJldiwgMiksXG4gICAgICAgICAgICAgIHByZXZOb2RlID0gX3ByZXZbMF0sXG4gICAgICAgICAgICAgIHByZXZQYXRoID0gX3ByZXZbMV07XG5cbiAgICAgICAgICB2YXIgX2Jsb2NrID0gX3NsaWNlZFRvQXJyYXkoYmxvY2ssIDIpLFxuICAgICAgICAgICAgICBibG9ja1BhdGggPSBfYmxvY2tbMV07XG5cbiAgICAgICAgICBpZiAoUGF0aC5pc0FuY2VzdG9yKGJsb2NrUGF0aCwgcHJldlBhdGgpKSB7XG4gICAgICAgICAgICBub2RlID0gcHJldk5vZGU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIF9ub2RlMiA9IG5vZGU7XG4gICAgICAgIF9ub2RlMi50ZXh0O1xuICAgICAgICB2YXIgcmVzdCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfbm9kZTIsIF9leGNsdWRlZDIkMyk7XG5cbiAgICByZXR1cm4gcmVzdDtcbiAgfSxcblxuICAvKipcclxuICAgKiBHZXQgdGhlIG1hdGNoaW5nIG5vZGUgaW4gdGhlIGJyYW5jaCBvZiB0aGUgZG9jdW1lbnQgYWZ0ZXIgYSBsb2NhdGlvbi5cclxuICAgKi9cbiAgbmV4dDogZnVuY3Rpb24gbmV4dChlZGl0b3IpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgdmFyIF9vcHRpb25zJG1vZGUyID0gb3B0aW9ucy5tb2RlLFxuICAgICAgICBtb2RlID0gX29wdGlvbnMkbW9kZTIgPT09IHZvaWQgMCA/ICdsb3dlc3QnIDogX29wdGlvbnMkbW9kZTIsXG4gICAgICAgIF9vcHRpb25zJHZvaWRzMyA9IG9wdGlvbnMudm9pZHMsXG4gICAgICAgIHZvaWRzID0gX29wdGlvbnMkdm9pZHMzID09PSB2b2lkIDAgPyBmYWxzZSA6IF9vcHRpb25zJHZvaWRzMztcbiAgICB2YXIgbWF0Y2ggPSBvcHRpb25zLm1hdGNoLFxuICAgICAgICBfb3B0aW9ucyRhdDMgPSBvcHRpb25zLmF0LFxuICAgICAgICBhdCA9IF9vcHRpb25zJGF0MyA9PT0gdm9pZCAwID8gZWRpdG9yLnNlbGVjdGlvbiA6IF9vcHRpb25zJGF0MztcblxuICAgIGlmICghYXQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgcG9pbnRBZnRlckxvY2F0aW9uID0gRWRpdG9yLmFmdGVyKGVkaXRvciwgYXQsIHtcbiAgICAgIHZvaWRzOiB2b2lkc1xuICAgIH0pO1xuICAgIGlmICghcG9pbnRBZnRlckxvY2F0aW9uKSByZXR1cm47XG5cbiAgICB2YXIgX0VkaXRvciRsYXN0ID0gRWRpdG9yLmxhc3QoZWRpdG9yLCBbXSksXG4gICAgICAgIF9FZGl0b3IkbGFzdDIgPSBfc2xpY2VkVG9BcnJheShfRWRpdG9yJGxhc3QsIDIpLFxuICAgICAgICB0byA9IF9FZGl0b3IkbGFzdDJbMV07XG5cbiAgICB2YXIgc3BhbiA9IFtwb2ludEFmdGVyTG9jYXRpb24ucGF0aCwgdG9dO1xuXG4gICAgaWYgKFBhdGguaXNQYXRoKGF0KSAmJiBhdC5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBnZXQgdGhlIG5leHQgbm9kZSBmcm9tIHRoZSByb290IG5vZGUhXCIpO1xuICAgIH1cblxuICAgIGlmIChtYXRjaCA9PSBudWxsKSB7XG4gICAgICBpZiAoUGF0aC5pc1BhdGgoYXQpKSB7XG4gICAgICAgIHZhciBfRWRpdG9yJHBhcmVudCA9IEVkaXRvci5wYXJlbnQoZWRpdG9yLCBhdCksXG4gICAgICAgICAgICBfRWRpdG9yJHBhcmVudDIgPSBfc2xpY2VkVG9BcnJheShfRWRpdG9yJHBhcmVudCwgMSksXG4gICAgICAgICAgICBwYXJlbnQgPSBfRWRpdG9yJHBhcmVudDJbMF07XG5cbiAgICAgICAgbWF0Y2ggPSBmdW5jdGlvbiBtYXRjaChuKSB7XG4gICAgICAgICAgcmV0dXJuIHBhcmVudC5jaGlsZHJlbi5pbmNsdWRlcyhuKTtcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1hdGNoID0gZnVuY3Rpb24gbWF0Y2goKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIF9FZGl0b3Ikbm9kZXMzID0gRWRpdG9yLm5vZGVzKGVkaXRvciwge1xuICAgICAgYXQ6IHNwYW4sXG4gICAgICBtYXRjaDogbWF0Y2gsXG4gICAgICBtb2RlOiBtb2RlLFxuICAgICAgdm9pZHM6IHZvaWRzXG4gICAgfSksXG4gICAgICAgIF9FZGl0b3Ikbm9kZXM0ID0gX3NsaWNlZFRvQXJyYXkoX0VkaXRvciRub2RlczMsIDEpLFxuICAgICAgICBuZXh0ID0gX0VkaXRvciRub2RlczRbMF07XG5cbiAgICByZXR1cm4gbmV4dDtcbiAgfSxcblxuICAvKipcclxuICAgKiBHZXQgdGhlIG5vZGUgYXQgYSBsb2NhdGlvbi5cclxuICAgKi9cbiAgbm9kZTogZnVuY3Rpb24gbm9kZShlZGl0b3IsIGF0KSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIHZhciBwYXRoID0gRWRpdG9yLnBhdGgoZWRpdG9yLCBhdCwgb3B0aW9ucyk7XG4gICAgdmFyIG5vZGUgPSBOb2RlLmdldChlZGl0b3IsIHBhdGgpO1xuICAgIHJldHVybiBbbm9kZSwgcGF0aF07XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogSXRlcmF0ZSB0aHJvdWdoIGFsbCBvZiB0aGUgbm9kZXMgaW4gdGhlIEVkaXRvci5cclxuICAgKi9cbiAgbm9kZXM6IGZ1bmN0aW9uKiBub2RlcyhlZGl0b3IpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgdmFyIF9vcHRpb25zJGF0NCA9IG9wdGlvbnMuYXQsXG4gICAgICAgIGF0ID0gX29wdGlvbnMkYXQ0ID09PSB2b2lkIDAgPyBlZGl0b3Iuc2VsZWN0aW9uIDogX29wdGlvbnMkYXQ0LFxuICAgICAgICBfb3B0aW9ucyRtb2RlMyA9IG9wdGlvbnMubW9kZSxcbiAgICAgICAgbW9kZSA9IF9vcHRpb25zJG1vZGUzID09PSB2b2lkIDAgPyAnYWxsJyA6IF9vcHRpb25zJG1vZGUzLFxuICAgICAgICBfb3B0aW9ucyR1bml2ZXJzYWwgPSBvcHRpb25zLnVuaXZlcnNhbCxcbiAgICAgICAgdW5pdmVyc2FsID0gX29wdGlvbnMkdW5pdmVyc2FsID09PSB2b2lkIDAgPyBmYWxzZSA6IF9vcHRpb25zJHVuaXZlcnNhbCxcbiAgICAgICAgX29wdGlvbnMkcmV2ZXJzZTIgPSBvcHRpb25zLnJldmVyc2UsXG4gICAgICAgIHJldmVyc2UgPSBfb3B0aW9ucyRyZXZlcnNlMiA9PT0gdm9pZCAwID8gZmFsc2UgOiBfb3B0aW9ucyRyZXZlcnNlMixcbiAgICAgICAgX29wdGlvbnMkdm9pZHM0ID0gb3B0aW9ucy52b2lkcyxcbiAgICAgICAgdm9pZHMgPSBfb3B0aW9ucyR2b2lkczQgPT09IHZvaWQgMCA/IGZhbHNlIDogX29wdGlvbnMkdm9pZHM0O1xuICAgIHZhciBtYXRjaCA9IG9wdGlvbnMubWF0Y2g7XG5cbiAgICBpZiAoIW1hdGNoKSB7XG4gICAgICBtYXRjaCA9IGZ1bmN0aW9uIG1hdGNoKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKCFhdCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBmcm9tO1xuICAgIHZhciB0bztcblxuICAgIGlmIChTcGFuLmlzU3BhbihhdCkpIHtcbiAgICAgIGZyb20gPSBhdFswXTtcbiAgICAgIHRvID0gYXRbMV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBmaXJzdCA9IEVkaXRvci5wYXRoKGVkaXRvciwgYXQsIHtcbiAgICAgICAgZWRnZTogJ3N0YXJ0J1xuICAgICAgfSk7XG4gICAgICB2YXIgbGFzdCA9IEVkaXRvci5wYXRoKGVkaXRvciwgYXQsIHtcbiAgICAgICAgZWRnZTogJ2VuZCdcbiAgICAgIH0pO1xuICAgICAgZnJvbSA9IHJldmVyc2UgPyBsYXN0IDogZmlyc3Q7XG4gICAgICB0byA9IHJldmVyc2UgPyBmaXJzdCA6IGxhc3Q7XG4gICAgfVxuXG4gICAgdmFyIG5vZGVFbnRyaWVzID0gTm9kZS5ub2RlcyhlZGl0b3IsIHtcbiAgICAgIHJldmVyc2U6IHJldmVyc2UsXG4gICAgICBmcm9tOiBmcm9tLFxuICAgICAgdG86IHRvLFxuICAgICAgcGFzczogZnVuY3Rpb24gcGFzcyhfcmVmKSB7XG4gICAgICAgIHZhciBfcmVmMiA9IF9zbGljZWRUb0FycmF5KF9yZWYsIDEpLFxuICAgICAgICAgICAgbiA9IF9yZWYyWzBdO1xuXG4gICAgICAgIHJldHVybiB2b2lkcyA/IGZhbHNlIDogRWxlbWVudC5pc0VsZW1lbnQobikgJiYgRWRpdG9yLmlzVm9pZChlZGl0b3IsIG4pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHZhciBtYXRjaGVzID0gW107XG4gICAgdmFyIGhpdDtcblxuICAgIHZhciBfaXRlcmF0b3I1ID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkNShub2RlRW50cmllcyksXG4gICAgICAgIF9zdGVwNTtcblxuICAgIHRyeSB7XG4gICAgICBmb3IgKF9pdGVyYXRvcjUucygpOyAhKF9zdGVwNSA9IF9pdGVyYXRvcjUubigpKS5kb25lOykge1xuICAgICAgICB2YXIgX3N0ZXA1JHZhbHVlID0gX3NsaWNlZFRvQXJyYXkoX3N0ZXA1LnZhbHVlLCAyKSxcbiAgICAgICAgICAgIG5vZGUgPSBfc3RlcDUkdmFsdWVbMF0sXG4gICAgICAgICAgICBwYXRoID0gX3N0ZXA1JHZhbHVlWzFdO1xuXG4gICAgICAgIHZhciBpc0xvd2VyID0gaGl0ICYmIFBhdGguY29tcGFyZShwYXRoLCBoaXRbMV0pID09PSAwOyAvLyBJbiBoaWdoZXN0IG1vZGUgYW55IG5vZGUgbG93ZXIgdGhhbiB0aGUgbGFzdCBoaXQgaXMgbm90IGEgbWF0Y2guXG5cbiAgICAgICAgaWYgKG1vZGUgPT09ICdoaWdoZXN0JyAmJiBpc0xvd2VyKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIW1hdGNoKG5vZGUsIHBhdGgpKSB7XG4gICAgICAgICAgLy8gSWYgd2UndmUgYXJyaXZlZCBhdCBhIGxlYWYgdGV4dCBub2RlIHRoYXQgaXMgbm90IGxvd2VyIHRoYW4gdGhlIGxhc3RcbiAgICAgICAgICAvLyBoaXQsIHRoZW4gd2UndmUgZm91bmQgYSBicmFuY2ggdGhhdCBkb2Vzbid0IGluY2x1ZGUgYSBtYXRjaCwgd2hpY2hcbiAgICAgICAgICAvLyBtZWFucyB0aGUgbWF0Y2ggaXMgbm90IHVuaXZlcnNhbC5cbiAgICAgICAgICBpZiAodW5pdmVyc2FsICYmICFpc0xvd2VyICYmIFRleHQuaXNUZXh0KG5vZGUpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBJZiB0aGVyZSdzIGEgbWF0Y2ggYW5kIGl0J3MgbG93ZXIgdGhhbiB0aGUgbGFzdCwgdXBkYXRlIHRoZSBoaXQuXG5cblxuICAgICAgICBpZiAobW9kZSA9PT0gJ2xvd2VzdCcgJiYgaXNMb3dlcikge1xuICAgICAgICAgIGhpdCA9IFtub2RlLCBwYXRoXTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSAvLyBJbiBsb3dlc3QgbW9kZSB3ZSBlbWl0IHRoZSBsYXN0IGhpdCwgb25jZSBpdCdzIGd1YXJhbnRlZWQgbG93ZXN0LlxuXG5cbiAgICAgICAgdmFyIGVtaXQgPSBtb2RlID09PSAnbG93ZXN0JyA/IGhpdCA6IFtub2RlLCBwYXRoXTtcblxuICAgICAgICBpZiAoZW1pdCkge1xuICAgICAgICAgIGlmICh1bml2ZXJzYWwpIHtcbiAgICAgICAgICAgIG1hdGNoZXMucHVzaChlbWl0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgeWllbGQgZW1pdDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBoaXQgPSBbbm9kZSwgcGF0aF07XG4gICAgICB9IC8vIFNpbmNlIGxvd2VzdCBpcyBhbHdheXMgZW1pdHRpbmcgb25lIGJlaGluZCwgY2F0Y2ggdXAgYXQgdGhlIGVuZC5cblxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgX2l0ZXJhdG9yNS5lKGVycik7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIF9pdGVyYXRvcjUuZigpO1xuICAgIH1cblxuICAgIGlmIChtb2RlID09PSAnbG93ZXN0JyAmJiBoaXQpIHtcbiAgICAgIGlmICh1bml2ZXJzYWwpIHtcbiAgICAgICAgbWF0Y2hlcy5wdXNoKGhpdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB5aWVsZCBoaXQ7XG4gICAgICB9XG4gICAgfSAvLyBVbml2ZXJzYWwgZGVmZXJzIHRvIGVuc3VyZSB0aGF0IHRoZSBtYXRjaCBvY2N1cnMgaW4gZXZlcnkgYnJhbmNoLCBzbyB3ZVxuICAgIC8vIHlpZWxkIGFsbCBvZiB0aGUgbWF0Y2hlcyBhZnRlciBpdGVyYXRpbmcuXG5cblxuICAgIGlmICh1bml2ZXJzYWwpIHtcbiAgICAgIHlpZWxkKiBtYXRjaGVzO1xuICAgIH1cbiAgfSxcblxuICAvKipcclxuICAgKiBOb3JtYWxpemUgYW55IGRpcnR5IG9iamVjdHMgaW4gdGhlIGVkaXRvci5cclxuICAgKi9cbiAgbm9ybWFsaXplOiBmdW5jdGlvbiBub3JtYWxpemUoZWRpdG9yKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIHZhciBfb3B0aW9ucyRmb3JjZSA9IG9wdGlvbnMuZm9yY2UsXG4gICAgICAgIGZvcmNlID0gX29wdGlvbnMkZm9yY2UgPT09IHZvaWQgMCA/IGZhbHNlIDogX29wdGlvbnMkZm9yY2UsXG4gICAgICAgIG9wZXJhdGlvbiA9IG9wdGlvbnMub3BlcmF0aW9uO1xuXG4gICAgdmFyIGdldERpcnR5UGF0aHMgPSBmdW5jdGlvbiBnZXREaXJ0eVBhdGhzKGVkaXRvcikge1xuICAgICAgcmV0dXJuIERJUlRZX1BBVEhTLmdldChlZGl0b3IpIHx8IFtdO1xuICAgIH07XG5cbiAgICB2YXIgZ2V0RGlydHlQYXRoS2V5cyA9IGZ1bmN0aW9uIGdldERpcnR5UGF0aEtleXMoZWRpdG9yKSB7XG4gICAgICByZXR1cm4gRElSVFlfUEFUSF9LRVlTLmdldChlZGl0b3IpIHx8IG5ldyBTZXQoKTtcbiAgICB9O1xuXG4gICAgdmFyIHBvcERpcnR5UGF0aCA9IGZ1bmN0aW9uIHBvcERpcnR5UGF0aChlZGl0b3IpIHtcbiAgICAgIHZhciBwYXRoID0gZ2V0RGlydHlQYXRocyhlZGl0b3IpLnBvcCgpO1xuICAgICAgdmFyIGtleSA9IHBhdGguam9pbignLCcpO1xuICAgICAgZ2V0RGlydHlQYXRoS2V5cyhlZGl0b3IpW1wiZGVsZXRlXCJdKGtleSk7XG4gICAgICByZXR1cm4gcGF0aDtcbiAgICB9O1xuXG4gICAgaWYgKCFFZGl0b3IuaXNOb3JtYWxpemluZyhlZGl0b3IpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGZvcmNlKSB7XG4gICAgICB2YXIgYWxsUGF0aHMgPSBBcnJheS5mcm9tKE5vZGUubm9kZXMoZWRpdG9yKSwgZnVuY3Rpb24gKF9yZWYzKSB7XG4gICAgICAgIHZhciBfcmVmNCA9IF9zbGljZWRUb0FycmF5KF9yZWYzLCAyKSxcbiAgICAgICAgICAgIHAgPSBfcmVmNFsxXTtcblxuICAgICAgICByZXR1cm4gcDtcbiAgICAgIH0pO1xuICAgICAgdmFyIGFsbFBhdGhLZXlzID0gbmV3IFNldChhbGxQYXRocy5tYXAoZnVuY3Rpb24gKHApIHtcbiAgICAgICAgcmV0dXJuIHAuam9pbignLCcpO1xuICAgICAgfSkpO1xuICAgICAgRElSVFlfUEFUSFMuc2V0KGVkaXRvciwgYWxsUGF0aHMpO1xuICAgICAgRElSVFlfUEFUSF9LRVlTLnNldChlZGl0b3IsIGFsbFBhdGhLZXlzKTtcbiAgICB9XG5cbiAgICBpZiAoZ2V0RGlydHlQYXRocyhlZGl0b3IpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIEVkaXRvci53aXRob3V0Tm9ybWFsaXppbmcoZWRpdG9yLCBmdW5jdGlvbiAoKSB7XG4gICAgICAvKlxyXG4gICAgICAgIEZpeCBkaXJ0eSBlbGVtZW50cyB3aXRoIG5vIGNoaWxkcmVuLlxyXG4gICAgICAgIGVkaXRvci5ub3JtYWxpemVOb2RlKCkgZG9lcyBmaXggdGhpcywgYnV0IHNvbWUgbm9ybWFsaXphdGlvbiBmaXhlcyBhbHNvIHJlcXVpcmUgaXQgdG8gd29yay5cclxuICAgICAgICBSdW5uaW5nIGFuIGluaXRpYWwgcGFzcyBhdm9pZHMgdGhlIGNhdGNoLTIyIHJhY2UgY29uZGl0aW9uLlxyXG4gICAgICAqL1xuICAgICAgdmFyIF9pdGVyYXRvcjYgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciQ1KGdldERpcnR5UGF0aHMoZWRpdG9yKSksXG4gICAgICAgICAgX3N0ZXA2O1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKF9pdGVyYXRvcjYucygpOyAhKF9zdGVwNiA9IF9pdGVyYXRvcjYubigpKS5kb25lOykge1xuICAgICAgICAgIHZhciBfZGlydHlQYXRoID0gX3N0ZXA2LnZhbHVlO1xuXG4gICAgICAgICAgaWYgKE5vZGUuaGFzKGVkaXRvciwgX2RpcnR5UGF0aCkpIHtcbiAgICAgICAgICAgIHZhciBfZW50cnkgPSBFZGl0b3Iubm9kZShlZGl0b3IsIF9kaXJ0eVBhdGgpO1xuXG4gICAgICAgICAgICB2YXIgX2VudHJ5MiA9IF9zbGljZWRUb0FycmF5KF9lbnRyeSwgMiksXG4gICAgICAgICAgICAgICAgbm9kZSA9IF9lbnRyeTJbMF0sXG4gICAgICAgICAgICAgICAgXyA9IF9lbnRyeTJbMV07XG4gICAgICAgICAgICAvKlxyXG4gICAgICAgICAgICAgIFRoZSBkZWZhdWx0IG5vcm1hbGl6ZXIgaW5zZXJ0cyBhbiBlbXB0eSB0ZXh0IG5vZGUgaW4gdGhpcyBzY2VuYXJpbywgYnV0IGl0IGNhbiBiZSBjdXN0b21pc2VkLlxyXG4gICAgICAgICAgICAgIFNvIHRoZXJlIGlzIHNvbWUgcmlzayBoZXJlLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgQXMgbG9uZyBhcyB0aGUgbm9ybWFsaXplciBvbmx5IGluc2VydHMgY2hpbGQgbm9kZXMgZm9yIHRoaXMgY2FzZSBpdCBpcyBzYWZlIHRvIGRvIGluIGFueSBvcmRlcjtcclxuICAgICAgICAgICAgICBieSBkZWZpbml0aW9uIGFkZGluZyBjaGlsZHJlbiB0byBhbiBlbXB0eSBub2RlIGNhbid0IGNhdXNlIG90aGVyIHBhdGhzIHRvIGNoYW5nZS5cclxuICAgICAgICAgICAgKi9cblxuXG4gICAgICAgICAgICBpZiAoRWxlbWVudC5pc0VsZW1lbnQobm9kZSkgJiYgbm9kZS5jaGlsZHJlbi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgZWRpdG9yLm5vcm1hbGl6ZU5vZGUoX2VudHJ5LCB7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBvcGVyYXRpb25cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2l0ZXJhdG9yNi5lKGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBfaXRlcmF0b3I2LmYoKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGRpcnR5UGF0aHMgPSBnZXREaXJ0eVBhdGhzKGVkaXRvcik7XG4gICAgICB2YXIgaW5pdGlhbERpcnR5UGF0aHNMZW5ndGggPSBkaXJ0eVBhdGhzLmxlbmd0aDtcbiAgICAgIHZhciBpdGVyYXRpb24gPSAwO1xuXG4gICAgICB3aGlsZSAoZGlydHlQYXRocy5sZW5ndGggIT09IDApIHtcbiAgICAgICAgaWYgKCFlZGl0b3Iuc2hvdWxkTm9ybWFsaXplKHtcbiAgICAgICAgICBkaXJ0eVBhdGhzOiBkaXJ0eVBhdGhzLFxuICAgICAgICAgIGl0ZXJhdGlvbjogaXRlcmF0aW9uLFxuICAgICAgICAgIGluaXRpYWxEaXJ0eVBhdGhzTGVuZ3RoOiBpbml0aWFsRGlydHlQYXRoc0xlbmd0aCxcbiAgICAgICAgICBvcGVyYXRpb246IG9wZXJhdGlvblxuICAgICAgICB9KSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkaXJ0eVBhdGggPSBwb3BEaXJ0eVBhdGgoZWRpdG9yKTsgLy8gSWYgdGhlIG5vZGUgZG9lc24ndCBleGlzdCBpbiB0aGUgdHJlZSwgaXQgZG9lcyBub3QgbmVlZCB0byBiZSBub3JtYWxpemVkLlxuXG4gICAgICAgIGlmIChOb2RlLmhhcyhlZGl0b3IsIGRpcnR5UGF0aCkpIHtcbiAgICAgICAgICB2YXIgZW50cnkgPSBFZGl0b3Iubm9kZShlZGl0b3IsIGRpcnR5UGF0aCk7XG4gICAgICAgICAgZWRpdG9yLm5vcm1hbGl6ZU5vZGUoZW50cnksIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbjogb3BlcmF0aW9uXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpdGVyYXRpb24rKztcbiAgICAgICAgZGlydHlQYXRocyA9IGdldERpcnR5UGF0aHMoZWRpdG9yKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcblxuICAvKipcclxuICAgKiBHZXQgdGhlIHBhcmVudCBub2RlIG9mIGEgbG9jYXRpb24uXHJcbiAgICovXG4gIHBhcmVudDogZnVuY3Rpb24gcGFyZW50KGVkaXRvciwgYXQpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgdmFyIHBhdGggPSBFZGl0b3IucGF0aChlZGl0b3IsIGF0LCBvcHRpb25zKTtcbiAgICB2YXIgcGFyZW50UGF0aCA9IFBhdGgucGFyZW50KHBhdGgpO1xuICAgIHZhciBlbnRyeSA9IEVkaXRvci5ub2RlKGVkaXRvciwgcGFyZW50UGF0aCk7XG4gICAgcmV0dXJuIGVudHJ5O1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgcGF0aCBvZiBhIGxvY2F0aW9uLlxyXG4gICAqL1xuICBwYXRoOiBmdW5jdGlvbiBwYXRoKGVkaXRvciwgYXQpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgdmFyIGRlcHRoID0gb3B0aW9ucy5kZXB0aCxcbiAgICAgICAgZWRnZSA9IG9wdGlvbnMuZWRnZTtcblxuICAgIGlmIChQYXRoLmlzUGF0aChhdCkpIHtcbiAgICAgIGlmIChlZGdlID09PSAnc3RhcnQnKSB7XG4gICAgICAgIHZhciBfTm9kZSRmaXJzdCA9IE5vZGUuZmlyc3QoZWRpdG9yLCBhdCksXG4gICAgICAgICAgICBfTm9kZSRmaXJzdDIgPSBfc2xpY2VkVG9BcnJheShfTm9kZSRmaXJzdCwgMiksXG4gICAgICAgICAgICBmaXJzdFBhdGggPSBfTm9kZSRmaXJzdDJbMV07XG5cbiAgICAgICAgYXQgPSBmaXJzdFBhdGg7XG4gICAgICB9IGVsc2UgaWYgKGVkZ2UgPT09ICdlbmQnKSB7XG4gICAgICAgIHZhciBfTm9kZSRsYXN0ID0gTm9kZS5sYXN0KGVkaXRvciwgYXQpLFxuICAgICAgICAgICAgX05vZGUkbGFzdDIgPSBfc2xpY2VkVG9BcnJheShfTm9kZSRsYXN0LCAyKSxcbiAgICAgICAgICAgIGxhc3RQYXRoID0gX05vZGUkbGFzdDJbMV07XG5cbiAgICAgICAgYXQgPSBsYXN0UGF0aDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoUmFuZ2UuaXNSYW5nZShhdCkpIHtcbiAgICAgIGlmIChlZGdlID09PSAnc3RhcnQnKSB7XG4gICAgICAgIGF0ID0gUmFuZ2Uuc3RhcnQoYXQpO1xuICAgICAgfSBlbHNlIGlmIChlZGdlID09PSAnZW5kJykge1xuICAgICAgICBhdCA9IFJhbmdlLmVuZChhdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhdCA9IFBhdGguY29tbW9uKGF0LmFuY2hvci5wYXRoLCBhdC5mb2N1cy5wYXRoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoUG9pbnQuaXNQb2ludChhdCkpIHtcbiAgICAgIGF0ID0gYXQucGF0aDtcbiAgICB9XG5cbiAgICBpZiAoZGVwdGggIT0gbnVsbCkge1xuICAgICAgYXQgPSBhdC5zbGljZSgwLCBkZXB0aCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGF0O1xuICB9LFxuICBoYXNQYXRoOiBmdW5jdGlvbiBoYXNQYXRoKGVkaXRvciwgcGF0aCkge1xuICAgIHJldHVybiBOb2RlLmhhcyhlZGl0b3IsIHBhdGgpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENyZWF0ZSBhIG11dGFibGUgcmVmIGZvciBhIGBQYXRoYCBvYmplY3QsIHdoaWNoIHdpbGwgc3RheSBpbiBzeW5jIGFzIG5ld1xyXG4gICAqIG9wZXJhdGlvbnMgYXJlIGFwcGxpZWQgdG8gdGhlIGVkaXRvci5cclxuICAgKi9cbiAgcGF0aFJlZjogZnVuY3Rpb24gcGF0aFJlZihlZGl0b3IsIHBhdGgpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgdmFyIF9vcHRpb25zJGFmZmluaXR5ID0gb3B0aW9ucy5hZmZpbml0eSxcbiAgICAgICAgYWZmaW5pdHkgPSBfb3B0aW9ucyRhZmZpbml0eSA9PT0gdm9pZCAwID8gJ2ZvcndhcmQnIDogX29wdGlvbnMkYWZmaW5pdHk7XG4gICAgdmFyIHJlZiA9IHtcbiAgICAgIGN1cnJlbnQ6IHBhdGgsXG4gICAgICBhZmZpbml0eTogYWZmaW5pdHksXG4gICAgICB1bnJlZjogZnVuY3Rpb24gdW5yZWYoKSB7XG4gICAgICAgIHZhciBjdXJyZW50ID0gcmVmLmN1cnJlbnQ7XG4gICAgICAgIHZhciBwYXRoUmVmcyA9IEVkaXRvci5wYXRoUmVmcyhlZGl0b3IpO1xuICAgICAgICBwYXRoUmVmc1tcImRlbGV0ZVwiXShyZWYpO1xuICAgICAgICByZWYuY3VycmVudCA9IG51bGw7XG4gICAgICAgIHJldHVybiBjdXJyZW50O1xuICAgICAgfVxuICAgIH07XG4gICAgdmFyIHJlZnMgPSBFZGl0b3IucGF0aFJlZnMoZWRpdG9yKTtcbiAgICByZWZzLmFkZChyZWYpO1xuICAgIHJldHVybiByZWY7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogR2V0IHRoZSBzZXQgb2YgY3VycmVudGx5IHRyYWNrZWQgcGF0aCByZWZzIG9mIHRoZSBlZGl0b3IuXHJcbiAgICovXG4gIHBhdGhSZWZzOiBmdW5jdGlvbiBwYXRoUmVmcyhlZGl0b3IpIHtcbiAgICB2YXIgcmVmcyA9IFBBVEhfUkVGUy5nZXQoZWRpdG9yKTtcblxuICAgIGlmICghcmVmcykge1xuICAgICAgcmVmcyA9IG5ldyBTZXQoKTtcbiAgICAgIFBBVEhfUkVGUy5zZXQoZWRpdG9yLCByZWZzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVmcztcbiAgfSxcblxuICAvKipcclxuICAgKiBHZXQgdGhlIHN0YXJ0IG9yIGVuZCBwb2ludCBvZiBhIGxvY2F0aW9uLlxyXG4gICAqL1xuICBwb2ludDogZnVuY3Rpb24gcG9pbnQoZWRpdG9yLCBhdCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICB2YXIgX29wdGlvbnMkZWRnZSA9IG9wdGlvbnMuZWRnZSxcbiAgICAgICAgZWRnZSA9IF9vcHRpb25zJGVkZ2UgPT09IHZvaWQgMCA/ICdzdGFydCcgOiBfb3B0aW9ucyRlZGdlO1xuXG4gICAgaWYgKFBhdGguaXNQYXRoKGF0KSkge1xuICAgICAgdmFyIHBhdGg7XG5cbiAgICAgIGlmIChlZGdlID09PSAnZW5kJykge1xuICAgICAgICB2YXIgX05vZGUkbGFzdDMgPSBOb2RlLmxhc3QoZWRpdG9yLCBhdCksXG4gICAgICAgICAgICBfTm9kZSRsYXN0NCA9IF9zbGljZWRUb0FycmF5KF9Ob2RlJGxhc3QzLCAyKSxcbiAgICAgICAgICAgIGxhc3RQYXRoID0gX05vZGUkbGFzdDRbMV07XG5cbiAgICAgICAgcGF0aCA9IGxhc3RQYXRoO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIF9Ob2RlJGZpcnN0MyA9IE5vZGUuZmlyc3QoZWRpdG9yLCBhdCksXG4gICAgICAgICAgICBfTm9kZSRmaXJzdDQgPSBfc2xpY2VkVG9BcnJheShfTm9kZSRmaXJzdDMsIDIpLFxuICAgICAgICAgICAgZmlyc3RQYXRoID0gX05vZGUkZmlyc3Q0WzFdO1xuXG4gICAgICAgIHBhdGggPSBmaXJzdFBhdGg7XG4gICAgICB9XG5cbiAgICAgIHZhciBub2RlID0gTm9kZS5nZXQoZWRpdG9yLCBwYXRoKTtcblxuICAgICAgaWYgKCFUZXh0LmlzVGV4dChub2RlKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZ2V0IHRoZSBcIi5jb25jYXQoZWRnZSwgXCIgcG9pbnQgaW4gdGhlIG5vZGUgYXQgcGF0aCBbXCIpLmNvbmNhdChhdCwgXCJdIGJlY2F1c2UgaXQgaGFzIG5vIFwiKS5jb25jYXQoZWRnZSwgXCIgdGV4dCBub2RlLlwiKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgIG9mZnNldDogZWRnZSA9PT0gJ2VuZCcgPyBub2RlLnRleHQubGVuZ3RoIDogMFxuICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAoUmFuZ2UuaXNSYW5nZShhdCkpIHtcbiAgICAgIHZhciBfUmFuZ2UkZWRnZXMgPSBSYW5nZS5lZGdlcyhhdCksXG4gICAgICAgICAgX1JhbmdlJGVkZ2VzMiA9IF9zbGljZWRUb0FycmF5KF9SYW5nZSRlZGdlcywgMiksXG4gICAgICAgICAgc3RhcnQgPSBfUmFuZ2UkZWRnZXMyWzBdLFxuICAgICAgICAgIGVuZCA9IF9SYW5nZSRlZGdlczJbMV07XG5cbiAgICAgIHJldHVybiBlZGdlID09PSAnc3RhcnQnID8gc3RhcnQgOiBlbmQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGF0O1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENyZWF0ZSBhIG11dGFibGUgcmVmIGZvciBhIGBQb2ludGAgb2JqZWN0LCB3aGljaCB3aWxsIHN0YXkgaW4gc3luYyBhcyBuZXdcclxuICAgKiBvcGVyYXRpb25zIGFyZSBhcHBsaWVkIHRvIHRoZSBlZGl0b3IuXHJcbiAgICovXG4gIHBvaW50UmVmOiBmdW5jdGlvbiBwb2ludFJlZihlZGl0b3IsIHBvaW50KSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIHZhciBfb3B0aW9ucyRhZmZpbml0eTIgPSBvcHRpb25zLmFmZmluaXR5LFxuICAgICAgICBhZmZpbml0eSA9IF9vcHRpb25zJGFmZmluaXR5MiA9PT0gdm9pZCAwID8gJ2ZvcndhcmQnIDogX29wdGlvbnMkYWZmaW5pdHkyO1xuICAgIHZhciByZWYgPSB7XG4gICAgICBjdXJyZW50OiBwb2ludCxcbiAgICAgIGFmZmluaXR5OiBhZmZpbml0eSxcbiAgICAgIHVucmVmOiBmdW5jdGlvbiB1bnJlZigpIHtcbiAgICAgICAgdmFyIGN1cnJlbnQgPSByZWYuY3VycmVudDtcbiAgICAgICAgdmFyIHBvaW50UmVmcyA9IEVkaXRvci5wb2ludFJlZnMoZWRpdG9yKTtcbiAgICAgICAgcG9pbnRSZWZzW1wiZGVsZXRlXCJdKHJlZik7XG4gICAgICAgIHJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIGN1cnJlbnQ7XG4gICAgICB9XG4gICAgfTtcbiAgICB2YXIgcmVmcyA9IEVkaXRvci5wb2ludFJlZnMoZWRpdG9yKTtcbiAgICByZWZzLmFkZChyZWYpO1xuICAgIHJldHVybiByZWY7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogR2V0IHRoZSBzZXQgb2YgY3VycmVudGx5IHRyYWNrZWQgcG9pbnQgcmVmcyBvZiB0aGUgZWRpdG9yLlxyXG4gICAqL1xuICBwb2ludFJlZnM6IGZ1bmN0aW9uIHBvaW50UmVmcyhlZGl0b3IpIHtcbiAgICB2YXIgcmVmcyA9IFBPSU5UX1JFRlMuZ2V0KGVkaXRvcik7XG5cbiAgICBpZiAoIXJlZnMpIHtcbiAgICAgIHJlZnMgPSBuZXcgU2V0KCk7XG4gICAgICBQT0lOVF9SRUZTLnNldChlZGl0b3IsIHJlZnMpO1xuICAgIH1cblxuICAgIHJldHVybiByZWZzO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIFJldHVybiBhbGwgdGhlIHBvc2l0aW9ucyBpbiBgYXRgIHJhbmdlIHdoZXJlIGEgYFBvaW50YCBjYW4gYmUgcGxhY2VkLlxyXG4gICAqXHJcbiAgICogQnkgZGVmYXVsdCwgbW92ZXMgZm9yd2FyZCBieSBpbmRpdmlkdWFsIG9mZnNldHMgYXQgYSB0aW1lLCBidXRcclxuICAgKiB0aGUgYHVuaXRgIG9wdGlvbiBjYW4gYmUgdXNlZCB0byB0byBtb3ZlIGJ5IGNoYXJhY3Rlciwgd29yZCwgbGluZSwgb3IgYmxvY2suXHJcbiAgICpcclxuICAgKiBUaGUgYHJldmVyc2VgIG9wdGlvbiBjYW4gYmUgdXNlZCB0byBjaGFuZ2UgaXRlcmF0aW9uIGRpcmVjdGlvbi5cclxuICAgKlxyXG4gICAqIE5vdGU6IEJ5IGRlZmF1bHQgdm9pZCBub2RlcyBhcmUgdHJlYXRlZCBhcyBhIHNpbmdsZSBwb2ludCBhbmQgaXRlcmF0aW9uXHJcbiAgICogd2lsbCBub3QgaGFwcGVuIGluc2lkZSB0aGVpciBjb250ZW50IHVubGVzcyB5b3UgcGFzcyBpbiB0cnVlIGZvciB0aGVcclxuICAgKiBgdm9pZHNgIG9wdGlvbiwgdGhlbiBpdGVyYXRpb24gd2lsbCBvY2N1ci5cclxuICAgKi9cbiAgcG9zaXRpb25zOiBmdW5jdGlvbiogcG9zaXRpb25zKGVkaXRvcikge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICB2YXIgX29wdGlvbnMkYXQ1ID0gb3B0aW9ucy5hdCxcbiAgICAgICAgYXQgPSBfb3B0aW9ucyRhdDUgPT09IHZvaWQgMCA/IGVkaXRvci5zZWxlY3Rpb24gOiBfb3B0aW9ucyRhdDUsXG4gICAgICAgIF9vcHRpb25zJHVuaXQzID0gb3B0aW9ucy51bml0LFxuICAgICAgICB1bml0ID0gX29wdGlvbnMkdW5pdDMgPT09IHZvaWQgMCA/ICdvZmZzZXQnIDogX29wdGlvbnMkdW5pdDMsXG4gICAgICAgIF9vcHRpb25zJHJldmVyc2UzID0gb3B0aW9ucy5yZXZlcnNlLFxuICAgICAgICByZXZlcnNlID0gX29wdGlvbnMkcmV2ZXJzZTMgPT09IHZvaWQgMCA/IGZhbHNlIDogX29wdGlvbnMkcmV2ZXJzZTMsXG4gICAgICAgIF9vcHRpb25zJHZvaWRzNSA9IG9wdGlvbnMudm9pZHMsXG4gICAgICAgIHZvaWRzID0gX29wdGlvbnMkdm9pZHM1ID09PSB2b2lkIDAgPyBmYWxzZSA6IF9vcHRpb25zJHZvaWRzNTtcblxuICAgIGlmICghYXQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLyoqXHJcbiAgICAgKiBBbGdvcml0aG0gbm90ZXM6XHJcbiAgICAgKlxyXG4gICAgICogRWFjaCBzdGVwIGBkaXN0YW5jZWAgaXMgZHluYW1pYyBkZXBlbmRpbmcgb24gdGhlIHVuZGVybHlpbmcgdGV4dFxyXG4gICAgICogYW5kIHRoZSBgdW5pdGAgc3BlY2lmaWVkLiAgRWFjaCBzdGVwLCBlLmcuLCBhIGxpbmUgb3Igd29yZCwgbWF5XHJcbiAgICAgKiBzcGFuIG11bHRpcGxlIHRleHQgbm9kZXMsIHNvIHdlIGl0ZXJhdGUgdGhyb3VnaCB0aGUgdGV4dCBib3RoIG9uXHJcbiAgICAgKiB0d28gbGV2ZWxzIGluIHN0ZXAtc3luYzpcclxuICAgICAqXHJcbiAgICAgKiBgbGVhZlRleHRgIHN0b3JlcyB0aGUgdGV4dCBvbiBhIHRleHQgbGVhZiBsZXZlbCwgYW5kIGlzIGFkdmFuY2VkXHJcbiAgICAgKiB0aHJvdWdoIHVzaW5nIHRoZSBjb3VudGVycyBgbGVhZlRleHRPZmZzZXRgIGFuZCBgbGVhZlRleHRSZW1haW5pbmdgLlxyXG4gICAgICpcclxuICAgICAqIGBibG9ja1RleHRgIHN0b3JlcyB0aGUgdGV4dCBvbiBhIGJsb2NrIGxldmVsLCBhbmQgaXMgc2hvcnRlbmVkXHJcbiAgICAgKiBieSBgZGlzdGFuY2VgIGV2ZXJ5IHRpbWUgaXQgaXMgYWR2YW5jZWQuXHJcbiAgICAgKlxyXG4gICAgICogV2Ugb25seSBtYWludGFpbiBhIHdpbmRvdyBvZiBvbmUgYmxvY2tUZXh0IGFuZCBvbmUgbGVhZlRleHQgYmVjYXVzZVxyXG4gICAgICogYSBibG9jayBub2RlIGFsd2F5cyBhcHBlYXJzIGJlZm9yZSBhbGwgb2YgaXRzIGxlYWYgbm9kZXMuXHJcbiAgICAgKi9cblxuXG4gICAgdmFyIHJhbmdlID0gRWRpdG9yLnJhbmdlKGVkaXRvciwgYXQpO1xuXG4gICAgdmFyIF9SYW5nZSRlZGdlczMgPSBSYW5nZS5lZGdlcyhyYW5nZSksXG4gICAgICAgIF9SYW5nZSRlZGdlczQgPSBfc2xpY2VkVG9BcnJheShfUmFuZ2UkZWRnZXMzLCAyKSxcbiAgICAgICAgc3RhcnQgPSBfUmFuZ2UkZWRnZXM0WzBdLFxuICAgICAgICBlbmQgPSBfUmFuZ2UkZWRnZXM0WzFdO1xuXG4gICAgdmFyIGZpcnN0ID0gcmV2ZXJzZSA/IGVuZCA6IHN0YXJ0O1xuICAgIHZhciBpc05ld0Jsb2NrID0gZmFsc2U7XG4gICAgdmFyIGJsb2NrVGV4dCA9ICcnO1xuICAgIHZhciBkaXN0YW5jZSA9IDA7IC8vIERpc3RhbmNlIGZvciBsZWFmVGV4dCB0byBjYXRjaCB1cCB0byBibG9ja1RleHQuXG5cbiAgICB2YXIgbGVhZlRleHRSZW1haW5pbmcgPSAwO1xuICAgIHZhciBsZWFmVGV4dE9mZnNldCA9IDA7IC8vIEl0ZXJhdGUgdGhyb3VnaCBhbGwgbm9kZXMgaW4gcmFuZ2UsIGdyYWJiaW5nIGVudGlyZSB0ZXh0dWFsIGNvbnRlbnRcbiAgICAvLyBvZiBibG9jayBub2RlcyBpbiBibG9ja1RleHQsIGFuZCB0ZXh0IG5vZGVzIGluIGxlYWZUZXh0LlxuICAgIC8vIEV4cGxvaXRzIHRoZSBmYWN0IHRoYXQgbm9kZXMgYXJlIHNlcXVlbmNlZCBpbiBzdWNoIGEgd2F5IHRoYXQgd2UgZmlyc3RcbiAgICAvLyBlbmNvdW50ZXIgdGhlIGJsb2NrIG5vZGUsIHRoZW4gYWxsIG9mIGl0cyB0ZXh0IG5vZGVzLCBzbyB3aGVuIGl0ZXJhdGluZ1xuICAgIC8vIHRocm91Z2ggdGhlIGJsb2NrVGV4dCBhbmQgbGVhZlRleHQgd2UganVzdCBuZWVkIHRvIHJlbWVtYmVyIGEgd2luZG93IG9mXG4gICAgLy8gb25lIGJsb2NrIG5vZGUgYW5kIGxlYWYgbm9kZSwgcmVzcGVjdGl2ZWx5LlxuXG4gICAgdmFyIF9pdGVyYXRvcjcgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciQ1KEVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICAgIGF0OiBhdCxcbiAgICAgIHJldmVyc2U6IHJldmVyc2UsXG4gICAgICB2b2lkczogdm9pZHNcbiAgICB9KSksXG4gICAgICAgIF9zdGVwNztcblxuICAgIHRyeSB7XG4gICAgICBmb3IgKF9pdGVyYXRvcjcucygpOyAhKF9zdGVwNyA9IF9pdGVyYXRvcjcubigpKS5kb25lOykge1xuICAgICAgICB2YXIgX3N0ZXA3JHZhbHVlID0gX3NsaWNlZFRvQXJyYXkoX3N0ZXA3LnZhbHVlLCAyKSxcbiAgICAgICAgICAgIG5vZGUgPSBfc3RlcDckdmFsdWVbMF0sXG4gICAgICAgICAgICBwYXRoID0gX3N0ZXA3JHZhbHVlWzFdO1xuXG4gICAgICAgIC8qXHJcbiAgICAgICAgICogRUxFTUVOVCBOT0RFIC0gWWllbGQgcG9zaXRpb24ocykgZm9yIHZvaWRzLCBjb2xsZWN0IGJsb2NrVGV4dCBmb3IgYmxvY2tzXHJcbiAgICAgICAgICovXG4gICAgICAgIGlmIChFbGVtZW50LmlzRWxlbWVudChub2RlKSkge1xuICAgICAgICAgIC8vIFZvaWQgbm9kZXMgYXJlIGEgc3BlY2lhbCBjYXNlLCBzbyBieSBkZWZhdWx0IHdlIHdpbGwgYWx3YXlzXG4gICAgICAgICAgLy8geWllbGQgdGhlaXIgZmlyc3QgcG9pbnQuIElmIHRoZSBgdm9pZHNgIG9wdGlvbiBpcyBzZXQgdG8gdHJ1ZSxcbiAgICAgICAgICAvLyB0aGVuIHdlIHdpbGwgaXRlcmF0ZSBvdmVyIHRoZWlyIGNvbnRlbnQuXG4gICAgICAgICAgaWYgKCF2b2lkcyAmJiBlZGl0b3IuaXNWb2lkKG5vZGUpKSB7XG4gICAgICAgICAgICB5aWVsZCBFZGl0b3Iuc3RhcnQoZWRpdG9yLCBwYXRoKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH0gLy8gSW5saW5lIGVsZW1lbnQgbm9kZXMgYXJlIGlnbm9yZWQgYXMgdGhleSBkb24ndCB0aGVtc2VsdmVzXG4gICAgICAgICAgLy8gY29udHJpYnV0ZSB0byBgYmxvY2tUZXh0YCBvciBgbGVhZlRleHRgIC0gdGhlaXIgcGFyZW50IGFuZFxuICAgICAgICAgIC8vIGNoaWxkcmVuIGRvLlxuXG5cbiAgICAgICAgICBpZiAoZWRpdG9yLmlzSW5saW5lKG5vZGUpKSBjb250aW51ZTsgLy8gQmxvY2sgZWxlbWVudCBub2RlIC0gc2V0IGBibG9ja1RleHRgIHRvIGl0cyB0ZXh0IGNvbnRlbnQuXG5cbiAgICAgICAgICBpZiAoRWRpdG9yLmhhc0lubGluZXMoZWRpdG9yLCBub2RlKSkge1xuICAgICAgICAgICAgLy8gV2UgYWx3YXlzIGV4aGF1c3QgYmxvY2sgbm9kZXMgYmVmb3JlIGVuY291bnRlcmluZyBhIG5ldyBvbmU6XG4gICAgICAgICAgICAvLyAgIGNvbnNvbGUuYXNzZXJ0KGJsb2NrVGV4dCA9PT0gJycsXG4gICAgICAgICAgICAvLyAgICAgYGJsb2NrVGV4dD0nJHtibG9ja1RleHR9JyAtIGArXG4gICAgICAgICAgICAvLyAgICAgYG5vdCBleGhhdXN0ZWQgYmVmb3JlIG5ldyBibG9jayBub2RlYCwgcGF0aClcbiAgICAgICAgICAgIC8vIEVuc3VyZSByYW5nZSBjb25zaWRlcmVkIGlzIGNhcHBlZCB0byBgcmFuZ2VgLCBpbiB0aGVcbiAgICAgICAgICAgIC8vIHN0YXJ0L2VuZCBlZGdlIGNhc2VzIHdoZXJlIGJsb2NrIGV4dGVuZHMgYmV5b25kIHJhbmdlLlxuICAgICAgICAgICAgLy8gRXF1aXZhbGVudCB0byB0aGlzLCBidXQgcHJlc3VtYWJseSBtb3JlIHBlcmZvcm1hbnQ6XG4gICAgICAgICAgICAvLyAgIGJsb2NrUmFuZ2UgPSBFZGl0b3IucmFuZ2UoZWRpdG9yLCAuLi5FZGl0b3IuZWRnZXMoZWRpdG9yLCBwYXRoKSlcbiAgICAgICAgICAgIC8vICAgYmxvY2tSYW5nZSA9IFJhbmdlLmludGVyc2VjdGlvbihyYW5nZSwgYmxvY2tSYW5nZSkgLy8gaW50ZXJzZWN0XG4gICAgICAgICAgICAvLyAgIGJsb2NrVGV4dCA9IEVkaXRvci5zdHJpbmcoZWRpdG9yLCBibG9ja1JhbmdlLCB7IHZvaWRzIH0pXG4gICAgICAgICAgICB2YXIgZSA9IFBhdGguaXNBbmNlc3RvcihwYXRoLCBlbmQucGF0aCkgPyBlbmQgOiBFZGl0b3IuZW5kKGVkaXRvciwgcGF0aCk7XG4gICAgICAgICAgICB2YXIgcyA9IFBhdGguaXNBbmNlc3RvcihwYXRoLCBzdGFydC5wYXRoKSA/IHN0YXJ0IDogRWRpdG9yLnN0YXJ0KGVkaXRvciwgcGF0aCk7XG4gICAgICAgICAgICBibG9ja1RleHQgPSBFZGl0b3Iuc3RyaW5nKGVkaXRvciwge1xuICAgICAgICAgICAgICBhbmNob3I6IHMsXG4gICAgICAgICAgICAgIGZvY3VzOiBlXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIHZvaWRzOiB2b2lkc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpc05ld0Jsb2NrID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLypcclxuICAgICAgICAgKiBURVhUIExFQUYgTk9ERSAtIEl0ZXJhdGUgdGhyb3VnaCB0ZXh0IGNvbnRlbnQsIHlpZWxkaW5nXHJcbiAgICAgICAgICogcG9zaXRpb25zIGV2ZXJ5IGBkaXN0YW5jZWAgb2Zmc2V0IGFjY29yZGluZyB0byBgdW5pdGAuXHJcbiAgICAgICAgICovXG5cblxuICAgICAgICBpZiAoVGV4dC5pc1RleHQobm9kZSkpIHtcbiAgICAgICAgICB2YXIgaXNGaXJzdCA9IFBhdGguZXF1YWxzKHBhdGgsIGZpcnN0LnBhdGgpOyAvLyBQcm9vZiB0aGF0IHdlIGFsd2F5cyBleGhhdXN0IHRleHQgbm9kZXMgYmVmb3JlIGVuY291bnRlcmluZyBhIG5ldyBvbmU6XG4gICAgICAgICAgLy8gICBjb25zb2xlLmFzc2VydChsZWFmVGV4dFJlbWFpbmluZyA8PSAwLFxuICAgICAgICAgIC8vICAgICBgbGVhZlRleHRSZW1haW5pbmc9JHtsZWFmVGV4dFJlbWFpbmluZ30gLSBgK1xuICAgICAgICAgIC8vICAgICBgbm90IGV4aGF1c3RlZCBiZWZvcmUgbmV3IGxlYWYgdGV4dCBub2RlYCwgcGF0aClcbiAgICAgICAgICAvLyBSZXNldCBgbGVhZlRleHRgIGNvdW50ZXJzIGZvciBuZXcgdGV4dCBub2RlLlxuXG4gICAgICAgICAgaWYgKGlzRmlyc3QpIHtcbiAgICAgICAgICAgIGxlYWZUZXh0UmVtYWluaW5nID0gcmV2ZXJzZSA/IGZpcnN0Lm9mZnNldCA6IG5vZGUudGV4dC5sZW5ndGggLSBmaXJzdC5vZmZzZXQ7XG4gICAgICAgICAgICBsZWFmVGV4dE9mZnNldCA9IGZpcnN0Lm9mZnNldDsgLy8gV29ya3MgZm9yIHJldmVyc2UgdG9vLlxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZWFmVGV4dFJlbWFpbmluZyA9IG5vZGUudGV4dC5sZW5ndGg7XG4gICAgICAgICAgICBsZWFmVGV4dE9mZnNldCA9IHJldmVyc2UgPyBsZWFmVGV4dFJlbWFpbmluZyA6IDA7XG4gICAgICAgICAgfSAvLyBZaWVsZCBwb3NpdGlvbiBhdCB0aGUgc3RhcnQgb2Ygbm9kZSAocG90ZW50aWFsbHkpLlxuXG5cbiAgICAgICAgICBpZiAoaXNGaXJzdCB8fCBpc05ld0Jsb2NrIHx8IHVuaXQgPT09ICdvZmZzZXQnKSB7XG4gICAgICAgICAgICB5aWVsZCB7XG4gICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgIG9mZnNldDogbGVhZlRleHRPZmZzZXRcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpc05ld0Jsb2NrID0gZmFsc2U7XG4gICAgICAgICAgfSAvLyBZaWVsZCBwb3NpdGlvbnMgZXZlcnkgKGR5bmFtaWNhbGx5IGNhbGN1bGF0ZWQpIGBkaXN0YW5jZWAgb2Zmc2V0LlxuXG5cbiAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgLy8gSWYgYGxlYWZUZXh0YCBoYXMgY2F1Z2h0IHVwIHdpdGggYGJsb2NrVGV4dGAgKGRpc3RhbmNlPTApLFxuICAgICAgICAgICAgLy8gYW5kIGlmIGJsb2NrVGV4dCBpcyBleGhhdXN0ZWQsIGJyZWFrIHRvIGdldCBhbm90aGVyIGJsb2NrIG5vZGUsXG4gICAgICAgICAgICAvLyBvdGhlcndpc2UgYWR2YW5jZSBibG9ja1RleHQgZm9yd2FyZCBieSB0aGUgbmV3IGBkaXN0YW5jZWAuXG4gICAgICAgICAgICBpZiAoZGlzdGFuY2UgPT09IDApIHtcbiAgICAgICAgICAgICAgaWYgKGJsb2NrVGV4dCA9PT0gJycpIGJyZWFrO1xuICAgICAgICAgICAgICBkaXN0YW5jZSA9IGNhbGNEaXN0YW5jZShibG9ja1RleHQsIHVuaXQsIHJldmVyc2UpOyAvLyBTcGxpdCB0aGUgc3RyaW5nIGF0IHRoZSBwcmV2aW91c2x5IGZvdW5kIGRpc3RhbmNlIGFuZCB1c2UgdGhlXG4gICAgICAgICAgICAgIC8vIHJlbWFpbmluZyBzdHJpbmcgZm9yIHRoZSBuZXh0IGl0ZXJhdGlvbi5cblxuICAgICAgICAgICAgICBibG9ja1RleHQgPSBzcGxpdEJ5Q2hhcmFjdGVyRGlzdGFuY2UoYmxvY2tUZXh0LCBkaXN0YW5jZSwgcmV2ZXJzZSlbMV07XG4gICAgICAgICAgICB9IC8vIEFkdmFuY2UgYGxlYWZUZXh0YCBieSB0aGUgY3VycmVudCBgZGlzdGFuY2VgLlxuXG5cbiAgICAgICAgICAgIGxlYWZUZXh0T2Zmc2V0ID0gcmV2ZXJzZSA/IGxlYWZUZXh0T2Zmc2V0IC0gZGlzdGFuY2UgOiBsZWFmVGV4dE9mZnNldCArIGRpc3RhbmNlO1xuICAgICAgICAgICAgbGVhZlRleHRSZW1haW5pbmcgPSBsZWFmVGV4dFJlbWFpbmluZyAtIGRpc3RhbmNlOyAvLyBJZiBgbGVhZlRleHRgIGlzIGV4aGF1c3RlZCwgYnJlYWsgdG8gZ2V0IGEgbmV3IGxlYWYgbm9kZVxuICAgICAgICAgICAgLy8gYW5kIHNldCBkaXN0YW5jZSB0byB0aGUgb3ZlcmZsb3cgYW1vdW50LCBzbyB3ZSdsbCAobWF5YmUpXG4gICAgICAgICAgICAvLyBjYXRjaCB1cCB0byBibG9ja1RleHQgaW4gdGhlIG5leHQgbGVhZiB0ZXh0IG5vZGUuXG5cbiAgICAgICAgICAgIGlmIChsZWFmVGV4dFJlbWFpbmluZyA8IDApIHtcbiAgICAgICAgICAgICAgZGlzdGFuY2UgPSAtbGVhZlRleHRSZW1haW5pbmc7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfSAvLyBTdWNjZXNzZnVsbHkgd2Fsa2VkIGBkaXN0YW5jZWAgb2Zmc2V0cyB0aHJvdWdoIGBsZWFmVGV4dGBcbiAgICAgICAgICAgIC8vIHRvIGNhdGNoIHVwIHdpdGggYGJsb2NrVGV4dGAsIHNvIHdlIGNhbiByZXNldCBgZGlzdGFuY2VgXG4gICAgICAgICAgICAvLyBhbmQgeWllbGQgdGhpcyBwb3NpdGlvbiBpbiB0aGlzIG5vZGUuXG5cblxuICAgICAgICAgICAgZGlzdGFuY2UgPSAwO1xuICAgICAgICAgICAgeWllbGQge1xuICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICBvZmZzZXQ6IGxlYWZUZXh0T2Zmc2V0XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSAvLyBQcm9vZiB0aGF0IHVwb24gY29tcGxldGlvbiwgd2UndmUgZXhhaHVzdGVkIGJvdGggbGVhZiBhbmQgYmxvY2sgdGV4dDpcbiAgICAgIC8vICAgY29uc29sZS5hc3NlcnQobGVhZlRleHRSZW1haW5pbmcgPD0gMCwgXCJsZWFmVGV4dCB3YXNuJ3QgZXhoYXVzdGVkXCIpXG4gICAgICAvLyAgIGNvbnNvbGUuYXNzZXJ0KGJsb2NrVGV4dCA9PT0gJycsIFwiYmxvY2tUZXh0IHdhc24ndCBleGhhdXN0ZWRcIilcbiAgICAgIC8vIEhlbHBlcjpcbiAgICAgIC8vIFJldHVybiB0aGUgZGlzdGFuY2UgaW4gb2Zmc2V0cyBmb3IgYSBzdGVwIG9mIHNpemUgYHVuaXRgIG9uIGdpdmVuIHN0cmluZy5cblxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgX2l0ZXJhdG9yNy5lKGVycik7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIF9pdGVyYXRvcjcuZigpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNhbGNEaXN0YW5jZSh0ZXh0LCB1bml0LCByZXZlcnNlKSB7XG4gICAgICBpZiAodW5pdCA9PT0gJ2NoYXJhY3RlcicpIHtcbiAgICAgICAgcmV0dXJuIGdldENoYXJhY3RlckRpc3RhbmNlKHRleHQsIHJldmVyc2UpO1xuICAgICAgfSBlbHNlIGlmICh1bml0ID09PSAnd29yZCcpIHtcbiAgICAgICAgcmV0dXJuIGdldFdvcmREaXN0YW5jZSh0ZXh0LCByZXZlcnNlKTtcbiAgICAgIH0gZWxzZSBpZiAodW5pdCA9PT0gJ2xpbmUnIHx8IHVuaXQgPT09ICdibG9jaycpIHtcbiAgICAgICAgcmV0dXJuIHRleHQubGVuZ3RoO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gMTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogR2V0IHRoZSBtYXRjaGluZyBub2RlIGluIHRoZSBicmFuY2ggb2YgdGhlIGRvY3VtZW50IGJlZm9yZSBhIGxvY2F0aW9uLlxyXG4gICAqL1xuICBwcmV2aW91czogZnVuY3Rpb24gcHJldmlvdXMoZWRpdG9yKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIHZhciBfb3B0aW9ucyRtb2RlNCA9IG9wdGlvbnMubW9kZSxcbiAgICAgICAgbW9kZSA9IF9vcHRpb25zJG1vZGU0ID09PSB2b2lkIDAgPyAnbG93ZXN0JyA6IF9vcHRpb25zJG1vZGU0LFxuICAgICAgICBfb3B0aW9ucyR2b2lkczYgPSBvcHRpb25zLnZvaWRzLFxuICAgICAgICB2b2lkcyA9IF9vcHRpb25zJHZvaWRzNiA9PT0gdm9pZCAwID8gZmFsc2UgOiBfb3B0aW9ucyR2b2lkczY7XG4gICAgdmFyIG1hdGNoID0gb3B0aW9ucy5tYXRjaCxcbiAgICAgICAgX29wdGlvbnMkYXQ2ID0gb3B0aW9ucy5hdCxcbiAgICAgICAgYXQgPSBfb3B0aW9ucyRhdDYgPT09IHZvaWQgMCA/IGVkaXRvci5zZWxlY3Rpb24gOiBfb3B0aW9ucyRhdDY7XG5cbiAgICBpZiAoIWF0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHBvaW50QmVmb3JlTG9jYXRpb24gPSBFZGl0b3IuYmVmb3JlKGVkaXRvciwgYXQsIHtcbiAgICAgIHZvaWRzOiB2b2lkc1xuICAgIH0pO1xuXG4gICAgaWYgKCFwb2ludEJlZm9yZUxvY2F0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIF9FZGl0b3IkZmlyc3QgPSBFZGl0b3IuZmlyc3QoZWRpdG9yLCBbXSksXG4gICAgICAgIF9FZGl0b3IkZmlyc3QyID0gX3NsaWNlZFRvQXJyYXkoX0VkaXRvciRmaXJzdCwgMiksXG4gICAgICAgIHRvID0gX0VkaXRvciRmaXJzdDJbMV07IC8vIFRoZSBzZWFyY2ggbG9jYXRpb24gaXMgZnJvbSB0aGUgc3RhcnQgb2YgdGhlIGRvY3VtZW50IHRvIHRoZSBwYXRoIG9mXG4gICAgLy8gdGhlIHBvaW50IGJlZm9yZSB0aGUgbG9jYXRpb24gcGFzc2VkIGluXG5cblxuICAgIHZhciBzcGFuID0gW3BvaW50QmVmb3JlTG9jYXRpb24ucGF0aCwgdG9dO1xuXG4gICAgaWYgKFBhdGguaXNQYXRoKGF0KSAmJiBhdC5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBnZXQgdGhlIHByZXZpb3VzIG5vZGUgZnJvbSB0aGUgcm9vdCBub2RlIVwiKTtcbiAgICB9XG5cbiAgICBpZiAobWF0Y2ggPT0gbnVsbCkge1xuICAgICAgaWYgKFBhdGguaXNQYXRoKGF0KSkge1xuICAgICAgICB2YXIgX0VkaXRvciRwYXJlbnQzID0gRWRpdG9yLnBhcmVudChlZGl0b3IsIGF0KSxcbiAgICAgICAgICAgIF9FZGl0b3IkcGFyZW50NCA9IF9zbGljZWRUb0FycmF5KF9FZGl0b3IkcGFyZW50MywgMSksXG4gICAgICAgICAgICBwYXJlbnQgPSBfRWRpdG9yJHBhcmVudDRbMF07XG5cbiAgICAgICAgbWF0Y2ggPSBmdW5jdGlvbiBtYXRjaChuKSB7XG4gICAgICAgICAgcmV0dXJuIHBhcmVudC5jaGlsZHJlbi5pbmNsdWRlcyhuKTtcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1hdGNoID0gZnVuY3Rpb24gbWF0Y2goKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIF9FZGl0b3Ikbm9kZXM1ID0gRWRpdG9yLm5vZGVzKGVkaXRvciwge1xuICAgICAgcmV2ZXJzZTogdHJ1ZSxcbiAgICAgIGF0OiBzcGFuLFxuICAgICAgbWF0Y2g6IG1hdGNoLFxuICAgICAgbW9kZTogbW9kZSxcbiAgICAgIHZvaWRzOiB2b2lkc1xuICAgIH0pLFxuICAgICAgICBfRWRpdG9yJG5vZGVzNiA9IF9zbGljZWRUb0FycmF5KF9FZGl0b3Ikbm9kZXM1LCAxKSxcbiAgICAgICAgcHJldmlvdXMgPSBfRWRpdG9yJG5vZGVzNlswXTtcblxuICAgIHJldHVybiBwcmV2aW91cztcbiAgfSxcblxuICAvKipcclxuICAgKiBHZXQgYSByYW5nZSBvZiBhIGxvY2F0aW9uLlxyXG4gICAqL1xuICByYW5nZTogZnVuY3Rpb24gcmFuZ2UoZWRpdG9yLCBhdCwgdG8pIHtcbiAgICBpZiAoUmFuZ2UuaXNSYW5nZShhdCkgJiYgIXRvKSB7XG4gICAgICByZXR1cm4gYXQ7XG4gICAgfVxuXG4gICAgdmFyIHN0YXJ0ID0gRWRpdG9yLnN0YXJ0KGVkaXRvciwgYXQpO1xuICAgIHZhciBlbmQgPSBFZGl0b3IuZW5kKGVkaXRvciwgdG8gfHwgYXQpO1xuICAgIHJldHVybiB7XG4gICAgICBhbmNob3I6IHN0YXJ0LFxuICAgICAgZm9jdXM6IGVuZFxuICAgIH07XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ3JlYXRlIGEgbXV0YWJsZSByZWYgZm9yIGEgYFJhbmdlYCBvYmplY3QsIHdoaWNoIHdpbGwgc3RheSBpbiBzeW5jIGFzIG5ld1xyXG4gICAqIG9wZXJhdGlvbnMgYXJlIGFwcGxpZWQgdG8gdGhlIGVkaXRvci5cclxuICAgKi9cbiAgcmFuZ2VSZWY6IGZ1bmN0aW9uIHJhbmdlUmVmKGVkaXRvciwgcmFuZ2UpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgdmFyIF9vcHRpb25zJGFmZmluaXR5MyA9IG9wdGlvbnMuYWZmaW5pdHksXG4gICAgICAgIGFmZmluaXR5ID0gX29wdGlvbnMkYWZmaW5pdHkzID09PSB2b2lkIDAgPyAnZm9yd2FyZCcgOiBfb3B0aW9ucyRhZmZpbml0eTM7XG4gICAgdmFyIHJlZiA9IHtcbiAgICAgIGN1cnJlbnQ6IHJhbmdlLFxuICAgICAgYWZmaW5pdHk6IGFmZmluaXR5LFxuICAgICAgdW5yZWY6IGZ1bmN0aW9uIHVucmVmKCkge1xuICAgICAgICB2YXIgY3VycmVudCA9IHJlZi5jdXJyZW50O1xuICAgICAgICB2YXIgcmFuZ2VSZWZzID0gRWRpdG9yLnJhbmdlUmVmcyhlZGl0b3IpO1xuICAgICAgICByYW5nZVJlZnNbXCJkZWxldGVcIl0ocmVmKTtcbiAgICAgICAgcmVmLmN1cnJlbnQgPSBudWxsO1xuICAgICAgICByZXR1cm4gY3VycmVudDtcbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciByZWZzID0gRWRpdG9yLnJhbmdlUmVmcyhlZGl0b3IpO1xuICAgIHJlZnMuYWRkKHJlZik7XG4gICAgcmV0dXJuIHJlZjtcbiAgfSxcblxuICAvKipcclxuICAgKiBHZXQgdGhlIHNldCBvZiBjdXJyZW50bHkgdHJhY2tlZCByYW5nZSByZWZzIG9mIHRoZSBlZGl0b3IuXHJcbiAgICovXG4gIHJhbmdlUmVmczogZnVuY3Rpb24gcmFuZ2VSZWZzKGVkaXRvcikge1xuICAgIHZhciByZWZzID0gUkFOR0VfUkVGUy5nZXQoZWRpdG9yKTtcblxuICAgIGlmICghcmVmcykge1xuICAgICAgcmVmcyA9IG5ldyBTZXQoKTtcbiAgICAgIFJBTkdFX1JFRlMuc2V0KGVkaXRvciwgcmVmcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlZnM7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogUmVtb3ZlIGEgY3VzdG9tIHByb3BlcnR5IGZyb20gYWxsIG9mIHRoZSBsZWFmIHRleHQgbm9kZXMgaW4gdGhlIGN1cnJlbnRcclxuICAgKiBzZWxlY3Rpb24uXHJcbiAgICpcclxuICAgKiBJZiB0aGUgc2VsZWN0aW9uIGlzIGN1cnJlbnRseSBjb2xsYXBzZWQsIHRoZSByZW1vdmFsIHdpbGwgYmUgc3RvcmVkIG9uXHJcbiAgICogYGVkaXRvci5tYXJrc2AgYW5kIGFwcGxpZWQgdG8gdGhlIHRleHQgaW5zZXJ0ZWQgbmV4dC5cclxuICAgKi9cbiAgcmVtb3ZlTWFyazogZnVuY3Rpb24gcmVtb3ZlTWFyayhlZGl0b3IsIGtleSkge1xuICAgIGVkaXRvci5yZW1vdmVNYXJrKGtleSk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogTWFudWFsbHkgc2V0IGlmIHRoZSBlZGl0b3Igc2hvdWxkIGN1cnJlbnRseSBiZSBub3JtYWxpemluZy5cclxuICAgKlxyXG4gICAqIE5vdGU6IFVzaW5nIHRoaXMgaW5jb3JyZWN0bHkgY2FuIGxlYXZlIHRoZSBlZGl0b3IgaW4gYW4gaW52YWxpZCBzdGF0ZS5cclxuICAgKlxyXG4gICAqL1xuICBzZXROb3JtYWxpemluZzogZnVuY3Rpb24gc2V0Tm9ybWFsaXppbmcoZWRpdG9yLCBpc05vcm1hbGl6aW5nKSB7XG4gICAgTk9STUFMSVpJTkcuc2V0KGVkaXRvciwgaXNOb3JtYWxpemluZyk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogR2V0IHRoZSBzdGFydCBwb2ludCBvZiBhIGxvY2F0aW9uLlxyXG4gICAqL1xuICBzdGFydDogZnVuY3Rpb24gc3RhcnQoZWRpdG9yLCBhdCkge1xuICAgIHJldHVybiBFZGl0b3IucG9pbnQoZWRpdG9yLCBhdCwge1xuICAgICAgZWRnZTogJ3N0YXJ0J1xuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgdGV4dCBzdHJpbmcgY29udGVudCBvZiBhIGxvY2F0aW9uLlxyXG4gICAqXHJcbiAgICogTm90ZTogYnkgZGVmYXVsdCB0aGUgdGV4dCBvZiB2b2lkIG5vZGVzIGlzIGNvbnNpZGVyZWQgdG8gYmUgYW4gZW1wdHlcclxuICAgKiBzdHJpbmcsIHJlZ2FyZGxlc3Mgb2YgY29udGVudCwgdW5sZXNzIHlvdSBwYXNzIGluIHRydWUgZm9yIHRoZSB2b2lkcyBvcHRpb25cclxuICAgKi9cbiAgc3RyaW5nOiBmdW5jdGlvbiBzdHJpbmcoZWRpdG9yLCBhdCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICB2YXIgX29wdGlvbnMkdm9pZHM3ID0gb3B0aW9ucy52b2lkcyxcbiAgICAgICAgdm9pZHMgPSBfb3B0aW9ucyR2b2lkczcgPT09IHZvaWQgMCA/IGZhbHNlIDogX29wdGlvbnMkdm9pZHM3O1xuICAgIHZhciByYW5nZSA9IEVkaXRvci5yYW5nZShlZGl0b3IsIGF0KTtcblxuICAgIHZhciBfUmFuZ2UkZWRnZXM1ID0gUmFuZ2UuZWRnZXMocmFuZ2UpLFxuICAgICAgICBfUmFuZ2UkZWRnZXM2ID0gX3NsaWNlZFRvQXJyYXkoX1JhbmdlJGVkZ2VzNSwgMiksXG4gICAgICAgIHN0YXJ0ID0gX1JhbmdlJGVkZ2VzNlswXSxcbiAgICAgICAgZW5kID0gX1JhbmdlJGVkZ2VzNlsxXTtcblxuICAgIHZhciB0ZXh0ID0gJyc7XG5cbiAgICB2YXIgX2l0ZXJhdG9yOCA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDUoRWRpdG9yLm5vZGVzKGVkaXRvciwge1xuICAgICAgYXQ6IHJhbmdlLFxuICAgICAgbWF0Y2g6IFRleHQuaXNUZXh0LFxuICAgICAgdm9pZHM6IHZvaWRzXG4gICAgfSkpLFxuICAgICAgICBfc3RlcDg7XG5cbiAgICB0cnkge1xuICAgICAgZm9yIChfaXRlcmF0b3I4LnMoKTsgIShfc3RlcDggPSBfaXRlcmF0b3I4Lm4oKSkuZG9uZTspIHtcbiAgICAgICAgdmFyIF9zdGVwOCR2YWx1ZSA9IF9zbGljZWRUb0FycmF5KF9zdGVwOC52YWx1ZSwgMiksXG4gICAgICAgICAgICBub2RlID0gX3N0ZXA4JHZhbHVlWzBdLFxuICAgICAgICAgICAgcGF0aCA9IF9zdGVwOCR2YWx1ZVsxXTtcblxuICAgICAgICB2YXIgdCA9IG5vZGUudGV4dDtcblxuICAgICAgICBpZiAoUGF0aC5lcXVhbHMocGF0aCwgZW5kLnBhdGgpKSB7XG4gICAgICAgICAgdCA9IHQuc2xpY2UoMCwgZW5kLm9mZnNldCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoUGF0aC5lcXVhbHMocGF0aCwgc3RhcnQucGF0aCkpIHtcbiAgICAgICAgICB0ID0gdC5zbGljZShzdGFydC5vZmZzZXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGV4dCArPSB0O1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgX2l0ZXJhdG9yOC5lKGVycik7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIF9pdGVyYXRvcjguZigpO1xuICAgIH1cblxuICAgIHJldHVybiB0ZXh0O1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENvbnZlcnQgYSByYW5nZSBpbnRvIGEgbm9uLWhhbmdpbmcgb25lLlxyXG4gICAqL1xuICB1bmhhbmdSYW5nZTogZnVuY3Rpb24gdW5oYW5nUmFuZ2UoZWRpdG9yLCByYW5nZSkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICB2YXIgX29wdGlvbnMkdm9pZHM4ID0gb3B0aW9ucy52b2lkcyxcbiAgICAgICAgdm9pZHMgPSBfb3B0aW9ucyR2b2lkczggPT09IHZvaWQgMCA/IGZhbHNlIDogX29wdGlvbnMkdm9pZHM4O1xuXG4gICAgdmFyIF9SYW5nZSRlZGdlczcgPSBSYW5nZS5lZGdlcyhyYW5nZSksXG4gICAgICAgIF9SYW5nZSRlZGdlczggPSBfc2xpY2VkVG9BcnJheShfUmFuZ2UkZWRnZXM3LCAyKSxcbiAgICAgICAgc3RhcnQgPSBfUmFuZ2UkZWRnZXM4WzBdLFxuICAgICAgICBlbmQgPSBfUmFuZ2UkZWRnZXM4WzFdOyAvLyBQRVJGOiBleGl0IGVhcmx5IGlmIHdlIGNhbiBndWFyYW50ZWUgdGhhdCB0aGUgcmFuZ2UgaXNuJ3QgaGFuZ2luZy5cblxuXG4gICAgaWYgKHN0YXJ0Lm9mZnNldCAhPT0gMCB8fCBlbmQub2Zmc2V0ICE9PSAwIHx8IFJhbmdlLmlzQ29sbGFwc2VkKHJhbmdlKSB8fCBQYXRoLmhhc1ByZXZpb3VzKGVuZC5wYXRoKSkge1xuICAgICAgcmV0dXJuIHJhbmdlO1xuICAgIH1cblxuICAgIHZhciBlbmRCbG9jayA9IEVkaXRvci5hYm92ZShlZGl0b3IsIHtcbiAgICAgIGF0OiBlbmQsXG4gICAgICBtYXRjaDogZnVuY3Rpb24gbWF0Y2gobikge1xuICAgICAgICByZXR1cm4gRWxlbWVudC5pc0VsZW1lbnQobikgJiYgRWRpdG9yLmlzQmxvY2soZWRpdG9yLCBuKTtcbiAgICAgIH0sXG4gICAgICB2b2lkczogdm9pZHNcbiAgICB9KTtcbiAgICB2YXIgYmxvY2tQYXRoID0gZW5kQmxvY2sgPyBlbmRCbG9ja1sxXSA6IFtdO1xuICAgIHZhciBmaXJzdCA9IEVkaXRvci5zdGFydChlZGl0b3IsIHN0YXJ0KTtcbiAgICB2YXIgYmVmb3JlID0ge1xuICAgICAgYW5jaG9yOiBmaXJzdCxcbiAgICAgIGZvY3VzOiBlbmRcbiAgICB9O1xuICAgIHZhciBza2lwID0gdHJ1ZTtcblxuICAgIHZhciBfaXRlcmF0b3I5ID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkNShFZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgICBhdDogYmVmb3JlLFxuICAgICAgbWF0Y2g6IFRleHQuaXNUZXh0LFxuICAgICAgcmV2ZXJzZTogdHJ1ZSxcbiAgICAgIHZvaWRzOiB2b2lkc1xuICAgIH0pKSxcbiAgICAgICAgX3N0ZXA5O1xuXG4gICAgdHJ5IHtcbiAgICAgIGZvciAoX2l0ZXJhdG9yOS5zKCk7ICEoX3N0ZXA5ID0gX2l0ZXJhdG9yOS5uKCkpLmRvbmU7KSB7XG4gICAgICAgIHZhciBfc3RlcDkkdmFsdWUgPSBfc2xpY2VkVG9BcnJheShfc3RlcDkudmFsdWUsIDIpLFxuICAgICAgICAgICAgbm9kZSA9IF9zdGVwOSR2YWx1ZVswXSxcbiAgICAgICAgICAgIHBhdGggPSBfc3RlcDkkdmFsdWVbMV07XG5cbiAgICAgICAgaWYgKHNraXApIHtcbiAgICAgICAgICBza2lwID0gZmFsc2U7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobm9kZS50ZXh0ICE9PSAnJyB8fCBQYXRoLmlzQmVmb3JlKHBhdGgsIGJsb2NrUGF0aCkpIHtcbiAgICAgICAgICBlbmQgPSB7XG4gICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgb2Zmc2V0OiBub2RlLnRleHQubGVuZ3RoXG4gICAgICAgICAgfTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgX2l0ZXJhdG9yOS5lKGVycik7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIF9pdGVyYXRvcjkuZigpO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBhbmNob3I6IHN0YXJ0LFxuICAgICAgZm9jdXM6IGVuZFxuICAgIH07XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogTWF0Y2ggYSB2b2lkIG5vZGUgaW4gdGhlIGN1cnJlbnQgYnJhbmNoIG9mIHRoZSBlZGl0b3IuXHJcbiAgICovXG4gIFwidm9pZFwiOiBmdW5jdGlvbiBfdm9pZChlZGl0b3IpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgcmV0dXJuIEVkaXRvci5hYm92ZShlZGl0b3IsIF9vYmplY3RTcHJlYWQkOChfb2JqZWN0U3ByZWFkJDgoe30sIG9wdGlvbnMpLCB7fSwge1xuICAgICAgbWF0Y2g6IGZ1bmN0aW9uIG1hdGNoKG4pIHtcbiAgICAgICAgcmV0dXJuIEVsZW1lbnQuaXNFbGVtZW50KG4pICYmIEVkaXRvci5pc1ZvaWQoZWRpdG9yLCBuKTtcbiAgICAgIH1cbiAgICB9KSk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2FsbCBhIGZ1bmN0aW9uLCBkZWZlcnJpbmcgbm9ybWFsaXphdGlvbiB1bnRpbCBhZnRlciBpdCBjb21wbGV0ZXMuXHJcbiAgICovXG4gIHdpdGhvdXROb3JtYWxpemluZzogZnVuY3Rpb24gd2l0aG91dE5vcm1hbGl6aW5nKGVkaXRvciwgZm4pIHtcbiAgICB2YXIgdmFsdWUgPSBFZGl0b3IuaXNOb3JtYWxpemluZyhlZGl0b3IpO1xuICAgIEVkaXRvci5zZXROb3JtYWxpemluZyhlZGl0b3IsIGZhbHNlKTtcblxuICAgIHRyeSB7XG4gICAgICBmbigpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBFZGl0b3Iuc2V0Tm9ybWFsaXppbmcoZWRpdG9yLCB2YWx1ZSk7XG4gICAgfVxuXG4gICAgRWRpdG9yLm5vcm1hbGl6ZShlZGl0b3IpO1xuICB9XG59O1xuXG52YXIgTG9jYXRpb24gPSB7XG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgdmFsdWUgaW1wbGVtZW50cyB0aGUgYExvY2F0aW9uYCBpbnRlcmZhY2UuXHJcbiAgICovXG4gIGlzTG9jYXRpb246IGZ1bmN0aW9uIGlzTG9jYXRpb24odmFsdWUpIHtcbiAgICByZXR1cm4gUGF0aC5pc1BhdGgodmFsdWUpIHx8IFBvaW50LmlzUG9pbnQodmFsdWUpIHx8IFJhbmdlLmlzUmFuZ2UodmFsdWUpO1xuICB9XG59OyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVkZWNsYXJlXG5cbnZhciBTcGFuID0ge1xuICAvKipcclxuICAgKiBDaGVjayBpZiBhIHZhbHVlIGltcGxlbWVudHMgdGhlIGBTcGFuYCBpbnRlcmZhY2UuXHJcbiAgICovXG4gIGlzU3BhbjogZnVuY3Rpb24gaXNTcGFuKHZhbHVlKSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsdWUpICYmIHZhbHVlLmxlbmd0aCA9PT0gMiAmJiB2YWx1ZS5ldmVyeShQYXRoLmlzUGF0aCk7XG4gIH1cbn07XG5cbnZhciBfZXhjbHVkZWQkMyA9IFtcImNoaWxkcmVuXCJdLFxuICAgIF9leGNsdWRlZDIkMiA9IFtcInRleHRcIl07XG5cbmZ1bmN0aW9uIF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDQobywgYWxsb3dBcnJheUxpa2UpIHsgdmFyIGl0ID0gdHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl0gfHwgb1tcIkBAaXRlcmF0b3JcIl07IGlmICghaXQpIHsgaWYgKEFycmF5LmlzQXJyYXkobykgfHwgKGl0ID0gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5JDQobykpIHx8IGFsbG93QXJyYXlMaWtlICYmIG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSB7IGlmIChpdCkgbyA9IGl0OyB2YXIgaSA9IDA7IHZhciBGID0gZnVuY3Rpb24gRigpIHt9OyByZXR1cm4geyBzOiBGLCBuOiBmdW5jdGlvbiBuKCkgeyBpZiAoaSA+PSBvLmxlbmd0aCkgcmV0dXJuIHsgZG9uZTogdHJ1ZSB9OyByZXR1cm4geyBkb25lOiBmYWxzZSwgdmFsdWU6IG9baSsrXSB9OyB9LCBlOiBmdW5jdGlvbiBlKF9lKSB7IHRocm93IF9lOyB9LCBmOiBGIH07IH0gdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9IHZhciBub3JtYWxDb21wbGV0aW9uID0gdHJ1ZSwgZGlkRXJyID0gZmFsc2UsIGVycjsgcmV0dXJuIHsgczogZnVuY3Rpb24gcygpIHsgaXQgPSBpdC5jYWxsKG8pOyB9LCBuOiBmdW5jdGlvbiBuKCkgeyB2YXIgc3RlcCA9IGl0Lm5leHQoKTsgbm9ybWFsQ29tcGxldGlvbiA9IHN0ZXAuZG9uZTsgcmV0dXJuIHN0ZXA7IH0sIGU6IGZ1bmN0aW9uIGUoX2UyKSB7IGRpZEVyciA9IHRydWU7IGVyciA9IF9lMjsgfSwgZjogZnVuY3Rpb24gZigpIHsgdHJ5IHsgaWYgKCFub3JtYWxDb21wbGV0aW9uICYmIGl0W1wicmV0dXJuXCJdICE9IG51bGwpIGl0W1wicmV0dXJuXCJdKCk7IH0gZmluYWxseSB7IGlmIChkaWRFcnIpIHRocm93IGVycjsgfSB9IH07IH1cblxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5JDQobywgbWluTGVuKSB7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheSQ0KG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkkNChvLCBtaW5MZW4pOyB9XG5cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5JDQoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgeyBhcnIyW2ldID0gYXJyW2ldOyB9IHJldHVybiBhcnIyOyB9XG52YXIgSVNfTk9ERV9MSVNUX0NBQ0hFID0gbmV3IFdlYWtNYXAoKTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlZGVjbGFyZVxuXG52YXIgTm9kZSA9IHtcbiAgLyoqXHJcbiAgICogR2V0IHRoZSBub2RlIGF0IGEgc3BlY2lmaWMgcGF0aCwgYXNzZXJ0aW5nIHRoYXQgaXQncyBhbiBhbmNlc3RvciBub2RlLlxyXG4gICAqL1xuICBhbmNlc3RvcjogZnVuY3Rpb24gYW5jZXN0b3Iocm9vdCwgcGF0aCkge1xuICAgIHZhciBub2RlID0gTm9kZS5nZXQocm9vdCwgcGF0aCk7XG5cbiAgICBpZiAoVGV4dC5pc1RleHQobm9kZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBnZXQgdGhlIGFuY2VzdG9yIG5vZGUgYXQgcGF0aCBbXCIuY29uY2F0KHBhdGgsIFwiXSBiZWNhdXNlIGl0IHJlZmVycyB0byBhIHRleHQgbm9kZSBpbnN0ZWFkOiBcIikuY29uY2F0KFNjcnViYmVyLnN0cmluZ2lmeShub2RlKSkpO1xuICAgIH1cblxuICAgIHJldHVybiBub2RlO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIFJldHVybiBhIGdlbmVyYXRvciBvZiBhbGwgdGhlIGFuY2VzdG9yIG5vZGVzIGFib3ZlIGEgc3BlY2lmaWMgcGF0aC5cclxuICAgKlxyXG4gICAqIEJ5IGRlZmF1bHQgdGhlIG9yZGVyIGlzIHRvcC1kb3duLCBmcm9tIGhpZ2hlc3QgdG8gbG93ZXN0IGFuY2VzdG9yIGluXHJcbiAgICogdGhlIHRyZWUsIGJ1dCB5b3UgY2FuIHBhc3MgdGhlIGByZXZlcnNlOiB0cnVlYCBvcHRpb24gdG8gZ28gYm90dG9tLXVwLlxyXG4gICAqL1xuICBhbmNlc3RvcnM6IGZ1bmN0aW9uKiBhbmNlc3RvcnMocm9vdCwgcGF0aCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcblxuICAgIHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciQ0KFBhdGguYW5jZXN0b3JzKHBhdGgsIG9wdGlvbnMpKSxcbiAgICAgICAgX3N0ZXA7XG5cbiAgICB0cnkge1xuICAgICAgZm9yIChfaXRlcmF0b3IucygpOyAhKF9zdGVwID0gX2l0ZXJhdG9yLm4oKSkuZG9uZTspIHtcbiAgICAgICAgdmFyIHAgPSBfc3RlcC52YWx1ZTtcbiAgICAgICAgdmFyIG4gPSBOb2RlLmFuY2VzdG9yKHJvb3QsIHApO1xuICAgICAgICB2YXIgZW50cnkgPSBbbiwgcF07XG4gICAgICAgIHlpZWxkIGVudHJ5O1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgX2l0ZXJhdG9yLmUoZXJyKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgX2l0ZXJhdG9yLmYoKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogR2V0IHRoZSBjaGlsZCBvZiBhIG5vZGUgYXQgYSBzcGVjaWZpYyBpbmRleC5cclxuICAgKi9cbiAgY2hpbGQ6IGZ1bmN0aW9uIGNoaWxkKHJvb3QsIGluZGV4KSB7XG4gICAgaWYgKFRleHQuaXNUZXh0KHJvb3QpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZ2V0IHRoZSBjaGlsZCBvZiBhIHRleHQgbm9kZTogXCIuY29uY2F0KFNjcnViYmVyLnN0cmluZ2lmeShyb290KSkpO1xuICAgIH1cblxuICAgIHZhciBjID0gcm9vdC5jaGlsZHJlbltpbmRleF07XG5cbiAgICBpZiAoYyA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZ2V0IGNoaWxkIGF0IGluZGV4IGBcIi5jb25jYXQoaW5kZXgsIFwiYCBpbiBub2RlOiBcIikuY29uY2F0KFNjcnViYmVyLnN0cmluZ2lmeShyb290KSkpO1xuICAgIH1cblxuICAgIHJldHVybiBjO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEl0ZXJhdGUgb3ZlciB0aGUgY2hpbGRyZW4gb2YgYSBub2RlIGF0IGEgc3BlY2lmaWMgcGF0aC5cclxuICAgKi9cbiAgY2hpbGRyZW46IGZ1bmN0aW9uKiBjaGlsZHJlbihyb290LCBwYXRoKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIHZhciBfb3B0aW9ucyRyZXZlcnNlID0gb3B0aW9ucy5yZXZlcnNlLFxuICAgICAgICByZXZlcnNlID0gX29wdGlvbnMkcmV2ZXJzZSA9PT0gdm9pZCAwID8gZmFsc2UgOiBfb3B0aW9ucyRyZXZlcnNlO1xuICAgIHZhciBhbmNlc3RvciA9IE5vZGUuYW5jZXN0b3Iocm9vdCwgcGF0aCk7XG4gICAgdmFyIGNoaWxkcmVuID0gYW5jZXN0b3IuY2hpbGRyZW47XG4gICAgdmFyIGluZGV4ID0gcmV2ZXJzZSA/IGNoaWxkcmVuLmxlbmd0aCAtIDEgOiAwO1xuXG4gICAgd2hpbGUgKHJldmVyc2UgPyBpbmRleCA+PSAwIDogaW5kZXggPCBjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgIHZhciBjaGlsZCA9IE5vZGUuY2hpbGQoYW5jZXN0b3IsIGluZGV4KTtcbiAgICAgIHZhciBjaGlsZFBhdGggPSBwYXRoLmNvbmNhdChpbmRleCk7XG4gICAgICB5aWVsZCBbY2hpbGQsIGNoaWxkUGF0aF07XG4gICAgICBpbmRleCA9IHJldmVyc2UgPyBpbmRleCAtIDEgOiBpbmRleCArIDE7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxyXG4gICAqIEdldCBhbiBlbnRyeSBmb3IgdGhlIGNvbW1vbiBhbmNlc2V0b3Igbm9kZSBvZiB0d28gcGF0aHMuXHJcbiAgICovXG4gIGNvbW1vbjogZnVuY3Rpb24gY29tbW9uKHJvb3QsIHBhdGgsIGFub3RoZXIpIHtcbiAgICB2YXIgcCA9IFBhdGguY29tbW9uKHBhdGgsIGFub3RoZXIpO1xuICAgIHZhciBuID0gTm9kZS5nZXQocm9vdCwgcCk7XG4gICAgcmV0dXJuIFtuLCBwXTtcbiAgfSxcblxuICAvKipcclxuICAgKiBHZXQgdGhlIG5vZGUgYXQgYSBzcGVjaWZpYyBwYXRoLCBhc3NlcnRpbmcgdGhhdCBpdCdzIGEgZGVzY2VuZGFudCBub2RlLlxyXG4gICAqL1xuICBkZXNjZW5kYW50OiBmdW5jdGlvbiBkZXNjZW5kYW50KHJvb3QsIHBhdGgpIHtcbiAgICB2YXIgbm9kZSA9IE5vZGUuZ2V0KHJvb3QsIHBhdGgpO1xuXG4gICAgaWYgKEVkaXRvci5pc0VkaXRvcihub2RlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGdldCB0aGUgZGVzY2VuZGFudCBub2RlIGF0IHBhdGggW1wiLmNvbmNhdChwYXRoLCBcIl0gYmVjYXVzZSBpdCByZWZlcnMgdG8gdGhlIHJvb3QgZWRpdG9yIG5vZGUgaW5zdGVhZDogXCIpLmNvbmNhdChTY3J1YmJlci5zdHJpbmdpZnkobm9kZSkpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbm9kZTtcbiAgfSxcblxuICAvKipcclxuICAgKiBSZXR1cm4gYSBnZW5lcmF0b3Igb2YgYWxsIHRoZSBkZXNjZW5kYW50IG5vZGUgZW50cmllcyBpbnNpZGUgYSByb290IG5vZGUuXHJcbiAgICovXG4gIGRlc2NlbmRhbnRzOiBmdW5jdGlvbiogZGVzY2VuZGFudHMocm9vdCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICAgIHZhciBfaXRlcmF0b3IyID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkNChOb2RlLm5vZGVzKHJvb3QsIG9wdGlvbnMpKSxcbiAgICAgICAgX3N0ZXAyO1xuXG4gICAgdHJ5IHtcbiAgICAgIGZvciAoX2l0ZXJhdG9yMi5zKCk7ICEoX3N0ZXAyID0gX2l0ZXJhdG9yMi5uKCkpLmRvbmU7KSB7XG4gICAgICAgIHZhciBfc3RlcDIkdmFsdWUgPSBfc2xpY2VkVG9BcnJheShfc3RlcDIudmFsdWUsIDIpLFxuICAgICAgICAgICAgbm9kZSA9IF9zdGVwMiR2YWx1ZVswXSxcbiAgICAgICAgICAgIHBhdGggPSBfc3RlcDIkdmFsdWVbMV07XG5cbiAgICAgICAgaWYgKHBhdGgubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgLy8gTk9URTogd2UgaGF2ZSB0byBjb2VyY2UgaGVyZSBiZWNhdXNlIGNoZWNraW5nIHRoZSBwYXRoJ3MgbGVuZ3RoIGRvZXNcbiAgICAgICAgICAvLyBndWFyYW50ZWUgdGhhdCBgbm9kZWAgaXMgbm90IGEgYEVkaXRvcmAsIGJ1dCBUeXBlU2NyaXB0IGRvZXNuJ3Qga25vdy5cbiAgICAgICAgICB5aWVsZCBbbm9kZSwgcGF0aF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIF9pdGVyYXRvcjIuZShlcnIpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBfaXRlcmF0b3IyLmYoKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogUmV0dXJuIGEgZ2VuZXJhdG9yIG9mIGFsbCB0aGUgZWxlbWVudCBub2RlcyBpbnNpZGUgYSByb290IG5vZGUuIEVhY2ggaXRlcmF0aW9uXHJcbiAgICogd2lsbCByZXR1cm4gYW4gYEVsZW1lbnRFbnRyeWAgdHVwbGUgY29uc2lzdGluZyBvZiBgW0VsZW1lbnQsIFBhdGhdYC4gSWYgdGhlXHJcbiAgICogcm9vdCBub2RlIGlzIGFuIGVsZW1lbnQgaXQgd2lsbCBiZSBpbmNsdWRlZCBpbiB0aGUgaXRlcmF0aW9uIGFzIHdlbGwuXHJcbiAgICovXG4gIGVsZW1lbnRzOiBmdW5jdGlvbiogZWxlbWVudHMocm9vdCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICAgIHZhciBfaXRlcmF0b3IzID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkNChOb2RlLm5vZGVzKHJvb3QsIG9wdGlvbnMpKSxcbiAgICAgICAgX3N0ZXAzO1xuXG4gICAgdHJ5IHtcbiAgICAgIGZvciAoX2l0ZXJhdG9yMy5zKCk7ICEoX3N0ZXAzID0gX2l0ZXJhdG9yMy5uKCkpLmRvbmU7KSB7XG4gICAgICAgIHZhciBfc3RlcDMkdmFsdWUgPSBfc2xpY2VkVG9BcnJheShfc3RlcDMudmFsdWUsIDIpLFxuICAgICAgICAgICAgbm9kZSA9IF9zdGVwMyR2YWx1ZVswXSxcbiAgICAgICAgICAgIHBhdGggPSBfc3RlcDMkdmFsdWVbMV07XG5cbiAgICAgICAgaWYgKEVsZW1lbnQuaXNFbGVtZW50KG5vZGUpKSB7XG4gICAgICAgICAgeWllbGQgW25vZGUsIHBhdGhdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBfaXRlcmF0b3IzLmUoZXJyKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgX2l0ZXJhdG9yMy5mKCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxyXG4gICAqIEV4dHJhY3QgcHJvcHMgZnJvbSBhIE5vZGUuXHJcbiAgICovXG4gIGV4dHJhY3RQcm9wczogZnVuY3Rpb24gZXh0cmFjdFByb3BzKG5vZGUpIHtcbiAgICBpZiAoRWxlbWVudC5pc0FuY2VzdG9yKG5vZGUpKSB7XG4gICAgICBub2RlLmNoaWxkcmVuO1xuICAgICAgICAgIHZhciBwcm9wZXJ0aWVzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKG5vZGUsIF9leGNsdWRlZCQzKTtcblxuICAgICAgcmV0dXJuIHByb3BlcnRpZXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGUudGV4dDtcbiAgICAgICAgICB2YXIgX3Byb3BlcnRpZXMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMobm9kZSwgX2V4Y2x1ZGVkMiQyKTtcblxuICAgICAgcmV0dXJuIF9wcm9wZXJ0aWVzO1xuICAgIH1cbiAgfSxcblxuICAvKipcclxuICAgKiBHZXQgdGhlIGZpcnN0IG5vZGUgZW50cnkgaW4gYSByb290IG5vZGUgZnJvbSBhIHBhdGguXHJcbiAgICovXG4gIGZpcnN0OiBmdW5jdGlvbiBmaXJzdChyb290LCBwYXRoKSB7XG4gICAgdmFyIHAgPSBwYXRoLnNsaWNlKCk7XG4gICAgdmFyIG4gPSBOb2RlLmdldChyb290LCBwKTtcblxuICAgIHdoaWxlIChuKSB7XG4gICAgICBpZiAoVGV4dC5pc1RleHQobikgfHwgbi5jaGlsZHJlbi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuID0gbi5jaGlsZHJlblswXTtcbiAgICAgICAgcC5wdXNoKDApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBbbiwgcF07XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogR2V0IHRoZSBzbGljZWQgZnJhZ21lbnQgcmVwcmVzZW50ZWQgYnkgYSByYW5nZSBpbnNpZGUgYSByb290IG5vZGUuXHJcbiAgICovXG4gIGZyYWdtZW50OiBmdW5jdGlvbiBmcmFnbWVudChyb290LCByYW5nZSkge1xuICAgIGlmIChUZXh0LmlzVGV4dChyb290KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGdldCBhIGZyYWdtZW50IHN0YXJ0aW5nIGZyb20gYSByb290IHRleHQgbm9kZTogXCIuY29uY2F0KFNjcnViYmVyLnN0cmluZ2lmeShyb290KSkpO1xuICAgIH1cblxuICAgIHZhciBuZXdSb290ID0gaW1tZXIucHJvZHVjZSh7XG4gICAgICBjaGlsZHJlbjogcm9vdC5jaGlsZHJlblxuICAgIH0sIGZ1bmN0aW9uIChyKSB7XG4gICAgICB2YXIgX1JhbmdlJGVkZ2VzID0gUmFuZ2UuZWRnZXMocmFuZ2UpLFxuICAgICAgICAgIF9SYW5nZSRlZGdlczIgPSBfc2xpY2VkVG9BcnJheShfUmFuZ2UkZWRnZXMsIDIpLFxuICAgICAgICAgIHN0YXJ0ID0gX1JhbmdlJGVkZ2VzMlswXSxcbiAgICAgICAgICBlbmQgPSBfUmFuZ2UkZWRnZXMyWzFdO1xuXG4gICAgICB2YXIgbm9kZUVudHJpZXMgPSBOb2RlLm5vZGVzKHIsIHtcbiAgICAgICAgcmV2ZXJzZTogdHJ1ZSxcbiAgICAgICAgcGFzczogZnVuY3Rpb24gcGFzcyhfcmVmKSB7XG4gICAgICAgICAgdmFyIF9yZWYyID0gX3NsaWNlZFRvQXJyYXkoX3JlZiwgMiksXG4gICAgICAgICAgICAgIHBhdGggPSBfcmVmMlsxXTtcblxuICAgICAgICAgIHJldHVybiAhUmFuZ2UuaW5jbHVkZXMocmFuZ2UsIHBhdGgpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgdmFyIF9pdGVyYXRvcjQgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciQ0KG5vZGVFbnRyaWVzKSxcbiAgICAgICAgICBfc3RlcDQ7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoX2l0ZXJhdG9yNC5zKCk7ICEoX3N0ZXA0ID0gX2l0ZXJhdG9yNC5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgdmFyIF9zdGVwNCR2YWx1ZSA9IF9zbGljZWRUb0FycmF5KF9zdGVwNC52YWx1ZSwgMiksXG4gICAgICAgICAgICAgIHBhdGggPSBfc3RlcDQkdmFsdWVbMV07XG5cbiAgICAgICAgICBpZiAoIVJhbmdlLmluY2x1ZGVzKHJhbmdlLCBwYXRoKSkge1xuICAgICAgICAgICAgdmFyIHBhcmVudCA9IE5vZGUucGFyZW50KHIsIHBhdGgpO1xuICAgICAgICAgICAgdmFyIGluZGV4ID0gcGF0aFtwYXRoLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgcGFyZW50LmNoaWxkcmVuLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKFBhdGguZXF1YWxzKHBhdGgsIGVuZC5wYXRoKSkge1xuICAgICAgICAgICAgdmFyIGxlYWYgPSBOb2RlLmxlYWYociwgcGF0aCk7XG4gICAgICAgICAgICBsZWFmLnRleHQgPSBsZWFmLnRleHQuc2xpY2UoMCwgZW5kLm9mZnNldCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKFBhdGguZXF1YWxzKHBhdGgsIHN0YXJ0LnBhdGgpKSB7XG4gICAgICAgICAgICB2YXIgX2xlYWYgPSBOb2RlLmxlYWYociwgcGF0aCk7XG5cbiAgICAgICAgICAgIF9sZWFmLnRleHQgPSBfbGVhZi50ZXh0LnNsaWNlKHN0YXJ0Lm9mZnNldCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2l0ZXJhdG9yNC5lKGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBfaXRlcmF0b3I0LmYoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKEVkaXRvci5pc0VkaXRvcihyKSkge1xuICAgICAgICByLnNlbGVjdGlvbiA9IG51bGw7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIG5ld1Jvb3QuY2hpbGRyZW47XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogR2V0IHRoZSBkZXNjZW5kYW50IG5vZGUgcmVmZXJyZWQgdG8gYnkgYSBzcGVjaWZpYyBwYXRoLiBJZiB0aGUgcGF0aCBpcyBhblxyXG4gICAqIGVtcHR5IGFycmF5LCBpdCByZWZlcnMgdG8gdGhlIHJvb3Qgbm9kZSBpdHNlbGYuXHJcbiAgICovXG4gIGdldDogZnVuY3Rpb24gZ2V0KHJvb3QsIHBhdGgpIHtcbiAgICB2YXIgbm9kZSA9IHJvb3Q7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdGgubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBwID0gcGF0aFtpXTtcblxuICAgICAgaWYgKFRleHQuaXNUZXh0KG5vZGUpIHx8ICFub2RlLmNoaWxkcmVuW3BdKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIGEgZGVzY2VuZGFudCBhdCBwYXRoIFtcIi5jb25jYXQocGF0aCwgXCJdIGluIG5vZGU6IFwiKS5jb25jYXQoU2NydWJiZXIuc3RyaW5naWZ5KHJvb3QpKSk7XG4gICAgICB9XG5cbiAgICAgIG5vZGUgPSBub2RlLmNoaWxkcmVuW3BdO1xuICAgIH1cblxuICAgIHJldHVybiBub2RlO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgZGVzY2VuZGFudCBub2RlIGV4aXN0cyBhdCBhIHNwZWNpZmljIHBhdGguXHJcbiAgICovXG4gIGhhczogZnVuY3Rpb24gaGFzKHJvb3QsIHBhdGgpIHtcbiAgICB2YXIgbm9kZSA9IHJvb3Q7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdGgubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBwID0gcGF0aFtpXTtcblxuICAgICAgaWYgKFRleHQuaXNUZXh0KG5vZGUpIHx8ICFub2RlLmNoaWxkcmVuW3BdKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgbm9kZSA9IG5vZGUuY2hpbGRyZW5bcF07XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSB2YWx1ZSBpbXBsZW1lbnRzIHRoZSBgTm9kZWAgaW50ZXJmYWNlLlxyXG4gICAqL1xuICBpc05vZGU6IGZ1bmN0aW9uIGlzTm9kZSh2YWx1ZSkge1xuICAgIHJldHVybiBUZXh0LmlzVGV4dCh2YWx1ZSkgfHwgRWxlbWVudC5pc0VsZW1lbnQodmFsdWUpIHx8IEVkaXRvci5pc0VkaXRvcih2YWx1ZSk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSB2YWx1ZSBpcyBhIGxpc3Qgb2YgYE5vZGVgIG9iamVjdHMuXHJcbiAgICovXG4gIGlzTm9kZUxpc3Q6IGZ1bmN0aW9uIGlzTm9kZUxpc3QodmFsdWUpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIGNhY2hlZFJlc3VsdCA9IElTX05PREVfTElTVF9DQUNIRS5nZXQodmFsdWUpO1xuXG4gICAgaWYgKGNhY2hlZFJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gY2FjaGVkUmVzdWx0O1xuICAgIH1cblxuICAgIHZhciBpc05vZGVMaXN0ID0gdmFsdWUuZXZlcnkoZnVuY3Rpb24gKHZhbCkge1xuICAgICAgcmV0dXJuIE5vZGUuaXNOb2RlKHZhbCk7XG4gICAgfSk7XG4gICAgSVNfTk9ERV9MSVNUX0NBQ0hFLnNldCh2YWx1ZSwgaXNOb2RlTGlzdCk7XG4gICAgcmV0dXJuIGlzTm9kZUxpc3Q7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogR2V0IHRoZSBsYXN0IG5vZGUgZW50cnkgaW4gYSByb290IG5vZGUgZnJvbSBhIHBhdGguXHJcbiAgICovXG4gIGxhc3Q6IGZ1bmN0aW9uIGxhc3Qocm9vdCwgcGF0aCkge1xuICAgIHZhciBwID0gcGF0aC5zbGljZSgpO1xuICAgIHZhciBuID0gTm9kZS5nZXQocm9vdCwgcCk7XG5cbiAgICB3aGlsZSAobikge1xuICAgICAgaWYgKFRleHQuaXNUZXh0KG4pIHx8IG4uY2hpbGRyZW4ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGkgPSBuLmNoaWxkcmVuLmxlbmd0aCAtIDE7XG4gICAgICAgIG4gPSBuLmNoaWxkcmVuW2ldO1xuICAgICAgICBwLnB1c2goaSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIFtuLCBwXTtcbiAgfSxcblxuICAvKipcclxuICAgKiBHZXQgdGhlIG5vZGUgYXQgYSBzcGVjaWZpYyBwYXRoLCBlbnN1cmluZyBpdCdzIGEgbGVhZiB0ZXh0IG5vZGUuXHJcbiAgICovXG4gIGxlYWY6IGZ1bmN0aW9uIGxlYWYocm9vdCwgcGF0aCkge1xuICAgIHZhciBub2RlID0gTm9kZS5nZXQocm9vdCwgcGF0aCk7XG5cbiAgICBpZiAoIVRleHQuaXNUZXh0KG5vZGUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZ2V0IHRoZSBsZWFmIG5vZGUgYXQgcGF0aCBbXCIuY29uY2F0KHBhdGgsIFwiXSBiZWNhdXNlIGl0IHJlZmVycyB0byBhIG5vbi1sZWFmIG5vZGU6IFwiKS5jb25jYXQoU2NydWJiZXIuc3RyaW5naWZ5KG5vZGUpKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGU7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogUmV0dXJuIGEgZ2VuZXJhdG9yIG9mIHRoZSBpbiBhIGJyYW5jaCBvZiB0aGUgdHJlZSwgZnJvbSBhIHNwZWNpZmljIHBhdGguXHJcbiAgICpcclxuICAgKiBCeSBkZWZhdWx0IHRoZSBvcmRlciBpcyB0b3AtZG93biwgZnJvbSBoaWdoZXN0IHRvIGxvd2VzdCBub2RlIGluIHRoZSB0cmVlLFxyXG4gICAqIGJ1dCB5b3UgY2FuIHBhc3MgdGhlIGByZXZlcnNlOiB0cnVlYCBvcHRpb24gdG8gZ28gYm90dG9tLXVwLlxyXG4gICAqL1xuICBsZXZlbHM6IGZ1bmN0aW9uKiBsZXZlbHMocm9vdCwgcGF0aCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcblxuICAgIHZhciBfaXRlcmF0b3I1ID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkNChQYXRoLmxldmVscyhwYXRoLCBvcHRpb25zKSksXG4gICAgICAgIF9zdGVwNTtcblxuICAgIHRyeSB7XG4gICAgICBmb3IgKF9pdGVyYXRvcjUucygpOyAhKF9zdGVwNSA9IF9pdGVyYXRvcjUubigpKS5kb25lOykge1xuICAgICAgICB2YXIgcCA9IF9zdGVwNS52YWx1ZTtcbiAgICAgICAgdmFyIG4gPSBOb2RlLmdldChyb290LCBwKTtcbiAgICAgICAgeWllbGQgW24sIHBdO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgX2l0ZXJhdG9yNS5lKGVycik7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIF9pdGVyYXRvcjUuZigpO1xuICAgIH1cbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhIG5vZGUgbWF0Y2hlcyBhIHNldCBvZiBwcm9wcy5cclxuICAgKi9cbiAgbWF0Y2hlczogZnVuY3Rpb24gbWF0Y2hlcyhub2RlLCBwcm9wcykge1xuICAgIHJldHVybiBFbGVtZW50LmlzRWxlbWVudChub2RlKSAmJiBFbGVtZW50LmlzRWxlbWVudFByb3BzKHByb3BzKSAmJiBFbGVtZW50Lm1hdGNoZXMobm9kZSwgcHJvcHMpIHx8IFRleHQuaXNUZXh0KG5vZGUpICYmIFRleHQuaXNUZXh0UHJvcHMocHJvcHMpICYmIFRleHQubWF0Y2hlcyhub2RlLCBwcm9wcyk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogUmV0dXJuIGEgZ2VuZXJhdG9yIG9mIGFsbCB0aGUgbm9kZSBlbnRyaWVzIG9mIGEgcm9vdCBub2RlLiBFYWNoIGVudHJ5IGlzXHJcbiAgICogcmV0dXJuZWQgYXMgYSBgW05vZGUsIFBhdGhdYCB0dXBsZSwgd2l0aCB0aGUgcGF0aCByZWZlcnJpbmcgdG8gdGhlIG5vZGUnc1xyXG4gICAqIHBvc2l0aW9uIGluc2lkZSB0aGUgcm9vdCBub2RlLlxyXG4gICAqL1xuICBub2RlczogZnVuY3Rpb24qIG5vZGVzKHJvb3QpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgdmFyIHBhc3MgPSBvcHRpb25zLnBhc3MsXG4gICAgICAgIF9vcHRpb25zJHJldmVyc2UyID0gb3B0aW9ucy5yZXZlcnNlLFxuICAgICAgICByZXZlcnNlID0gX29wdGlvbnMkcmV2ZXJzZTIgPT09IHZvaWQgMCA/IGZhbHNlIDogX29wdGlvbnMkcmV2ZXJzZTI7XG4gICAgdmFyIF9vcHRpb25zJGZyb20gPSBvcHRpb25zLmZyb20sXG4gICAgICAgIGZyb20gPSBfb3B0aW9ucyRmcm9tID09PSB2b2lkIDAgPyBbXSA6IF9vcHRpb25zJGZyb20sXG4gICAgICAgIHRvID0gb3B0aW9ucy50bztcbiAgICB2YXIgdmlzaXRlZCA9IG5ldyBTZXQoKTtcbiAgICB2YXIgcCA9IFtdO1xuICAgIHZhciBuID0gcm9vdDtcblxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBpZiAodG8gJiYgKHJldmVyc2UgPyBQYXRoLmlzQmVmb3JlKHAsIHRvKSA6IFBhdGguaXNBZnRlcihwLCB0bykpKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXZpc2l0ZWQuaGFzKG4pKSB7XG4gICAgICAgIHlpZWxkIFtuLCBwXTtcbiAgICAgIH0gLy8gSWYgd2UncmUgYWxsb3dlZCB0byBnbyBkb3dud2FyZCBhbmQgd2UgaGF2ZW4ndCBkZXNjZW5kZWQgeWV0LCBkby5cblxuXG4gICAgICBpZiAoIXZpc2l0ZWQuaGFzKG4pICYmICFUZXh0LmlzVGV4dChuKSAmJiBuLmNoaWxkcmVuLmxlbmd0aCAhPT0gMCAmJiAocGFzcyA9PSBudWxsIHx8IHBhc3MoW24sIHBdKSA9PT0gZmFsc2UpKSB7XG4gICAgICAgIHZpc2l0ZWQuYWRkKG4pO1xuICAgICAgICB2YXIgbmV4dEluZGV4ID0gcmV2ZXJzZSA/IG4uY2hpbGRyZW4ubGVuZ3RoIC0gMSA6IDA7XG5cbiAgICAgICAgaWYgKFBhdGguaXNBbmNlc3RvcihwLCBmcm9tKSkge1xuICAgICAgICAgIG5leHRJbmRleCA9IGZyb21bcC5sZW5ndGhdO1xuICAgICAgICB9XG5cbiAgICAgICAgcCA9IHAuY29uY2F0KG5leHRJbmRleCk7XG4gICAgICAgIG4gPSBOb2RlLmdldChyb290LCBwKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IC8vIElmIHdlJ3JlIGF0IHRoZSByb290IGFuZCB3ZSBjYW4ndCBnbyBkb3duLCB3ZSdyZSBkb25lLlxuXG5cbiAgICAgIGlmIChwLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH0gLy8gSWYgd2UncmUgZ29pbmcgZm9yd2FyZC4uLlxuXG5cbiAgICAgIGlmICghcmV2ZXJzZSkge1xuICAgICAgICB2YXIgbmV3UGF0aCA9IFBhdGgubmV4dChwKTtcblxuICAgICAgICBpZiAoTm9kZS5oYXMocm9vdCwgbmV3UGF0aCkpIHtcbiAgICAgICAgICBwID0gbmV3UGF0aDtcbiAgICAgICAgICBuID0gTm9kZS5nZXQocm9vdCwgcCk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gSWYgd2UncmUgZ29pbmcgYmFja3dhcmQuLi5cblxuXG4gICAgICBpZiAocmV2ZXJzZSAmJiBwW3AubGVuZ3RoIC0gMV0gIT09IDApIHtcbiAgICAgICAgdmFyIF9uZXdQYXRoID0gUGF0aC5wcmV2aW91cyhwKTtcblxuICAgICAgICBwID0gX25ld1BhdGg7XG4gICAgICAgIG4gPSBOb2RlLmdldChyb290LCBwKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IC8vIE90aGVyd2lzZSB3ZSdyZSBnb2luZyB1cHdhcmQuLi5cblxuXG4gICAgICBwID0gUGF0aC5wYXJlbnQocCk7XG4gICAgICBuID0gTm9kZS5nZXQocm9vdCwgcCk7XG4gICAgICB2aXNpdGVkLmFkZChuKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogR2V0IHRoZSBwYXJlbnQgb2YgYSBub2RlIGF0IGEgc3BlY2lmaWMgcGF0aC5cclxuICAgKi9cbiAgcGFyZW50OiBmdW5jdGlvbiBwYXJlbnQocm9vdCwgcGF0aCkge1xuICAgIHZhciBwYXJlbnRQYXRoID0gUGF0aC5wYXJlbnQocGF0aCk7XG4gICAgdmFyIHAgPSBOb2RlLmdldChyb290LCBwYXJlbnRQYXRoKTtcblxuICAgIGlmIChUZXh0LmlzVGV4dChwKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGdldCB0aGUgcGFyZW50IG9mIHBhdGggW1wiLmNvbmNhdChwYXRoLCBcIl0gYmVjYXVzZSBpdCBkb2VzIG5vdCBleGlzdCBpbiB0aGUgcm9vdC5cIikpO1xuICAgIH1cblxuICAgIHJldHVybiBwO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgY29uY2F0ZW5hdGVkIHRleHQgc3RyaW5nIG9mIGEgbm9kZSdzIGNvbnRlbnQuXHJcbiAgICpcclxuICAgKiBOb3RlIHRoYXQgdGhpcyB3aWxsIG5vdCBpbmNsdWRlIHNwYWNlcyBvciBsaW5lIGJyZWFrcyBiZXR3ZWVuIGJsb2NrIG5vZGVzLlxyXG4gICAqIEl0IGlzIG5vdCBhIHVzZXItZmFjaW5nIHN0cmluZywgYnV0IGEgc3RyaW5nIGZvciBwZXJmb3JtaW5nIG9mZnNldC1yZWxhdGVkXHJcbiAgICogY29tcHV0YXRpb25zIGZvciBhIG5vZGUuXHJcbiAgICovXG4gIHN0cmluZzogZnVuY3Rpb24gc3RyaW5nKG5vZGUpIHtcbiAgICBpZiAoVGV4dC5pc1RleHQobm9kZSkpIHtcbiAgICAgIHJldHVybiBub2RlLnRleHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBub2RlLmNoaWxkcmVuLm1hcChOb2RlLnN0cmluZykuam9pbignJyk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxyXG4gICAqIFJldHVybiBhIGdlbmVyYXRvciBvZiBhbGwgbGVhZiB0ZXh0IG5vZGVzIGluIGEgcm9vdCBub2RlLlxyXG4gICAqL1xuICB0ZXh0czogZnVuY3Rpb24qIHRleHRzKHJvb3QpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgICB2YXIgX2l0ZXJhdG9yNiA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDQoTm9kZS5ub2Rlcyhyb290LCBvcHRpb25zKSksXG4gICAgICAgIF9zdGVwNjtcblxuICAgIHRyeSB7XG4gICAgICBmb3IgKF9pdGVyYXRvcjYucygpOyAhKF9zdGVwNiA9IF9pdGVyYXRvcjYubigpKS5kb25lOykge1xuICAgICAgICB2YXIgX3N0ZXA2JHZhbHVlID0gX3NsaWNlZFRvQXJyYXkoX3N0ZXA2LnZhbHVlLCAyKSxcbiAgICAgICAgICAgIG5vZGUgPSBfc3RlcDYkdmFsdWVbMF0sXG4gICAgICAgICAgICBwYXRoID0gX3N0ZXA2JHZhbHVlWzFdO1xuXG4gICAgICAgIGlmIChUZXh0LmlzVGV4dChub2RlKSkge1xuICAgICAgICAgIHlpZWxkIFtub2RlLCBwYXRoXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgX2l0ZXJhdG9yNi5lKGVycik7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIF9pdGVyYXRvcjYuZigpO1xuICAgIH1cbiAgfVxufTtcblxuZnVuY3Rpb24gb3duS2V5cyQ3KG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgaWYgKGVudW1lcmFibGVPbmx5KSB7IHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KTsgfSBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCQ3KHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgaWYgKGkgJSAyKSB7IG93bktleXMkNyhPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBvd25LZXlzJDcoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbnZhciBPcGVyYXRpb24gPSB7XG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgdmFsdWUgaXMgYSBgTm9kZU9wZXJhdGlvbmAgb2JqZWN0LlxyXG4gICAqL1xuICBpc05vZGVPcGVyYXRpb246IGZ1bmN0aW9uIGlzTm9kZU9wZXJhdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiBPcGVyYXRpb24uaXNPcGVyYXRpb24odmFsdWUpICYmIHZhbHVlLnR5cGUuZW5kc1dpdGgoJ19ub2RlJyk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSB2YWx1ZSBpcyBhbiBgT3BlcmF0aW9uYCBvYmplY3QuXHJcbiAgICovXG4gIGlzT3BlcmF0aW9uOiBmdW5jdGlvbiBpc09wZXJhdGlvbih2YWx1ZSkge1xuICAgIGlmICghaXNQbGFpbk9iamVjdC5pc1BsYWluT2JqZWN0KHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHN3aXRjaCAodmFsdWUudHlwZSkge1xuICAgICAgY2FzZSAnaW5zZXJ0X25vZGUnOlxuICAgICAgICByZXR1cm4gUGF0aC5pc1BhdGgodmFsdWUucGF0aCkgJiYgTm9kZS5pc05vZGUodmFsdWUubm9kZSk7XG5cbiAgICAgIGNhc2UgJ2luc2VydF90ZXh0JzpcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZS5vZmZzZXQgPT09ICdudW1iZXInICYmIHR5cGVvZiB2YWx1ZS50ZXh0ID09PSAnc3RyaW5nJyAmJiBQYXRoLmlzUGF0aCh2YWx1ZS5wYXRoKTtcblxuICAgICAgY2FzZSAnbWVyZ2Vfbm9kZSc6XG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUucG9zaXRpb24gPT09ICdudW1iZXInICYmIFBhdGguaXNQYXRoKHZhbHVlLnBhdGgpICYmIGlzUGxhaW5PYmplY3QuaXNQbGFpbk9iamVjdCh2YWx1ZS5wcm9wZXJ0aWVzKTtcblxuICAgICAgY2FzZSAnbW92ZV9ub2RlJzpcbiAgICAgICAgcmV0dXJuIFBhdGguaXNQYXRoKHZhbHVlLnBhdGgpICYmIFBhdGguaXNQYXRoKHZhbHVlLm5ld1BhdGgpO1xuXG4gICAgICBjYXNlICdyZW1vdmVfbm9kZSc6XG4gICAgICAgIHJldHVybiBQYXRoLmlzUGF0aCh2YWx1ZS5wYXRoKSAmJiBOb2RlLmlzTm9kZSh2YWx1ZS5ub2RlKTtcblxuICAgICAgY2FzZSAncmVtb3ZlX3RleHQnOlxuICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlLm9mZnNldCA9PT0gJ251bWJlcicgJiYgdHlwZW9mIHZhbHVlLnRleHQgPT09ICdzdHJpbmcnICYmIFBhdGguaXNQYXRoKHZhbHVlLnBhdGgpO1xuXG4gICAgICBjYXNlICdzZXRfbm9kZSc6XG4gICAgICAgIHJldHVybiBQYXRoLmlzUGF0aCh2YWx1ZS5wYXRoKSAmJiBpc1BsYWluT2JqZWN0LmlzUGxhaW5PYmplY3QodmFsdWUucHJvcGVydGllcykgJiYgaXNQbGFpbk9iamVjdC5pc1BsYWluT2JqZWN0KHZhbHVlLm5ld1Byb3BlcnRpZXMpO1xuXG4gICAgICBjYXNlICdzZXRfc2VsZWN0aW9uJzpcbiAgICAgICAgcmV0dXJuIHZhbHVlLnByb3BlcnRpZXMgPT09IG51bGwgJiYgUmFuZ2UuaXNSYW5nZSh2YWx1ZS5uZXdQcm9wZXJ0aWVzKSB8fCB2YWx1ZS5uZXdQcm9wZXJ0aWVzID09PSBudWxsICYmIFJhbmdlLmlzUmFuZ2UodmFsdWUucHJvcGVydGllcykgfHwgaXNQbGFpbk9iamVjdC5pc1BsYWluT2JqZWN0KHZhbHVlLnByb3BlcnRpZXMpICYmIGlzUGxhaW5PYmplY3QuaXNQbGFpbk9iamVjdCh2YWx1ZS5uZXdQcm9wZXJ0aWVzKTtcblxuICAgICAgY2FzZSAnc3BsaXRfbm9kZSc6XG4gICAgICAgIHJldHVybiBQYXRoLmlzUGF0aCh2YWx1ZS5wYXRoKSAmJiB0eXBlb2YgdmFsdWUucG9zaXRpb24gPT09ICdudW1iZXInICYmIGlzUGxhaW5PYmplY3QuaXNQbGFpbk9iamVjdCh2YWx1ZS5wcm9wZXJ0aWVzKTtcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhIHZhbHVlIGlzIGEgbGlzdCBvZiBgT3BlcmF0aW9uYCBvYmplY3RzLlxyXG4gICAqL1xuICBpc09wZXJhdGlvbkxpc3Q6IGZ1bmN0aW9uIGlzT3BlcmF0aW9uTGlzdCh2YWx1ZSkge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKSAmJiB2YWx1ZS5ldmVyeShmdW5jdGlvbiAodmFsKSB7XG4gICAgICByZXR1cm4gT3BlcmF0aW9uLmlzT3BlcmF0aW9uKHZhbCk7XG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSB2YWx1ZSBpcyBhIGBTZWxlY3Rpb25PcGVyYXRpb25gIG9iamVjdC5cclxuICAgKi9cbiAgaXNTZWxlY3Rpb25PcGVyYXRpb246IGZ1bmN0aW9uIGlzU2VsZWN0aW9uT3BlcmF0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIE9wZXJhdGlvbi5pc09wZXJhdGlvbih2YWx1ZSkgJiYgdmFsdWUudHlwZS5lbmRzV2l0aCgnX3NlbGVjdGlvbicpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgdmFsdWUgaXMgYSBgVGV4dE9wZXJhdGlvbmAgb2JqZWN0LlxyXG4gICAqL1xuICBpc1RleHRPcGVyYXRpb246IGZ1bmN0aW9uIGlzVGV4dE9wZXJhdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiBPcGVyYXRpb24uaXNPcGVyYXRpb24odmFsdWUpICYmIHZhbHVlLnR5cGUuZW5kc1dpdGgoJ190ZXh0Jyk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogSW52ZXJ0IGFuIG9wZXJhdGlvbiwgcmV0dXJuaW5nIGEgbmV3IG9wZXJhdGlvbiB0aGF0IHdpbGwgZXhhY3RseSB1bmRvIHRoZVxyXG4gICAqIG9yaWdpbmFsIHdoZW4gYXBwbGllZC5cclxuICAgKi9cbiAgaW52ZXJzZTogZnVuY3Rpb24gaW52ZXJzZShvcCkge1xuICAgIHN3aXRjaCAob3AudHlwZSkge1xuICAgICAgY2FzZSAnaW5zZXJ0X25vZGUnOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQkNyhfb2JqZWN0U3ByZWFkJDcoe30sIG9wKSwge30sIHtcbiAgICAgICAgICAgIHR5cGU6ICdyZW1vdmVfbm9kZSdcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlICdpbnNlcnRfdGV4dCc6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gX29iamVjdFNwcmVhZCQ3KF9vYmplY3RTcHJlYWQkNyh7fSwgb3ApLCB7fSwge1xuICAgICAgICAgICAgdHlwZTogJ3JlbW92ZV90ZXh0J1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgJ21lcmdlX25vZGUnOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQkNyhfb2JqZWN0U3ByZWFkJDcoe30sIG9wKSwge30sIHtcbiAgICAgICAgICAgIHR5cGU6ICdzcGxpdF9ub2RlJyxcbiAgICAgICAgICAgIHBhdGg6IFBhdGgucHJldmlvdXMob3AucGF0aClcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlICdtb3ZlX25vZGUnOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIG5ld1BhdGggPSBvcC5uZXdQYXRoLFxuICAgICAgICAgICAgICBwYXRoID0gb3AucGF0aDsgLy8gUEVSRjogaW4gdGhpcyBjYXNlIHRoZSBtb3ZlIG9wZXJhdGlvbiBpcyBhIG5vLW9wIGFueXdheXMuXG5cbiAgICAgICAgICBpZiAoUGF0aC5lcXVhbHMobmV3UGF0aCwgcGF0aCkpIHtcbiAgICAgICAgICAgIHJldHVybiBvcDtcbiAgICAgICAgICB9IC8vIElmIHRoZSBtb3ZlIGhhcHBlbnMgY29tcGxldGVseSB3aXRoaW4gYSBzaW5nbGUgcGFyZW50IHRoZSBwYXRoIGFuZFxuICAgICAgICAgIC8vIG5ld1BhdGggYXJlIHN0YWJsZSB3aXRoIHJlc3BlY3QgdG8gZWFjaCBvdGhlci5cblxuXG4gICAgICAgICAgaWYgKFBhdGguaXNTaWJsaW5nKHBhdGgsIG5ld1BhdGgpKSB7XG4gICAgICAgICAgICByZXR1cm4gX29iamVjdFNwcmVhZCQ3KF9vYmplY3RTcHJlYWQkNyh7fSwgb3ApLCB7fSwge1xuICAgICAgICAgICAgICBwYXRoOiBuZXdQYXRoLFxuICAgICAgICAgICAgICBuZXdQYXRoOiBwYXRoXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IC8vIElmIHRoZSBtb3ZlIGRvZXMgbm90IGhhcHBlbiB3aXRoaW4gYSBzaW5nbGUgcGFyZW50IGl0IGlzIHBvc3NpYmxlXG4gICAgICAgICAgLy8gZm9yIHRoZSBtb3ZlIHRvIGltcGFjdCB0aGUgdHJ1ZSBwYXRoIHRvIHRoZSBsb2NhdGlvbiB3aGVyZSB0aGUgbm9kZVxuICAgICAgICAgIC8vIHdhcyByZW1vdmVkIGZyb20gYW5kIHdoZXJlIGl0IHdhcyBpbnNlcnRlZC4gV2UgaGF2ZSB0byBhZGp1c3QgZm9yIHRoaXNcbiAgICAgICAgICAvLyBhbmQgZmluZCB0aGUgb3JpZ2luYWwgcGF0aC4gV2UgY2FuIGFjY29tcGxpc2ggdGhpcyAob25seSBpbiBub24tc2libGluZylcbiAgICAgICAgICAvLyBtb3ZlcyBieSBsb29raW5nIGF0IHRoZSBpbXBhY3Qgb2YgdGhlIG1vdmUgb3BlcmF0aW9uIG9uIHRoZSBub2RlXG4gICAgICAgICAgLy8gYWZ0ZXIgdGhlIG9yaWdpbmFsIG1vdmUgcGF0aC5cblxuXG4gICAgICAgICAgdmFyIGludmVyc2VQYXRoID0gUGF0aC50cmFuc2Zvcm0ocGF0aCwgb3ApO1xuICAgICAgICAgIHZhciBpbnZlcnNlTmV3UGF0aCA9IFBhdGgudHJhbnNmb3JtKFBhdGgubmV4dChwYXRoKSwgb3ApO1xuICAgICAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkJDcoX29iamVjdFNwcmVhZCQ3KHt9LCBvcCksIHt9LCB7XG4gICAgICAgICAgICBwYXRoOiBpbnZlcnNlUGF0aCxcbiAgICAgICAgICAgIG5ld1BhdGg6IGludmVyc2VOZXdQYXRoXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSAncmVtb3ZlX25vZGUnOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQkNyhfb2JqZWN0U3ByZWFkJDcoe30sIG9wKSwge30sIHtcbiAgICAgICAgICAgIHR5cGU6ICdpbnNlcnRfbm9kZSdcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlICdyZW1vdmVfdGV4dCc6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gX29iamVjdFNwcmVhZCQ3KF9vYmplY3RTcHJlYWQkNyh7fSwgb3ApLCB7fSwge1xuICAgICAgICAgICAgdHlwZTogJ2luc2VydF90ZXh0J1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgJ3NldF9ub2RlJzpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBwcm9wZXJ0aWVzID0gb3AucHJvcGVydGllcyxcbiAgICAgICAgICAgICAgbmV3UHJvcGVydGllcyA9IG9wLm5ld1Byb3BlcnRpZXM7XG4gICAgICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQkNyhfb2JqZWN0U3ByZWFkJDcoe30sIG9wKSwge30sIHtcbiAgICAgICAgICAgIHByb3BlcnRpZXM6IG5ld1Byb3BlcnRpZXMsXG4gICAgICAgICAgICBuZXdQcm9wZXJ0aWVzOiBwcm9wZXJ0aWVzXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSAnc2V0X3NlbGVjdGlvbic6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgX3Byb3BlcnRpZXMgPSBvcC5wcm9wZXJ0aWVzLFxuICAgICAgICAgICAgICBfbmV3UHJvcGVydGllcyA9IG9wLm5ld1Byb3BlcnRpZXM7XG5cbiAgICAgICAgICBpZiAoX3Byb3BlcnRpZXMgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQkNyhfb2JqZWN0U3ByZWFkJDcoe30sIG9wKSwge30sIHtcbiAgICAgICAgICAgICAgcHJvcGVydGllczogX25ld1Byb3BlcnRpZXMsXG4gICAgICAgICAgICAgIG5ld1Byb3BlcnRpZXM6IG51bGxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSBpZiAoX25ld1Byb3BlcnRpZXMgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQkNyhfb2JqZWN0U3ByZWFkJDcoe30sIG9wKSwge30sIHtcbiAgICAgICAgICAgICAgcHJvcGVydGllczogbnVsbCxcbiAgICAgICAgICAgICAgbmV3UHJvcGVydGllczogX3Byb3BlcnRpZXNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gX29iamVjdFNwcmVhZCQ3KF9vYmplY3RTcHJlYWQkNyh7fSwgb3ApLCB7fSwge1xuICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiBfbmV3UHJvcGVydGllcyxcbiAgICAgICAgICAgICAgbmV3UHJvcGVydGllczogX3Byb3BlcnRpZXNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICBjYXNlICdzcGxpdF9ub2RlJzpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkJDcoX29iamVjdFNwcmVhZCQ3KHt9LCBvcCksIHt9LCB7XG4gICAgICAgICAgICB0eXBlOiAnbWVyZ2Vfbm9kZScsXG4gICAgICAgICAgICBwYXRoOiBQYXRoLm5leHQob3AucGF0aClcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlZGVjbGFyZVxudmFyIFBhdGggPSB7XG4gIC8qKlxyXG4gICAqIEdldCBhIGxpc3Qgb2YgYW5jZXN0b3IgcGF0aHMgZm9yIGEgZ2l2ZW4gcGF0aC5cclxuICAgKlxyXG4gICAqIFRoZSBwYXRocyBhcmUgc29ydGVkIGZyb20gc2hhbGxvd2VzdCB0byBkZWVwZXN0IGFuY2VzdG9yLiBIb3dldmVyLCBpZiB0aGVcclxuICAgKiBgcmV2ZXJzZTogdHJ1ZWAgb3B0aW9uIGlzIHBhc3NlZCwgdGhleSBhcmUgcmV2ZXJzZWQuXHJcbiAgICovXG4gIGFuY2VzdG9yczogZnVuY3Rpb24gYW5jZXN0b3JzKHBhdGgpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgdmFyIF9vcHRpb25zJHJldmVyc2UgPSBvcHRpb25zLnJldmVyc2UsXG4gICAgICAgIHJldmVyc2UgPSBfb3B0aW9ucyRyZXZlcnNlID09PSB2b2lkIDAgPyBmYWxzZSA6IF9vcHRpb25zJHJldmVyc2U7XG4gICAgdmFyIHBhdGhzID0gUGF0aC5sZXZlbHMocGF0aCwgb3B0aW9ucyk7XG5cbiAgICBpZiAocmV2ZXJzZSkge1xuICAgICAgcGF0aHMgPSBwYXRocy5zbGljZSgxKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGF0aHMgPSBwYXRocy5zbGljZSgwLCAtMSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhdGhzO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgY29tbW9uIGFuY2VzdG9yIHBhdGggb2YgdHdvIHBhdGhzLlxyXG4gICAqL1xuICBjb21tb246IGZ1bmN0aW9uIGNvbW1vbihwYXRoLCBhbm90aGVyKSB7XG4gICAgdmFyIGNvbW1vbiA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXRoLmxlbmd0aCAmJiBpIDwgYW5vdGhlci5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGF2ID0gcGF0aFtpXTtcbiAgICAgIHZhciBidiA9IGFub3RoZXJbaV07XG5cbiAgICAgIGlmIChhdiAhPT0gYnYpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGNvbW1vbi5wdXNoKGF2KTtcbiAgICB9XG5cbiAgICByZXR1cm4gY29tbW9uO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENvbXBhcmUgYSBwYXRoIHRvIGFub3RoZXIsIHJldHVybmluZyBhbiBpbnRlZ2VyIGluZGljYXRpbmcgd2hldGhlciB0aGUgcGF0aFxyXG4gICAqIHdhcyBiZWZvcmUsIGF0LCBvciBhZnRlciB0aGUgb3RoZXIuXHJcbiAgICpcclxuICAgKiBOb3RlOiBUd28gcGF0aHMgb2YgdW5lcXVhbCBsZW5ndGggY2FuIHN0aWxsIHJlY2VpdmUgYSBgMGAgcmVzdWx0IGlmIG9uZSBpc1xyXG4gICAqIGRpcmVjdGx5IGFib3ZlIG9yIGJlbG93IHRoZSBvdGhlci4gSWYgeW91IHdhbnQgZXhhY3QgbWF0Y2hpbmcsIHVzZVxyXG4gICAqIFtbUGF0aC5lcXVhbHNdXSBpbnN0ZWFkLlxyXG4gICAqL1xuICBjb21wYXJlOiBmdW5jdGlvbiBjb21wYXJlKHBhdGgsIGFub3RoZXIpIHtcbiAgICB2YXIgbWluID0gTWF0aC5taW4ocGF0aC5sZW5ndGgsIGFub3RoZXIubGVuZ3RoKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWluOyBpKyspIHtcbiAgICAgIGlmIChwYXRoW2ldIDwgYW5vdGhlcltpXSkgcmV0dXJuIC0xO1xuICAgICAgaWYgKHBhdGhbaV0gPiBhbm90aGVyW2ldKSByZXR1cm4gMTtcbiAgICB9XG5cbiAgICByZXR1cm4gMDtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhIHBhdGggZW5kcyBhZnRlciBvbmUgb2YgdGhlIGluZGV4ZXMgaW4gYW5vdGhlci5cclxuICAgKi9cbiAgZW5kc0FmdGVyOiBmdW5jdGlvbiBlbmRzQWZ0ZXIocGF0aCwgYW5vdGhlcikge1xuICAgIHZhciBpID0gcGF0aC5sZW5ndGggLSAxO1xuICAgIHZhciBhcyA9IHBhdGguc2xpY2UoMCwgaSk7XG4gICAgdmFyIGJzID0gYW5vdGhlci5zbGljZSgwLCBpKTtcbiAgICB2YXIgYXYgPSBwYXRoW2ldO1xuICAgIHZhciBidiA9IGFub3RoZXJbaV07XG4gICAgcmV0dXJuIFBhdGguZXF1YWxzKGFzLCBicykgJiYgYXYgPiBidjtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhIHBhdGggZW5kcyBhdCBvbmUgb2YgdGhlIGluZGV4ZXMgaW4gYW5vdGhlci5cclxuICAgKi9cbiAgZW5kc0F0OiBmdW5jdGlvbiBlbmRzQXQocGF0aCwgYW5vdGhlcikge1xuICAgIHZhciBpID0gcGF0aC5sZW5ndGg7XG4gICAgdmFyIGFzID0gcGF0aC5zbGljZSgwLCBpKTtcbiAgICB2YXIgYnMgPSBhbm90aGVyLnNsaWNlKDAsIGkpO1xuICAgIHJldHVybiBQYXRoLmVxdWFscyhhcywgYnMpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgcGF0aCBlbmRzIGJlZm9yZSBvbmUgb2YgdGhlIGluZGV4ZXMgaW4gYW5vdGhlci5cclxuICAgKi9cbiAgZW5kc0JlZm9yZTogZnVuY3Rpb24gZW5kc0JlZm9yZShwYXRoLCBhbm90aGVyKSB7XG4gICAgdmFyIGkgPSBwYXRoLmxlbmd0aCAtIDE7XG4gICAgdmFyIGFzID0gcGF0aC5zbGljZSgwLCBpKTtcbiAgICB2YXIgYnMgPSBhbm90aGVyLnNsaWNlKDAsIGkpO1xuICAgIHZhciBhdiA9IHBhdGhbaV07XG4gICAgdmFyIGJ2ID0gYW5vdGhlcltpXTtcbiAgICByZXR1cm4gUGF0aC5lcXVhbHMoYXMsIGJzKSAmJiBhdiA8IGJ2O1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgcGF0aCBpcyBleGFjdGx5IGVxdWFsIHRvIGFub3RoZXIuXHJcbiAgICovXG4gIGVxdWFsczogZnVuY3Rpb24gZXF1YWxzKHBhdGgsIGFub3RoZXIpIHtcbiAgICByZXR1cm4gcGF0aC5sZW5ndGggPT09IGFub3RoZXIubGVuZ3RoICYmIHBhdGguZXZlcnkoZnVuY3Rpb24gKG4sIGkpIHtcbiAgICAgIHJldHVybiBuID09PSBhbm90aGVyW2ldO1xuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIHRoZSBwYXRoIG9mIHByZXZpb3VzIHNpYmxpbmcgbm9kZSBleGlzdHNcclxuICAgKi9cbiAgaGFzUHJldmlvdXM6IGZ1bmN0aW9uIGhhc1ByZXZpb3VzKHBhdGgpIHtcbiAgICByZXR1cm4gcGF0aFtwYXRoLmxlbmd0aCAtIDFdID4gMDtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhIHBhdGggaXMgYWZ0ZXIgYW5vdGhlci5cclxuICAgKi9cbiAgaXNBZnRlcjogZnVuY3Rpb24gaXNBZnRlcihwYXRoLCBhbm90aGVyKSB7XG4gICAgcmV0dXJuIFBhdGguY29tcGFyZShwYXRoLCBhbm90aGVyKSA9PT0gMTtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhIHBhdGggaXMgYW4gYW5jZXN0b3Igb2YgYW5vdGhlci5cclxuICAgKi9cbiAgaXNBbmNlc3RvcjogZnVuY3Rpb24gaXNBbmNlc3RvcihwYXRoLCBhbm90aGVyKSB7XG4gICAgcmV0dXJuIHBhdGgubGVuZ3RoIDwgYW5vdGhlci5sZW5ndGggJiYgUGF0aC5jb21wYXJlKHBhdGgsIGFub3RoZXIpID09PSAwO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgcGF0aCBpcyBiZWZvcmUgYW5vdGhlci5cclxuICAgKi9cbiAgaXNCZWZvcmU6IGZ1bmN0aW9uIGlzQmVmb3JlKHBhdGgsIGFub3RoZXIpIHtcbiAgICByZXR1cm4gUGF0aC5jb21wYXJlKHBhdGgsIGFub3RoZXIpID09PSAtMTtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhIHBhdGggaXMgYSBjaGlsZCBvZiBhbm90aGVyLlxyXG4gICAqL1xuICBpc0NoaWxkOiBmdW5jdGlvbiBpc0NoaWxkKHBhdGgsIGFub3RoZXIpIHtcbiAgICByZXR1cm4gcGF0aC5sZW5ndGggPT09IGFub3RoZXIubGVuZ3RoICsgMSAmJiBQYXRoLmNvbXBhcmUocGF0aCwgYW5vdGhlcikgPT09IDA7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSBwYXRoIGlzIGVxdWFsIHRvIG9yIGFuIGFuY2VzdG9yIG9mIGFub3RoZXIuXHJcbiAgICovXG4gIGlzQ29tbW9uOiBmdW5jdGlvbiBpc0NvbW1vbihwYXRoLCBhbm90aGVyKSB7XG4gICAgcmV0dXJuIHBhdGgubGVuZ3RoIDw9IGFub3RoZXIubGVuZ3RoICYmIFBhdGguY29tcGFyZShwYXRoLCBhbm90aGVyKSA9PT0gMDtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhIHBhdGggaXMgYSBkZXNjZW5kYW50IG9mIGFub3RoZXIuXHJcbiAgICovXG4gIGlzRGVzY2VuZGFudDogZnVuY3Rpb24gaXNEZXNjZW5kYW50KHBhdGgsIGFub3RoZXIpIHtcbiAgICByZXR1cm4gcGF0aC5sZW5ndGggPiBhbm90aGVyLmxlbmd0aCAmJiBQYXRoLmNvbXBhcmUocGF0aCwgYW5vdGhlcikgPT09IDA7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSBwYXRoIGlzIHRoZSBwYXJlbnQgb2YgYW5vdGhlci5cclxuICAgKi9cbiAgaXNQYXJlbnQ6IGZ1bmN0aW9uIGlzUGFyZW50KHBhdGgsIGFub3RoZXIpIHtcbiAgICByZXR1cm4gcGF0aC5sZW5ndGggKyAxID09PSBhbm90aGVyLmxlbmd0aCAmJiBQYXRoLmNvbXBhcmUocGF0aCwgYW5vdGhlcikgPT09IDA7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaXMgYSB2YWx1ZSBpbXBsZW1lbnRzIHRoZSBgUGF0aGAgaW50ZXJmYWNlLlxyXG4gICAqL1xuICBpc1BhdGg6IGZ1bmN0aW9uIGlzUGF0aCh2YWx1ZSkge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKSAmJiAodmFsdWUubGVuZ3RoID09PSAwIHx8IHR5cGVvZiB2YWx1ZVswXSA9PT0gJ251bWJlcicpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgcGF0aCBpcyBhIHNpYmxpbmcgb2YgYW5vdGhlci5cclxuICAgKi9cbiAgaXNTaWJsaW5nOiBmdW5jdGlvbiBpc1NpYmxpbmcocGF0aCwgYW5vdGhlcikge1xuICAgIGlmIChwYXRoLmxlbmd0aCAhPT0gYW5vdGhlci5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgYXMgPSBwYXRoLnNsaWNlKDAsIC0xKTtcbiAgICB2YXIgYnMgPSBhbm90aGVyLnNsaWNlKDAsIC0xKTtcbiAgICB2YXIgYWwgPSBwYXRoW3BhdGgubGVuZ3RoIC0gMV07XG4gICAgdmFyIGJsID0gYW5vdGhlclthbm90aGVyLmxlbmd0aCAtIDFdO1xuICAgIHJldHVybiBhbCAhPT0gYmwgJiYgUGF0aC5lcXVhbHMoYXMsIGJzKTtcbiAgfSxcblxuICAvKipcclxuICAgKiBHZXQgYSBsaXN0IG9mIHBhdGhzIGF0IGV2ZXJ5IGxldmVsIGRvd24gdG8gYSBwYXRoLiBOb3RlOiB0aGlzIGlzIHRoZSBzYW1lXHJcbiAgICogYXMgYFBhdGguYW5jZXN0b3JzYCwgYnV0IGluY2x1ZGluZyB0aGUgcGF0aCBpdHNlbGYuXHJcbiAgICpcclxuICAgKiBUaGUgcGF0aHMgYXJlIHNvcnRlZCBmcm9tIHNoYWxsb3dlc3QgdG8gZGVlcGVzdC4gSG93ZXZlciwgaWYgdGhlIGByZXZlcnNlOlxyXG4gICAqIHRydWVgIG9wdGlvbiBpcyBwYXNzZWQsIHRoZXkgYXJlIHJldmVyc2VkLlxyXG4gICAqL1xuICBsZXZlbHM6IGZ1bmN0aW9uIGxldmVscyhwYXRoKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIHZhciBfb3B0aW9ucyRyZXZlcnNlMiA9IG9wdGlvbnMucmV2ZXJzZSxcbiAgICAgICAgcmV2ZXJzZSA9IF9vcHRpb25zJHJldmVyc2UyID09PSB2b2lkIDAgPyBmYWxzZSA6IF9vcHRpb25zJHJldmVyc2UyO1xuICAgIHZhciBsaXN0ID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8PSBwYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsaXN0LnB1c2gocGF0aC5zbGljZSgwLCBpKSk7XG4gICAgfVxuXG4gICAgaWYgKHJldmVyc2UpIHtcbiAgICAgIGxpc3QucmV2ZXJzZSgpO1xuICAgIH1cblxuICAgIHJldHVybiBsaXN0O1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEdpdmVuIGEgcGF0aCwgZ2V0IHRoZSBwYXRoIHRvIHRoZSBuZXh0IHNpYmxpbmcgbm9kZS5cclxuICAgKi9cbiAgbmV4dDogZnVuY3Rpb24gbmV4dChwYXRoKSB7XG4gICAgaWYgKHBhdGgubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZ2V0IHRoZSBuZXh0IHBhdGggb2YgYSByb290IHBhdGggW1wiLmNvbmNhdChwYXRoLCBcIl0sIGJlY2F1c2UgaXQgaGFzIG5vIG5leHQgaW5kZXguXCIpKTtcbiAgICB9XG5cbiAgICB2YXIgbGFzdCA9IHBhdGhbcGF0aC5sZW5ndGggLSAxXTtcbiAgICByZXR1cm4gcGF0aC5zbGljZSgwLCAtMSkuY29uY2F0KGxhc3QgKyAxKTtcbiAgfSxcblxuICAvKipcclxuICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhpcyBvcGVyYXRpb24gY2FuIGFmZmVjdCBwYXRocyBvciBub3QuIFVzZWQgYXMgYW5cclxuICAgKiBvcHRpbWl6YXRpb24gd2hlbiB1cGRhdGluZyBkaXJ0eSBwYXRocyBkdXJpbmcgbm9ybWFsaXphdGlvblxyXG4gICAqXHJcbiAgICogTk9URTogVGhpcyAqbXVzdCogYmUga2VwdCBpbiBzeW5jIHdpdGggdGhlIGltcGxlbWVudGF0aW9uIG9mICd0cmFuc2Zvcm0nXHJcbiAgICogYmVsb3dcclxuICAgKi9cbiAgb3BlcmF0aW9uQ2FuVHJhbnNmb3JtUGF0aDogZnVuY3Rpb24gb3BlcmF0aW9uQ2FuVHJhbnNmb3JtUGF0aChvcGVyYXRpb24pIHtcbiAgICBzd2l0Y2ggKG9wZXJhdGlvbi50eXBlKSB7XG4gICAgICBjYXNlICdpbnNlcnRfbm9kZSc6XG4gICAgICBjYXNlICdyZW1vdmVfbm9kZSc6XG4gICAgICBjYXNlICdtZXJnZV9ub2RlJzpcbiAgICAgIGNhc2UgJ3NwbGl0X25vZGUnOlxuICAgICAgY2FzZSAnbW92ZV9ub2RlJzpcbiAgICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogR2l2ZW4gYSBwYXRoLCByZXR1cm4gYSBuZXcgcGF0aCByZWZlcnJpbmcgdG8gdGhlIHBhcmVudCBub2RlIGFib3ZlIGl0LlxyXG4gICAqL1xuICBwYXJlbnQ6IGZ1bmN0aW9uIHBhcmVudChwYXRoKSB7XG4gICAgaWYgKHBhdGgubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZ2V0IHRoZSBwYXJlbnQgcGF0aCBvZiB0aGUgcm9vdCBwYXRoIFtcIi5jb25jYXQocGF0aCwgXCJdLlwiKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhdGguc2xpY2UoMCwgLTEpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEdpdmVuIGEgcGF0aCwgZ2V0IHRoZSBwYXRoIHRvIHRoZSBwcmV2aW91cyBzaWJsaW5nIG5vZGUuXHJcbiAgICovXG4gIHByZXZpb3VzOiBmdW5jdGlvbiBwcmV2aW91cyhwYXRoKSB7XG4gICAgaWYgKHBhdGgubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZ2V0IHRoZSBwcmV2aW91cyBwYXRoIG9mIGEgcm9vdCBwYXRoIFtcIi5jb25jYXQocGF0aCwgXCJdLCBiZWNhdXNlIGl0IGhhcyBubyBwcmV2aW91cyBpbmRleC5cIikpO1xuICAgIH1cblxuICAgIHZhciBsYXN0ID0gcGF0aFtwYXRoLmxlbmd0aCAtIDFdO1xuXG4gICAgaWYgKGxhc3QgPD0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGdldCB0aGUgcHJldmlvdXMgcGF0aCBvZiBhIGZpcnN0IGNoaWxkIHBhdGggW1wiLmNvbmNhdChwYXRoLCBcIl0gYmVjYXVzZSBpdCB3b3VsZCByZXN1bHQgaW4gYSBuZWdhdGl2ZSBpbmRleC5cIikpO1xuICAgIH1cblxuICAgIHJldHVybiBwYXRoLnNsaWNlKDAsIC0xKS5jb25jYXQobGFzdCAtIDEpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEdldCBhIHBhdGggcmVsYXRpdmUgdG8gYW4gYW5jZXN0b3IuXHJcbiAgICovXG4gIHJlbGF0aXZlOiBmdW5jdGlvbiByZWxhdGl2ZShwYXRoLCBhbmNlc3Rvcikge1xuICAgIGlmICghUGF0aC5pc0FuY2VzdG9yKGFuY2VzdG9yLCBwYXRoKSAmJiAhUGF0aC5lcXVhbHMocGF0aCwgYW5jZXN0b3IpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZ2V0IHRoZSByZWxhdGl2ZSBwYXRoIG9mIFtcIi5jb25jYXQocGF0aCwgXCJdIGluc2lkZSBhbmNlc3RvciBbXCIpLmNvbmNhdChhbmNlc3RvciwgXCJdLCBiZWNhdXNlIGl0IGlzIG5vdCBhYm92ZSBvciBlcXVhbCB0byB0aGUgcGF0aC5cIikpO1xuICAgIH1cblxuICAgIHJldHVybiBwYXRoLnNsaWNlKGFuY2VzdG9yLmxlbmd0aCk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogVHJhbnNmb3JtIGEgcGF0aCBieSBhbiBvcGVyYXRpb24uXHJcbiAgICovXG4gIHRyYW5zZm9ybTogZnVuY3Rpb24gdHJhbnNmb3JtKHBhdGgsIG9wZXJhdGlvbikge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICBpZiAoIXBhdGgpIHJldHVybiBudWxsOyAvLyBQRVJGOiB1c2UgZGVzdHJ1Y3RpbmcgaW5zdGVhZCBvZiBpbW1lclxuXG4gICAgdmFyIHAgPSBfdG9Db25zdW1hYmxlQXJyYXkocGF0aCk7XG5cbiAgICB2YXIgX29wdGlvbnMkYWZmaW5pdHkgPSBvcHRpb25zLmFmZmluaXR5LFxuICAgICAgICBhZmZpbml0eSA9IF9vcHRpb25zJGFmZmluaXR5ID09PSB2b2lkIDAgPyAnZm9yd2FyZCcgOiBfb3B0aW9ucyRhZmZpbml0eTsgLy8gUEVSRjogRXhpdCBlYXJseSBpZiB0aGUgb3BlcmF0aW9uIGlzIGd1YXJhbnRlZWQgbm90IHRvIGhhdmUgYW4gZWZmZWN0LlxuXG4gICAgaWYgKHBhdGgubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gcDtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKG9wZXJhdGlvbi50eXBlKSB7XG4gICAgICBjYXNlICdpbnNlcnRfbm9kZSc6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgb3AgPSBvcGVyYXRpb24ucGF0aDtcblxuICAgICAgICAgIGlmIChQYXRoLmVxdWFscyhvcCwgcCkgfHwgUGF0aC5lbmRzQmVmb3JlKG9wLCBwKSB8fCBQYXRoLmlzQW5jZXN0b3Iob3AsIHApKSB7XG4gICAgICAgICAgICBwW29wLmxlbmd0aCAtIDFdICs9IDE7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSAncmVtb3ZlX25vZGUnOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIF9vcCA9IG9wZXJhdGlvbi5wYXRoO1xuXG4gICAgICAgICAgaWYgKFBhdGguZXF1YWxzKF9vcCwgcCkgfHwgUGF0aC5pc0FuY2VzdG9yKF9vcCwgcCkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH0gZWxzZSBpZiAoUGF0aC5lbmRzQmVmb3JlKF9vcCwgcCkpIHtcbiAgICAgICAgICAgIHBbX29wLmxlbmd0aCAtIDFdIC09IDE7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSAnbWVyZ2Vfbm9kZSc6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgX29wMiA9IG9wZXJhdGlvbi5wYXRoLFxuICAgICAgICAgICAgICBwb3NpdGlvbiA9IG9wZXJhdGlvbi5wb3NpdGlvbjtcblxuICAgICAgICAgIGlmIChQYXRoLmVxdWFscyhfb3AyLCBwKSB8fCBQYXRoLmVuZHNCZWZvcmUoX29wMiwgcCkpIHtcbiAgICAgICAgICAgIHBbX29wMi5sZW5ndGggLSAxXSAtPSAxO1xuICAgICAgICAgIH0gZWxzZSBpZiAoUGF0aC5pc0FuY2VzdG9yKF9vcDIsIHApKSB7XG4gICAgICAgICAgICBwW19vcDIubGVuZ3RoIC0gMV0gLT0gMTtcbiAgICAgICAgICAgIHBbX29wMi5sZW5ndGhdICs9IHBvc2l0aW9uO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgJ3NwbGl0X25vZGUnOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIF9vcDMgPSBvcGVyYXRpb24ucGF0aCxcbiAgICAgICAgICAgICAgX3Bvc2l0aW9uID0gb3BlcmF0aW9uLnBvc2l0aW9uO1xuXG4gICAgICAgICAgaWYgKFBhdGguZXF1YWxzKF9vcDMsIHApKSB7XG4gICAgICAgICAgICBpZiAoYWZmaW5pdHkgPT09ICdmb3J3YXJkJykge1xuICAgICAgICAgICAgICBwW3AubGVuZ3RoIC0gMV0gKz0gMTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYWZmaW5pdHkgPT09ICdiYWNrd2FyZCcpIDsgZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoUGF0aC5lbmRzQmVmb3JlKF9vcDMsIHApKSB7XG4gICAgICAgICAgICBwW19vcDMubGVuZ3RoIC0gMV0gKz0gMTtcbiAgICAgICAgICB9IGVsc2UgaWYgKFBhdGguaXNBbmNlc3Rvcihfb3AzLCBwKSAmJiBwYXRoW19vcDMubGVuZ3RoXSA+PSBfcG9zaXRpb24pIHtcbiAgICAgICAgICAgIHBbX29wMy5sZW5ndGggLSAxXSArPSAxO1xuICAgICAgICAgICAgcFtfb3AzLmxlbmd0aF0gLT0gX3Bvc2l0aW9uO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgJ21vdmVfbm9kZSc6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgX29wNCA9IG9wZXJhdGlvbi5wYXRoLFxuICAgICAgICAgICAgICBvbnAgPSBvcGVyYXRpb24ubmV3UGF0aDsgLy8gSWYgdGhlIG9sZCBhbmQgbmV3IHBhdGggYXJlIHRoZSBzYW1lLCBpdCdzIGEgbm8tb3AuXG5cbiAgICAgICAgICBpZiAoUGF0aC5lcXVhbHMoX29wNCwgb25wKSkge1xuICAgICAgICAgICAgcmV0dXJuIHA7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKFBhdGguaXNBbmNlc3Rvcihfb3A0LCBwKSB8fCBQYXRoLmVxdWFscyhfb3A0LCBwKSkge1xuICAgICAgICAgICAgdmFyIGNvcHkgPSBvbnAuc2xpY2UoKTtcblxuICAgICAgICAgICAgaWYgKFBhdGguZW5kc0JlZm9yZShfb3A0LCBvbnApICYmIF9vcDQubGVuZ3RoIDwgb25wLmxlbmd0aCkge1xuICAgICAgICAgICAgICBjb3B5W19vcDQubGVuZ3RoIC0gMV0gLT0gMTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGNvcHkuY29uY2F0KHAuc2xpY2UoX29wNC5sZW5ndGgpKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKFBhdGguaXNTaWJsaW5nKF9vcDQsIG9ucCkgJiYgKFBhdGguaXNBbmNlc3RvcihvbnAsIHApIHx8IFBhdGguZXF1YWxzKG9ucCwgcCkpKSB7XG4gICAgICAgICAgICBpZiAoUGF0aC5lbmRzQmVmb3JlKF9vcDQsIHApKSB7XG4gICAgICAgICAgICAgIHBbX29wNC5sZW5ndGggLSAxXSAtPSAxO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcFtfb3A0Lmxlbmd0aCAtIDFdICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChQYXRoLmVuZHNCZWZvcmUob25wLCBwKSB8fCBQYXRoLmVxdWFscyhvbnAsIHApIHx8IFBhdGguaXNBbmNlc3RvcihvbnAsIHApKSB7XG4gICAgICAgICAgICBpZiAoUGF0aC5lbmRzQmVmb3JlKF9vcDQsIHApKSB7XG4gICAgICAgICAgICAgIHBbX29wNC5sZW5ndGggLSAxXSAtPSAxO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwW29ucC5sZW5ndGggLSAxXSArPSAxO1xuICAgICAgICAgIH0gZWxzZSBpZiAoUGF0aC5lbmRzQmVmb3JlKF9vcDQsIHApKSB7XG4gICAgICAgICAgICBpZiAoUGF0aC5lcXVhbHMob25wLCBwKSkge1xuICAgICAgICAgICAgICBwW29ucC5sZW5ndGggLSAxXSArPSAxO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwW19vcDQubGVuZ3RoIC0gMV0gLT0gMTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBwO1xuICB9XG59O1xuXG52YXIgUGF0aFJlZiA9IHtcbiAgLyoqXHJcbiAgICogVHJhbnNmb3JtIHRoZSBwYXRoIHJlZidzIGN1cnJlbnQgdmFsdWUgYnkgYW4gb3BlcmF0aW9uLlxyXG4gICAqL1xuICB0cmFuc2Zvcm06IGZ1bmN0aW9uIHRyYW5zZm9ybShyZWYsIG9wKSB7XG4gICAgdmFyIGN1cnJlbnQgPSByZWYuY3VycmVudCxcbiAgICAgICAgYWZmaW5pdHkgPSByZWYuYWZmaW5pdHk7XG5cbiAgICBpZiAoY3VycmVudCA9PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHBhdGggPSBQYXRoLnRyYW5zZm9ybShjdXJyZW50LCBvcCwge1xuICAgICAgYWZmaW5pdHk6IGFmZmluaXR5XG4gICAgfSk7XG4gICAgcmVmLmN1cnJlbnQgPSBwYXRoO1xuXG4gICAgaWYgKHBhdGggPT0gbnVsbCkge1xuICAgICAgcmVmLnVucmVmKCk7XG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBvd25LZXlzJDYob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBpZiAoZW51bWVyYWJsZU9ubHkpIHsgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyB9IGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkJDYodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgb3duS2V5cyQ2KE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pOyB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7IH0gZWxzZSB7IG93bktleXMkNihPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxudmFyIFBvaW50ID0ge1xuICAvKipcclxuICAgKiBDb21wYXJlIGEgcG9pbnQgdG8gYW5vdGhlciwgcmV0dXJuaW5nIGFuIGludGVnZXIgaW5kaWNhdGluZyB3aGV0aGVyIHRoZVxyXG4gICAqIHBvaW50IHdhcyBiZWZvcmUsIGF0LCBvciBhZnRlciB0aGUgb3RoZXIuXHJcbiAgICovXG4gIGNvbXBhcmU6IGZ1bmN0aW9uIGNvbXBhcmUocG9pbnQsIGFub3RoZXIpIHtcbiAgICB2YXIgcmVzdWx0ID0gUGF0aC5jb21wYXJlKHBvaW50LnBhdGgsIGFub3RoZXIucGF0aCk7XG5cbiAgICBpZiAocmVzdWx0ID09PSAwKSB7XG4gICAgICBpZiAocG9pbnQub2Zmc2V0IDwgYW5vdGhlci5vZmZzZXQpIHJldHVybiAtMTtcbiAgICAgIGlmIChwb2ludC5vZmZzZXQgPiBhbm90aGVyLm9mZnNldCkgcmV0dXJuIDE7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgcG9pbnQgaXMgYWZ0ZXIgYW5vdGhlci5cclxuICAgKi9cbiAgaXNBZnRlcjogZnVuY3Rpb24gaXNBZnRlcihwb2ludCwgYW5vdGhlcikge1xuICAgIHJldHVybiBQb2ludC5jb21wYXJlKHBvaW50LCBhbm90aGVyKSA9PT0gMTtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhIHBvaW50IGlzIGJlZm9yZSBhbm90aGVyLlxyXG4gICAqL1xuICBpc0JlZm9yZTogZnVuY3Rpb24gaXNCZWZvcmUocG9pbnQsIGFub3RoZXIpIHtcbiAgICByZXR1cm4gUG9pbnQuY29tcGFyZShwb2ludCwgYW5vdGhlcikgPT09IC0xO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgcG9pbnQgaXMgZXhhY3RseSBlcXVhbCB0byBhbm90aGVyLlxyXG4gICAqL1xuICBlcXVhbHM6IGZ1bmN0aW9uIGVxdWFscyhwb2ludCwgYW5vdGhlcikge1xuICAgIC8vIFBFUkY6IGVuc3VyZSB0aGUgb2Zmc2V0cyBhcmUgZXF1YWwgZmlyc3Qgc2luY2UgdGhleSBhcmUgY2hlYXBlciB0byBjaGVjay5cbiAgICByZXR1cm4gcG9pbnQub2Zmc2V0ID09PSBhbm90aGVyLm9mZnNldCAmJiBQYXRoLmVxdWFscyhwb2ludC5wYXRoLCBhbm90aGVyLnBhdGgpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgdmFsdWUgaW1wbGVtZW50cyB0aGUgYFBvaW50YCBpbnRlcmZhY2UuXHJcbiAgICovXG4gIGlzUG9pbnQ6IGZ1bmN0aW9uIGlzUG9pbnQodmFsdWUpIHtcbiAgICByZXR1cm4gaXNQbGFpbk9iamVjdC5pc1BsYWluT2JqZWN0KHZhbHVlKSAmJiB0eXBlb2YgdmFsdWUub2Zmc2V0ID09PSAnbnVtYmVyJyAmJiBQYXRoLmlzUGF0aCh2YWx1ZS5wYXRoKTtcbiAgfSxcblxuICAvKipcclxuICAgKiBUcmFuc2Zvcm0gYSBwb2ludCBieSBhbiBvcGVyYXRpb24uXHJcbiAgICovXG4gIHRyYW5zZm9ybTogZnVuY3Rpb24gdHJhbnNmb3JtKHBvaW50LCBvcCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICByZXR1cm4gaW1tZXIucHJvZHVjZShwb2ludCwgZnVuY3Rpb24gKHApIHtcbiAgICAgIGlmIChwID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgX29wdGlvbnMkYWZmaW5pdHkgPSBvcHRpb25zLmFmZmluaXR5LFxuICAgICAgICAgIGFmZmluaXR5ID0gX29wdGlvbnMkYWZmaW5pdHkgPT09IHZvaWQgMCA/ICdmb3J3YXJkJyA6IF9vcHRpb25zJGFmZmluaXR5O1xuICAgICAgdmFyIHBhdGggPSBwLnBhdGgsXG4gICAgICAgICAgb2Zmc2V0ID0gcC5vZmZzZXQ7XG5cbiAgICAgIHN3aXRjaCAob3AudHlwZSkge1xuICAgICAgICBjYXNlICdpbnNlcnRfbm9kZSc6XG4gICAgICAgIGNhc2UgJ21vdmVfbm9kZSc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgcC5wYXRoID0gUGF0aC50cmFuc2Zvcm0ocGF0aCwgb3AsIG9wdGlvbnMpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgJ2luc2VydF90ZXh0JzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZiAoUGF0aC5lcXVhbHMob3AucGF0aCwgcGF0aCkgJiYgKG9wLm9mZnNldCA8IG9mZnNldCB8fCBvcC5vZmZzZXQgPT09IG9mZnNldCAmJiBhZmZpbml0eSA9PT0gJ2ZvcndhcmQnKSkge1xuICAgICAgICAgICAgICBwLm9mZnNldCArPSBvcC50ZXh0Lmxlbmd0aDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgJ21lcmdlX25vZGUnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmIChQYXRoLmVxdWFscyhvcC5wYXRoLCBwYXRoKSkge1xuICAgICAgICAgICAgICBwLm9mZnNldCArPSBvcC5wb3NpdGlvbjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcC5wYXRoID0gUGF0aC50cmFuc2Zvcm0ocGF0aCwgb3AsIG9wdGlvbnMpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgJ3JlbW92ZV90ZXh0JzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZiAoUGF0aC5lcXVhbHMob3AucGF0aCwgcGF0aCkgJiYgb3Aub2Zmc2V0IDw9IG9mZnNldCkge1xuICAgICAgICAgICAgICBwLm9mZnNldCAtPSBNYXRoLm1pbihvZmZzZXQgLSBvcC5vZmZzZXQsIG9wLnRleHQubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgJ3JlbW92ZV9ub2RlJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZiAoUGF0aC5lcXVhbHMob3AucGF0aCwgcGF0aCkgfHwgUGF0aC5pc0FuY2VzdG9yKG9wLnBhdGgsIHBhdGgpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwLnBhdGggPSBQYXRoLnRyYW5zZm9ybShwYXRoLCBvcCwgb3B0aW9ucyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSAnc3BsaXRfbm9kZSc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgaWYgKFBhdGguZXF1YWxzKG9wLnBhdGgsIHBhdGgpKSB7XG4gICAgICAgICAgICAgIGlmIChvcC5wb3NpdGlvbiA9PT0gb2Zmc2V0ICYmIGFmZmluaXR5ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChvcC5wb3NpdGlvbiA8IG9mZnNldCB8fCBvcC5wb3NpdGlvbiA9PT0gb2Zmc2V0ICYmIGFmZmluaXR5ID09PSAnZm9yd2FyZCcpIHtcbiAgICAgICAgICAgICAgICBwLm9mZnNldCAtPSBvcC5wb3NpdGlvbjtcbiAgICAgICAgICAgICAgICBwLnBhdGggPSBQYXRoLnRyYW5zZm9ybShwYXRoLCBvcCwgX29iamVjdFNwcmVhZCQ2KF9vYmplY3RTcHJlYWQkNih7fSwgb3B0aW9ucyksIHt9LCB7XG4gICAgICAgICAgICAgICAgICBhZmZpbml0eTogJ2ZvcndhcmQnXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBwLnBhdGggPSBQYXRoLnRyYW5zZm9ybShwYXRoLCBvcCwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufTtcblxudmFyIFBvaW50UmVmID0ge1xuICAvKipcclxuICAgKiBUcmFuc2Zvcm0gdGhlIHBvaW50IHJlZidzIGN1cnJlbnQgdmFsdWUgYnkgYW4gb3BlcmF0aW9uLlxyXG4gICAqL1xuICB0cmFuc2Zvcm06IGZ1bmN0aW9uIHRyYW5zZm9ybShyZWYsIG9wKSB7XG4gICAgdmFyIGN1cnJlbnQgPSByZWYuY3VycmVudCxcbiAgICAgICAgYWZmaW5pdHkgPSByZWYuYWZmaW5pdHk7XG5cbiAgICBpZiAoY3VycmVudCA9PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHBvaW50ID0gUG9pbnQudHJhbnNmb3JtKGN1cnJlbnQsIG9wLCB7XG4gICAgICBhZmZpbml0eTogYWZmaW5pdHlcbiAgICB9KTtcbiAgICByZWYuY3VycmVudCA9IHBvaW50O1xuXG4gICAgaWYgKHBvaW50ID09IG51bGwpIHtcbiAgICAgIHJlZi51bnJlZigpO1xuICAgIH1cbiAgfVxufTtcblxudmFyIF9leGNsdWRlZCQyID0gW1wiYW5jaG9yXCIsIFwiZm9jdXNcIl07XG5cbmZ1bmN0aW9uIG93bktleXMkNShvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgeyBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSk7IH0ga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQkNSh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyBvd25LZXlzJDUoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHsgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTsgfSBlbHNlIHsgb3duS2V5cyQ1KE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG52YXIgUmFuZ2UgPSB7XG4gIC8qKlxyXG4gICAqIEdldCB0aGUgc3RhcnQgYW5kIGVuZCBwb2ludHMgb2YgYSByYW5nZSwgaW4gdGhlIG9yZGVyIGluIHdoaWNoIHRoZXkgYXBwZWFyXHJcbiAgICogaW4gdGhlIGRvY3VtZW50LlxyXG4gICAqL1xuICBlZGdlczogZnVuY3Rpb24gZWRnZXMocmFuZ2UpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgdmFyIF9vcHRpb25zJHJldmVyc2UgPSBvcHRpb25zLnJldmVyc2UsXG4gICAgICAgIHJldmVyc2UgPSBfb3B0aW9ucyRyZXZlcnNlID09PSB2b2lkIDAgPyBmYWxzZSA6IF9vcHRpb25zJHJldmVyc2U7XG4gICAgdmFyIGFuY2hvciA9IHJhbmdlLmFuY2hvcixcbiAgICAgICAgZm9jdXMgPSByYW5nZS5mb2N1cztcbiAgICByZXR1cm4gUmFuZ2UuaXNCYWNrd2FyZChyYW5nZSkgPT09IHJldmVyc2UgPyBbYW5jaG9yLCBmb2N1c10gOiBbZm9jdXMsIGFuY2hvcl07XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogR2V0IHRoZSBlbmQgcG9pbnQgb2YgYSByYW5nZS5cclxuICAgKi9cbiAgZW5kOiBmdW5jdGlvbiBlbmQocmFuZ2UpIHtcbiAgICB2YXIgX1JhbmdlJGVkZ2VzID0gUmFuZ2UuZWRnZXMocmFuZ2UpLFxuICAgICAgICBfUmFuZ2UkZWRnZXMyID0gX3NsaWNlZFRvQXJyYXkoX1JhbmdlJGVkZ2VzLCAyKSxcbiAgICAgICAgZW5kID0gX1JhbmdlJGVkZ2VzMlsxXTtcblxuICAgIHJldHVybiBlbmQ7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSByYW5nZSBpcyBleGFjdGx5IGVxdWFsIHRvIGFub3RoZXIuXHJcbiAgICovXG4gIGVxdWFsczogZnVuY3Rpb24gZXF1YWxzKHJhbmdlLCBhbm90aGVyKSB7XG4gICAgcmV0dXJuIFBvaW50LmVxdWFscyhyYW5nZS5hbmNob3IsIGFub3RoZXIuYW5jaG9yKSAmJiBQb2ludC5lcXVhbHMocmFuZ2UuZm9jdXMsIGFub3RoZXIuZm9jdXMpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgcmFuZ2UgaW5jbHVkZXMgYSBwYXRoLCBhIHBvaW50IG9yIHBhcnQgb2YgYW5vdGhlciByYW5nZS5cclxuICAgKi9cbiAgaW5jbHVkZXM6IGZ1bmN0aW9uIGluY2x1ZGVzKHJhbmdlLCB0YXJnZXQpIHtcbiAgICBpZiAoUmFuZ2UuaXNSYW5nZSh0YXJnZXQpKSB7XG4gICAgICBpZiAoUmFuZ2UuaW5jbHVkZXMocmFuZ2UsIHRhcmdldC5hbmNob3IpIHx8IFJhbmdlLmluY2x1ZGVzKHJhbmdlLCB0YXJnZXQuZm9jdXMpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgX1JhbmdlJGVkZ2VzMyA9IFJhbmdlLmVkZ2VzKHJhbmdlKSxcbiAgICAgICAgICBfUmFuZ2UkZWRnZXM0ID0gX3NsaWNlZFRvQXJyYXkoX1JhbmdlJGVkZ2VzMywgMiksXG4gICAgICAgICAgcnMgPSBfUmFuZ2UkZWRnZXM0WzBdLFxuICAgICAgICAgIHJlID0gX1JhbmdlJGVkZ2VzNFsxXTtcblxuICAgICAgdmFyIF9SYW5nZSRlZGdlczUgPSBSYW5nZS5lZGdlcyh0YXJnZXQpLFxuICAgICAgICAgIF9SYW5nZSRlZGdlczYgPSBfc2xpY2VkVG9BcnJheShfUmFuZ2UkZWRnZXM1LCAyKSxcbiAgICAgICAgICB0cyA9IF9SYW5nZSRlZGdlczZbMF0sXG4gICAgICAgICAgdGUgPSBfUmFuZ2UkZWRnZXM2WzFdO1xuXG4gICAgICByZXR1cm4gUG9pbnQuaXNCZWZvcmUocnMsIHRzKSAmJiBQb2ludC5pc0FmdGVyKHJlLCB0ZSk7XG4gICAgfVxuXG4gICAgdmFyIF9SYW5nZSRlZGdlczcgPSBSYW5nZS5lZGdlcyhyYW5nZSksXG4gICAgICAgIF9SYW5nZSRlZGdlczggPSBfc2xpY2VkVG9BcnJheShfUmFuZ2UkZWRnZXM3LCAyKSxcbiAgICAgICAgc3RhcnQgPSBfUmFuZ2UkZWRnZXM4WzBdLFxuICAgICAgICBlbmQgPSBfUmFuZ2UkZWRnZXM4WzFdO1xuXG4gICAgdmFyIGlzQWZ0ZXJTdGFydCA9IGZhbHNlO1xuICAgIHZhciBpc0JlZm9yZUVuZCA9IGZhbHNlO1xuXG4gICAgaWYgKFBvaW50LmlzUG9pbnQodGFyZ2V0KSkge1xuICAgICAgaXNBZnRlclN0YXJ0ID0gUG9pbnQuY29tcGFyZSh0YXJnZXQsIHN0YXJ0KSA+PSAwO1xuICAgICAgaXNCZWZvcmVFbmQgPSBQb2ludC5jb21wYXJlKHRhcmdldCwgZW5kKSA8PSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICBpc0FmdGVyU3RhcnQgPSBQYXRoLmNvbXBhcmUodGFyZ2V0LCBzdGFydC5wYXRoKSA+PSAwO1xuICAgICAgaXNCZWZvcmVFbmQgPSBQYXRoLmNvbXBhcmUodGFyZ2V0LCBlbmQucGF0aCkgPD0gMDtcbiAgICB9XG5cbiAgICByZXR1cm4gaXNBZnRlclN0YXJ0ICYmIGlzQmVmb3JlRW5kO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgaW50ZXJzZWN0aW9uIG9mIGEgcmFuZ2Ugd2l0aCBhbm90aGVyLlxyXG4gICAqL1xuICBpbnRlcnNlY3Rpb246IGZ1bmN0aW9uIGludGVyc2VjdGlvbihyYW5nZSwgYW5vdGhlcikge1xuICAgIHJhbmdlLmFuY2hvcjtcbiAgICAgICAgcmFuZ2UuZm9jdXM7XG4gICAgICAgIHZhciByZXN0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHJhbmdlLCBfZXhjbHVkZWQkMik7XG5cbiAgICB2YXIgX1JhbmdlJGVkZ2VzOSA9IFJhbmdlLmVkZ2VzKHJhbmdlKSxcbiAgICAgICAgX1JhbmdlJGVkZ2VzMTAgPSBfc2xpY2VkVG9BcnJheShfUmFuZ2UkZWRnZXM5LCAyKSxcbiAgICAgICAgczEgPSBfUmFuZ2UkZWRnZXMxMFswXSxcbiAgICAgICAgZTEgPSBfUmFuZ2UkZWRnZXMxMFsxXTtcblxuICAgIHZhciBfUmFuZ2UkZWRnZXMxMSA9IFJhbmdlLmVkZ2VzKGFub3RoZXIpLFxuICAgICAgICBfUmFuZ2UkZWRnZXMxMiA9IF9zbGljZWRUb0FycmF5KF9SYW5nZSRlZGdlczExLCAyKSxcbiAgICAgICAgczIgPSBfUmFuZ2UkZWRnZXMxMlswXSxcbiAgICAgICAgZTIgPSBfUmFuZ2UkZWRnZXMxMlsxXTtcblxuICAgIHZhciBzdGFydCA9IFBvaW50LmlzQmVmb3JlKHMxLCBzMikgPyBzMiA6IHMxO1xuICAgIHZhciBlbmQgPSBQb2ludC5pc0JlZm9yZShlMSwgZTIpID8gZTEgOiBlMjtcblxuICAgIGlmIChQb2ludC5pc0JlZm9yZShlbmQsIHN0YXJ0KSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkJDUoe1xuICAgICAgICBhbmNob3I6IHN0YXJ0LFxuICAgICAgICBmb2N1czogZW5kXG4gICAgICB9LCByZXN0KTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSByYW5nZSBpcyBiYWNrd2FyZCwgbWVhbmluZyB0aGF0IGl0cyBhbmNob3IgcG9pbnQgYXBwZWFycyBpbiB0aGVcclxuICAgKiBkb2N1bWVudCBfYWZ0ZXJfIGl0cyBmb2N1cyBwb2ludC5cclxuICAgKi9cbiAgaXNCYWNrd2FyZDogZnVuY3Rpb24gaXNCYWNrd2FyZChyYW5nZSkge1xuICAgIHZhciBhbmNob3IgPSByYW5nZS5hbmNob3IsXG4gICAgICAgIGZvY3VzID0gcmFuZ2UuZm9jdXM7XG4gICAgcmV0dXJuIFBvaW50LmlzQWZ0ZXIoYW5jaG9yLCBmb2N1cyk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSByYW5nZSBpcyBjb2xsYXBzZWQsIG1lYW5pbmcgdGhhdCBib3RoIGl0cyBhbmNob3IgYW5kIGZvY3VzXHJcbiAgICogcG9pbnRzIHJlZmVyIHRvIHRoZSBleGFjdCBzYW1lIHBvc2l0aW9uIGluIHRoZSBkb2N1bWVudC5cclxuICAgKi9cbiAgaXNDb2xsYXBzZWQ6IGZ1bmN0aW9uIGlzQ29sbGFwc2VkKHJhbmdlKSB7XG4gICAgdmFyIGFuY2hvciA9IHJhbmdlLmFuY2hvcixcbiAgICAgICAgZm9jdXMgPSByYW5nZS5mb2N1cztcbiAgICByZXR1cm4gUG9pbnQuZXF1YWxzKGFuY2hvciwgZm9jdXMpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgcmFuZ2UgaXMgZXhwYW5kZWQuXHJcbiAgICpcclxuICAgKiBUaGlzIGlzIHRoZSBvcHBvc2l0ZSBvZiBbW1JhbmdlLmlzQ29sbGFwc2VkXV0gYW5kIGlzIHByb3ZpZGVkIGZvciBsZWdpYmlsaXR5LlxyXG4gICAqL1xuICBpc0V4cGFuZGVkOiBmdW5jdGlvbiBpc0V4cGFuZGVkKHJhbmdlKSB7XG4gICAgcmV0dXJuICFSYW5nZS5pc0NvbGxhcHNlZChyYW5nZSk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSByYW5nZSBpcyBmb3J3YXJkLlxyXG4gICAqXHJcbiAgICogVGhpcyBpcyB0aGUgb3Bwb3NpdGUgb2YgW1tSYW5nZS5pc0JhY2t3YXJkXV0gYW5kIGlzIHByb3ZpZGVkIGZvciBsZWdpYmlsaXR5LlxyXG4gICAqL1xuICBpc0ZvcndhcmQ6IGZ1bmN0aW9uIGlzRm9yd2FyZChyYW5nZSkge1xuICAgIHJldHVybiAhUmFuZ2UuaXNCYWNrd2FyZChyYW5nZSk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSB2YWx1ZSBpbXBsZW1lbnRzIHRoZSBbW1JhbmdlXV0gaW50ZXJmYWNlLlxyXG4gICAqL1xuICBpc1JhbmdlOiBmdW5jdGlvbiBpc1JhbmdlKHZhbHVlKSB7XG4gICAgcmV0dXJuIGlzUGxhaW5PYmplY3QuaXNQbGFpbk9iamVjdCh2YWx1ZSkgJiYgUG9pbnQuaXNQb2ludCh2YWx1ZS5hbmNob3IpICYmIFBvaW50LmlzUG9pbnQodmFsdWUuZm9jdXMpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEl0ZXJhdGUgdGhyb3VnaCBhbGwgb2YgdGhlIHBvaW50IGVudHJpZXMgaW4gYSByYW5nZS5cclxuICAgKi9cbiAgcG9pbnRzOiBmdW5jdGlvbiogcG9pbnRzKHJhbmdlKSB7XG4gICAgeWllbGQgW3JhbmdlLmFuY2hvciwgJ2FuY2hvciddO1xuICAgIHlpZWxkIFtyYW5nZS5mb2N1cywgJ2ZvY3VzJ107XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogR2V0IHRoZSBzdGFydCBwb2ludCBvZiBhIHJhbmdlLlxyXG4gICAqL1xuICBzdGFydDogZnVuY3Rpb24gc3RhcnQocmFuZ2UpIHtcbiAgICB2YXIgX1JhbmdlJGVkZ2VzMTMgPSBSYW5nZS5lZGdlcyhyYW5nZSksXG4gICAgICAgIF9SYW5nZSRlZGdlczE0ID0gX3NsaWNlZFRvQXJyYXkoX1JhbmdlJGVkZ2VzMTMsIDEpLFxuICAgICAgICBzdGFydCA9IF9SYW5nZSRlZGdlczE0WzBdO1xuXG4gICAgcmV0dXJuIHN0YXJ0O1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIFRyYW5zZm9ybSBhIHJhbmdlIGJ5IGFuIG9wZXJhdGlvbi5cclxuICAgKi9cbiAgdHJhbnNmb3JtOiBmdW5jdGlvbiB0cmFuc2Zvcm0ocmFuZ2UsIG9wKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIHJldHVybiBpbW1lci5wcm9kdWNlKHJhbmdlLCBmdW5jdGlvbiAocikge1xuICAgICAgaWYgKHIgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciBfb3B0aW9ucyRhZmZpbml0eSA9IG9wdGlvbnMuYWZmaW5pdHksXG4gICAgICAgICAgYWZmaW5pdHkgPSBfb3B0aW9ucyRhZmZpbml0eSA9PT0gdm9pZCAwID8gJ2lud2FyZCcgOiBfb3B0aW9ucyRhZmZpbml0eTtcbiAgICAgIHZhciBhZmZpbml0eUFuY2hvcjtcbiAgICAgIHZhciBhZmZpbml0eUZvY3VzO1xuXG4gICAgICBpZiAoYWZmaW5pdHkgPT09ICdpbndhcmQnKSB7XG4gICAgICAgIC8vIElmIHRoZSByYW5nZSBpcyBjb2xsYXBzZWQsIG1ha2Ugc3VyZSB0byB1c2UgdGhlIHNhbWUgYWZmaW5pdHkgdG9cbiAgICAgICAgLy8gYXZvaWQgdGhlIHR3byBwb2ludHMgcGFzc2luZyBlYWNoIG90aGVyIGFuZCBleHBhbmRpbmcgaW4gdGhlIG9wcG9zaXRlXG4gICAgICAgIC8vIGRpcmVjdGlvblxuICAgICAgICB2YXIgaXNDb2xsYXBzZWQgPSBSYW5nZS5pc0NvbGxhcHNlZChyKTtcblxuICAgICAgICBpZiAoUmFuZ2UuaXNGb3J3YXJkKHIpKSB7XG4gICAgICAgICAgYWZmaW5pdHlBbmNob3IgPSAnZm9yd2FyZCc7XG4gICAgICAgICAgYWZmaW5pdHlGb2N1cyA9IGlzQ29sbGFwc2VkID8gYWZmaW5pdHlBbmNob3IgOiAnYmFja3dhcmQnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFmZmluaXR5QW5jaG9yID0gJ2JhY2t3YXJkJztcbiAgICAgICAgICBhZmZpbml0eUZvY3VzID0gaXNDb2xsYXBzZWQgPyBhZmZpbml0eUFuY2hvciA6ICdmb3J3YXJkJztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChhZmZpbml0eSA9PT0gJ291dHdhcmQnKSB7XG4gICAgICAgIGlmIChSYW5nZS5pc0ZvcndhcmQocikpIHtcbiAgICAgICAgICBhZmZpbml0eUFuY2hvciA9ICdiYWNrd2FyZCc7XG4gICAgICAgICAgYWZmaW5pdHlGb2N1cyA9ICdmb3J3YXJkJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhZmZpbml0eUFuY2hvciA9ICdmb3J3YXJkJztcbiAgICAgICAgICBhZmZpbml0eUZvY3VzID0gJ2JhY2t3YXJkJztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWZmaW5pdHlBbmNob3IgPSBhZmZpbml0eTtcbiAgICAgICAgYWZmaW5pdHlGb2N1cyA9IGFmZmluaXR5O1xuICAgICAgfVxuXG4gICAgICB2YXIgYW5jaG9yID0gUG9pbnQudHJhbnNmb3JtKHIuYW5jaG9yLCBvcCwge1xuICAgICAgICBhZmZpbml0eTogYWZmaW5pdHlBbmNob3JcbiAgICAgIH0pO1xuICAgICAgdmFyIGZvY3VzID0gUG9pbnQudHJhbnNmb3JtKHIuZm9jdXMsIG9wLCB7XG4gICAgICAgIGFmZmluaXR5OiBhZmZpbml0eUZvY3VzXG4gICAgICB9KTtcblxuICAgICAgaWYgKCFhbmNob3IgfHwgIWZvY3VzKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICByLmFuY2hvciA9IGFuY2hvcjtcbiAgICAgIHIuZm9jdXMgPSBmb2N1cztcbiAgICB9KTtcbiAgfVxufTtcblxudmFyIFJhbmdlUmVmID0ge1xuICAvKipcclxuICAgKiBUcmFuc2Zvcm0gdGhlIHJhbmdlIHJlZidzIGN1cnJlbnQgdmFsdWUgYnkgYW4gb3BlcmF0aW9uLlxyXG4gICAqL1xuICB0cmFuc2Zvcm06IGZ1bmN0aW9uIHRyYW5zZm9ybShyZWYsIG9wKSB7XG4gICAgdmFyIGN1cnJlbnQgPSByZWYuY3VycmVudCxcbiAgICAgICAgYWZmaW5pdHkgPSByZWYuYWZmaW5pdHk7XG5cbiAgICBpZiAoY3VycmVudCA9PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHBhdGggPSBSYW5nZS50cmFuc2Zvcm0oY3VycmVudCwgb3AsIHtcbiAgICAgIGFmZmluaXR5OiBhZmZpbml0eVxuICAgIH0pO1xuICAgIHJlZi5jdXJyZW50ID0gcGF0aDtcblxuICAgIGlmIChwYXRoID09IG51bGwpIHtcbiAgICAgIHJlZi51bnJlZigpO1xuICAgIH1cbiAgfVxufTtcblxudmFyIF9zY3J1YmJlciA9IHVuZGVmaW5lZDtcbi8qKlxyXG4gKiBUaGlzIGludGVyZmFjZSBpbXBsZW1lbnRzIGEgc3RyaW5naWZ5KCkgZnVuY3Rpb24sIHdoaWNoIGlzIHVzZWQgYnkgU2xhdGVcclxuICogaW50ZXJuYWxseSB3aGVuIGdlbmVyYXRpbmcgZXhjZXB0aW9ucyBjb250YWluaW5nIGVuZCB1c2VyIGRhdGEuIERldmVsb3BlcnNcclxuICogdXNpbmcgU2xhdGUgbWF5IGNhbGwgU2NydWJiZXIuc2V0U2NydWJiZXIoKSB0byBhbHRlciB0aGUgYmVoYXZpb3Igb2YgdGhpc1xyXG4gKiBzdHJpbmdpZnkoKSBmdW5jdGlvbi5cclxuICpcclxuICogRm9yIGV4YW1wbGUsIHRvIHByZXZlbnQgdGhlIGNsZWFydGV4dCBsb2dnaW5nIG9mICd0ZXh0JyBmaWVsZHMgd2l0aGluIE5vZGVzOlxyXG4gKlxyXG4gKiAgICBpbXBvcnQgeyBTY3J1YmJlciB9IGZyb20gJ3NsYXRlJztcclxuICogICAgU2NydWJiZXIuc2V0U2NydWJiZXIoKGtleSwgdmFsKSA9PiB7XHJcbiAqICAgICAgaWYgKGtleSA9PT0gJ3RleHQnKSByZXR1cm4gJy4uLnNjcnViYmVkLi4uJ1xyXG4gKiAgICAgIHJldHVybiB2YWxcclxuICogICAgfSk7XHJcbiAqXHJcbiAqL1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlZGVjbGFyZVxuXG52YXIgU2NydWJiZXIgPSB7XG4gIHNldFNjcnViYmVyOiBmdW5jdGlvbiBzZXRTY3J1YmJlcihzY3J1YmJlcikge1xuICAgIF9zY3J1YmJlciA9IHNjcnViYmVyO1xuICB9LFxuICBzdHJpbmdpZnk6IGZ1bmN0aW9uIHN0cmluZ2lmeSh2YWx1ZSkge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh2YWx1ZSwgX3NjcnViYmVyKTtcbiAgfVxufTtcblxuLypcclxuICBDdXN0b20gZGVlcCBlcXVhbCBjb21wYXJpc29uIGZvciBTbGF0ZSBub2Rlcy5cclxuXG4gIFdlIGRvbid0IG5lZWQgZ2VuZXJhbCBwdXJwb3NlIGRlZXAgZXF1YWxpdHk7XHJcbiAgU2xhdGUgb25seSBzdXBwb3J0cyBwbGFpbiB2YWx1ZXMsIEFycmF5cywgYW5kIG5lc3RlZCBvYmplY3RzLlxyXG4gIENvbXBsZXggdmFsdWVzIG5lc3RlZCBpbnNpZGUgQXJyYXlzIGFyZSBub3Qgc3VwcG9ydGVkLlxyXG5cbiAgU2xhdGUgb2JqZWN0cyBhcmUgZGVzaWduZWQgdG8gYmUgc2VyaWFsaXNlZCwgc29cclxuICBtaXNzaW5nIGtleXMgYXJlIGRlbGliZXJhdGVseSBub3JtYWxpc2VkIHRvIHVuZGVmaW5lZC5cclxuICovXG5cbnZhciBpc0RlZXBFcXVhbCA9IGZ1bmN0aW9uIGlzRGVlcEVxdWFsKG5vZGUsIGFub3RoZXIpIHtcbiAgZm9yICh2YXIga2V5IGluIG5vZGUpIHtcbiAgICB2YXIgYSA9IG5vZGVba2V5XTtcbiAgICB2YXIgYiA9IGFub3RoZXJba2V5XTtcblxuICAgIGlmIChpc1BsYWluT2JqZWN0LmlzUGxhaW5PYmplY3QoYSkgJiYgaXNQbGFpbk9iamVjdC5pc1BsYWluT2JqZWN0KGIpKSB7XG4gICAgICBpZiAoIWlzRGVlcEVxdWFsKGEsIGIpKSByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGEpICYmIEFycmF5LmlzQXJyYXkoYikpIHtcbiAgICAgIGlmIChhLmxlbmd0aCAhPT0gYi5sZW5ndGgpIHJldHVybiBmYWxzZTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChhW2ldICE9PSBiW2ldKSByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChhICE9PSBiKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIC8qXHJcbiAgICBEZWVwIG9iamVjdCBlcXVhbGl0eSBpcyBvbmx5IG5lY2Vzc2FyeSBpbiBvbmUgZGlyZWN0aW9uOyBpbiB0aGUgcmV2ZXJzZSBkaXJlY3Rpb25cclxuICAgIHdlIGFyZSBvbmx5IGxvb2tpbmcgZm9yIGtleXMgdGhhdCBhcmUgbWlzc2luZy5cclxuICAgIEFzIGFib3ZlLCB1bmRlZmluZWQga2V5cyBhcmUgbm9ybWFsaXNlZCB0byBtaXNzaW5nLlxyXG4gICovXG5cblxuICBmb3IgKHZhciBfa2V5IGluIGFub3RoZXIpIHtcbiAgICBpZiAobm9kZVtfa2V5XSA9PT0gdW5kZWZpbmVkICYmIGFub3RoZXJbX2tleV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxudmFyIF9leGNsdWRlZCQxID0gW1widGV4dFwiXSxcbiAgICBfZXhjbHVkZWQyJDEgPSBbXCJhbmNob3JcIiwgXCJmb2N1c1wiXTtcblxuZnVuY3Rpb24gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkMyhvLCBhbGxvd0FycmF5TGlrZSkgeyB2YXIgaXQgPSB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXSB8fCBvW1wiQEBpdGVyYXRvclwiXTsgaWYgKCFpdCkgeyBpZiAoQXJyYXkuaXNBcnJheShvKSB8fCAoaXQgPSBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkkMyhvKSkgfHwgYWxsb3dBcnJheUxpa2UgJiYgbyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHsgaWYgKGl0KSBvID0gaXQ7IHZhciBpID0gMDsgdmFyIEYgPSBmdW5jdGlvbiBGKCkge307IHJldHVybiB7IHM6IEYsIG46IGZ1bmN0aW9uIG4oKSB7IGlmIChpID49IG8ubGVuZ3RoKSByZXR1cm4geyBkb25lOiB0cnVlIH07IHJldHVybiB7IGRvbmU6IGZhbHNlLCB2YWx1ZTogb1tpKytdIH07IH0sIGU6IGZ1bmN0aW9uIGUoX2UpIHsgdGhyb3cgX2U7IH0sIGY6IEYgfTsgfSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGl0ZXJhdGUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH0gdmFyIG5vcm1hbENvbXBsZXRpb24gPSB0cnVlLCBkaWRFcnIgPSBmYWxzZSwgZXJyOyByZXR1cm4geyBzOiBmdW5jdGlvbiBzKCkgeyBpdCA9IGl0LmNhbGwobyk7IH0sIG46IGZ1bmN0aW9uIG4oKSB7IHZhciBzdGVwID0gaXQubmV4dCgpOyBub3JtYWxDb21wbGV0aW9uID0gc3RlcC5kb25lOyByZXR1cm4gc3RlcDsgfSwgZTogZnVuY3Rpb24gZShfZTIpIHsgZGlkRXJyID0gdHJ1ZTsgZXJyID0gX2UyOyB9LCBmOiBmdW5jdGlvbiBmKCkgeyB0cnkgeyBpZiAoIW5vcm1hbENvbXBsZXRpb24gJiYgaXRbXCJyZXR1cm5cIl0gIT0gbnVsbCkgaXRbXCJyZXR1cm5cIl0oKTsgfSBmaW5hbGx5IHsgaWYgKGRpZEVycikgdGhyb3cgZXJyOyB9IH0gfTsgfVxuXG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkkMyhvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5JDMobywgbWluTGVuKTsgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheSQzKG8sIG1pbkxlbik7IH1cblxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkkMyhhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH1cblxuZnVuY3Rpb24gb3duS2V5cyQ0KG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgaWYgKGVudW1lcmFibGVPbmx5KSB7IHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KTsgfSBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCQ0KHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgaWYgKGkgJSAyKSB7IG93bktleXMkNChPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBvd25LZXlzJDQoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbnZhciBUZXh0ID0ge1xuICAvKipcclxuICAgKiBDaGVjayBpZiB0d28gdGV4dCBub2RlcyBhcmUgZXF1YWwuXHJcbiAgICpcclxuICAgKiBXaGVuIGxvb3NlIGlzIHNldCwgdGhlIHRleHQgaXMgbm90IGNvbXBhcmVkLiBUaGlzIGlzXHJcbiAgICogdXNlZCB0byBjaGVjayB3aGV0aGVyIHNpYmxpbmcgdGV4dCBub2RlcyBjYW4gYmUgbWVyZ2VkLlxyXG4gICAqL1xuICBlcXVhbHM6IGZ1bmN0aW9uIGVxdWFscyh0ZXh0LCBhbm90aGVyKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIHZhciBfb3B0aW9ucyRsb29zZSA9IG9wdGlvbnMubG9vc2UsXG4gICAgICAgIGxvb3NlID0gX29wdGlvbnMkbG9vc2UgPT09IHZvaWQgMCA/IGZhbHNlIDogX29wdGlvbnMkbG9vc2U7XG5cbiAgICBmdW5jdGlvbiBvbWl0VGV4dChvYmopIHtcbiAgICAgIG9iai50ZXh0O1xuICAgICAgICAgIHZhciByZXN0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKG9iaiwgX2V4Y2x1ZGVkJDEpO1xuXG4gICAgICByZXR1cm4gcmVzdDtcbiAgICB9XG5cbiAgICByZXR1cm4gaXNEZWVwRXF1YWwobG9vc2UgPyBvbWl0VGV4dCh0ZXh0KSA6IHRleHQsIGxvb3NlID8gb21pdFRleHQoYW5vdGhlcikgOiBhbm90aGVyKTtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhIHZhbHVlIGltcGxlbWVudHMgdGhlIGBUZXh0YCBpbnRlcmZhY2UuXHJcbiAgICovXG4gIGlzVGV4dDogZnVuY3Rpb24gaXNUZXh0KHZhbHVlKSB7XG4gICAgcmV0dXJuIGlzUGxhaW5PYmplY3QuaXNQbGFpbk9iamVjdCh2YWx1ZSkgJiYgdHlwZW9mIHZhbHVlLnRleHQgPT09ICdzdHJpbmcnO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgdmFsdWUgaXMgYSBsaXN0IG9mIGBUZXh0YCBvYmplY3RzLlxyXG4gICAqL1xuICBpc1RleHRMaXN0OiBmdW5jdGlvbiBpc1RleHRMaXN0KHZhbHVlKSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsdWUpICYmIHZhbHVlLmV2ZXJ5KGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgIHJldHVybiBUZXh0LmlzVGV4dCh2YWwpO1xuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIHNvbWUgcHJvcHMgYXJlIGEgcGFydGlhbCBvZiBUZXh0LlxyXG4gICAqL1xuICBpc1RleHRQcm9wczogZnVuY3Rpb24gaXNUZXh0UHJvcHMocHJvcHMpIHtcbiAgICByZXR1cm4gcHJvcHMudGV4dCAhPT0gdW5kZWZpbmVkO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGFuIHRleHQgbWF0Y2hlcyBzZXQgb2YgcHJvcGVydGllcy5cclxuICAgKlxyXG4gICAqIE5vdGU6IHRoaXMgaXMgZm9yIG1hdGNoaW5nIGN1c3RvbSBwcm9wZXJ0aWVzLCBhbmQgaXQgZG9lcyBub3QgZW5zdXJlIHRoYXRcclxuICAgKiB0aGUgYHRleHRgIHByb3BlcnR5IGFyZSB0d28gbm9kZXMgZXF1YWwuXHJcbiAgICovXG4gIG1hdGNoZXM6IGZ1bmN0aW9uIG1hdGNoZXModGV4dCwgcHJvcHMpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gcHJvcHMpIHtcbiAgICAgIGlmIChrZXkgPT09ICd0ZXh0Jykge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0ZXh0Lmhhc093blByb3BlcnR5KGtleSkgfHwgdGV4dFtrZXldICE9PSBwcm9wc1trZXldKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSxcblxuICAvKipcclxuICAgKiBHZXQgdGhlIGxlYXZlcyBmb3IgYSB0ZXh0IG5vZGUgZ2l2ZW4gZGVjb3JhdGlvbnMuXHJcbiAgICovXG4gIGRlY29yYXRpb25zOiBmdW5jdGlvbiBkZWNvcmF0aW9ucyhub2RlLCBfZGVjb3JhdGlvbnMpIHtcbiAgICB2YXIgbGVhdmVzID0gW19vYmplY3RTcHJlYWQkNCh7fSwgbm9kZSldO1xuXG4gICAgdmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDMoX2RlY29yYXRpb25zKSxcbiAgICAgICAgX3N0ZXA7XG5cbiAgICB0cnkge1xuICAgICAgZm9yIChfaXRlcmF0b3IucygpOyAhKF9zdGVwID0gX2l0ZXJhdG9yLm4oKSkuZG9uZTspIHtcbiAgICAgICAgdmFyIGRlYyA9IF9zdGVwLnZhbHVlO1xuXG4gICAgICAgIHZhciBhbmNob3IgPSBkZWMuYW5jaG9yLFxuICAgICAgICAgICAgZm9jdXMgPSBkZWMuZm9jdXMsXG4gICAgICAgICAgICByZXN0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKGRlYywgX2V4Y2x1ZGVkMiQxKTtcblxuICAgICAgICB2YXIgX1JhbmdlJGVkZ2VzID0gUmFuZ2UuZWRnZXMoZGVjKSxcbiAgICAgICAgICAgIF9SYW5nZSRlZGdlczIgPSBfc2xpY2VkVG9BcnJheShfUmFuZ2UkZWRnZXMsIDIpLFxuICAgICAgICAgICAgc3RhcnQgPSBfUmFuZ2UkZWRnZXMyWzBdLFxuICAgICAgICAgICAgZW5kID0gX1JhbmdlJGVkZ2VzMlsxXTtcblxuICAgICAgICB2YXIgbmV4dCA9IFtdO1xuICAgICAgICB2YXIgbGVhZkVuZCA9IDA7XG4gICAgICAgIHZhciBkZWNvcmF0aW9uU3RhcnQgPSBzdGFydC5vZmZzZXQ7XG4gICAgICAgIHZhciBkZWNvcmF0aW9uRW5kID0gZW5kLm9mZnNldDtcblxuICAgICAgICB2YXIgX2l0ZXJhdG9yMiA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDMobGVhdmVzKSxcbiAgICAgICAgICAgIF9zdGVwMjtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIGZvciAoX2l0ZXJhdG9yMi5zKCk7ICEoX3N0ZXAyID0gX2l0ZXJhdG9yMi5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgICB2YXIgbGVhZiA9IF9zdGVwMi52YWx1ZTtcbiAgICAgICAgICAgIHZhciBsZW5ndGggPSBsZWFmLnRleHQubGVuZ3RoO1xuICAgICAgICAgICAgdmFyIGxlYWZTdGFydCA9IGxlYWZFbmQ7XG4gICAgICAgICAgICBsZWFmRW5kICs9IGxlbmd0aDsgLy8gSWYgdGhlIHJhbmdlIGVuY29tcGFzc2VzIHRoZSBlbnRpcmUgbGVhZiwgYWRkIHRoZSByYW5nZS5cblxuICAgICAgICAgICAgaWYgKGRlY29yYXRpb25TdGFydCA8PSBsZWFmU3RhcnQgJiYgbGVhZkVuZCA8PSBkZWNvcmF0aW9uRW5kKSB7XG4gICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24obGVhZiwgcmVzdCk7XG4gICAgICAgICAgICAgIG5leHQucHVzaChsZWFmKTtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9IC8vIElmIHRoZSByYW5nZSBleHBhbmRlZCBhbmQgbWF0Y2ggdGhlIGxlYWYsIG9yIHN0YXJ0cyBhZnRlciwgb3IgZW5kcyBiZWZvcmUgaXQsIGNvbnRpbnVlLlxuXG5cbiAgICAgICAgICAgIGlmIChkZWNvcmF0aW9uU3RhcnQgIT09IGRlY29yYXRpb25FbmQgJiYgKGRlY29yYXRpb25TdGFydCA9PT0gbGVhZkVuZCB8fCBkZWNvcmF0aW9uRW5kID09PSBsZWFmU3RhcnQpIHx8IGRlY29yYXRpb25TdGFydCA+IGxlYWZFbmQgfHwgZGVjb3JhdGlvbkVuZCA8IGxlYWZTdGFydCB8fCBkZWNvcmF0aW9uRW5kID09PSBsZWFmU3RhcnQgJiYgbGVhZlN0YXJ0ICE9PSAwKSB7XG4gICAgICAgICAgICAgIG5leHQucHVzaChsZWFmKTtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9IC8vIE90aGVyd2lzZSB3ZSBuZWVkIHRvIHNwbGl0IHRoZSBsZWFmLCBhdCB0aGUgc3RhcnQsIGVuZCwgb3IgYm90aCxcbiAgICAgICAgICAgIC8vIGFuZCBhZGQgdGhlIHJhbmdlIHRvIHRoZSBtaWRkbGUgaW50ZXJzZWN0aW5nIHNlY3Rpb24uIERvIHRoZSBlbmRcbiAgICAgICAgICAgIC8vIHNwbGl0IGZpcnN0IHNpbmNlIHdlIGRvbid0IG5lZWQgdG8gdXBkYXRlIHRoZSBvZmZzZXQgdGhhdCB3YXkuXG5cblxuICAgICAgICAgICAgdmFyIG1pZGRsZSA9IGxlYWY7XG4gICAgICAgICAgICB2YXIgYmVmb3JlID0gdm9pZCAwO1xuICAgICAgICAgICAgdmFyIGFmdGVyID0gdm9pZCAwO1xuXG4gICAgICAgICAgICBpZiAoZGVjb3JhdGlvbkVuZCA8IGxlYWZFbmQpIHtcbiAgICAgICAgICAgICAgdmFyIG9mZiA9IGRlY29yYXRpb25FbmQgLSBsZWFmU3RhcnQ7XG4gICAgICAgICAgICAgIGFmdGVyID0gX29iamVjdFNwcmVhZCQ0KF9vYmplY3RTcHJlYWQkNCh7fSwgbWlkZGxlKSwge30sIHtcbiAgICAgICAgICAgICAgICB0ZXh0OiBtaWRkbGUudGV4dC5zbGljZShvZmYpXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBtaWRkbGUgPSBfb2JqZWN0U3ByZWFkJDQoX29iamVjdFNwcmVhZCQ0KHt9LCBtaWRkbGUpLCB7fSwge1xuICAgICAgICAgICAgICAgIHRleHQ6IG1pZGRsZS50ZXh0LnNsaWNlKDAsIG9mZilcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChkZWNvcmF0aW9uU3RhcnQgPiBsZWFmU3RhcnQpIHtcbiAgICAgICAgICAgICAgdmFyIF9vZmYgPSBkZWNvcmF0aW9uU3RhcnQgLSBsZWFmU3RhcnQ7XG5cbiAgICAgICAgICAgICAgYmVmb3JlID0gX29iamVjdFNwcmVhZCQ0KF9vYmplY3RTcHJlYWQkNCh7fSwgbWlkZGxlKSwge30sIHtcbiAgICAgICAgICAgICAgICB0ZXh0OiBtaWRkbGUudGV4dC5zbGljZSgwLCBfb2ZmKVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgbWlkZGxlID0gX29iamVjdFNwcmVhZCQ0KF9vYmplY3RTcHJlYWQkNCh7fSwgbWlkZGxlKSwge30sIHtcbiAgICAgICAgICAgICAgICB0ZXh0OiBtaWRkbGUudGV4dC5zbGljZShfb2ZmKVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihtaWRkbGUsIHJlc3QpO1xuXG4gICAgICAgICAgICBpZiAoYmVmb3JlKSB7XG4gICAgICAgICAgICAgIG5leHQucHVzaChiZWZvcmUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBuZXh0LnB1c2gobWlkZGxlKTtcblxuICAgICAgICAgICAgaWYgKGFmdGVyKSB7XG4gICAgICAgICAgICAgIG5leHQucHVzaChhZnRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBfaXRlcmF0b3IyLmUoZXJyKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBfaXRlcmF0b3IyLmYoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxlYXZlcyA9IG5leHQ7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBfaXRlcmF0b3IuZShlcnIpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBfaXRlcmF0b3IuZigpO1xuICAgIH1cblxuICAgIHJldHVybiBsZWF2ZXM7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIG93bktleXMkMyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgeyBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSk7IH0ga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQkMyh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyBvd25LZXlzJDMoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHsgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTsgfSBlbHNlIHsgb3duS2V5cyQzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciQyKG8sIGFsbG93QXJyYXlMaWtlKSB7IHZhciBpdCA9IHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdIHx8IG9bXCJAQGl0ZXJhdG9yXCJdOyBpZiAoIWl0KSB7IGlmIChBcnJheS5pc0FycmF5KG8pIHx8IChpdCA9IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSQyKG8pKSB8fCBhbGxvd0FycmF5TGlrZSAmJiBvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgeyBpZiAoaXQpIG8gPSBpdDsgdmFyIGkgPSAwOyB2YXIgRiA9IGZ1bmN0aW9uIEYoKSB7fTsgcmV0dXJuIHsgczogRiwgbjogZnVuY3Rpb24gbigpIHsgaWYgKGkgPj0gby5sZW5ndGgpIHJldHVybiB7IGRvbmU6IHRydWUgfTsgcmV0dXJuIHsgZG9uZTogZmFsc2UsIHZhbHVlOiBvW2krK10gfTsgfSwgZTogZnVuY3Rpb24gZShfZSkgeyB0aHJvdyBfZTsgfSwgZjogRiB9OyB9IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfSB2YXIgbm9ybWFsQ29tcGxldGlvbiA9IHRydWUsIGRpZEVyciA9IGZhbHNlLCBlcnI7IHJldHVybiB7IHM6IGZ1bmN0aW9uIHMoKSB7IGl0ID0gaXQuY2FsbChvKTsgfSwgbjogZnVuY3Rpb24gbigpIHsgdmFyIHN0ZXAgPSBpdC5uZXh0KCk7IG5vcm1hbENvbXBsZXRpb24gPSBzdGVwLmRvbmU7IHJldHVybiBzdGVwOyB9LCBlOiBmdW5jdGlvbiBlKF9lMikgeyBkaWRFcnIgPSB0cnVlOyBlcnIgPSBfZTI7IH0sIGY6IGZ1bmN0aW9uIGYoKSB7IHRyeSB7IGlmICghbm9ybWFsQ29tcGxldGlvbiAmJiBpdFtcInJldHVyblwiXSAhPSBudWxsKSBpdFtcInJldHVyblwiXSgpOyB9IGZpbmFsbHkgeyBpZiAoZGlkRXJyKSB0aHJvdyBlcnI7IH0gfSB9OyB9XG5cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSQyKG8sIG1pbkxlbikgeyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkkMihvLCBtaW5MZW4pOyB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5JDIobywgbWluTGVuKTsgfVxuXG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheSQyKGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfVxuXG52YXIgYXBwbHlUb0RyYWZ0ID0gZnVuY3Rpb24gYXBwbHlUb0RyYWZ0KGVkaXRvciwgc2VsZWN0aW9uLCBvcCkge1xuICBzd2l0Y2ggKG9wLnR5cGUpIHtcbiAgICBjYXNlICdpbnNlcnRfbm9kZSc6XG4gICAgICB7XG4gICAgICAgIHZhciBwYXRoID0gb3AucGF0aCxcbiAgICAgICAgICAgIG5vZGUgPSBvcC5ub2RlO1xuICAgICAgICB2YXIgcGFyZW50ID0gTm9kZS5wYXJlbnQoZWRpdG9yLCBwYXRoKTtcbiAgICAgICAgdmFyIGluZGV4ID0gcGF0aFtwYXRoLmxlbmd0aCAtIDFdO1xuXG4gICAgICAgIGlmIChpbmRleCA+IHBhcmVudC5jaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgYXBwbHkgYW4gXFxcImluc2VydF9ub2RlXFxcIiBvcGVyYXRpb24gYXQgcGF0aCBbXCIuY29uY2F0KHBhdGgsIFwiXSBiZWNhdXNlIHRoZSBkZXN0aW5hdGlvbiBpcyBwYXN0IHRoZSBlbmQgb2YgdGhlIG5vZGUuXCIpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHBhcmVudC5jaGlsZHJlbi5zcGxpY2UoaW5kZXgsIDAsIG5vZGUpO1xuXG4gICAgICAgIGlmIChzZWxlY3Rpb24pIHtcbiAgICAgICAgICB2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkMihSYW5nZS5wb2ludHMoc2VsZWN0aW9uKSksXG4gICAgICAgICAgICAgIF9zdGVwO1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAoX2l0ZXJhdG9yLnMoKTsgIShfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgICAgIHZhciBfc3RlcCR2YWx1ZSA9IF9zbGljZWRUb0FycmF5KF9zdGVwLnZhbHVlLCAyKSxcbiAgICAgICAgICAgICAgICAgIHBvaW50ID0gX3N0ZXAkdmFsdWVbMF0sXG4gICAgICAgICAgICAgICAgICBrZXkgPSBfc3RlcCR2YWx1ZVsxXTtcblxuICAgICAgICAgICAgICBzZWxlY3Rpb25ba2V5XSA9IFBvaW50LnRyYW5zZm9ybShwb2ludCwgb3ApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgX2l0ZXJhdG9yLmUoZXJyKTtcbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgX2l0ZXJhdG9yLmYoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGNhc2UgJ2luc2VydF90ZXh0JzpcbiAgICAgIHtcbiAgICAgICAgdmFyIF9wYXRoID0gb3AucGF0aCxcbiAgICAgICAgICAgIG9mZnNldCA9IG9wLm9mZnNldCxcbiAgICAgICAgICAgIHRleHQgPSBvcC50ZXh0O1xuICAgICAgICBpZiAodGV4dC5sZW5ndGggPT09IDApIGJyZWFrO1xuXG4gICAgICAgIHZhciBfbm9kZSA9IE5vZGUubGVhZihlZGl0b3IsIF9wYXRoKTtcblxuICAgICAgICB2YXIgYmVmb3JlID0gX25vZGUudGV4dC5zbGljZSgwLCBvZmZzZXQpO1xuXG4gICAgICAgIHZhciBhZnRlciA9IF9ub2RlLnRleHQuc2xpY2Uob2Zmc2V0KTtcblxuICAgICAgICBfbm9kZS50ZXh0ID0gYmVmb3JlICsgdGV4dCArIGFmdGVyO1xuXG4gICAgICAgIGlmIChzZWxlY3Rpb24pIHtcbiAgICAgICAgICB2YXIgX2l0ZXJhdG9yMiA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDIoUmFuZ2UucG9pbnRzKHNlbGVjdGlvbikpLFxuICAgICAgICAgICAgICBfc3RlcDI7XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yIChfaXRlcmF0b3IyLnMoKTsgIShfc3RlcDIgPSBfaXRlcmF0b3IyLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICAgICAgdmFyIF9zdGVwMiR2YWx1ZSA9IF9zbGljZWRUb0FycmF5KF9zdGVwMi52YWx1ZSwgMiksXG4gICAgICAgICAgICAgICAgICBfcG9pbnQgPSBfc3RlcDIkdmFsdWVbMF0sXG4gICAgICAgICAgICAgICAgICBfa2V5ID0gX3N0ZXAyJHZhbHVlWzFdO1xuXG4gICAgICAgICAgICAgIHNlbGVjdGlvbltfa2V5XSA9IFBvaW50LnRyYW5zZm9ybShfcG9pbnQsIG9wKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIF9pdGVyYXRvcjIuZShlcnIpO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBfaXRlcmF0b3IyLmYoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGNhc2UgJ21lcmdlX25vZGUnOlxuICAgICAge1xuICAgICAgICB2YXIgX3BhdGgyID0gb3AucGF0aDtcblxuICAgICAgICB2YXIgX25vZGUyID0gTm9kZS5nZXQoZWRpdG9yLCBfcGF0aDIpO1xuXG4gICAgICAgIHZhciBwcmV2UGF0aCA9IFBhdGgucHJldmlvdXMoX3BhdGgyKTtcbiAgICAgICAgdmFyIHByZXYgPSBOb2RlLmdldChlZGl0b3IsIHByZXZQYXRoKTtcblxuICAgICAgICB2YXIgX3BhcmVudCA9IE5vZGUucGFyZW50KGVkaXRvciwgX3BhdGgyKTtcblxuICAgICAgICB2YXIgX2luZGV4ID0gX3BhdGgyW19wYXRoMi5sZW5ndGggLSAxXTtcblxuICAgICAgICBpZiAoVGV4dC5pc1RleHQoX25vZGUyKSAmJiBUZXh0LmlzVGV4dChwcmV2KSkge1xuICAgICAgICAgIHByZXYudGV4dCArPSBfbm9kZTIudGV4dDtcbiAgICAgICAgfSBlbHNlIGlmICghVGV4dC5pc1RleHQoX25vZGUyKSAmJiAhVGV4dC5pc1RleHQocHJldikpIHtcbiAgICAgICAgICB2YXIgX3ByZXYkY2hpbGRyZW47XG5cbiAgICAgICAgICAoX3ByZXYkY2hpbGRyZW4gPSBwcmV2LmNoaWxkcmVuKS5wdXNoLmFwcGx5KF9wcmV2JGNoaWxkcmVuLCBfdG9Db25zdW1hYmxlQXJyYXkoX25vZGUyLmNoaWxkcmVuKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGFwcGx5IGEgXFxcIm1lcmdlX25vZGVcXFwiIG9wZXJhdGlvbiBhdCBwYXRoIFtcIi5jb25jYXQoX3BhdGgyLCBcIl0gdG8gbm9kZXMgb2YgZGlmZmVyZW50IGludGVyZmFjZXM6IFwiKS5jb25jYXQoU2NydWJiZXIuc3RyaW5naWZ5KF9ub2RlMiksIFwiIFwiKS5jb25jYXQoU2NydWJiZXIuc3RyaW5naWZ5KHByZXYpKSk7XG4gICAgICAgIH1cblxuICAgICAgICBfcGFyZW50LmNoaWxkcmVuLnNwbGljZShfaW5kZXgsIDEpO1xuXG4gICAgICAgIGlmIChzZWxlY3Rpb24pIHtcbiAgICAgICAgICB2YXIgX2l0ZXJhdG9yMyA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDIoUmFuZ2UucG9pbnRzKHNlbGVjdGlvbikpLFxuICAgICAgICAgICAgICBfc3RlcDM7XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yIChfaXRlcmF0b3IzLnMoKTsgIShfc3RlcDMgPSBfaXRlcmF0b3IzLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICAgICAgdmFyIF9zdGVwMyR2YWx1ZSA9IF9zbGljZWRUb0FycmF5KF9zdGVwMy52YWx1ZSwgMiksXG4gICAgICAgICAgICAgICAgICBfcG9pbnQyID0gX3N0ZXAzJHZhbHVlWzBdLFxuICAgICAgICAgICAgICAgICAgX2tleTIgPSBfc3RlcDMkdmFsdWVbMV07XG5cbiAgICAgICAgICAgICAgc2VsZWN0aW9uW19rZXkyXSA9IFBvaW50LnRyYW5zZm9ybShfcG9pbnQyLCBvcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBfaXRlcmF0b3IzLmUoZXJyKTtcbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgX2l0ZXJhdG9yMy5mKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlICdtb3ZlX25vZGUnOlxuICAgICAge1xuICAgICAgICB2YXIgX3BhdGgzID0gb3AucGF0aCxcbiAgICAgICAgICAgIG5ld1BhdGggPSBvcC5uZXdQYXRoO1xuXG4gICAgICAgIGlmIChQYXRoLmlzQW5jZXN0b3IoX3BhdGgzLCBuZXdQYXRoKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBtb3ZlIGEgcGF0aCBbXCIuY29uY2F0KF9wYXRoMywgXCJdIHRvIG5ldyBwYXRoIFtcIikuY29uY2F0KG5ld1BhdGgsIFwiXSBiZWNhdXNlIHRoZSBkZXN0aW5hdGlvbiBpcyBpbnNpZGUgaXRzZWxmLlwiKSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgX25vZGUzID0gTm9kZS5nZXQoZWRpdG9yLCBfcGF0aDMpO1xuXG4gICAgICAgIHZhciBfcGFyZW50MiA9IE5vZGUucGFyZW50KGVkaXRvciwgX3BhdGgzKTtcblxuICAgICAgICB2YXIgX2luZGV4MiA9IF9wYXRoM1tfcGF0aDMubGVuZ3RoIC0gMV07IC8vIFRoaXMgaXMgdHJpY2t5LCBidXQgc2luY2UgdGhlIGBwYXRoYCBhbmQgYG5ld1BhdGhgIGJvdGggcmVmZXIgdG9cbiAgICAgICAgLy8gdGhlIHNhbWUgc25hcHNob3QgaW4gdGltZSwgdGhlcmUncyBhIG1pc21hdGNoLiBBZnRlciBlaXRoZXJcbiAgICAgICAgLy8gcmVtb3ZpbmcgdGhlIG9yaWdpbmFsIHBvc2l0aW9uLCB0aGUgc2Vjb25kIHN0ZXAncyBwYXRoIGNhbiBiZSBvdXRcbiAgICAgICAgLy8gb2YgZGF0ZS4gU28gaW5zdGVhZCBvZiB1c2luZyB0aGUgYG9wLm5ld1BhdGhgIGRpcmVjdGx5LCB3ZVxuICAgICAgICAvLyB0cmFuc2Zvcm0gYG9wLnBhdGhgIHRvIGFzY2VydGFpbiB3aGF0IHRoZSBgbmV3UGF0aGAgd291bGQgYmUgYWZ0ZXJcbiAgICAgICAgLy8gdGhlIG9wZXJhdGlvbiB3YXMgYXBwbGllZC5cblxuICAgICAgICBfcGFyZW50Mi5jaGlsZHJlbi5zcGxpY2UoX2luZGV4MiwgMSk7XG5cbiAgICAgICAgdmFyIHRydWVQYXRoID0gUGF0aC50cmFuc2Zvcm0oX3BhdGgzLCBvcCk7XG4gICAgICAgIHZhciBuZXdQYXJlbnQgPSBOb2RlLmdldChlZGl0b3IsIFBhdGgucGFyZW50KHRydWVQYXRoKSk7XG4gICAgICAgIHZhciBuZXdJbmRleCA9IHRydWVQYXRoW3RydWVQYXRoLmxlbmd0aCAtIDFdO1xuICAgICAgICBuZXdQYXJlbnQuY2hpbGRyZW4uc3BsaWNlKG5ld0luZGV4LCAwLCBfbm9kZTMpO1xuXG4gICAgICAgIGlmIChzZWxlY3Rpb24pIHtcbiAgICAgICAgICB2YXIgX2l0ZXJhdG9yNCA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDIoUmFuZ2UucG9pbnRzKHNlbGVjdGlvbikpLFxuICAgICAgICAgICAgICBfc3RlcDQ7XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yIChfaXRlcmF0b3I0LnMoKTsgIShfc3RlcDQgPSBfaXRlcmF0b3I0Lm4oKSkuZG9uZTspIHtcbiAgICAgICAgICAgICAgdmFyIF9zdGVwNCR2YWx1ZSA9IF9zbGljZWRUb0FycmF5KF9zdGVwNC52YWx1ZSwgMiksXG4gICAgICAgICAgICAgICAgICBfcG9pbnQzID0gX3N0ZXA0JHZhbHVlWzBdLFxuICAgICAgICAgICAgICAgICAgX2tleTMgPSBfc3RlcDQkdmFsdWVbMV07XG5cbiAgICAgICAgICAgICAgc2VsZWN0aW9uW19rZXkzXSA9IFBvaW50LnRyYW5zZm9ybShfcG9pbnQzLCBvcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBfaXRlcmF0b3I0LmUoZXJyKTtcbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgX2l0ZXJhdG9yNC5mKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlICdyZW1vdmVfbm9kZSc6XG4gICAgICB7XG4gICAgICAgIHZhciBfcGF0aDQgPSBvcC5wYXRoO1xuICAgICAgICB2YXIgX2luZGV4MyA9IF9wYXRoNFtfcGF0aDQubGVuZ3RoIC0gMV07XG5cbiAgICAgICAgdmFyIF9wYXJlbnQzID0gTm9kZS5wYXJlbnQoZWRpdG9yLCBfcGF0aDQpO1xuXG4gICAgICAgIF9wYXJlbnQzLmNoaWxkcmVuLnNwbGljZShfaW5kZXgzLCAxKTsgLy8gVHJhbnNmb3JtIGFsbCBvZiB0aGUgcG9pbnRzIGluIHRoZSB2YWx1ZSwgYnV0IGlmIHRoZSBwb2ludCB3YXMgaW4gdGhlXG4gICAgICAgIC8vIG5vZGUgdGhhdCB3YXMgcmVtb3ZlZCB3ZSBuZWVkIHRvIHVwZGF0ZSB0aGUgcmFuZ2Ugb3IgcmVtb3ZlIGl0LlxuXG5cbiAgICAgICAgaWYgKHNlbGVjdGlvbikge1xuICAgICAgICAgIHZhciBfaXRlcmF0b3I1ID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkMihSYW5nZS5wb2ludHMoc2VsZWN0aW9uKSksXG4gICAgICAgICAgICAgIF9zdGVwNTtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKF9pdGVyYXRvcjUucygpOyAhKF9zdGVwNSA9IF9pdGVyYXRvcjUubigpKS5kb25lOykge1xuICAgICAgICAgICAgICB2YXIgX3N0ZXA1JHZhbHVlID0gX3NsaWNlZFRvQXJyYXkoX3N0ZXA1LnZhbHVlLCAyKSxcbiAgICAgICAgICAgICAgICAgIF9wb2ludDQgPSBfc3RlcDUkdmFsdWVbMF0sXG4gICAgICAgICAgICAgICAgICBfa2V5NCA9IF9zdGVwNSR2YWx1ZVsxXTtcblxuICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gUG9pbnQudHJhbnNmb3JtKF9wb2ludDQsIG9wKTtcblxuICAgICAgICAgICAgICBpZiAoc2VsZWN0aW9uICE9IG51bGwgJiYgcmVzdWx0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb25bX2tleTRdID0gcmVzdWx0O1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBfcHJldiA9IHZvaWQgMDtcblxuICAgICAgICAgICAgICAgIHZhciBuZXh0ID0gdm9pZCAwO1xuXG4gICAgICAgICAgICAgICAgdmFyIF9pdGVyYXRvcjYgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciQyKE5vZGUudGV4dHMoZWRpdG9yKSksXG4gICAgICAgICAgICAgICAgICAgIF9zdGVwNjtcblxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICBmb3IgKF9pdGVyYXRvcjYucygpOyAhKF9zdGVwNiA9IF9pdGVyYXRvcjYubigpKS5kb25lOykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX3N0ZXA2JHZhbHVlID0gX3NsaWNlZFRvQXJyYXkoX3N0ZXA2LnZhbHVlLCAyKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG4gPSBfc3RlcDYkdmFsdWVbMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICBwID0gX3N0ZXA2JHZhbHVlWzFdO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChQYXRoLmNvbXBhcmUocCwgX3BhdGg0KSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICBfcHJldiA9IFtuLCBwXTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICBuZXh0ID0gW24sIHBdO1xuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICBfaXRlcmF0b3I2LmUoZXJyKTtcbiAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgX2l0ZXJhdG9yNi5mKCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIHByZWZlck5leHQgPSBmYWxzZTtcblxuICAgICAgICAgICAgICAgIGlmIChfcHJldiAmJiBuZXh0KSB7XG4gICAgICAgICAgICAgICAgICBpZiAoUGF0aC5lcXVhbHMobmV4dFsxXSwgX3BhdGg0KSkge1xuICAgICAgICAgICAgICAgICAgICBwcmVmZXJOZXh0ID0gIVBhdGguaGFzUHJldmlvdXMobmV4dFsxXSk7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwcmVmZXJOZXh0ID0gUGF0aC5jb21tb24oX3ByZXZbMV0sIF9wYXRoNCkubGVuZ3RoIDwgUGF0aC5jb21tb24obmV4dFsxXSwgX3BhdGg0KS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKF9wcmV2ICYmICFwcmVmZXJOZXh0KSB7XG4gICAgICAgICAgICAgICAgICBfcG9pbnQ0LnBhdGggPSBfcHJldlsxXTtcbiAgICAgICAgICAgICAgICAgIF9wb2ludDQub2Zmc2V0ID0gX3ByZXZbMF0udGV4dC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChuZXh0KSB7XG4gICAgICAgICAgICAgICAgICBfcG9pbnQ0LnBhdGggPSBuZXh0WzFdO1xuICAgICAgICAgICAgICAgICAgX3BvaW50NC5vZmZzZXQgPSAwO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBzZWxlY3Rpb24gPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgX2l0ZXJhdG9yNS5lKGVycik7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIF9pdGVyYXRvcjUuZigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSAncmVtb3ZlX3RleHQnOlxuICAgICAge1xuICAgICAgICB2YXIgX3BhdGg1ID0gb3AucGF0aCxcbiAgICAgICAgICAgIF9vZmZzZXQgPSBvcC5vZmZzZXQsXG4gICAgICAgICAgICBfdGV4dCA9IG9wLnRleHQ7XG4gICAgICAgIGlmIChfdGV4dC5sZW5ndGggPT09IDApIGJyZWFrO1xuXG4gICAgICAgIHZhciBfbm9kZTQgPSBOb2RlLmxlYWYoZWRpdG9yLCBfcGF0aDUpO1xuXG4gICAgICAgIHZhciBfYmVmb3JlID0gX25vZGU0LnRleHQuc2xpY2UoMCwgX29mZnNldCk7XG5cbiAgICAgICAgdmFyIF9hZnRlciA9IF9ub2RlNC50ZXh0LnNsaWNlKF9vZmZzZXQgKyBfdGV4dC5sZW5ndGgpO1xuXG4gICAgICAgIF9ub2RlNC50ZXh0ID0gX2JlZm9yZSArIF9hZnRlcjtcblxuICAgICAgICBpZiAoc2VsZWN0aW9uKSB7XG4gICAgICAgICAgdmFyIF9pdGVyYXRvcjcgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciQyKFJhbmdlLnBvaW50cyhzZWxlY3Rpb24pKSxcbiAgICAgICAgICAgICAgX3N0ZXA3O1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAoX2l0ZXJhdG9yNy5zKCk7ICEoX3N0ZXA3ID0gX2l0ZXJhdG9yNy5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgICAgIHZhciBfc3RlcDckdmFsdWUgPSBfc2xpY2VkVG9BcnJheShfc3RlcDcudmFsdWUsIDIpLFxuICAgICAgICAgICAgICAgICAgX3BvaW50NSA9IF9zdGVwNyR2YWx1ZVswXSxcbiAgICAgICAgICAgICAgICAgIF9rZXk1ID0gX3N0ZXA3JHZhbHVlWzFdO1xuXG4gICAgICAgICAgICAgIHNlbGVjdGlvbltfa2V5NV0gPSBQb2ludC50cmFuc2Zvcm0oX3BvaW50NSwgb3ApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgX2l0ZXJhdG9yNy5lKGVycik7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIF9pdGVyYXRvcjcuZigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSAnc2V0X25vZGUnOlxuICAgICAge1xuICAgICAgICB2YXIgX3BhdGg2ID0gb3AucGF0aCxcbiAgICAgICAgICAgIHByb3BlcnRpZXMgPSBvcC5wcm9wZXJ0aWVzLFxuICAgICAgICAgICAgbmV3UHJvcGVydGllcyA9IG9wLm5ld1Byb3BlcnRpZXM7XG5cbiAgICAgICAgaWYgKF9wYXRoNi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3Qgc2V0IHByb3BlcnRpZXMgb24gdGhlIHJvb3Qgbm9kZSFcIik7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgX25vZGU1ID0gTm9kZS5nZXQoZWRpdG9yLCBfcGF0aDYpO1xuXG4gICAgICAgIGZvciAodmFyIF9rZXk2IGluIG5ld1Byb3BlcnRpZXMpIHtcbiAgICAgICAgICBpZiAoX2tleTYgPT09ICdjaGlsZHJlbicgfHwgX2tleTYgPT09ICd0ZXh0Jykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHNldCB0aGUgXFxcIlwiLmNvbmNhdChfa2V5NiwgXCJcXFwiIHByb3BlcnR5IG9mIG5vZGVzIVwiKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHZhbHVlID0gbmV3UHJvcGVydGllc1tfa2V5Nl07XG5cbiAgICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgZGVsZXRlIF9ub2RlNVtfa2V5Nl07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIF9ub2RlNVtfa2V5Nl0gPSB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gcHJvcGVydGllcyB0aGF0IHdlcmUgcHJldmlvdXNseSBkZWZpbmVkLCBidXQgYXJlIG5vdyBtaXNzaW5nLCBtdXN0IGJlIGRlbGV0ZWRcblxuXG4gICAgICAgIGZvciAodmFyIF9rZXk3IGluIHByb3BlcnRpZXMpIHtcbiAgICAgICAgICBpZiAoIW5ld1Byb3BlcnRpZXMuaGFzT3duUHJvcGVydHkoX2tleTcpKSB7XG4gICAgICAgICAgICBkZWxldGUgX25vZGU1W19rZXk3XTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGNhc2UgJ3NldF9zZWxlY3Rpb24nOlxuICAgICAge1xuICAgICAgICB2YXIgX25ld1Byb3BlcnRpZXMgPSBvcC5uZXdQcm9wZXJ0aWVzO1xuXG4gICAgICAgIGlmIChfbmV3UHJvcGVydGllcyA9PSBudWxsKSB7XG4gICAgICAgICAgc2VsZWN0aW9uID0gX25ld1Byb3BlcnRpZXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHNlbGVjdGlvbiA9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoIVJhbmdlLmlzUmFuZ2UoX25ld1Byb3BlcnRpZXMpKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBhcHBseSBhbiBpbmNvbXBsZXRlIFxcXCJzZXRfc2VsZWN0aW9uXFxcIiBvcGVyYXRpb24gcHJvcGVydGllcyBcIi5jb25jYXQoU2NydWJiZXIuc3RyaW5naWZ5KF9uZXdQcm9wZXJ0aWVzKSwgXCIgd2hlbiB0aGVyZSBpcyBubyBjdXJyZW50IHNlbGVjdGlvbi5cIikpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzZWxlY3Rpb24gPSBfb2JqZWN0U3ByZWFkJDMoe30sIF9uZXdQcm9wZXJ0aWVzKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmb3IgKHZhciBfa2V5OCBpbiBfbmV3UHJvcGVydGllcykge1xuICAgICAgICAgICAgdmFyIF92YWx1ZSA9IF9uZXdQcm9wZXJ0aWVzW19rZXk4XTtcblxuICAgICAgICAgICAgaWYgKF92YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgIGlmIChfa2V5OCA9PT0gJ2FuY2hvcicgfHwgX2tleTggPT09ICdmb2N1cycpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgcmVtb3ZlIHRoZSBcXFwiXCIuY29uY2F0KF9rZXk4LCBcIlxcXCIgc2VsZWN0aW9uIHByb3BlcnR5XCIpKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGRlbGV0ZSBzZWxlY3Rpb25bX2tleThdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc2VsZWN0aW9uW19rZXk4XSA9IF92YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGNhc2UgJ3NwbGl0X25vZGUnOlxuICAgICAge1xuICAgICAgICB2YXIgX3BhdGg3ID0gb3AucGF0aCxcbiAgICAgICAgICAgIHBvc2l0aW9uID0gb3AucG9zaXRpb24sXG4gICAgICAgICAgICBfcHJvcGVydGllcyA9IG9wLnByb3BlcnRpZXM7XG5cbiAgICAgICAgaWYgKF9wYXRoNy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgYXBwbHkgYSBcXFwic3BsaXRfbm9kZVxcXCIgb3BlcmF0aW9uIGF0IHBhdGggW1wiLmNvbmNhdChfcGF0aDcsIFwiXSBiZWNhdXNlIHRoZSByb290IG5vZGUgY2Fubm90IGJlIHNwbGl0LlwiKSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgX25vZGU2ID0gTm9kZS5nZXQoZWRpdG9yLCBfcGF0aDcpO1xuXG4gICAgICAgIHZhciBfcGFyZW50NCA9IE5vZGUucGFyZW50KGVkaXRvciwgX3BhdGg3KTtcblxuICAgICAgICB2YXIgX2luZGV4NCA9IF9wYXRoN1tfcGF0aDcubGVuZ3RoIC0gMV07XG4gICAgICAgIHZhciBuZXdOb2RlO1xuXG4gICAgICAgIGlmIChUZXh0LmlzVGV4dChfbm9kZTYpKSB7XG4gICAgICAgICAgdmFyIF9iZWZvcmUyID0gX25vZGU2LnRleHQuc2xpY2UoMCwgcG9zaXRpb24pO1xuXG4gICAgICAgICAgdmFyIF9hZnRlcjIgPSBfbm9kZTYudGV4dC5zbGljZShwb3NpdGlvbik7XG5cbiAgICAgICAgICBfbm9kZTYudGV4dCA9IF9iZWZvcmUyO1xuICAgICAgICAgIG5ld05vZGUgPSBfb2JqZWN0U3ByZWFkJDMoX29iamVjdFNwcmVhZCQzKHt9LCBfcHJvcGVydGllcyksIHt9LCB7XG4gICAgICAgICAgICB0ZXh0OiBfYWZ0ZXIyXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIF9iZWZvcmUzID0gX25vZGU2LmNoaWxkcmVuLnNsaWNlKDAsIHBvc2l0aW9uKTtcblxuICAgICAgICAgIHZhciBfYWZ0ZXIzID0gX25vZGU2LmNoaWxkcmVuLnNsaWNlKHBvc2l0aW9uKTtcblxuICAgICAgICAgIF9ub2RlNi5jaGlsZHJlbiA9IF9iZWZvcmUzO1xuICAgICAgICAgIG5ld05vZGUgPSBfb2JqZWN0U3ByZWFkJDMoX29iamVjdFNwcmVhZCQzKHt9LCBfcHJvcGVydGllcyksIHt9LCB7XG4gICAgICAgICAgICBjaGlsZHJlbjogX2FmdGVyM1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgX3BhcmVudDQuY2hpbGRyZW4uc3BsaWNlKF9pbmRleDQgKyAxLCAwLCBuZXdOb2RlKTtcblxuICAgICAgICBpZiAoc2VsZWN0aW9uKSB7XG4gICAgICAgICAgdmFyIF9pdGVyYXRvcjggPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciQyKFJhbmdlLnBvaW50cyhzZWxlY3Rpb24pKSxcbiAgICAgICAgICAgICAgX3N0ZXA4O1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAoX2l0ZXJhdG9yOC5zKCk7ICEoX3N0ZXA4ID0gX2l0ZXJhdG9yOC5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgICAgIHZhciBfc3RlcDgkdmFsdWUgPSBfc2xpY2VkVG9BcnJheShfc3RlcDgudmFsdWUsIDIpLFxuICAgICAgICAgICAgICAgICAgX3BvaW50NiA9IF9zdGVwOCR2YWx1ZVswXSxcbiAgICAgICAgICAgICAgICAgIF9rZXk5ID0gX3N0ZXA4JHZhbHVlWzFdO1xuXG4gICAgICAgICAgICAgIHNlbGVjdGlvbltfa2V5OV0gPSBQb2ludC50cmFuc2Zvcm0oX3BvaW50Niwgb3ApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgX2l0ZXJhdG9yOC5lKGVycik7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIF9pdGVyYXRvcjguZigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICB9XG5cbiAgcmV0dXJuIHNlbGVjdGlvbjtcbn07IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZWRlY2xhcmVcblxuXG52YXIgR2VuZXJhbFRyYW5zZm9ybXMgPSB7XG4gIC8qKlxyXG4gICAqIFRyYW5zZm9ybSB0aGUgZWRpdG9yIGJ5IGFuIG9wZXJhdGlvbi5cclxuICAgKi9cbiAgdHJhbnNmb3JtOiBmdW5jdGlvbiB0cmFuc2Zvcm0oZWRpdG9yLCBvcCkge1xuICAgIGVkaXRvci5jaGlsZHJlbiA9IGltbWVyLmNyZWF0ZURyYWZ0KGVkaXRvci5jaGlsZHJlbik7XG4gICAgdmFyIHNlbGVjdGlvbiA9IGVkaXRvci5zZWxlY3Rpb24gJiYgaW1tZXIuY3JlYXRlRHJhZnQoZWRpdG9yLnNlbGVjdGlvbik7XG5cbiAgICB0cnkge1xuICAgICAgc2VsZWN0aW9uID0gYXBwbHlUb0RyYWZ0KGVkaXRvciwgc2VsZWN0aW9uLCBvcCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGVkaXRvci5jaGlsZHJlbiA9IGltbWVyLmZpbmlzaERyYWZ0KGVkaXRvci5jaGlsZHJlbik7XG5cbiAgICAgIGlmIChzZWxlY3Rpb24pIHtcbiAgICAgICAgZWRpdG9yLnNlbGVjdGlvbiA9IGltbWVyLmlzRHJhZnQoc2VsZWN0aW9uKSA/IGltbWVyLmZpbmlzaERyYWZ0KHNlbGVjdGlvbikgOiBzZWxlY3Rpb247XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlZGl0b3Iuc2VsZWN0aW9uID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbnZhciBfZXhjbHVkZWQgPSBbXCJ0ZXh0XCJdLFxuICAgIF9leGNsdWRlZDIgPSBbXCJjaGlsZHJlblwiXTtcblxuZnVuY3Rpb24gb3duS2V5cyQyKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgaWYgKGVudW1lcmFibGVPbmx5KSB7IHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KTsgfSBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCQyKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgaWYgKGkgJSAyKSB7IG93bktleXMkMihPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBvd25LZXlzJDIoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDEobywgYWxsb3dBcnJheUxpa2UpIHsgdmFyIGl0ID0gdHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl0gfHwgb1tcIkBAaXRlcmF0b3JcIl07IGlmICghaXQpIHsgaWYgKEFycmF5LmlzQXJyYXkobykgfHwgKGl0ID0gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5JDEobykpIHx8IGFsbG93QXJyYXlMaWtlICYmIG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSB7IGlmIChpdCkgbyA9IGl0OyB2YXIgaSA9IDA7IHZhciBGID0gZnVuY3Rpb24gRigpIHt9OyByZXR1cm4geyBzOiBGLCBuOiBmdW5jdGlvbiBuKCkgeyBpZiAoaSA+PSBvLmxlbmd0aCkgcmV0dXJuIHsgZG9uZTogdHJ1ZSB9OyByZXR1cm4geyBkb25lOiBmYWxzZSwgdmFsdWU6IG9baSsrXSB9OyB9LCBlOiBmdW5jdGlvbiBlKF9lKSB7IHRocm93IF9lOyB9LCBmOiBGIH07IH0gdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9IHZhciBub3JtYWxDb21wbGV0aW9uID0gdHJ1ZSwgZGlkRXJyID0gZmFsc2UsIGVycjsgcmV0dXJuIHsgczogZnVuY3Rpb24gcygpIHsgaXQgPSBpdC5jYWxsKG8pOyB9LCBuOiBmdW5jdGlvbiBuKCkgeyB2YXIgc3RlcCA9IGl0Lm5leHQoKTsgbm9ybWFsQ29tcGxldGlvbiA9IHN0ZXAuZG9uZTsgcmV0dXJuIHN0ZXA7IH0sIGU6IGZ1bmN0aW9uIGUoX2UyKSB7IGRpZEVyciA9IHRydWU7IGVyciA9IF9lMjsgfSwgZjogZnVuY3Rpb24gZigpIHsgdHJ5IHsgaWYgKCFub3JtYWxDb21wbGV0aW9uICYmIGl0W1wicmV0dXJuXCJdICE9IG51bGwpIGl0W1wicmV0dXJuXCJdKCk7IH0gZmluYWxseSB7IGlmIChkaWRFcnIpIHRocm93IGVycjsgfSB9IH07IH1cblxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5JDEobywgbWluTGVuKSB7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheSQxKG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkkMShvLCBtaW5MZW4pOyB9XG5cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5JDEoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgeyBhcnIyW2ldID0gYXJyW2ldOyB9IHJldHVybiBhcnIyOyB9XG5cbnZhciBOb2RlVHJhbnNmb3JtcyA9IHtcbiAgLyoqXHJcbiAgICogSW5zZXJ0IG5vZGVzIGF0IGEgc3BlY2lmaWMgbG9jYXRpb24gaW4gdGhlIEVkaXRvci5cclxuICAgKi9cbiAgaW5zZXJ0Tm9kZXM6IGZ1bmN0aW9uIGluc2VydE5vZGVzKGVkaXRvciwgbm9kZXMpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgRWRpdG9yLndpdGhvdXROb3JtYWxpemluZyhlZGl0b3IsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfb3B0aW9ucyRoYW5naW5nID0gb3B0aW9ucy5oYW5naW5nLFxuICAgICAgICAgIGhhbmdpbmcgPSBfb3B0aW9ucyRoYW5naW5nID09PSB2b2lkIDAgPyBmYWxzZSA6IF9vcHRpb25zJGhhbmdpbmcsXG4gICAgICAgICAgX29wdGlvbnMkdm9pZHMgPSBvcHRpb25zLnZvaWRzLFxuICAgICAgICAgIHZvaWRzID0gX29wdGlvbnMkdm9pZHMgPT09IHZvaWQgMCA/IGZhbHNlIDogX29wdGlvbnMkdm9pZHMsXG4gICAgICAgICAgX29wdGlvbnMkbW9kZSA9IG9wdGlvbnMubW9kZSxcbiAgICAgICAgICBtb2RlID0gX29wdGlvbnMkbW9kZSA9PT0gdm9pZCAwID8gJ2xvd2VzdCcgOiBfb3B0aW9ucyRtb2RlO1xuICAgICAgdmFyIGF0ID0gb3B0aW9ucy5hdCxcbiAgICAgICAgICBtYXRjaCA9IG9wdGlvbnMubWF0Y2gsXG4gICAgICAgICAgc2VsZWN0ID0gb3B0aW9ucy5zZWxlY3Q7XG5cbiAgICAgIGlmIChOb2RlLmlzTm9kZShub2RlcykpIHtcbiAgICAgICAgbm9kZXMgPSBbbm9kZXNdO1xuICAgICAgfVxuXG4gICAgICBpZiAobm9kZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIF9ub2RlcyA9IG5vZGVzLFxuICAgICAgICAgIF9ub2RlczIgPSBfc2xpY2VkVG9BcnJheShfbm9kZXMsIDEpLFxuICAgICAgICAgIG5vZGUgPSBfbm9kZXMyWzBdOyAvLyBCeSBkZWZhdWx0LCB1c2UgdGhlIHNlbGVjdGlvbiBhcyB0aGUgdGFyZ2V0IGxvY2F0aW9uLiBCdXQgaWYgdGhlcmUgaXNcbiAgICAgIC8vIG5vIHNlbGVjdGlvbiwgaW5zZXJ0IGF0IHRoZSBlbmQgb2YgdGhlIGRvY3VtZW50IHNpbmNlIHRoYXQgaXMgc3VjaCBhXG4gICAgICAvLyBjb21tb24gdXNlIGNhc2Ugd2hlbiBpbnNlcnRpbmcgZnJvbSBhIG5vbi1zZWxlY3RlZCBzdGF0ZS5cblxuXG4gICAgICBpZiAoIWF0KSB7XG4gICAgICAgIGlmIChlZGl0b3Iuc2VsZWN0aW9uKSB7XG4gICAgICAgICAgYXQgPSBlZGl0b3Iuc2VsZWN0aW9uO1xuICAgICAgICB9IGVsc2UgaWYgKGVkaXRvci5jaGlsZHJlbi5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgYXQgPSBFZGl0b3IuZW5kKGVkaXRvciwgW10pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGF0ID0gWzBdO1xuICAgICAgICB9XG5cbiAgICAgICAgc2VsZWN0ID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNlbGVjdCA9PSBudWxsKSB7XG4gICAgICAgIHNlbGVjdCA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiAoUmFuZ2UuaXNSYW5nZShhdCkpIHtcbiAgICAgICAgaWYgKCFoYW5naW5nKSB7XG4gICAgICAgICAgYXQgPSBFZGl0b3IudW5oYW5nUmFuZ2UoZWRpdG9yLCBhdCwge1xuICAgICAgICAgICAgdm9pZHM6IHZvaWRzXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoUmFuZ2UuaXNDb2xsYXBzZWQoYXQpKSB7XG4gICAgICAgICAgYXQgPSBhdC5hbmNob3I7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIF9SYW5nZSRlZGdlcyA9IFJhbmdlLmVkZ2VzKGF0KSxcbiAgICAgICAgICAgICAgX1JhbmdlJGVkZ2VzMiA9IF9zbGljZWRUb0FycmF5KF9SYW5nZSRlZGdlcywgMiksXG4gICAgICAgICAgICAgIGVuZCA9IF9SYW5nZSRlZGdlczJbMV07XG5cbiAgICAgICAgICB2YXIgcG9pbnRSZWYgPSBFZGl0b3IucG9pbnRSZWYoZWRpdG9yLCBlbmQpO1xuICAgICAgICAgIFRyYW5zZm9ybXNbXCJkZWxldGVcIl0oZWRpdG9yLCB7XG4gICAgICAgICAgICBhdDogYXRcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBhdCA9IHBvaW50UmVmLnVucmVmKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKFBvaW50LmlzUG9pbnQoYXQpKSB7XG4gICAgICAgIGlmIChtYXRjaCA9PSBudWxsKSB7XG4gICAgICAgICAgaWYgKFRleHQuaXNUZXh0KG5vZGUpKSB7XG4gICAgICAgICAgICBtYXRjaCA9IGZ1bmN0aW9uIG1hdGNoKG4pIHtcbiAgICAgICAgICAgICAgcmV0dXJuIFRleHQuaXNUZXh0KG4pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGVkaXRvci5pc0lubGluZShub2RlKSkge1xuICAgICAgICAgICAgbWF0Y2ggPSBmdW5jdGlvbiBtYXRjaChuKSB7XG4gICAgICAgICAgICAgIHJldHVybiBUZXh0LmlzVGV4dChuKSB8fCBFZGl0b3IuaXNJbmxpbmUoZWRpdG9yLCBuKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1hdGNoID0gZnVuY3Rpb24gbWF0Y2gobikge1xuICAgICAgICAgICAgICByZXR1cm4gRWxlbWVudC5pc0VsZW1lbnQobikgJiYgRWRpdG9yLmlzQmxvY2soZWRpdG9yLCBuKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIF9FZGl0b3Ikbm9kZXMgPSBFZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgYXQ6IGF0LnBhdGgsXG4gICAgICAgICAgbWF0Y2g6IG1hdGNoLFxuICAgICAgICAgIG1vZGU6IG1vZGUsXG4gICAgICAgICAgdm9pZHM6IHZvaWRzXG4gICAgICAgIH0pLFxuICAgICAgICAgICAgX0VkaXRvciRub2RlczIgPSBfc2xpY2VkVG9BcnJheShfRWRpdG9yJG5vZGVzLCAxKSxcbiAgICAgICAgICAgIGVudHJ5ID0gX0VkaXRvciRub2RlczJbMF07XG5cbiAgICAgICAgaWYgKGVudHJ5KSB7XG4gICAgICAgICAgdmFyIF9lbnRyeSA9IF9zbGljZWRUb0FycmF5KGVudHJ5LCAyKSxcbiAgICAgICAgICAgICAgX21hdGNoUGF0aCA9IF9lbnRyeVsxXTtcblxuICAgICAgICAgIHZhciBwYXRoUmVmID0gRWRpdG9yLnBhdGhSZWYoZWRpdG9yLCBfbWF0Y2hQYXRoKTtcbiAgICAgICAgICB2YXIgaXNBdEVuZCA9IEVkaXRvci5pc0VuZChlZGl0b3IsIGF0LCBfbWF0Y2hQYXRoKTtcbiAgICAgICAgICBUcmFuc2Zvcm1zLnNwbGl0Tm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICBhdDogYXQsXG4gICAgICAgICAgICBtYXRjaDogbWF0Y2gsXG4gICAgICAgICAgICBtb2RlOiBtb2RlLFxuICAgICAgICAgICAgdm9pZHM6IHZvaWRzXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdmFyIHBhdGggPSBwYXRoUmVmLnVucmVmKCk7XG4gICAgICAgICAgYXQgPSBpc0F0RW5kID8gUGF0aC5uZXh0KHBhdGgpIDogcGF0aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHBhcmVudFBhdGggPSBQYXRoLnBhcmVudChhdCk7XG4gICAgICB2YXIgaW5kZXggPSBhdFthdC5sZW5ndGggLSAxXTtcblxuICAgICAgaWYgKCF2b2lkcyAmJiBFZGl0b3JbXCJ2b2lkXCJdKGVkaXRvciwge1xuICAgICAgICBhdDogcGFyZW50UGF0aFxuICAgICAgfSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkMShub2RlcyksXG4gICAgICAgICAgX3N0ZXA7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoX2l0ZXJhdG9yLnMoKTsgIShfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgdmFyIF9ub2RlID0gX3N0ZXAudmFsdWU7XG5cbiAgICAgICAgICB2YXIgX3BhdGggPSBwYXJlbnRQYXRoLmNvbmNhdChpbmRleCk7XG5cbiAgICAgICAgICBpbmRleCsrO1xuICAgICAgICAgIGVkaXRvci5hcHBseSh7XG4gICAgICAgICAgICB0eXBlOiAnaW5zZXJ0X25vZGUnLFxuICAgICAgICAgICAgcGF0aDogX3BhdGgsXG4gICAgICAgICAgICBub2RlOiBfbm9kZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGF0ID0gUGF0aC5uZXh0KGF0KTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9pdGVyYXRvci5lKGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBfaXRlcmF0b3IuZigpO1xuICAgICAgfVxuXG4gICAgICBhdCA9IFBhdGgucHJldmlvdXMoYXQpO1xuXG4gICAgICBpZiAoc2VsZWN0KSB7XG4gICAgICAgIHZhciBwb2ludCA9IEVkaXRvci5lbmQoZWRpdG9yLCBhdCk7XG5cbiAgICAgICAgaWYgKHBvaW50KSB7XG4gICAgICAgICAgVHJhbnNmb3Jtcy5zZWxlY3QoZWRpdG9yLCBwb2ludCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcblxuICAvKipcclxuICAgKiBMaWZ0IG5vZGVzIGF0IGEgc3BlY2lmaWMgbG9jYXRpb24gdXB3YXJkcyBpbiB0aGUgZG9jdW1lbnQgdHJlZSwgc3BsaXR0aW5nXHJcbiAgICogdGhlaXIgcGFyZW50IGluIHR3byBpZiBuZWNlc3NhcnkuXHJcbiAgICovXG4gIGxpZnROb2RlczogZnVuY3Rpb24gbGlmdE5vZGVzKGVkaXRvcikge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICBFZGl0b3Iud2l0aG91dE5vcm1hbGl6aW5nKGVkaXRvciwgZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9vcHRpb25zJGF0ID0gb3B0aW9ucy5hdCxcbiAgICAgICAgICBhdCA9IF9vcHRpb25zJGF0ID09PSB2b2lkIDAgPyBlZGl0b3Iuc2VsZWN0aW9uIDogX29wdGlvbnMkYXQsXG4gICAgICAgICAgX29wdGlvbnMkbW9kZTIgPSBvcHRpb25zLm1vZGUsXG4gICAgICAgICAgbW9kZSA9IF9vcHRpb25zJG1vZGUyID09PSB2b2lkIDAgPyAnbG93ZXN0JyA6IF9vcHRpb25zJG1vZGUyLFxuICAgICAgICAgIF9vcHRpb25zJHZvaWRzMiA9IG9wdGlvbnMudm9pZHMsXG4gICAgICAgICAgdm9pZHMgPSBfb3B0aW9ucyR2b2lkczIgPT09IHZvaWQgMCA/IGZhbHNlIDogX29wdGlvbnMkdm9pZHMyO1xuICAgICAgdmFyIG1hdGNoID0gb3B0aW9ucy5tYXRjaDtcblxuICAgICAgaWYgKG1hdGNoID09IG51bGwpIHtcbiAgICAgICAgbWF0Y2ggPSBQYXRoLmlzUGF0aChhdCkgPyBtYXRjaFBhdGgoZWRpdG9yLCBhdCkgOiBmdW5jdGlvbiAobikge1xuICAgICAgICAgIHJldHVybiBFbGVtZW50LmlzRWxlbWVudChuKSAmJiBFZGl0b3IuaXNCbG9jayhlZGl0b3IsIG4pO1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBpZiAoIWF0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIG1hdGNoZXMgPSBFZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgICAgIGF0OiBhdCxcbiAgICAgICAgbWF0Y2g6IG1hdGNoLFxuICAgICAgICBtb2RlOiBtb2RlLFxuICAgICAgICB2b2lkczogdm9pZHNcbiAgICAgIH0pO1xuICAgICAgdmFyIHBhdGhSZWZzID0gQXJyYXkuZnJvbShtYXRjaGVzLCBmdW5jdGlvbiAoX3JlZikge1xuICAgICAgICB2YXIgX3JlZjIgPSBfc2xpY2VkVG9BcnJheShfcmVmLCAyKSxcbiAgICAgICAgICAgIHAgPSBfcmVmMlsxXTtcblxuICAgICAgICByZXR1cm4gRWRpdG9yLnBhdGhSZWYoZWRpdG9yLCBwKTtcbiAgICAgIH0pO1xuXG4gICAgICBmb3IgKHZhciBfaSA9IDAsIF9wYXRoUmVmcyA9IHBhdGhSZWZzOyBfaSA8IF9wYXRoUmVmcy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgdmFyIHBhdGhSZWYgPSBfcGF0aFJlZnNbX2ldO1xuICAgICAgICB2YXIgcGF0aCA9IHBhdGhSZWYudW5yZWYoKTtcblxuICAgICAgICBpZiAocGF0aC5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGxpZnQgbm9kZSBhdCBhIHBhdGggW1wiLmNvbmNhdChwYXRoLCBcIl0gYmVjYXVzZSBpdCBoYXMgYSBkZXB0aCBvZiBsZXNzIHRoYW4gYDJgLlwiKSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcGFyZW50Tm9kZUVudHJ5ID0gRWRpdG9yLm5vZGUoZWRpdG9yLCBQYXRoLnBhcmVudChwYXRoKSk7XG5cbiAgICAgICAgdmFyIF9wYXJlbnROb2RlRW50cnkgPSBfc2xpY2VkVG9BcnJheShwYXJlbnROb2RlRW50cnksIDIpLFxuICAgICAgICAgICAgcGFyZW50ID0gX3BhcmVudE5vZGVFbnRyeVswXSxcbiAgICAgICAgICAgIHBhcmVudFBhdGggPSBfcGFyZW50Tm9kZUVudHJ5WzFdO1xuXG4gICAgICAgIHZhciBpbmRleCA9IHBhdGhbcGF0aC5sZW5ndGggLSAxXTtcbiAgICAgICAgdmFyIGxlbmd0aCA9IHBhcmVudC5jaGlsZHJlbi5sZW5ndGg7XG5cbiAgICAgICAgaWYgKGxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgIHZhciB0b1BhdGggPSBQYXRoLm5leHQocGFyZW50UGF0aCk7XG4gICAgICAgICAgVHJhbnNmb3Jtcy5tb3ZlTm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICBhdDogcGF0aCxcbiAgICAgICAgICAgIHRvOiB0b1BhdGgsXG4gICAgICAgICAgICB2b2lkczogdm9pZHNcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBUcmFuc2Zvcm1zLnJlbW92ZU5vZGVzKGVkaXRvciwge1xuICAgICAgICAgICAgYXQ6IHBhcmVudFBhdGgsXG4gICAgICAgICAgICB2b2lkczogdm9pZHNcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmIChpbmRleCA9PT0gMCkge1xuICAgICAgICAgIFRyYW5zZm9ybXMubW92ZU5vZGVzKGVkaXRvciwge1xuICAgICAgICAgICAgYXQ6IHBhdGgsXG4gICAgICAgICAgICB0bzogcGFyZW50UGF0aCxcbiAgICAgICAgICAgIHZvaWRzOiB2b2lkc1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKGluZGV4ID09PSBsZW5ndGggLSAxKSB7XG4gICAgICAgICAgdmFyIF90b1BhdGggPSBQYXRoLm5leHQocGFyZW50UGF0aCk7XG5cbiAgICAgICAgICBUcmFuc2Zvcm1zLm1vdmVOb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAgIGF0OiBwYXRoLFxuICAgICAgICAgICAgdG86IF90b1BhdGgsXG4gICAgICAgICAgICB2b2lkczogdm9pZHNcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgc3BsaXRQYXRoID0gUGF0aC5uZXh0KHBhdGgpO1xuXG4gICAgICAgICAgdmFyIF90b1BhdGgyID0gUGF0aC5uZXh0KHBhcmVudFBhdGgpO1xuXG4gICAgICAgICAgVHJhbnNmb3Jtcy5zcGxpdE5vZGVzKGVkaXRvciwge1xuICAgICAgICAgICAgYXQ6IHNwbGl0UGF0aCxcbiAgICAgICAgICAgIHZvaWRzOiB2b2lkc1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIFRyYW5zZm9ybXMubW92ZU5vZGVzKGVkaXRvciwge1xuICAgICAgICAgICAgYXQ6IHBhdGgsXG4gICAgICAgICAgICB0bzogX3RvUGF0aDIsXG4gICAgICAgICAgICB2b2lkczogdm9pZHNcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIE1lcmdlIGEgbm9kZSBhdCBhIGxvY2F0aW9uIHdpdGggdGhlIHByZXZpb3VzIG5vZGUgb2YgdGhlIHNhbWUgZGVwdGgsXHJcbiAgICogcmVtb3ZpbmcgYW55IGVtcHR5IGNvbnRhaW5pbmcgbm9kZXMgYWZ0ZXIgdGhlIG1lcmdlIGlmIG5lY2Vzc2FyeS5cclxuICAgKi9cbiAgbWVyZ2VOb2RlczogZnVuY3Rpb24gbWVyZ2VOb2RlcyhlZGl0b3IpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgRWRpdG9yLndpdGhvdXROb3JtYWxpemluZyhlZGl0b3IsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBtYXRjaCA9IG9wdGlvbnMubWF0Y2gsXG4gICAgICAgICAgX29wdGlvbnMkYXQyID0gb3B0aW9ucy5hdCxcbiAgICAgICAgICBhdCA9IF9vcHRpb25zJGF0MiA9PT0gdm9pZCAwID8gZWRpdG9yLnNlbGVjdGlvbiA6IF9vcHRpb25zJGF0MjtcbiAgICAgIHZhciBfb3B0aW9ucyRoYW5naW5nMiA9IG9wdGlvbnMuaGFuZ2luZyxcbiAgICAgICAgICBoYW5naW5nID0gX29wdGlvbnMkaGFuZ2luZzIgPT09IHZvaWQgMCA/IGZhbHNlIDogX29wdGlvbnMkaGFuZ2luZzIsXG4gICAgICAgICAgX29wdGlvbnMkdm9pZHMzID0gb3B0aW9ucy52b2lkcyxcbiAgICAgICAgICB2b2lkcyA9IF9vcHRpb25zJHZvaWRzMyA9PT0gdm9pZCAwID8gZmFsc2UgOiBfb3B0aW9ucyR2b2lkczMsXG4gICAgICAgICAgX29wdGlvbnMkbW9kZTMgPSBvcHRpb25zLm1vZGUsXG4gICAgICAgICAgbW9kZSA9IF9vcHRpb25zJG1vZGUzID09PSB2b2lkIDAgPyAnbG93ZXN0JyA6IF9vcHRpb25zJG1vZGUzO1xuXG4gICAgICBpZiAoIWF0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKG1hdGNoID09IG51bGwpIHtcbiAgICAgICAgaWYgKFBhdGguaXNQYXRoKGF0KSkge1xuICAgICAgICAgIHZhciBfRWRpdG9yJHBhcmVudCA9IEVkaXRvci5wYXJlbnQoZWRpdG9yLCBhdCksXG4gICAgICAgICAgICAgIF9FZGl0b3IkcGFyZW50MiA9IF9zbGljZWRUb0FycmF5KF9FZGl0b3IkcGFyZW50LCAxKSxcbiAgICAgICAgICAgICAgcGFyZW50ID0gX0VkaXRvciRwYXJlbnQyWzBdO1xuXG4gICAgICAgICAgbWF0Y2ggPSBmdW5jdGlvbiBtYXRjaChuKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyZW50LmNoaWxkcmVuLmluY2x1ZGVzKG4pO1xuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbWF0Y2ggPSBmdW5jdGlvbiBtYXRjaChuKSB7XG4gICAgICAgICAgICByZXR1cm4gRWxlbWVudC5pc0VsZW1lbnQobikgJiYgRWRpdG9yLmlzQmxvY2soZWRpdG9yLCBuKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghaGFuZ2luZyAmJiBSYW5nZS5pc1JhbmdlKGF0KSkge1xuICAgICAgICBhdCA9IEVkaXRvci51bmhhbmdSYW5nZShlZGl0b3IsIGF0LCB7XG4gICAgICAgICAgdm9pZHM6IHZvaWRzXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAoUmFuZ2UuaXNSYW5nZShhdCkpIHtcbiAgICAgICAgaWYgKFJhbmdlLmlzQ29sbGFwc2VkKGF0KSkge1xuICAgICAgICAgIGF0ID0gYXQuYW5jaG9yO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBfUmFuZ2UkZWRnZXMzID0gUmFuZ2UuZWRnZXMoYXQpLFxuICAgICAgICAgICAgICBfUmFuZ2UkZWRnZXM0ID0gX3NsaWNlZFRvQXJyYXkoX1JhbmdlJGVkZ2VzMywgMiksXG4gICAgICAgICAgICAgIGVuZCA9IF9SYW5nZSRlZGdlczRbMV07XG5cbiAgICAgICAgICB2YXIgcG9pbnRSZWYgPSBFZGl0b3IucG9pbnRSZWYoZWRpdG9yLCBlbmQpO1xuICAgICAgICAgIFRyYW5zZm9ybXNbXCJkZWxldGVcIl0oZWRpdG9yLCB7XG4gICAgICAgICAgICBhdDogYXRcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBhdCA9IHBvaW50UmVmLnVucmVmKCk7XG5cbiAgICAgICAgICBpZiAob3B0aW9ucy5hdCA9PSBudWxsKSB7XG4gICAgICAgICAgICBUcmFuc2Zvcm1zLnNlbGVjdChlZGl0b3IsIGF0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIF9FZGl0b3Ikbm9kZXMzID0gRWRpdG9yLm5vZGVzKGVkaXRvciwge1xuICAgICAgICBhdDogYXQsXG4gICAgICAgIG1hdGNoOiBtYXRjaCxcbiAgICAgICAgdm9pZHM6IHZvaWRzLFxuICAgICAgICBtb2RlOiBtb2RlXG4gICAgICB9KSxcbiAgICAgICAgICBfRWRpdG9yJG5vZGVzNCA9IF9zbGljZWRUb0FycmF5KF9FZGl0b3Ikbm9kZXMzLCAxKSxcbiAgICAgICAgICBjdXJyZW50ID0gX0VkaXRvciRub2RlczRbMF07XG5cbiAgICAgIHZhciBwcmV2ID0gRWRpdG9yLnByZXZpb3VzKGVkaXRvciwge1xuICAgICAgICBhdDogYXQsXG4gICAgICAgIG1hdGNoOiBtYXRjaCxcbiAgICAgICAgdm9pZHM6IHZvaWRzLFxuICAgICAgICBtb2RlOiBtb2RlXG4gICAgICB9KTtcblxuICAgICAgaWYgKCFjdXJyZW50IHx8ICFwcmV2KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIF9jdXJyZW50ID0gX3NsaWNlZFRvQXJyYXkoY3VycmVudCwgMiksXG4gICAgICAgICAgbm9kZSA9IF9jdXJyZW50WzBdLFxuICAgICAgICAgIHBhdGggPSBfY3VycmVudFsxXTtcblxuICAgICAgdmFyIF9wcmV2ID0gX3NsaWNlZFRvQXJyYXkocHJldiwgMiksXG4gICAgICAgICAgcHJldk5vZGUgPSBfcHJldlswXSxcbiAgICAgICAgICBwcmV2UGF0aCA9IF9wcmV2WzFdO1xuXG4gICAgICBpZiAocGF0aC5sZW5ndGggPT09IDAgfHwgcHJldlBhdGgubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIG5ld1BhdGggPSBQYXRoLm5leHQocHJldlBhdGgpO1xuICAgICAgdmFyIGNvbW1vblBhdGggPSBQYXRoLmNvbW1vbihwYXRoLCBwcmV2UGF0aCk7XG4gICAgICB2YXIgaXNQcmV2aW91c1NpYmxpbmcgPSBQYXRoLmlzU2libGluZyhwYXRoLCBwcmV2UGF0aCk7XG4gICAgICB2YXIgbGV2ZWxzID0gQXJyYXkuZnJvbShFZGl0b3IubGV2ZWxzKGVkaXRvciwge1xuICAgICAgICBhdDogcGF0aFxuICAgICAgfSksIGZ1bmN0aW9uIChfcmVmMykge1xuICAgICAgICB2YXIgX3JlZjQgPSBfc2xpY2VkVG9BcnJheShfcmVmMywgMSksXG4gICAgICAgICAgICBuID0gX3JlZjRbMF07XG5cbiAgICAgICAgcmV0dXJuIG47XG4gICAgICB9KS5zbGljZShjb21tb25QYXRoLmxlbmd0aCkuc2xpY2UoMCwgLTEpOyAvLyBEZXRlcm1pbmUgaWYgdGhlIG1lcmdlIHdpbGwgbGVhdmUgYW4gYW5jZXN0b3Igb2YgdGhlIHBhdGggZW1wdHkgYXMgYVxuICAgICAgLy8gcmVzdWx0LCBpbiB3aGljaCBjYXNlIHdlJ2xsIHdhbnQgdG8gcmVtb3ZlIGl0IGFmdGVyIG1lcmdpbmcuXG5cbiAgICAgIHZhciBlbXB0eUFuY2VzdG9yID0gRWRpdG9yLmFib3ZlKGVkaXRvciwge1xuICAgICAgICBhdDogcGF0aCxcbiAgICAgICAgbW9kZTogJ2hpZ2hlc3QnLFxuICAgICAgICBtYXRjaDogZnVuY3Rpb24gbWF0Y2gobikge1xuICAgICAgICAgIHJldHVybiBsZXZlbHMuaW5jbHVkZXMobikgJiYgaGFzU2luZ2xlQ2hpbGROZXN0KGVkaXRvciwgbik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdmFyIGVtcHR5UmVmID0gZW1wdHlBbmNlc3RvciAmJiBFZGl0b3IucGF0aFJlZihlZGl0b3IsIGVtcHR5QW5jZXN0b3JbMV0pO1xuICAgICAgdmFyIHByb3BlcnRpZXM7XG4gICAgICB2YXIgcG9zaXRpb247IC8vIEVuc3VyZSB0aGF0IHRoZSBub2RlcyBhcmUgZXF1aXZhbGVudCwgYW5kIGZpZ3VyZSBvdXQgd2hhdCB0aGUgcG9zaXRpb25cbiAgICAgIC8vIGFuZCBleHRyYSBwcm9wZXJ0aWVzIG9mIHRoZSBtZXJnZSB3aWxsIGJlLlxuXG4gICAgICBpZiAoVGV4dC5pc1RleHQobm9kZSkgJiYgVGV4dC5pc1RleHQocHJldk5vZGUpKSB7XG4gICAgICAgIG5vZGUudGV4dDtcbiAgICAgICAgICAgIHZhciByZXN0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKG5vZGUsIF9leGNsdWRlZCk7XG5cbiAgICAgICAgcG9zaXRpb24gPSBwcmV2Tm9kZS50ZXh0Lmxlbmd0aDtcbiAgICAgICAgcHJvcGVydGllcyA9IHJlc3Q7XG4gICAgICB9IGVsc2UgaWYgKEVsZW1lbnQuaXNFbGVtZW50KG5vZGUpICYmIEVsZW1lbnQuaXNFbGVtZW50KHByZXZOb2RlKSkge1xuICAgICAgICBub2RlLmNoaWxkcmVuO1xuICAgICAgICAgICAgdmFyIF9yZXN0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKG5vZGUsIF9leGNsdWRlZDIpO1xuXG4gICAgICAgIHBvc2l0aW9uID0gcHJldk5vZGUuY2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgICBwcm9wZXJ0aWVzID0gX3Jlc3Q7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgbWVyZ2UgdGhlIG5vZGUgYXQgcGF0aCBbXCIuY29uY2F0KHBhdGgsIFwiXSB3aXRoIHRoZSBwcmV2aW91cyBzaWJsaW5nIGJlY2F1c2UgaXQgaXMgbm90IHRoZSBzYW1lIGtpbmQ6IFwiKS5jb25jYXQoU2NydWJiZXIuc3RyaW5naWZ5KG5vZGUpLCBcIiBcIikuY29uY2F0KFNjcnViYmVyLnN0cmluZ2lmeShwcmV2Tm9kZSkpKTtcbiAgICAgIH0gLy8gSWYgdGhlIG5vZGUgaXNuJ3QgYWxyZWFkeSB0aGUgbmV4dCBzaWJsaW5nIG9mIHRoZSBwcmV2aW91cyBub2RlLCBtb3ZlXG4gICAgICAvLyBpdCBzbyB0aGF0IGl0IGlzIGJlZm9yZSBtZXJnaW5nLlxuXG5cbiAgICAgIGlmICghaXNQcmV2aW91c1NpYmxpbmcpIHtcbiAgICAgICAgVHJhbnNmb3Jtcy5tb3ZlTm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgYXQ6IHBhdGgsXG4gICAgICAgICAgdG86IG5ld1BhdGgsXG4gICAgICAgICAgdm9pZHM6IHZvaWRzXG4gICAgICAgIH0pO1xuICAgICAgfSAvLyBJZiB0aGVyZSB3YXMgZ29pbmcgdG8gYmUgYW4gZW1wdHkgYW5jZXN0b3Igb2YgdGhlIG5vZGUgdGhhdCB3YXMgbWVyZ2VkLFxuICAgICAgLy8gd2UgcmVtb3ZlIGl0IGZyb20gdGhlIHRyZWUuXG5cblxuICAgICAgaWYgKGVtcHR5UmVmKSB7XG4gICAgICAgIFRyYW5zZm9ybXMucmVtb3ZlTm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgYXQ6IGVtcHR5UmVmLmN1cnJlbnQsXG4gICAgICAgICAgdm9pZHM6IHZvaWRzXG4gICAgICAgIH0pO1xuICAgICAgfSAvLyBJZiB0aGUgdGFyZ2V0IG5vZGUgdGhhdCB3ZSdyZSBtZXJnaW5nIHdpdGggaXMgZW1wdHksIHJlbW92ZSBpdCBpbnN0ZWFkXG4gICAgICAvLyBvZiBtZXJnaW5nIHRoZSB0d28uIFRoaXMgaXMgYSBjb21tb24gcmljaCB0ZXh0IGVkaXRvciBiZWhhdmlvciB0b1xuICAgICAgLy8gcHJldmVudCBsb3NpbmcgZm9ybWF0dGluZyB3aGVuIGRlbGV0aW5nIGVudGlyZSBub2RlcyB3aGVuIHlvdSBoYXZlIGFcbiAgICAgIC8vIGhhbmdpbmcgc2VsZWN0aW9uLlxuICAgICAgLy8gaWYgcHJldk5vZGUgaXMgZmlyc3QgY2hpbGQgaW4gcGFyZW50LGRvbid0IHJlbW92ZSBpdC5cblxuXG4gICAgICBpZiAoRWxlbWVudC5pc0VsZW1lbnQocHJldk5vZGUpICYmIEVkaXRvci5pc0VtcHR5KGVkaXRvciwgcHJldk5vZGUpIHx8IFRleHQuaXNUZXh0KHByZXZOb2RlKSAmJiBwcmV2Tm9kZS50ZXh0ID09PSAnJyAmJiBwcmV2UGF0aFtwcmV2UGF0aC5sZW5ndGggLSAxXSAhPT0gMCkge1xuICAgICAgICBUcmFuc2Zvcm1zLnJlbW92ZU5vZGVzKGVkaXRvciwge1xuICAgICAgICAgIGF0OiBwcmV2UGF0aCxcbiAgICAgICAgICB2b2lkczogdm9pZHNcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlZGl0b3IuYXBwbHkoe1xuICAgICAgICAgIHR5cGU6ICdtZXJnZV9ub2RlJyxcbiAgICAgICAgICBwYXRoOiBuZXdQYXRoLFxuICAgICAgICAgIHBvc2l0aW9uOiBwb3NpdGlvbixcbiAgICAgICAgICBwcm9wZXJ0aWVzOiBwcm9wZXJ0aWVzXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAoZW1wdHlSZWYpIHtcbiAgICAgICAgZW1wdHlSZWYudW5yZWYoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcblxuICAvKipcclxuICAgKiBNb3ZlIHRoZSBub2RlcyBhdCBhIGxvY2F0aW9uIHRvIGEgbmV3IGxvY2F0aW9uLlxyXG4gICAqL1xuICBtb3ZlTm9kZXM6IGZ1bmN0aW9uIG1vdmVOb2RlcyhlZGl0b3IsIG9wdGlvbnMpIHtcbiAgICBFZGl0b3Iud2l0aG91dE5vcm1hbGl6aW5nKGVkaXRvciwgZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHRvID0gb3B0aW9ucy50byxcbiAgICAgICAgICBfb3B0aW9ucyRhdDMgPSBvcHRpb25zLmF0LFxuICAgICAgICAgIGF0ID0gX29wdGlvbnMkYXQzID09PSB2b2lkIDAgPyBlZGl0b3Iuc2VsZWN0aW9uIDogX29wdGlvbnMkYXQzLFxuICAgICAgICAgIF9vcHRpb25zJG1vZGU0ID0gb3B0aW9ucy5tb2RlLFxuICAgICAgICAgIG1vZGUgPSBfb3B0aW9ucyRtb2RlNCA9PT0gdm9pZCAwID8gJ2xvd2VzdCcgOiBfb3B0aW9ucyRtb2RlNCxcbiAgICAgICAgICBfb3B0aW9ucyR2b2lkczQgPSBvcHRpb25zLnZvaWRzLFxuICAgICAgICAgIHZvaWRzID0gX29wdGlvbnMkdm9pZHM0ID09PSB2b2lkIDAgPyBmYWxzZSA6IF9vcHRpb25zJHZvaWRzNDtcbiAgICAgIHZhciBtYXRjaCA9IG9wdGlvbnMubWF0Y2g7XG5cbiAgICAgIGlmICghYXQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAobWF0Y2ggPT0gbnVsbCkge1xuICAgICAgICBtYXRjaCA9IFBhdGguaXNQYXRoKGF0KSA/IG1hdGNoUGF0aChlZGl0b3IsIGF0KSA6IGZ1bmN0aW9uIChuKSB7XG4gICAgICAgICAgcmV0dXJuIEVsZW1lbnQuaXNFbGVtZW50KG4pICYmIEVkaXRvci5pc0Jsb2NrKGVkaXRvciwgbik7XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHZhciB0b1JlZiA9IEVkaXRvci5wYXRoUmVmKGVkaXRvciwgdG8pO1xuICAgICAgdmFyIHRhcmdldHMgPSBFZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgICAgIGF0OiBhdCxcbiAgICAgICAgbWF0Y2g6IG1hdGNoLFxuICAgICAgICBtb2RlOiBtb2RlLFxuICAgICAgICB2b2lkczogdm9pZHNcbiAgICAgIH0pO1xuICAgICAgdmFyIHBhdGhSZWZzID0gQXJyYXkuZnJvbSh0YXJnZXRzLCBmdW5jdGlvbiAoX3JlZjUpIHtcbiAgICAgICAgdmFyIF9yZWY2ID0gX3NsaWNlZFRvQXJyYXkoX3JlZjUsIDIpLFxuICAgICAgICAgICAgcCA9IF9yZWY2WzFdO1xuXG4gICAgICAgIHJldHVybiBFZGl0b3IucGF0aFJlZihlZGl0b3IsIHApO1xuICAgICAgfSk7XG5cbiAgICAgIGZvciAodmFyIF9pMiA9IDAsIF9wYXRoUmVmczIgPSBwYXRoUmVmczsgX2kyIDwgX3BhdGhSZWZzMi5sZW5ndGg7IF9pMisrKSB7XG4gICAgICAgIHZhciBwYXRoUmVmID0gX3BhdGhSZWZzMltfaTJdO1xuICAgICAgICB2YXIgcGF0aCA9IHBhdGhSZWYudW5yZWYoKTtcbiAgICAgICAgdmFyIG5ld1BhdGggPSB0b1JlZi5jdXJyZW50O1xuXG4gICAgICAgIGlmIChwYXRoLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgIGVkaXRvci5hcHBseSh7XG4gICAgICAgICAgICB0eXBlOiAnbW92ZV9ub2RlJyxcbiAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICBuZXdQYXRoOiBuZXdQYXRoXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodG9SZWYuY3VycmVudCAmJiBQYXRoLmlzU2libGluZyhuZXdQYXRoLCBwYXRoKSAmJiBQYXRoLmlzQWZ0ZXIobmV3UGF0aCwgcGF0aCkpIHtcbiAgICAgICAgICAvLyBXaGVuIHBlcmZvcm1pbmcgYSBzaWJsaW5nIG1vdmUgdG8gYSBsYXRlciBpbmRleCwgdGhlIHBhdGggYXQgdGhlIGRlc3RpbmF0aW9uIGlzIHNoaWZ0ZWRcbiAgICAgICAgICAvLyB0byBiZWZvcmUgdGhlIGluc2VydGlvbiBwb2ludCBpbnN0ZWFkIG9mIGFmdGVyLiBUbyBlbnN1cmUgb3VyIGdyb3VwIG9mIG5vZGVzIGFyZSBpbnNlcnRlZFxuICAgICAgICAgIC8vIGluIHRoZSBjb3JyZWN0IG9yZGVyIHdlIGluY3JlbWVudCB0b1JlZiB0byBhY2NvdW50IGZvciB0aGF0XG4gICAgICAgICAgdG9SZWYuY3VycmVudCA9IFBhdGgubmV4dCh0b1JlZi5jdXJyZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0b1JlZi51bnJlZigpO1xuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIFJlbW92ZSB0aGUgbm9kZXMgYXQgYSBzcGVjaWZpYyBsb2NhdGlvbiBpbiB0aGUgZG9jdW1lbnQuXHJcbiAgICovXG4gIHJlbW92ZU5vZGVzOiBmdW5jdGlvbiByZW1vdmVOb2RlcyhlZGl0b3IpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgRWRpdG9yLndpdGhvdXROb3JtYWxpemluZyhlZGl0b3IsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfb3B0aW9ucyRoYW5naW5nMyA9IG9wdGlvbnMuaGFuZ2luZyxcbiAgICAgICAgICBoYW5naW5nID0gX29wdGlvbnMkaGFuZ2luZzMgPT09IHZvaWQgMCA/IGZhbHNlIDogX29wdGlvbnMkaGFuZ2luZzMsXG4gICAgICAgICAgX29wdGlvbnMkdm9pZHM1ID0gb3B0aW9ucy52b2lkcyxcbiAgICAgICAgICB2b2lkcyA9IF9vcHRpb25zJHZvaWRzNSA9PT0gdm9pZCAwID8gZmFsc2UgOiBfb3B0aW9ucyR2b2lkczUsXG4gICAgICAgICAgX29wdGlvbnMkbW9kZTUgPSBvcHRpb25zLm1vZGUsXG4gICAgICAgICAgbW9kZSA9IF9vcHRpb25zJG1vZGU1ID09PSB2b2lkIDAgPyAnbG93ZXN0JyA6IF9vcHRpb25zJG1vZGU1O1xuICAgICAgdmFyIF9vcHRpb25zJGF0NCA9IG9wdGlvbnMuYXQsXG4gICAgICAgICAgYXQgPSBfb3B0aW9ucyRhdDQgPT09IHZvaWQgMCA/IGVkaXRvci5zZWxlY3Rpb24gOiBfb3B0aW9ucyRhdDQsXG4gICAgICAgICAgbWF0Y2ggPSBvcHRpb25zLm1hdGNoO1xuXG4gICAgICBpZiAoIWF0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKG1hdGNoID09IG51bGwpIHtcbiAgICAgICAgbWF0Y2ggPSBQYXRoLmlzUGF0aChhdCkgPyBtYXRjaFBhdGgoZWRpdG9yLCBhdCkgOiBmdW5jdGlvbiAobikge1xuICAgICAgICAgIHJldHVybiBFbGVtZW50LmlzRWxlbWVudChuKSAmJiBFZGl0b3IuaXNCbG9jayhlZGl0b3IsIG4pO1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBpZiAoIWhhbmdpbmcgJiYgUmFuZ2UuaXNSYW5nZShhdCkpIHtcbiAgICAgICAgYXQgPSBFZGl0b3IudW5oYW5nUmFuZ2UoZWRpdG9yLCBhdCwge1xuICAgICAgICAgIHZvaWRzOiB2b2lkc1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgdmFyIGRlcHRocyA9IEVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICAgICAgYXQ6IGF0LFxuICAgICAgICBtYXRjaDogbWF0Y2gsXG4gICAgICAgIG1vZGU6IG1vZGUsXG4gICAgICAgIHZvaWRzOiB2b2lkc1xuICAgICAgfSk7XG4gICAgICB2YXIgcGF0aFJlZnMgPSBBcnJheS5mcm9tKGRlcHRocywgZnVuY3Rpb24gKF9yZWY3KSB7XG4gICAgICAgIHZhciBfcmVmOCA9IF9zbGljZWRUb0FycmF5KF9yZWY3LCAyKSxcbiAgICAgICAgICAgIHAgPSBfcmVmOFsxXTtcblxuICAgICAgICByZXR1cm4gRWRpdG9yLnBhdGhSZWYoZWRpdG9yLCBwKTtcbiAgICAgIH0pO1xuXG4gICAgICBmb3IgKHZhciBfaTMgPSAwLCBfcGF0aFJlZnMzID0gcGF0aFJlZnM7IF9pMyA8IF9wYXRoUmVmczMubGVuZ3RoOyBfaTMrKykge1xuICAgICAgICB2YXIgcGF0aFJlZiA9IF9wYXRoUmVmczNbX2kzXTtcbiAgICAgICAgdmFyIHBhdGggPSBwYXRoUmVmLnVucmVmKCk7XG5cbiAgICAgICAgaWYgKHBhdGgpIHtcbiAgICAgICAgICB2YXIgX0VkaXRvciRub2RlID0gRWRpdG9yLm5vZGUoZWRpdG9yLCBwYXRoKSxcbiAgICAgICAgICAgICAgX0VkaXRvciRub2RlMiA9IF9zbGljZWRUb0FycmF5KF9FZGl0b3Ikbm9kZSwgMSksXG4gICAgICAgICAgICAgIG5vZGUgPSBfRWRpdG9yJG5vZGUyWzBdO1xuXG4gICAgICAgICAgZWRpdG9yLmFwcGx5KHtcbiAgICAgICAgICAgIHR5cGU6ICdyZW1vdmVfbm9kZScsXG4gICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgbm9kZTogbm9kZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogU2V0IG5ldyBwcm9wZXJ0aWVzIG9uIHRoZSBub2RlcyBhdCBhIGxvY2F0aW9uLlxyXG4gICAqL1xuICBzZXROb2RlczogZnVuY3Rpb24gc2V0Tm9kZXMoZWRpdG9yLCBwcm9wcykge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICBFZGl0b3Iud2l0aG91dE5vcm1hbGl6aW5nKGVkaXRvciwgZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIG1hdGNoID0gb3B0aW9ucy5tYXRjaCxcbiAgICAgICAgICBfb3B0aW9ucyRhdDUgPSBvcHRpb25zLmF0LFxuICAgICAgICAgIGF0ID0gX29wdGlvbnMkYXQ1ID09PSB2b2lkIDAgPyBlZGl0b3Iuc2VsZWN0aW9uIDogX29wdGlvbnMkYXQ1LFxuICAgICAgICAgIGNvbXBhcmUgPSBvcHRpb25zLmNvbXBhcmUsXG4gICAgICAgICAgbWVyZ2UgPSBvcHRpb25zLm1lcmdlO1xuICAgICAgdmFyIF9vcHRpb25zJGhhbmdpbmc0ID0gb3B0aW9ucy5oYW5naW5nLFxuICAgICAgICAgIGhhbmdpbmcgPSBfb3B0aW9ucyRoYW5naW5nNCA9PT0gdm9pZCAwID8gZmFsc2UgOiBfb3B0aW9ucyRoYW5naW5nNCxcbiAgICAgICAgICBfb3B0aW9ucyRtb2RlNiA9IG9wdGlvbnMubW9kZSxcbiAgICAgICAgICBtb2RlID0gX29wdGlvbnMkbW9kZTYgPT09IHZvaWQgMCA/ICdsb3dlc3QnIDogX29wdGlvbnMkbW9kZTYsXG4gICAgICAgICAgX29wdGlvbnMkc3BsaXQgPSBvcHRpb25zLnNwbGl0LFxuICAgICAgICAgIHNwbGl0ID0gX29wdGlvbnMkc3BsaXQgPT09IHZvaWQgMCA/IGZhbHNlIDogX29wdGlvbnMkc3BsaXQsXG4gICAgICAgICAgX29wdGlvbnMkdm9pZHM2ID0gb3B0aW9ucy52b2lkcyxcbiAgICAgICAgICB2b2lkcyA9IF9vcHRpb25zJHZvaWRzNiA9PT0gdm9pZCAwID8gZmFsc2UgOiBfb3B0aW9ucyR2b2lkczY7XG5cbiAgICAgIGlmICghYXQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAobWF0Y2ggPT0gbnVsbCkge1xuICAgICAgICBtYXRjaCA9IFBhdGguaXNQYXRoKGF0KSA/IG1hdGNoUGF0aChlZGl0b3IsIGF0KSA6IGZ1bmN0aW9uIChuKSB7XG4gICAgICAgICAgcmV0dXJuIEVsZW1lbnQuaXNFbGVtZW50KG4pICYmIEVkaXRvci5pc0Jsb2NrKGVkaXRvciwgbik7XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGlmICghaGFuZ2luZyAmJiBSYW5nZS5pc1JhbmdlKGF0KSkge1xuICAgICAgICBhdCA9IEVkaXRvci51bmhhbmdSYW5nZShlZGl0b3IsIGF0LCB7XG4gICAgICAgICAgdm9pZHM6IHZvaWRzXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3BsaXQgJiYgUmFuZ2UuaXNSYW5nZShhdCkpIHtcbiAgICAgICAgaWYgKFJhbmdlLmlzQ29sbGFwc2VkKGF0KSAmJiBFZGl0b3IubGVhZihlZGl0b3IsIGF0LmFuY2hvcilbMF0udGV4dC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgLy8gSWYgdGhlIHJhbmdlIGlzIGNvbGxhcHNlZCBpbiBhIG5vbi1lbXB0eSBub2RlIGFuZCAnc3BsaXQnIGlzIHRydWUsIHRoZXJlJ3Mgbm90aGluZyB0b1xuICAgICAgICAgIC8vIHNldCB0aGF0IHdvbid0IGdldCBub3JtYWxpemVkIGF3YXlcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmFuZ2VSZWYgPSBFZGl0b3IucmFuZ2VSZWYoZWRpdG9yLCBhdCwge1xuICAgICAgICAgIGFmZmluaXR5OiAnaW53YXJkJ1xuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgX1JhbmdlJGVkZ2VzNSA9IFJhbmdlLmVkZ2VzKGF0KSxcbiAgICAgICAgICAgIF9SYW5nZSRlZGdlczYgPSBfc2xpY2VkVG9BcnJheShfUmFuZ2UkZWRnZXM1LCAyKSxcbiAgICAgICAgICAgIHN0YXJ0ID0gX1JhbmdlJGVkZ2VzNlswXSxcbiAgICAgICAgICAgIGVuZCA9IF9SYW5nZSRlZGdlczZbMV07XG5cbiAgICAgICAgdmFyIHNwbGl0TW9kZSA9IG1vZGUgPT09ICdsb3dlc3QnID8gJ2xvd2VzdCcgOiAnaGlnaGVzdCc7XG4gICAgICAgIHZhciBlbmRBdEVuZE9mTm9kZSA9IEVkaXRvci5pc0VuZChlZGl0b3IsIGVuZCwgZW5kLnBhdGgpO1xuICAgICAgICBUcmFuc2Zvcm1zLnNwbGl0Tm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgYXQ6IGVuZCxcbiAgICAgICAgICBtYXRjaDogbWF0Y2gsXG4gICAgICAgICAgbW9kZTogc3BsaXRNb2RlLFxuICAgICAgICAgIHZvaWRzOiB2b2lkcyxcbiAgICAgICAgICBhbHdheXM6ICFlbmRBdEVuZE9mTm9kZVxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIHN0YXJ0QXRTdGFydE9mTm9kZSA9IEVkaXRvci5pc1N0YXJ0KGVkaXRvciwgc3RhcnQsIHN0YXJ0LnBhdGgpO1xuICAgICAgICBUcmFuc2Zvcm1zLnNwbGl0Tm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgYXQ6IHN0YXJ0LFxuICAgICAgICAgIG1hdGNoOiBtYXRjaCxcbiAgICAgICAgICBtb2RlOiBzcGxpdE1vZGUsXG4gICAgICAgICAgdm9pZHM6IHZvaWRzLFxuICAgICAgICAgIGFsd2F5czogIXN0YXJ0QXRTdGFydE9mTm9kZVxuICAgICAgICB9KTtcbiAgICAgICAgYXQgPSByYW5nZVJlZi51bnJlZigpO1xuXG4gICAgICAgIGlmIChvcHRpb25zLmF0ID09IG51bGwpIHtcbiAgICAgICAgICBUcmFuc2Zvcm1zLnNlbGVjdChlZGl0b3IsIGF0KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIWNvbXBhcmUpIHtcbiAgICAgICAgY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUocHJvcCwgbm9kZVByb3ApIHtcbiAgICAgICAgICByZXR1cm4gcHJvcCAhPT0gbm9kZVByb3A7XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHZhciBfaXRlcmF0b3IyID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkMShFZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgICAgIGF0OiBhdCxcbiAgICAgICAgbWF0Y2g6IG1hdGNoLFxuICAgICAgICBtb2RlOiBtb2RlLFxuICAgICAgICB2b2lkczogdm9pZHNcbiAgICAgIH0pKSxcbiAgICAgICAgICBfc3RlcDI7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoX2l0ZXJhdG9yMi5zKCk7ICEoX3N0ZXAyID0gX2l0ZXJhdG9yMi5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgdmFyIF9zdGVwMiR2YWx1ZSA9IF9zbGljZWRUb0FycmF5KF9zdGVwMi52YWx1ZSwgMiksXG4gICAgICAgICAgICAgIG5vZGUgPSBfc3RlcDIkdmFsdWVbMF0sXG4gICAgICAgICAgICAgIHBhdGggPSBfc3RlcDIkdmFsdWVbMV07XG5cbiAgICAgICAgICB2YXIgcHJvcGVydGllcyA9IHt9O1xuICAgICAgICAgIHZhciBuZXdQcm9wZXJ0aWVzID0ge307IC8vIFlvdSBjYW4ndCBzZXQgcHJvcGVydGllcyBvbiB0aGUgZWRpdG9yIG5vZGUuXG5cbiAgICAgICAgICBpZiAocGF0aC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBoYXNDaGFuZ2VzID0gZmFsc2U7XG5cbiAgICAgICAgICBmb3IgKHZhciBrIGluIHByb3BzKSB7XG4gICAgICAgICAgICBpZiAoayA9PT0gJ2NoaWxkcmVuJyB8fCBrID09PSAndGV4dCcpIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChjb21wYXJlKHByb3BzW2tdLCBub2RlW2tdKSkge1xuICAgICAgICAgICAgICBoYXNDaGFuZ2VzID0gdHJ1ZTsgLy8gT21pdCBuZXcgcHJvcGVydGllcyBmcm9tIHRoZSBvbGQgcHJvcGVydGllcyBsaXN0XG5cbiAgICAgICAgICAgICAgaWYgKG5vZGUuaGFzT3duUHJvcGVydHkoaykpIHByb3BlcnRpZXNba10gPSBub2RlW2tdOyAvLyBPbWl0IHByb3BlcnRpZXMgdGhhdCBoYXZlIGJlZW4gcmVtb3ZlZCBmcm9tIHRoZSBuZXcgcHJvcGVydGllcyBsaXN0XG5cbiAgICAgICAgICAgICAgaWYgKG1lcmdlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHByb3BzW2tdICE9IG51bGwpIG5ld1Byb3BlcnRpZXNba10gPSBtZXJnZShub2RlW2tdLCBwcm9wc1trXSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHByb3BzW2tdICE9IG51bGwpIG5ld1Byb3BlcnRpZXNba10gPSBwcm9wc1trXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChoYXNDaGFuZ2VzKSB7XG4gICAgICAgICAgICBlZGl0b3IuYXBwbHkoe1xuICAgICAgICAgICAgICB0eXBlOiAnc2V0X25vZGUnLFxuICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiBwcm9wZXJ0aWVzLFxuICAgICAgICAgICAgICBuZXdQcm9wZXJ0aWVzOiBuZXdQcm9wZXJ0aWVzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3IyLmUoZXJyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIF9pdGVyYXRvcjIuZigpO1xuICAgICAgfVxuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIFNwbGl0IHRoZSBub2RlcyBhdCBhIHNwZWNpZmljIGxvY2F0aW9uLlxyXG4gICAqL1xuICBzcGxpdE5vZGVzOiBmdW5jdGlvbiBzcGxpdE5vZGVzKGVkaXRvcikge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICBFZGl0b3Iud2l0aG91dE5vcm1hbGl6aW5nKGVkaXRvciwgZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9vcHRpb25zJG1vZGU3ID0gb3B0aW9ucy5tb2RlLFxuICAgICAgICAgIG1vZGUgPSBfb3B0aW9ucyRtb2RlNyA9PT0gdm9pZCAwID8gJ2xvd2VzdCcgOiBfb3B0aW9ucyRtb2RlNyxcbiAgICAgICAgICBfb3B0aW9ucyR2b2lkczcgPSBvcHRpb25zLnZvaWRzLFxuICAgICAgICAgIHZvaWRzID0gX29wdGlvbnMkdm9pZHM3ID09PSB2b2lkIDAgPyBmYWxzZSA6IF9vcHRpb25zJHZvaWRzNztcbiAgICAgIHZhciBtYXRjaCA9IG9wdGlvbnMubWF0Y2gsXG4gICAgICAgICAgX29wdGlvbnMkYXQ2ID0gb3B0aW9ucy5hdCxcbiAgICAgICAgICBhdCA9IF9vcHRpb25zJGF0NiA9PT0gdm9pZCAwID8gZWRpdG9yLnNlbGVjdGlvbiA6IF9vcHRpb25zJGF0NixcbiAgICAgICAgICBfb3B0aW9ucyRoZWlnaHQgPSBvcHRpb25zLmhlaWdodCxcbiAgICAgICAgICBoZWlnaHQgPSBfb3B0aW9ucyRoZWlnaHQgPT09IHZvaWQgMCA/IDAgOiBfb3B0aW9ucyRoZWlnaHQsXG4gICAgICAgICAgX29wdGlvbnMkYWx3YXlzID0gb3B0aW9ucy5hbHdheXMsXG4gICAgICAgICAgYWx3YXlzID0gX29wdGlvbnMkYWx3YXlzID09PSB2b2lkIDAgPyBmYWxzZSA6IF9vcHRpb25zJGFsd2F5cztcblxuICAgICAgaWYgKG1hdGNoID09IG51bGwpIHtcbiAgICAgICAgbWF0Y2ggPSBmdW5jdGlvbiBtYXRjaChuKSB7XG4gICAgICAgICAgcmV0dXJuIEVsZW1lbnQuaXNFbGVtZW50KG4pICYmIEVkaXRvci5pc0Jsb2NrKGVkaXRvciwgbik7XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGlmIChSYW5nZS5pc1JhbmdlKGF0KSkge1xuICAgICAgICBhdCA9IGRlbGV0ZVJhbmdlKGVkaXRvciwgYXQpO1xuICAgICAgfSAvLyBJZiB0aGUgdGFyZ2V0IGlzIGEgcGF0aCwgdGhlIGRlZmF1bHQgaGVpZ2h0LXNraXBwaW5nIGFuZCBwb3NpdGlvblxuICAgICAgLy8gY291bnRlcnMgbmVlZCB0byBhY2NvdW50IGZvciB1cyBwb3RlbnRpYWxseSBzcGxpdHRpbmcgYXQgYSBub24tbGVhZi5cblxuXG4gICAgICBpZiAoUGF0aC5pc1BhdGgoYXQpKSB7XG4gICAgICAgIHZhciBwYXRoID0gYXQ7XG4gICAgICAgIHZhciBwb2ludCA9IEVkaXRvci5wb2ludChlZGl0b3IsIHBhdGgpO1xuXG4gICAgICAgIHZhciBfRWRpdG9yJHBhcmVudDMgPSBFZGl0b3IucGFyZW50KGVkaXRvciwgcGF0aCksXG4gICAgICAgICAgICBfRWRpdG9yJHBhcmVudDQgPSBfc2xpY2VkVG9BcnJheShfRWRpdG9yJHBhcmVudDMsIDEpLFxuICAgICAgICAgICAgcGFyZW50ID0gX0VkaXRvciRwYXJlbnQ0WzBdO1xuXG4gICAgICAgIG1hdGNoID0gZnVuY3Rpb24gbWF0Y2gobikge1xuICAgICAgICAgIHJldHVybiBuID09PSBwYXJlbnQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgaGVpZ2h0ID0gcG9pbnQucGF0aC5sZW5ndGggLSBwYXRoLmxlbmd0aCArIDE7XG4gICAgICAgIGF0ID0gcG9pbnQ7XG4gICAgICAgIGFsd2F5cyA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmICghYXQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgYmVmb3JlUmVmID0gRWRpdG9yLnBvaW50UmVmKGVkaXRvciwgYXQsIHtcbiAgICAgICAgYWZmaW5pdHk6ICdiYWNrd2FyZCdcbiAgICAgIH0pO1xuICAgICAgdmFyIGFmdGVyUmVmO1xuXG4gICAgICB0cnkge1xuICAgICAgICB2YXIgX0VkaXRvciRub2RlczUgPSBFZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgYXQ6IGF0LFxuICAgICAgICAgIG1hdGNoOiBtYXRjaCxcbiAgICAgICAgICBtb2RlOiBtb2RlLFxuICAgICAgICAgIHZvaWRzOiB2b2lkc1xuICAgICAgICB9KSxcbiAgICAgICAgICAgIF9FZGl0b3Ikbm9kZXM2ID0gX3NsaWNlZFRvQXJyYXkoX0VkaXRvciRub2RlczUsIDEpLFxuICAgICAgICAgICAgaGlnaGVzdCA9IF9FZGl0b3Ikbm9kZXM2WzBdO1xuXG4gICAgICAgIGlmICghaGlnaGVzdCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB2b2lkTWF0Y2ggPSBFZGl0b3JbXCJ2b2lkXCJdKGVkaXRvciwge1xuICAgICAgICAgIGF0OiBhdCxcbiAgICAgICAgICBtb2RlOiAnaGlnaGVzdCdcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBudWRnZSA9IDA7XG5cbiAgICAgICAgaWYgKCF2b2lkcyAmJiB2b2lkTWF0Y2gpIHtcbiAgICAgICAgICB2YXIgX3ZvaWRNYXRjaCA9IF9zbGljZWRUb0FycmF5KHZvaWRNYXRjaCwgMiksXG4gICAgICAgICAgICAgIHZvaWROb2RlID0gX3ZvaWRNYXRjaFswXSxcbiAgICAgICAgICAgICAgdm9pZFBhdGggPSBfdm9pZE1hdGNoWzFdO1xuXG4gICAgICAgICAgaWYgKEVsZW1lbnQuaXNFbGVtZW50KHZvaWROb2RlKSAmJiBlZGl0b3IuaXNJbmxpbmUodm9pZE5vZGUpKSB7XG4gICAgICAgICAgICB2YXIgYWZ0ZXIgPSBFZGl0b3IuYWZ0ZXIoZWRpdG9yLCB2b2lkUGF0aCk7XG5cbiAgICAgICAgICAgIGlmICghYWZ0ZXIpIHtcbiAgICAgICAgICAgICAgdmFyIHRleHQgPSB7XG4gICAgICAgICAgICAgICAgdGV4dDogJydcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgdmFyIGFmdGVyUGF0aCA9IFBhdGgubmV4dCh2b2lkUGF0aCk7XG4gICAgICAgICAgICAgIFRyYW5zZm9ybXMuaW5zZXJ0Tm9kZXMoZWRpdG9yLCB0ZXh0LCB7XG4gICAgICAgICAgICAgICAgYXQ6IGFmdGVyUGF0aCxcbiAgICAgICAgICAgICAgICB2b2lkczogdm9pZHNcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGFmdGVyID0gRWRpdG9yLnBvaW50KGVkaXRvciwgYWZ0ZXJQYXRoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYXQgPSBhZnRlcjtcbiAgICAgICAgICAgIGFsd2F5cyA9IHRydWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHNpYmxpbmdIZWlnaHQgPSBhdC5wYXRoLmxlbmd0aCAtIHZvaWRQYXRoLmxlbmd0aDtcbiAgICAgICAgICBoZWlnaHQgPSBzaWJsaW5nSGVpZ2h0ICsgMTtcbiAgICAgICAgICBhbHdheXMgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgYWZ0ZXJSZWYgPSBFZGl0b3IucG9pbnRSZWYoZWRpdG9yLCBhdCk7XG4gICAgICAgIHZhciBkZXB0aCA9IGF0LnBhdGgubGVuZ3RoIC0gaGVpZ2h0O1xuXG4gICAgICAgIHZhciBfaGlnaGVzdCA9IF9zbGljZWRUb0FycmF5KGhpZ2hlc3QsIDIpLFxuICAgICAgICAgICAgaGlnaGVzdFBhdGggPSBfaGlnaGVzdFsxXTtcblxuICAgICAgICB2YXIgbG93ZXN0UGF0aCA9IGF0LnBhdGguc2xpY2UoMCwgZGVwdGgpO1xuICAgICAgICB2YXIgcG9zaXRpb24gPSBoZWlnaHQgPT09IDAgPyBhdC5vZmZzZXQgOiBhdC5wYXRoW2RlcHRoXSArIG51ZGdlO1xuXG4gICAgICAgIHZhciBfaXRlcmF0b3IzID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkMShFZGl0b3IubGV2ZWxzKGVkaXRvciwge1xuICAgICAgICAgIGF0OiBsb3dlc3RQYXRoLFxuICAgICAgICAgIHJldmVyc2U6IHRydWUsXG4gICAgICAgICAgdm9pZHM6IHZvaWRzXG4gICAgICAgIH0pKSxcbiAgICAgICAgICAgIF9zdGVwMztcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIGZvciAoX2l0ZXJhdG9yMy5zKCk7ICEoX3N0ZXAzID0gX2l0ZXJhdG9yMy5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgICB2YXIgX3N0ZXAzJHZhbHVlID0gX3NsaWNlZFRvQXJyYXkoX3N0ZXAzLnZhbHVlLCAyKSxcbiAgICAgICAgICAgICAgICBub2RlID0gX3N0ZXAzJHZhbHVlWzBdLFxuICAgICAgICAgICAgICAgIF9wYXRoMiA9IF9zdGVwMyR2YWx1ZVsxXTtcblxuICAgICAgICAgICAgdmFyIHNwbGl0ID0gZmFsc2U7XG5cbiAgICAgICAgICAgIGlmIChfcGF0aDIubGVuZ3RoIDwgaGlnaGVzdFBhdGgubGVuZ3RoIHx8IF9wYXRoMi5sZW5ndGggPT09IDAgfHwgIXZvaWRzICYmIEVsZW1lbnQuaXNFbGVtZW50KG5vZGUpICYmIEVkaXRvci5pc1ZvaWQoZWRpdG9yLCBub2RlKSkge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIF9wb2ludDIgPSBiZWZvcmVSZWYuY3VycmVudDtcbiAgICAgICAgICAgIHZhciBpc0VuZCA9IEVkaXRvci5pc0VuZChlZGl0b3IsIF9wb2ludDIsIF9wYXRoMik7XG5cbiAgICAgICAgICAgIGlmIChhbHdheXMgfHwgIWJlZm9yZVJlZiB8fCAhRWRpdG9yLmlzRWRnZShlZGl0b3IsIF9wb2ludDIsIF9wYXRoMikpIHtcbiAgICAgICAgICAgICAgc3BsaXQgPSB0cnVlO1xuICAgICAgICAgICAgICB2YXIgcHJvcGVydGllcyA9IE5vZGUuZXh0cmFjdFByb3BzKG5vZGUpO1xuICAgICAgICAgICAgICBlZGl0b3IuYXBwbHkoe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdzcGxpdF9ub2RlJyxcbiAgICAgICAgICAgICAgICBwYXRoOiBfcGF0aDIsXG4gICAgICAgICAgICAgICAgcG9zaXRpb246IHBvc2l0aW9uLFxuICAgICAgICAgICAgICAgIHByb3BlcnRpZXM6IHByb3BlcnRpZXNcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHBvc2l0aW9uID0gX3BhdGgyW19wYXRoMi5sZW5ndGggLSAxXSArIChzcGxpdCB8fCBpc0VuZCA/IDEgOiAwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIF9pdGVyYXRvcjMuZShlcnIpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIF9pdGVyYXRvcjMuZigpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuYXQgPT0gbnVsbCkge1xuICAgICAgICAgIHZhciBfcG9pbnQgPSBhZnRlclJlZi5jdXJyZW50IHx8IEVkaXRvci5lbmQoZWRpdG9yLCBbXSk7XG5cbiAgICAgICAgICBUcmFuc2Zvcm1zLnNlbGVjdChlZGl0b3IsIF9wb2ludCk7XG4gICAgICAgIH1cbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHZhciBfYWZ0ZXJSZWY7XG5cbiAgICAgICAgYmVmb3JlUmVmLnVucmVmKCk7XG4gICAgICAgIChfYWZ0ZXJSZWYgPSBhZnRlclJlZikgPT09IG51bGwgfHwgX2FmdGVyUmVmID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYWZ0ZXJSZWYudW5yZWYoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcblxuICAvKipcclxuICAgKiBVbnNldCBwcm9wZXJ0aWVzIG9uIHRoZSBub2RlcyBhdCBhIGxvY2F0aW9uLlxyXG4gICAqL1xuICB1bnNldE5vZGVzOiBmdW5jdGlvbiB1bnNldE5vZGVzKGVkaXRvciwgcHJvcHMpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG5cbiAgICBpZiAoIUFycmF5LmlzQXJyYXkocHJvcHMpKSB7XG4gICAgICBwcm9wcyA9IFtwcm9wc107XG4gICAgfVxuXG4gICAgdmFyIG9iaiA9IHt9O1xuXG4gICAgdmFyIF9pdGVyYXRvcjQgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciQxKHByb3BzKSxcbiAgICAgICAgX3N0ZXA0O1xuXG4gICAgdHJ5IHtcbiAgICAgIGZvciAoX2l0ZXJhdG9yNC5zKCk7ICEoX3N0ZXA0ID0gX2l0ZXJhdG9yNC5uKCkpLmRvbmU7KSB7XG4gICAgICAgIHZhciBrZXkgPSBfc3RlcDQudmFsdWU7XG4gICAgICAgIG9ialtrZXldID0gbnVsbDtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIF9pdGVyYXRvcjQuZShlcnIpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBfaXRlcmF0b3I0LmYoKTtcbiAgICB9XG5cbiAgICBUcmFuc2Zvcm1zLnNldE5vZGVzKGVkaXRvciwgb2JqLCBvcHRpb25zKTtcbiAgfSxcblxuICAvKipcclxuICAgKiBVbndyYXAgdGhlIG5vZGVzIGF0IGEgbG9jYXRpb24gZnJvbSBhIHBhcmVudCBub2RlLCBzcGxpdHRpbmcgdGhlIHBhcmVudCBpZlxyXG4gICAqIG5lY2Vzc2FyeSB0byBlbnN1cmUgdGhhdCBvbmx5IHRoZSBjb250ZW50IGluIHRoZSByYW5nZSBpcyB1bndyYXBwZWQuXHJcbiAgICovXG4gIHVud3JhcE5vZGVzOiBmdW5jdGlvbiB1bndyYXBOb2RlcyhlZGl0b3IpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgRWRpdG9yLndpdGhvdXROb3JtYWxpemluZyhlZGl0b3IsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfb3B0aW9ucyRtb2RlOCA9IG9wdGlvbnMubW9kZSxcbiAgICAgICAgICBtb2RlID0gX29wdGlvbnMkbW9kZTggPT09IHZvaWQgMCA/ICdsb3dlc3QnIDogX29wdGlvbnMkbW9kZTgsXG4gICAgICAgICAgX29wdGlvbnMkc3BsaXQyID0gb3B0aW9ucy5zcGxpdCxcbiAgICAgICAgICBzcGxpdCA9IF9vcHRpb25zJHNwbGl0MiA9PT0gdm9pZCAwID8gZmFsc2UgOiBfb3B0aW9ucyRzcGxpdDIsXG4gICAgICAgICAgX29wdGlvbnMkdm9pZHM4ID0gb3B0aW9ucy52b2lkcyxcbiAgICAgICAgICB2b2lkcyA9IF9vcHRpb25zJHZvaWRzOCA9PT0gdm9pZCAwID8gZmFsc2UgOiBfb3B0aW9ucyR2b2lkczg7XG4gICAgICB2YXIgX29wdGlvbnMkYXQ3ID0gb3B0aW9ucy5hdCxcbiAgICAgICAgICBhdCA9IF9vcHRpb25zJGF0NyA9PT0gdm9pZCAwID8gZWRpdG9yLnNlbGVjdGlvbiA6IF9vcHRpb25zJGF0NyxcbiAgICAgICAgICBtYXRjaCA9IG9wdGlvbnMubWF0Y2g7XG5cbiAgICAgIGlmICghYXQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAobWF0Y2ggPT0gbnVsbCkge1xuICAgICAgICBtYXRjaCA9IFBhdGguaXNQYXRoKGF0KSA/IG1hdGNoUGF0aChlZGl0b3IsIGF0KSA6IGZ1bmN0aW9uIChuKSB7XG4gICAgICAgICAgcmV0dXJuIEVsZW1lbnQuaXNFbGVtZW50KG4pICYmIEVkaXRvci5pc0Jsb2NrKGVkaXRvciwgbik7XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGlmIChQYXRoLmlzUGF0aChhdCkpIHtcbiAgICAgICAgYXQgPSBFZGl0b3IucmFuZ2UoZWRpdG9yLCBhdCk7XG4gICAgICB9XG5cbiAgICAgIHZhciByYW5nZVJlZiA9IFJhbmdlLmlzUmFuZ2UoYXQpID8gRWRpdG9yLnJhbmdlUmVmKGVkaXRvciwgYXQpIDogbnVsbDtcbiAgICAgIHZhciBtYXRjaGVzID0gRWRpdG9yLm5vZGVzKGVkaXRvciwge1xuICAgICAgICBhdDogYXQsXG4gICAgICAgIG1hdGNoOiBtYXRjaCxcbiAgICAgICAgbW9kZTogbW9kZSxcbiAgICAgICAgdm9pZHM6IHZvaWRzXG4gICAgICB9KTtcbiAgICAgIHZhciBwYXRoUmVmcyA9IEFycmF5LmZyb20obWF0Y2hlcywgZnVuY3Rpb24gKF9yZWY5KSB7XG4gICAgICAgIHZhciBfcmVmMTAgPSBfc2xpY2VkVG9BcnJheShfcmVmOSwgMiksXG4gICAgICAgICAgICBwID0gX3JlZjEwWzFdO1xuXG4gICAgICAgIHJldHVybiBFZGl0b3IucGF0aFJlZihlZGl0b3IsIHApO1xuICAgICAgfSAvLyB1bndyYXBOb2RlIHdpbGwgY2FsbCBsaWZ0Tm9kZSB3aGljaCBkb2VzIG5vdCBzdXBwb3J0IHNwbGl0dGluZyB0aGUgbm9kZSB3aGVuIG5lc3RlZC5cbiAgICAgIC8vIElmIHdlIGRvIG5vdCByZXZlcnNlIHRoZSBvcmRlciBhbmQgY2FsbCBpdCBmcm9tIHRvcCB0byB0aGUgYm90dG9tLCBpdCB3aWxsIHJlbW92ZSBhbGwgYmxvY2tzXG4gICAgICAvLyB0aGF0IHdyYXAgdGFyZ2V0IG5vZGUuIFNvIHdlIHJldmVyc2UgdGhlIG9yZGVyLlxuICAgICAgKS5yZXZlcnNlKCk7XG5cbiAgICAgIHZhciBfaXRlcmF0b3I1ID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkMShwYXRoUmVmcyksXG4gICAgICAgICAgX3N0ZXA1O1xuXG4gICAgICB0cnkge1xuICAgICAgICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcCgpIHtcbiAgICAgICAgICB2YXIgcGF0aFJlZiA9IF9zdGVwNS52YWx1ZTtcbiAgICAgICAgICB2YXIgcGF0aCA9IHBhdGhSZWYudW5yZWYoKTtcblxuICAgICAgICAgIHZhciBfRWRpdG9yJG5vZGUzID0gRWRpdG9yLm5vZGUoZWRpdG9yLCBwYXRoKSxcbiAgICAgICAgICAgICAgX0VkaXRvciRub2RlNCA9IF9zbGljZWRUb0FycmF5KF9FZGl0b3Ikbm9kZTMsIDEpLFxuICAgICAgICAgICAgICBub2RlID0gX0VkaXRvciRub2RlNFswXTtcblxuICAgICAgICAgIHZhciByYW5nZSA9IEVkaXRvci5yYW5nZShlZGl0b3IsIHBhdGgpO1xuXG4gICAgICAgICAgaWYgKHNwbGl0ICYmIHJhbmdlUmVmKSB7XG4gICAgICAgICAgICByYW5nZSA9IFJhbmdlLmludGVyc2VjdGlvbihyYW5nZVJlZi5jdXJyZW50LCByYW5nZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgVHJhbnNmb3Jtcy5saWZ0Tm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICBhdDogcmFuZ2UsXG4gICAgICAgICAgICBtYXRjaDogZnVuY3Rpb24gbWF0Y2gobikge1xuICAgICAgICAgICAgICByZXR1cm4gRWxlbWVudC5pc0FuY2VzdG9yKG5vZGUpICYmIG5vZGUuY2hpbGRyZW4uaW5jbHVkZXMobik7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdm9pZHM6IHZvaWRzXG4gICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgZm9yIChfaXRlcmF0b3I1LnMoKTsgIShfc3RlcDUgPSBfaXRlcmF0b3I1Lm4oKSkuZG9uZTspIHtcbiAgICAgICAgICBfbG9vcCgpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2l0ZXJhdG9yNS5lKGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBfaXRlcmF0b3I1LmYoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHJhbmdlUmVmKSB7XG4gICAgICAgIHJhbmdlUmVmLnVucmVmKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogV3JhcCB0aGUgbm9kZXMgYXQgYSBsb2NhdGlvbiBpbiBhIG5ldyBjb250YWluZXIgbm9kZSwgc3BsaXR0aW5nIHRoZSBlZGdlc1xyXG4gICAqIG9mIHRoZSByYW5nZSBmaXJzdCB0byBlbnN1cmUgdGhhdCBvbmx5IHRoZSBjb250ZW50IGluIHRoZSByYW5nZSBpcyB3cmFwcGVkLlxyXG4gICAqL1xuICB3cmFwTm9kZXM6IGZ1bmN0aW9uIHdyYXBOb2RlcyhlZGl0b3IsIGVsZW1lbnQpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgRWRpdG9yLndpdGhvdXROb3JtYWxpemluZyhlZGl0b3IsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfb3B0aW9ucyRtb2RlOSA9IG9wdGlvbnMubW9kZSxcbiAgICAgICAgICBtb2RlID0gX29wdGlvbnMkbW9kZTkgPT09IHZvaWQgMCA/ICdsb3dlc3QnIDogX29wdGlvbnMkbW9kZTksXG4gICAgICAgICAgX29wdGlvbnMkc3BsaXQzID0gb3B0aW9ucy5zcGxpdCxcbiAgICAgICAgICBzcGxpdCA9IF9vcHRpb25zJHNwbGl0MyA9PT0gdm9pZCAwID8gZmFsc2UgOiBfb3B0aW9ucyRzcGxpdDMsXG4gICAgICAgICAgX29wdGlvbnMkdm9pZHM5ID0gb3B0aW9ucy52b2lkcyxcbiAgICAgICAgICB2b2lkcyA9IF9vcHRpb25zJHZvaWRzOSA9PT0gdm9pZCAwID8gZmFsc2UgOiBfb3B0aW9ucyR2b2lkczk7XG4gICAgICB2YXIgbWF0Y2ggPSBvcHRpb25zLm1hdGNoLFxuICAgICAgICAgIF9vcHRpb25zJGF0OCA9IG9wdGlvbnMuYXQsXG4gICAgICAgICAgYXQgPSBfb3B0aW9ucyRhdDggPT09IHZvaWQgMCA/IGVkaXRvci5zZWxlY3Rpb24gOiBfb3B0aW9ucyRhdDg7XG5cbiAgICAgIGlmICghYXQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAobWF0Y2ggPT0gbnVsbCkge1xuICAgICAgICBpZiAoUGF0aC5pc1BhdGgoYXQpKSB7XG4gICAgICAgICAgbWF0Y2ggPSBtYXRjaFBhdGgoZWRpdG9yLCBhdCk7XG4gICAgICAgIH0gZWxzZSBpZiAoZWRpdG9yLmlzSW5saW5lKGVsZW1lbnQpKSB7XG4gICAgICAgICAgbWF0Y2ggPSBmdW5jdGlvbiBtYXRjaChuKSB7XG4gICAgICAgICAgICByZXR1cm4gRWxlbWVudC5pc0VsZW1lbnQobikgJiYgRWRpdG9yLmlzSW5saW5lKGVkaXRvciwgbikgfHwgVGV4dC5pc1RleHQobik7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtYXRjaCA9IGZ1bmN0aW9uIG1hdGNoKG4pIHtcbiAgICAgICAgICAgIHJldHVybiBFbGVtZW50LmlzRWxlbWVudChuKSAmJiBFZGl0b3IuaXNCbG9jayhlZGl0b3IsIG4pO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHNwbGl0ICYmIFJhbmdlLmlzUmFuZ2UoYXQpKSB7XG4gICAgICAgIHZhciBfUmFuZ2UkZWRnZXM3ID0gUmFuZ2UuZWRnZXMoYXQpLFxuICAgICAgICAgICAgX1JhbmdlJGVkZ2VzOCA9IF9zbGljZWRUb0FycmF5KF9SYW5nZSRlZGdlczcsIDIpLFxuICAgICAgICAgICAgc3RhcnQgPSBfUmFuZ2UkZWRnZXM4WzBdLFxuICAgICAgICAgICAgZW5kID0gX1JhbmdlJGVkZ2VzOFsxXTtcblxuICAgICAgICB2YXIgcmFuZ2VSZWYgPSBFZGl0b3IucmFuZ2VSZWYoZWRpdG9yLCBhdCwge1xuICAgICAgICAgIGFmZmluaXR5OiAnaW53YXJkJ1xuICAgICAgICB9KTtcbiAgICAgICAgVHJhbnNmb3Jtcy5zcGxpdE5vZGVzKGVkaXRvciwge1xuICAgICAgICAgIGF0OiBlbmQsXG4gICAgICAgICAgbWF0Y2g6IG1hdGNoLFxuICAgICAgICAgIHZvaWRzOiB2b2lkc1xuICAgICAgICB9KTtcbiAgICAgICAgVHJhbnNmb3Jtcy5zcGxpdE5vZGVzKGVkaXRvciwge1xuICAgICAgICAgIGF0OiBzdGFydCxcbiAgICAgICAgICBtYXRjaDogbWF0Y2gsXG4gICAgICAgICAgdm9pZHM6IHZvaWRzXG4gICAgICAgIH0pO1xuICAgICAgICBhdCA9IHJhbmdlUmVmLnVucmVmKCk7XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuYXQgPT0gbnVsbCkge1xuICAgICAgICAgIFRyYW5zZm9ybXMuc2VsZWN0KGVkaXRvciwgYXQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciByb290cyA9IEFycmF5LmZyb20oRWRpdG9yLm5vZGVzKGVkaXRvciwge1xuICAgICAgICBhdDogYXQsXG4gICAgICAgIG1hdGNoOiBlZGl0b3IuaXNJbmxpbmUoZWxlbWVudCkgPyBmdW5jdGlvbiAobikge1xuICAgICAgICAgIHJldHVybiBFbGVtZW50LmlzRWxlbWVudChuKSAmJiBFZGl0b3IuaXNCbG9jayhlZGl0b3IsIG4pO1xuICAgICAgICB9IDogZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgICByZXR1cm4gRWRpdG9yLmlzRWRpdG9yKG4pO1xuICAgICAgICB9LFxuICAgICAgICBtb2RlOiAnbG93ZXN0JyxcbiAgICAgICAgdm9pZHM6IHZvaWRzXG4gICAgICB9KSk7XG5cbiAgICAgIGZvciAodmFyIF9pNCA9IDAsIF9yb290cyA9IHJvb3RzOyBfaTQgPCBfcm9vdHMubGVuZ3RoOyBfaTQrKykge1xuICAgICAgICB2YXIgX3Jvb3RzJF9pID0gX3NsaWNlZFRvQXJyYXkoX3Jvb3RzW19pNF0sIDIpLFxuICAgICAgICAgICAgcm9vdFBhdGggPSBfcm9vdHMkX2lbMV07XG5cbiAgICAgICAgdmFyIGEgPSBSYW5nZS5pc1JhbmdlKGF0KSA/IFJhbmdlLmludGVyc2VjdGlvbihhdCwgRWRpdG9yLnJhbmdlKGVkaXRvciwgcm9vdFBhdGgpKSA6IGF0O1xuXG4gICAgICAgIGlmICghYSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG1hdGNoZXMgPSBBcnJheS5mcm9tKEVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICBhdDogYSxcbiAgICAgICAgICBtYXRjaDogbWF0Y2gsXG4gICAgICAgICAgbW9kZTogbW9kZSxcbiAgICAgICAgICB2b2lkczogdm9pZHNcbiAgICAgICAgfSkpO1xuXG4gICAgICAgIGlmIChtYXRjaGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICB2YXIgX3JldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfbWF0Y2hlcyA9IF9zbGljZWRUb0FycmF5KG1hdGNoZXMsIDEpLFxuICAgICAgICAgICAgICAgIGZpcnN0ID0gX21hdGNoZXNbMF07XG5cbiAgICAgICAgICAgIHZhciBsYXN0ID0gbWF0Y2hlc1ttYXRjaGVzLmxlbmd0aCAtIDFdO1xuXG4gICAgICAgICAgICB2YXIgX2ZpcnN0ID0gX3NsaWNlZFRvQXJyYXkoZmlyc3QsIDIpLFxuICAgICAgICAgICAgICAgIGZpcnN0UGF0aCA9IF9maXJzdFsxXTtcblxuICAgICAgICAgICAgdmFyIF9sYXN0ID0gX3NsaWNlZFRvQXJyYXkobGFzdCwgMiksXG4gICAgICAgICAgICAgICAgbGFzdFBhdGggPSBfbGFzdFsxXTtcblxuICAgICAgICAgICAgaWYgKGZpcnN0UGF0aC5sZW5ndGggPT09IDAgJiYgbGFzdFBhdGgubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgIC8vIGlmIHRoZXJlJ3Mgbm8gbWF0Y2hpbmcgcGFyZW50IC0gdXN1YWxseSBtZWFucyB0aGUgbm9kZSBpcyBhbiBlZGl0b3IgLSBkb24ndCBkbyBhbnl0aGluZ1xuICAgICAgICAgICAgICByZXR1cm4gXCJjb250aW51ZVwiO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgY29tbW9uUGF0aCA9IFBhdGguZXF1YWxzKGZpcnN0UGF0aCwgbGFzdFBhdGgpID8gUGF0aC5wYXJlbnQoZmlyc3RQYXRoKSA6IFBhdGguY29tbW9uKGZpcnN0UGF0aCwgbGFzdFBhdGgpO1xuICAgICAgICAgICAgdmFyIHJhbmdlID0gRWRpdG9yLnJhbmdlKGVkaXRvciwgZmlyc3RQYXRoLCBsYXN0UGF0aCk7XG4gICAgICAgICAgICB2YXIgY29tbW9uTm9kZUVudHJ5ID0gRWRpdG9yLm5vZGUoZWRpdG9yLCBjb21tb25QYXRoKTtcblxuICAgICAgICAgICAgdmFyIF9jb21tb25Ob2RlRW50cnkgPSBfc2xpY2VkVG9BcnJheShjb21tb25Ob2RlRW50cnksIDEpLFxuICAgICAgICAgICAgICAgIGNvbW1vbk5vZGUgPSBfY29tbW9uTm9kZUVudHJ5WzBdO1xuXG4gICAgICAgICAgICB2YXIgZGVwdGggPSBjb21tb25QYXRoLmxlbmd0aCArIDE7XG4gICAgICAgICAgICB2YXIgd3JhcHBlclBhdGggPSBQYXRoLm5leHQobGFzdFBhdGguc2xpY2UoMCwgZGVwdGgpKTtcblxuICAgICAgICAgICAgdmFyIHdyYXBwZXIgPSBfb2JqZWN0U3ByZWFkJDIoX29iamVjdFNwcmVhZCQyKHt9LCBlbGVtZW50KSwge30sIHtcbiAgICAgICAgICAgICAgY2hpbGRyZW46IFtdXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgVHJhbnNmb3Jtcy5pbnNlcnROb2RlcyhlZGl0b3IsIHdyYXBwZXIsIHtcbiAgICAgICAgICAgICAgYXQ6IHdyYXBwZXJQYXRoLFxuICAgICAgICAgICAgICB2b2lkczogdm9pZHNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgVHJhbnNmb3Jtcy5tb3ZlTm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICAgIGF0OiByYW5nZSxcbiAgICAgICAgICAgICAgbWF0Y2g6IGZ1bmN0aW9uIG1hdGNoKG4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gRWxlbWVudC5pc0FuY2VzdG9yKGNvbW1vbk5vZGUpICYmIGNvbW1vbk5vZGUuY2hpbGRyZW4uaW5jbHVkZXMobik7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHRvOiB3cmFwcGVyUGF0aC5jb25jYXQoMCksXG4gICAgICAgICAgICAgIHZvaWRzOiB2b2lkc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSgpO1xuXG4gICAgICAgICAgaWYgKF9yZXQgPT09IFwiY29udGludWVcIikgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufTtcblxudmFyIGhhc1NpbmdsZUNoaWxkTmVzdCA9IGZ1bmN0aW9uIGhhc1NpbmdsZUNoaWxkTmVzdChlZGl0b3IsIG5vZGUpIHtcbiAgaWYgKEVsZW1lbnQuaXNFbGVtZW50KG5vZGUpKSB7XG4gICAgdmFyIGVsZW1lbnQgPSBub2RlO1xuXG4gICAgaWYgKEVkaXRvci5pc1ZvaWQoZWRpdG9yLCBub2RlKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmIChlbGVtZW50LmNoaWxkcmVuLmxlbmd0aCA9PT0gMSkge1xuICAgICAgcmV0dXJuIGhhc1NpbmdsZUNoaWxkTmVzdChlZGl0b3IsIGVsZW1lbnQuY2hpbGRyZW5bMF0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9IGVsc2UgaWYgKEVkaXRvci5pc0VkaXRvcihub2RlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTtcbi8qKlxyXG4gKiBDb252ZXJ0IGEgcmFuZ2UgaW50byBhIHBvaW50IGJ5IGRlbGV0aW5nIGl0J3MgY29udGVudC5cclxuICovXG5cblxudmFyIGRlbGV0ZVJhbmdlID0gZnVuY3Rpb24gZGVsZXRlUmFuZ2UoZWRpdG9yLCByYW5nZSkge1xuICBpZiAoUmFuZ2UuaXNDb2xsYXBzZWQocmFuZ2UpKSB7XG4gICAgcmV0dXJuIHJhbmdlLmFuY2hvcjtcbiAgfSBlbHNlIHtcbiAgICB2YXIgX1JhbmdlJGVkZ2VzOSA9IFJhbmdlLmVkZ2VzKHJhbmdlKSxcbiAgICAgICAgX1JhbmdlJGVkZ2VzMTAgPSBfc2xpY2VkVG9BcnJheShfUmFuZ2UkZWRnZXM5LCAyKSxcbiAgICAgICAgZW5kID0gX1JhbmdlJGVkZ2VzMTBbMV07XG5cbiAgICB2YXIgcG9pbnRSZWYgPSBFZGl0b3IucG9pbnRSZWYoZWRpdG9yLCBlbmQpO1xuICAgIFRyYW5zZm9ybXNbXCJkZWxldGVcIl0oZWRpdG9yLCB7XG4gICAgICBhdDogcmFuZ2VcbiAgICB9KTtcbiAgICByZXR1cm4gcG9pbnRSZWYudW5yZWYoKTtcbiAgfVxufTtcblxudmFyIG1hdGNoUGF0aCA9IGZ1bmN0aW9uIG1hdGNoUGF0aChlZGl0b3IsIHBhdGgpIHtcbiAgdmFyIF9FZGl0b3Ikbm9kZTUgPSBFZGl0b3Iubm9kZShlZGl0b3IsIHBhdGgpLFxuICAgICAgX0VkaXRvciRub2RlNiA9IF9zbGljZWRUb0FycmF5KF9FZGl0b3Ikbm9kZTUsIDEpLFxuICAgICAgbm9kZSA9IF9FZGl0b3Ikbm9kZTZbMF07XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChuKSB7XG4gICAgcmV0dXJuIG4gPT09IG5vZGU7XG4gIH07XG59O1xuXG5mdW5jdGlvbiBvd25LZXlzJDEob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBpZiAoZW51bWVyYWJsZU9ubHkpIHsgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyB9IGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkJDEodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgb3duS2V5cyQxKE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pOyB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7IH0gZWxzZSB7IG93bktleXMkMShPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxudmFyIFNlbGVjdGlvblRyYW5zZm9ybXMgPSB7XG4gIC8qKlxyXG4gICAqIENvbGxhcHNlIHRoZSBzZWxlY3Rpb24uXHJcbiAgICovXG4gIGNvbGxhcHNlOiBmdW5jdGlvbiBjb2xsYXBzZShlZGl0b3IpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgdmFyIF9vcHRpb25zJGVkZ2UgPSBvcHRpb25zLmVkZ2UsXG4gICAgICAgIGVkZ2UgPSBfb3B0aW9ucyRlZGdlID09PSB2b2lkIDAgPyAnYW5jaG9yJyA6IF9vcHRpb25zJGVkZ2U7XG4gICAgdmFyIHNlbGVjdGlvbiA9IGVkaXRvci5zZWxlY3Rpb247XG5cbiAgICBpZiAoIXNlbGVjdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSBpZiAoZWRnZSA9PT0gJ2FuY2hvcicpIHtcbiAgICAgIFRyYW5zZm9ybXMuc2VsZWN0KGVkaXRvciwgc2VsZWN0aW9uLmFuY2hvcik7XG4gICAgfSBlbHNlIGlmIChlZGdlID09PSAnZm9jdXMnKSB7XG4gICAgICBUcmFuc2Zvcm1zLnNlbGVjdChlZGl0b3IsIHNlbGVjdGlvbi5mb2N1cyk7XG4gICAgfSBlbHNlIGlmIChlZGdlID09PSAnc3RhcnQnKSB7XG4gICAgICB2YXIgX1JhbmdlJGVkZ2VzID0gUmFuZ2UuZWRnZXMoc2VsZWN0aW9uKSxcbiAgICAgICAgICBfUmFuZ2UkZWRnZXMyID0gX3NsaWNlZFRvQXJyYXkoX1JhbmdlJGVkZ2VzLCAxKSxcbiAgICAgICAgICBzdGFydCA9IF9SYW5nZSRlZGdlczJbMF07XG5cbiAgICAgIFRyYW5zZm9ybXMuc2VsZWN0KGVkaXRvciwgc3RhcnQpO1xuICAgIH0gZWxzZSBpZiAoZWRnZSA9PT0gJ2VuZCcpIHtcbiAgICAgIHZhciBfUmFuZ2UkZWRnZXMzID0gUmFuZ2UuZWRnZXMoc2VsZWN0aW9uKSxcbiAgICAgICAgICBfUmFuZ2UkZWRnZXM0ID0gX3NsaWNlZFRvQXJyYXkoX1JhbmdlJGVkZ2VzMywgMiksXG4gICAgICAgICAgZW5kID0gX1JhbmdlJGVkZ2VzNFsxXTtcblxuICAgICAgVHJhbnNmb3Jtcy5zZWxlY3QoZWRpdG9yLCBlbmQpO1xuICAgIH1cbiAgfSxcblxuICAvKipcclxuICAgKiBVbnNldCB0aGUgc2VsZWN0aW9uLlxyXG4gICAqL1xuICBkZXNlbGVjdDogZnVuY3Rpb24gZGVzZWxlY3QoZWRpdG9yKSB7XG4gICAgdmFyIHNlbGVjdGlvbiA9IGVkaXRvci5zZWxlY3Rpb247XG5cbiAgICBpZiAoc2VsZWN0aW9uKSB7XG4gICAgICBlZGl0b3IuYXBwbHkoe1xuICAgICAgICB0eXBlOiAnc2V0X3NlbGVjdGlvbicsXG4gICAgICAgIHByb3BlcnRpZXM6IHNlbGVjdGlvbixcbiAgICAgICAgbmV3UHJvcGVydGllczogbnVsbFxuICAgICAgfSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxyXG4gICAqIE1vdmUgdGhlIHNlbGVjdGlvbidzIHBvaW50IGZvcndhcmQgb3IgYmFja3dhcmQuXHJcbiAgICovXG4gIG1vdmU6IGZ1bmN0aW9uIG1vdmUoZWRpdG9yKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIHZhciBzZWxlY3Rpb24gPSBlZGl0b3Iuc2VsZWN0aW9uO1xuICAgIHZhciBfb3B0aW9ucyRkaXN0YW5jZSA9IG9wdGlvbnMuZGlzdGFuY2UsXG4gICAgICAgIGRpc3RhbmNlID0gX29wdGlvbnMkZGlzdGFuY2UgPT09IHZvaWQgMCA/IDEgOiBfb3B0aW9ucyRkaXN0YW5jZSxcbiAgICAgICAgX29wdGlvbnMkdW5pdCA9IG9wdGlvbnMudW5pdCxcbiAgICAgICAgdW5pdCA9IF9vcHRpb25zJHVuaXQgPT09IHZvaWQgMCA/ICdjaGFyYWN0ZXInIDogX29wdGlvbnMkdW5pdCxcbiAgICAgICAgX29wdGlvbnMkcmV2ZXJzZSA9IG9wdGlvbnMucmV2ZXJzZSxcbiAgICAgICAgcmV2ZXJzZSA9IF9vcHRpb25zJHJldmVyc2UgPT09IHZvaWQgMCA/IGZhbHNlIDogX29wdGlvbnMkcmV2ZXJzZTtcbiAgICB2YXIgX29wdGlvbnMkZWRnZTIgPSBvcHRpb25zLmVkZ2UsXG4gICAgICAgIGVkZ2UgPSBfb3B0aW9ucyRlZGdlMiA9PT0gdm9pZCAwID8gbnVsbCA6IF9vcHRpb25zJGVkZ2UyO1xuXG4gICAgaWYgKCFzZWxlY3Rpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZWRnZSA9PT0gJ3N0YXJ0Jykge1xuICAgICAgZWRnZSA9IFJhbmdlLmlzQmFja3dhcmQoc2VsZWN0aW9uKSA/ICdmb2N1cycgOiAnYW5jaG9yJztcbiAgICB9XG5cbiAgICBpZiAoZWRnZSA9PT0gJ2VuZCcpIHtcbiAgICAgIGVkZ2UgPSBSYW5nZS5pc0JhY2t3YXJkKHNlbGVjdGlvbikgPyAnYW5jaG9yJyA6ICdmb2N1cyc7XG4gICAgfVxuXG4gICAgdmFyIGFuY2hvciA9IHNlbGVjdGlvbi5hbmNob3IsXG4gICAgICAgIGZvY3VzID0gc2VsZWN0aW9uLmZvY3VzO1xuICAgIHZhciBvcHRzID0ge1xuICAgICAgZGlzdGFuY2U6IGRpc3RhbmNlLFxuICAgICAgdW5pdDogdW5pdFxuICAgIH07XG4gICAgdmFyIHByb3BzID0ge307XG5cbiAgICBpZiAoZWRnZSA9PSBudWxsIHx8IGVkZ2UgPT09ICdhbmNob3InKSB7XG4gICAgICB2YXIgcG9pbnQgPSByZXZlcnNlID8gRWRpdG9yLmJlZm9yZShlZGl0b3IsIGFuY2hvciwgb3B0cykgOiBFZGl0b3IuYWZ0ZXIoZWRpdG9yLCBhbmNob3IsIG9wdHMpO1xuXG4gICAgICBpZiAocG9pbnQpIHtcbiAgICAgICAgcHJvcHMuYW5jaG9yID0gcG9pbnQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGVkZ2UgPT0gbnVsbCB8fCBlZGdlID09PSAnZm9jdXMnKSB7XG4gICAgICB2YXIgX3BvaW50ID0gcmV2ZXJzZSA/IEVkaXRvci5iZWZvcmUoZWRpdG9yLCBmb2N1cywgb3B0cykgOiBFZGl0b3IuYWZ0ZXIoZWRpdG9yLCBmb2N1cywgb3B0cyk7XG5cbiAgICAgIGlmIChfcG9pbnQpIHtcbiAgICAgICAgcHJvcHMuZm9jdXMgPSBfcG9pbnQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgVHJhbnNmb3Jtcy5zZXRTZWxlY3Rpb24oZWRpdG9yLCBwcm9wcyk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogU2V0IHRoZSBzZWxlY3Rpb24gdG8gYSBuZXcgdmFsdWUuXHJcbiAgICovXG4gIHNlbGVjdDogZnVuY3Rpb24gc2VsZWN0KGVkaXRvciwgdGFyZ2V0KSB7XG4gICAgdmFyIHNlbGVjdGlvbiA9IGVkaXRvci5zZWxlY3Rpb247XG4gICAgdGFyZ2V0ID0gRWRpdG9yLnJhbmdlKGVkaXRvciwgdGFyZ2V0KTtcblxuICAgIGlmIChzZWxlY3Rpb24pIHtcbiAgICAgIFRyYW5zZm9ybXMuc2V0U2VsZWN0aW9uKGVkaXRvciwgdGFyZ2V0KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIVJhbmdlLmlzUmFuZ2UodGFyZ2V0KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiV2hlbiBzZXR0aW5nIHRoZSBzZWxlY3Rpb24gYW5kIHRoZSBjdXJyZW50IHNlbGVjdGlvbiBpcyBgbnVsbGAgeW91IG11c3QgcHJvdmlkZSBhdCBsZWFzdCBhbiBgYW5jaG9yYCBhbmQgYGZvY3VzYCwgYnV0IHlvdSBwYXNzZWQ6IFwiLmNvbmNhdChTY3J1YmJlci5zdHJpbmdpZnkodGFyZ2V0KSkpO1xuICAgIH1cblxuICAgIGVkaXRvci5hcHBseSh7XG4gICAgICB0eXBlOiAnc2V0X3NlbGVjdGlvbicsXG4gICAgICBwcm9wZXJ0aWVzOiBzZWxlY3Rpb24sXG4gICAgICBuZXdQcm9wZXJ0aWVzOiB0YXJnZXRcbiAgICB9KTtcbiAgfSxcblxuICAvKipcclxuICAgKiBTZXQgbmV3IHByb3BlcnRpZXMgb24gb25lIG9mIHRoZSBzZWxlY3Rpb24ncyBwb2ludHMuXHJcbiAgICovXG4gIHNldFBvaW50OiBmdW5jdGlvbiBzZXRQb2ludChlZGl0b3IsIHByb3BzKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIHZhciBzZWxlY3Rpb24gPSBlZGl0b3Iuc2VsZWN0aW9uO1xuICAgIHZhciBfb3B0aW9ucyRlZGdlMyA9IG9wdGlvbnMuZWRnZSxcbiAgICAgICAgZWRnZSA9IF9vcHRpb25zJGVkZ2UzID09PSB2b2lkIDAgPyAnYm90aCcgOiBfb3B0aW9ucyRlZGdlMztcblxuICAgIGlmICghc2VsZWN0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGVkZ2UgPT09ICdzdGFydCcpIHtcbiAgICAgIGVkZ2UgPSBSYW5nZS5pc0JhY2t3YXJkKHNlbGVjdGlvbikgPyAnZm9jdXMnIDogJ2FuY2hvcic7XG4gICAgfVxuXG4gICAgaWYgKGVkZ2UgPT09ICdlbmQnKSB7XG4gICAgICBlZGdlID0gUmFuZ2UuaXNCYWNrd2FyZChzZWxlY3Rpb24pID8gJ2FuY2hvcicgOiAnZm9jdXMnO1xuICAgIH1cblxuICAgIHZhciBhbmNob3IgPSBzZWxlY3Rpb24uYW5jaG9yLFxuICAgICAgICBmb2N1cyA9IHNlbGVjdGlvbi5mb2N1cztcbiAgICB2YXIgcG9pbnQgPSBlZGdlID09PSAnYW5jaG9yJyA/IGFuY2hvciA6IGZvY3VzO1xuICAgIFRyYW5zZm9ybXMuc2V0U2VsZWN0aW9uKGVkaXRvciwgX2RlZmluZVByb3BlcnR5KHt9LCBlZGdlID09PSAnYW5jaG9yJyA/ICdhbmNob3InIDogJ2ZvY3VzJywgX29iamVjdFNwcmVhZCQxKF9vYmplY3RTcHJlYWQkMSh7fSwgcG9pbnQpLCBwcm9wcykpKTtcbiAgfSxcblxuICAvKipcclxuICAgKiBTZXQgbmV3IHByb3BlcnRpZXMgb24gdGhlIHNlbGVjdGlvbi5cclxuICAgKi9cbiAgc2V0U2VsZWN0aW9uOiBmdW5jdGlvbiBzZXRTZWxlY3Rpb24oZWRpdG9yLCBwcm9wcykge1xuICAgIHZhciBzZWxlY3Rpb24gPSBlZGl0b3Iuc2VsZWN0aW9uO1xuICAgIHZhciBvbGRQcm9wcyA9IHt9O1xuICAgIHZhciBuZXdQcm9wcyA9IHt9O1xuXG4gICAgaWYgKCFzZWxlY3Rpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBrIGluIHByb3BzKSB7XG4gICAgICBpZiAoayA9PT0gJ2FuY2hvcicgJiYgcHJvcHMuYW5jaG9yICE9IG51bGwgJiYgIVBvaW50LmVxdWFscyhwcm9wcy5hbmNob3IsIHNlbGVjdGlvbi5hbmNob3IpIHx8IGsgPT09ICdmb2N1cycgJiYgcHJvcHMuZm9jdXMgIT0gbnVsbCAmJiAhUG9pbnQuZXF1YWxzKHByb3BzLmZvY3VzLCBzZWxlY3Rpb24uZm9jdXMpIHx8IGsgIT09ICdhbmNob3InICYmIGsgIT09ICdmb2N1cycgJiYgcHJvcHNba10gIT09IHNlbGVjdGlvbltrXSkge1xuICAgICAgICBvbGRQcm9wc1trXSA9IHNlbGVjdGlvbltrXTtcbiAgICAgICAgbmV3UHJvcHNba10gPSBwcm9wc1trXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoT2JqZWN0LmtleXMob2xkUHJvcHMpLmxlbmd0aCA+IDApIHtcbiAgICAgIGVkaXRvci5hcHBseSh7XG4gICAgICAgIHR5cGU6ICdzZXRfc2VsZWN0aW9uJyxcbiAgICAgICAgcHJvcGVydGllczogb2xkUHJvcHMsXG4gICAgICAgIG5ld1Byb3BlcnRpZXM6IG5ld1Byb3BzXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn07XG5cbmZ1bmN0aW9uIF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKG8sIGFsbG93QXJyYXlMaWtlKSB7IHZhciBpdCA9IHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdIHx8IG9bXCJAQGl0ZXJhdG9yXCJdOyBpZiAoIWl0KSB7IGlmIChBcnJheS5pc0FycmF5KG8pIHx8IChpdCA9IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvKSkgfHwgYWxsb3dBcnJheUxpa2UgJiYgbyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHsgaWYgKGl0KSBvID0gaXQ7IHZhciBpID0gMDsgdmFyIEYgPSBmdW5jdGlvbiBGKCkge307IHJldHVybiB7IHM6IEYsIG46IGZ1bmN0aW9uIG4oKSB7IGlmIChpID49IG8ubGVuZ3RoKSByZXR1cm4geyBkb25lOiB0cnVlIH07IHJldHVybiB7IGRvbmU6IGZhbHNlLCB2YWx1ZTogb1tpKytdIH07IH0sIGU6IGZ1bmN0aW9uIGUoX2UpIHsgdGhyb3cgX2U7IH0sIGY6IEYgfTsgfSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGl0ZXJhdGUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH0gdmFyIG5vcm1hbENvbXBsZXRpb24gPSB0cnVlLCBkaWRFcnIgPSBmYWxzZSwgZXJyOyByZXR1cm4geyBzOiBmdW5jdGlvbiBzKCkgeyBpdCA9IGl0LmNhbGwobyk7IH0sIG46IGZ1bmN0aW9uIG4oKSB7IHZhciBzdGVwID0gaXQubmV4dCgpOyBub3JtYWxDb21wbGV0aW9uID0gc3RlcC5kb25lOyByZXR1cm4gc3RlcDsgfSwgZTogZnVuY3Rpb24gZShfZTIpIHsgZGlkRXJyID0gdHJ1ZTsgZXJyID0gX2UyOyB9LCBmOiBmdW5jdGlvbiBmKCkgeyB0cnkgeyBpZiAoIW5vcm1hbENvbXBsZXRpb24gJiYgaXRbXCJyZXR1cm5cIl0gIT0gbnVsbCkgaXRbXCJyZXR1cm5cIl0oKTsgfSBmaW5hbGx5IHsgaWYgKGRpZEVycikgdGhyb3cgZXJyOyB9IH0gfTsgfVxuXG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IH1cblxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgeyBhcnIyW2ldID0gYXJyW2ldOyB9IHJldHVybiBhcnIyOyB9XG5cbnZhciBUZXh0VHJhbnNmb3JtcyA9IHtcbiAgLyoqXHJcbiAgICogRGVsZXRlIGNvbnRlbnQgaW4gdGhlIGVkaXRvci5cclxuICAgKi9cbiAgXCJkZWxldGVcIjogZnVuY3Rpb24gX2RlbGV0ZShlZGl0b3IpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgRWRpdG9yLndpdGhvdXROb3JtYWxpemluZyhlZGl0b3IsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfb3B0aW9ucyRyZXZlcnNlID0gb3B0aW9ucy5yZXZlcnNlLFxuICAgICAgICAgIHJldmVyc2UgPSBfb3B0aW9ucyRyZXZlcnNlID09PSB2b2lkIDAgPyBmYWxzZSA6IF9vcHRpb25zJHJldmVyc2UsXG4gICAgICAgICAgX29wdGlvbnMkdW5pdCA9IG9wdGlvbnMudW5pdCxcbiAgICAgICAgICB1bml0ID0gX29wdGlvbnMkdW5pdCA9PT0gdm9pZCAwID8gJ2NoYXJhY3RlcicgOiBfb3B0aW9ucyR1bml0LFxuICAgICAgICAgIF9vcHRpb25zJGRpc3RhbmNlID0gb3B0aW9ucy5kaXN0YW5jZSxcbiAgICAgICAgICBkaXN0YW5jZSA9IF9vcHRpb25zJGRpc3RhbmNlID09PSB2b2lkIDAgPyAxIDogX29wdGlvbnMkZGlzdGFuY2UsXG4gICAgICAgICAgX29wdGlvbnMkdm9pZHMgPSBvcHRpb25zLnZvaWRzLFxuICAgICAgICAgIHZvaWRzID0gX29wdGlvbnMkdm9pZHMgPT09IHZvaWQgMCA/IGZhbHNlIDogX29wdGlvbnMkdm9pZHM7XG4gICAgICB2YXIgX29wdGlvbnMkYXQgPSBvcHRpb25zLmF0LFxuICAgICAgICAgIGF0ID0gX29wdGlvbnMkYXQgPT09IHZvaWQgMCA/IGVkaXRvci5zZWxlY3Rpb24gOiBfb3B0aW9ucyRhdCxcbiAgICAgICAgICBfb3B0aW9ucyRoYW5naW5nID0gb3B0aW9ucy5oYW5naW5nLFxuICAgICAgICAgIGhhbmdpbmcgPSBfb3B0aW9ucyRoYW5naW5nID09PSB2b2lkIDAgPyBmYWxzZSA6IF9vcHRpb25zJGhhbmdpbmc7XG5cbiAgICAgIGlmICghYXQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgaXNDb2xsYXBzZWQgPSBmYWxzZTtcblxuICAgICAgaWYgKFJhbmdlLmlzUmFuZ2UoYXQpICYmIFJhbmdlLmlzQ29sbGFwc2VkKGF0KSkge1xuICAgICAgICBpc0NvbGxhcHNlZCA9IHRydWU7XG4gICAgICAgIGF0ID0gYXQuYW5jaG9yO1xuICAgICAgfVxuXG4gICAgICBpZiAoUG9pbnQuaXNQb2ludChhdCkpIHtcbiAgICAgICAgdmFyIGZ1cnRoZXN0Vm9pZCA9IEVkaXRvcltcInZvaWRcIl0oZWRpdG9yLCB7XG4gICAgICAgICAgYXQ6IGF0LFxuICAgICAgICAgIG1vZGU6ICdoaWdoZXN0J1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoIXZvaWRzICYmIGZ1cnRoZXN0Vm9pZCkge1xuICAgICAgICAgIHZhciBfZnVydGhlc3RWb2lkID0gX3NsaWNlZFRvQXJyYXkoZnVydGhlc3RWb2lkLCAyKSxcbiAgICAgICAgICAgICAgdm9pZFBhdGggPSBfZnVydGhlc3RWb2lkWzFdO1xuXG4gICAgICAgICAgYXQgPSB2b2lkUGF0aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgb3B0cyA9IHtcbiAgICAgICAgICAgIHVuaXQ6IHVuaXQsXG4gICAgICAgICAgICBkaXN0YW5jZTogZGlzdGFuY2VcbiAgICAgICAgICB9O1xuICAgICAgICAgIHZhciB0YXJnZXQgPSByZXZlcnNlID8gRWRpdG9yLmJlZm9yZShlZGl0b3IsIGF0LCBvcHRzKSB8fCBFZGl0b3Iuc3RhcnQoZWRpdG9yLCBbXSkgOiBFZGl0b3IuYWZ0ZXIoZWRpdG9yLCBhdCwgb3B0cykgfHwgRWRpdG9yLmVuZChlZGl0b3IsIFtdKTtcbiAgICAgICAgICBhdCA9IHtcbiAgICAgICAgICAgIGFuY2hvcjogYXQsXG4gICAgICAgICAgICBmb2N1czogdGFyZ2V0XG4gICAgICAgICAgfTtcbiAgICAgICAgICBoYW5naW5nID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoUGF0aC5pc1BhdGgoYXQpKSB7XG4gICAgICAgIFRyYW5zZm9ybXMucmVtb3ZlTm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgYXQ6IGF0LFxuICAgICAgICAgIHZvaWRzOiB2b2lkc1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoUmFuZ2UuaXNDb2xsYXBzZWQoYXQpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKCFoYW5naW5nKSB7XG4gICAgICAgIHZhciBfUmFuZ2UkZWRnZXMgPSBSYW5nZS5lZGdlcyhhdCksXG4gICAgICAgICAgICBfUmFuZ2UkZWRnZXMyID0gX3NsaWNlZFRvQXJyYXkoX1JhbmdlJGVkZ2VzLCAyKSxcbiAgICAgICAgICAgIF9lbmQgPSBfUmFuZ2UkZWRnZXMyWzFdO1xuXG4gICAgICAgIHZhciBlbmRPZkRvYyA9IEVkaXRvci5lbmQoZWRpdG9yLCBbXSk7XG5cbiAgICAgICAgaWYgKCFQb2ludC5lcXVhbHMoX2VuZCwgZW5kT2ZEb2MpKSB7XG4gICAgICAgICAgYXQgPSBFZGl0b3IudW5oYW5nUmFuZ2UoZWRpdG9yLCBhdCwge1xuICAgICAgICAgICAgdm9pZHM6IHZvaWRzXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIF9SYW5nZSRlZGdlczMgPSBSYW5nZS5lZGdlcyhhdCksXG4gICAgICAgICAgX1JhbmdlJGVkZ2VzNCA9IF9zbGljZWRUb0FycmF5KF9SYW5nZSRlZGdlczMsIDIpLFxuICAgICAgICAgIHN0YXJ0ID0gX1JhbmdlJGVkZ2VzNFswXSxcbiAgICAgICAgICBlbmQgPSBfUmFuZ2UkZWRnZXM0WzFdO1xuXG4gICAgICB2YXIgc3RhcnRCbG9jayA9IEVkaXRvci5hYm92ZShlZGl0b3IsIHtcbiAgICAgICAgbWF0Y2g6IGZ1bmN0aW9uIG1hdGNoKG4pIHtcbiAgICAgICAgICByZXR1cm4gRWxlbWVudC5pc0VsZW1lbnQobikgJiYgRWRpdG9yLmlzQmxvY2soZWRpdG9yLCBuKTtcbiAgICAgICAgfSxcbiAgICAgICAgYXQ6IHN0YXJ0LFxuICAgICAgICB2b2lkczogdm9pZHNcbiAgICAgIH0pO1xuICAgICAgdmFyIGVuZEJsb2NrID0gRWRpdG9yLmFib3ZlKGVkaXRvciwge1xuICAgICAgICBtYXRjaDogZnVuY3Rpb24gbWF0Y2gobikge1xuICAgICAgICAgIHJldHVybiBFbGVtZW50LmlzRWxlbWVudChuKSAmJiBFZGl0b3IuaXNCbG9jayhlZGl0b3IsIG4pO1xuICAgICAgICB9LFxuICAgICAgICBhdDogZW5kLFxuICAgICAgICB2b2lkczogdm9pZHNcbiAgICAgIH0pO1xuICAgICAgdmFyIGlzQWNyb3NzQmxvY2tzID0gc3RhcnRCbG9jayAmJiBlbmRCbG9jayAmJiAhUGF0aC5lcXVhbHMoc3RhcnRCbG9ja1sxXSwgZW5kQmxvY2tbMV0pO1xuICAgICAgdmFyIGlzU2luZ2xlVGV4dCA9IFBhdGguZXF1YWxzKHN0YXJ0LnBhdGgsIGVuZC5wYXRoKTtcbiAgICAgIHZhciBzdGFydFZvaWQgPSB2b2lkcyA/IG51bGwgOiBFZGl0b3JbXCJ2b2lkXCJdKGVkaXRvciwge1xuICAgICAgICBhdDogc3RhcnQsXG4gICAgICAgIG1vZGU6ICdoaWdoZXN0J1xuICAgICAgfSk7XG4gICAgICB2YXIgZW5kVm9pZCA9IHZvaWRzID8gbnVsbCA6IEVkaXRvcltcInZvaWRcIl0oZWRpdG9yLCB7XG4gICAgICAgIGF0OiBlbmQsXG4gICAgICAgIG1vZGU6ICdoaWdoZXN0J1xuICAgICAgfSk7IC8vIElmIHRoZSBzdGFydCBvciBlbmQgcG9pbnRzIGFyZSBpbnNpZGUgYW4gaW5saW5lIHZvaWQsIG51ZGdlIHRoZW0gb3V0LlxuXG4gICAgICBpZiAoc3RhcnRWb2lkKSB7XG4gICAgICAgIHZhciBiZWZvcmUgPSBFZGl0b3IuYmVmb3JlKGVkaXRvciwgc3RhcnQpO1xuXG4gICAgICAgIGlmIChiZWZvcmUgJiYgc3RhcnRCbG9jayAmJiBQYXRoLmlzQW5jZXN0b3Ioc3RhcnRCbG9ja1sxXSwgYmVmb3JlLnBhdGgpKSB7XG4gICAgICAgICAgc3RhcnQgPSBiZWZvcmU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGVuZFZvaWQpIHtcbiAgICAgICAgdmFyIGFmdGVyID0gRWRpdG9yLmFmdGVyKGVkaXRvciwgZW5kKTtcblxuICAgICAgICBpZiAoYWZ0ZXIgJiYgZW5kQmxvY2sgJiYgUGF0aC5pc0FuY2VzdG9yKGVuZEJsb2NrWzFdLCBhZnRlci5wYXRoKSkge1xuICAgICAgICAgIGVuZCA9IGFmdGVyO1xuICAgICAgICB9XG4gICAgICB9IC8vIEdldCB0aGUgaGlnaGVzdCBub2RlcyB0aGF0IGFyZSBjb21wbGV0ZWx5IGluc2lkZSB0aGUgcmFuZ2UsIGFzIHdlbGwgYXNcbiAgICAgIC8vIHRoZSBzdGFydCBhbmQgZW5kIG5vZGVzLlxuXG5cbiAgICAgIHZhciBtYXRjaGVzID0gW107XG4gICAgICB2YXIgbGFzdFBhdGg7XG5cbiAgICAgIHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihFZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgICAgIGF0OiBhdCxcbiAgICAgICAgdm9pZHM6IHZvaWRzXG4gICAgICB9KSksXG4gICAgICAgICAgX3N0ZXA7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoX2l0ZXJhdG9yLnMoKTsgIShfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgdmFyIGVudHJ5ID0gX3N0ZXAudmFsdWU7XG5cbiAgICAgICAgICB2YXIgX2VudHJ5ID0gX3NsaWNlZFRvQXJyYXkoZW50cnksIDIpLFxuICAgICAgICAgICAgICBfbm9kZTIgPSBfZW50cnlbMF0sXG4gICAgICAgICAgICAgIF9wYXRoMiA9IF9lbnRyeVsxXTtcblxuICAgICAgICAgIGlmIChsYXN0UGF0aCAmJiBQYXRoLmNvbXBhcmUoX3BhdGgyLCBsYXN0UGF0aCkgPT09IDApIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghdm9pZHMgJiYgRWxlbWVudC5pc0VsZW1lbnQoX25vZGUyKSAmJiBFZGl0b3IuaXNWb2lkKGVkaXRvciwgX25vZGUyKSB8fCAhUGF0aC5pc0NvbW1vbihfcGF0aDIsIHN0YXJ0LnBhdGgpICYmICFQYXRoLmlzQ29tbW9uKF9wYXRoMiwgZW5kLnBhdGgpKSB7XG4gICAgICAgICAgICBtYXRjaGVzLnB1c2goZW50cnkpO1xuICAgICAgICAgICAgbGFzdFBhdGggPSBfcGF0aDI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2l0ZXJhdG9yLmUoZXJyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIF9pdGVyYXRvci5mKCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBwYXRoUmVmcyA9IEFycmF5LmZyb20obWF0Y2hlcywgZnVuY3Rpb24gKF9yZWYpIHtcbiAgICAgICAgdmFyIF9yZWYyID0gX3NsaWNlZFRvQXJyYXkoX3JlZiwgMiksXG4gICAgICAgICAgICBwID0gX3JlZjJbMV07XG5cbiAgICAgICAgcmV0dXJuIEVkaXRvci5wYXRoUmVmKGVkaXRvciwgcCk7XG4gICAgICB9KTtcbiAgICAgIHZhciBzdGFydFJlZiA9IEVkaXRvci5wb2ludFJlZihlZGl0b3IsIHN0YXJ0KTtcbiAgICAgIHZhciBlbmRSZWYgPSBFZGl0b3IucG9pbnRSZWYoZWRpdG9yLCBlbmQpO1xuICAgICAgdmFyIHJlbW92ZWRUZXh0ID0gJyc7XG5cbiAgICAgIGlmICghaXNTaW5nbGVUZXh0ICYmICFzdGFydFZvaWQpIHtcbiAgICAgICAgdmFyIF9wb2ludCA9IHN0YXJ0UmVmLmN1cnJlbnQ7XG5cbiAgICAgICAgdmFyIF9FZGl0b3IkbGVhZiA9IEVkaXRvci5sZWFmKGVkaXRvciwgX3BvaW50KSxcbiAgICAgICAgICAgIF9FZGl0b3IkbGVhZjIgPSBfc2xpY2VkVG9BcnJheShfRWRpdG9yJGxlYWYsIDEpLFxuICAgICAgICAgICAgbm9kZSA9IF9FZGl0b3IkbGVhZjJbMF07XG5cbiAgICAgICAgdmFyIHBhdGggPSBfcG9pbnQucGF0aDtcbiAgICAgICAgdmFyIF9zdGFydCA9IHN0YXJ0LFxuICAgICAgICAgICAgb2Zmc2V0ID0gX3N0YXJ0Lm9mZnNldDtcbiAgICAgICAgdmFyIHRleHQgPSBub2RlLnRleHQuc2xpY2Uob2Zmc2V0KTtcblxuICAgICAgICBpZiAodGV4dC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgZWRpdG9yLmFwcGx5KHtcbiAgICAgICAgICAgIHR5cGU6ICdyZW1vdmVfdGV4dCcsXG4gICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgb2Zmc2V0OiBvZmZzZXQsXG4gICAgICAgICAgICB0ZXh0OiB0ZXh0XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmVtb3ZlZFRleHQgPSB0ZXh0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHBhdGhSZWZzLnJldmVyc2UoKS5tYXAoZnVuY3Rpb24gKHIpIHtcbiAgICAgICAgcmV0dXJuIHIudW5yZWYoKTtcbiAgICAgIH0pLmZpbHRlcihmdW5jdGlvbiAocikge1xuICAgICAgICByZXR1cm4gciAhPT0gbnVsbDtcbiAgICAgIH0pLmZvckVhY2goZnVuY3Rpb24gKHApIHtcbiAgICAgICAgcmV0dXJuIFRyYW5zZm9ybXMucmVtb3ZlTm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgYXQ6IHAsXG4gICAgICAgICAgdm9pZHM6IHZvaWRzXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICAgIGlmICghZW5kVm9pZCkge1xuICAgICAgICB2YXIgX3BvaW50MiA9IGVuZFJlZi5jdXJyZW50O1xuXG4gICAgICAgIHZhciBfRWRpdG9yJGxlYWYzID0gRWRpdG9yLmxlYWYoZWRpdG9yLCBfcG9pbnQyKSxcbiAgICAgICAgICAgIF9FZGl0b3IkbGVhZjQgPSBfc2xpY2VkVG9BcnJheShfRWRpdG9yJGxlYWYzLCAxKSxcbiAgICAgICAgICAgIF9ub2RlID0gX0VkaXRvciRsZWFmNFswXTtcblxuICAgICAgICB2YXIgX3BhdGggPSBfcG9pbnQyLnBhdGg7XG5cbiAgICAgICAgdmFyIF9vZmZzZXQgPSBpc1NpbmdsZVRleHQgPyBzdGFydC5vZmZzZXQgOiAwO1xuXG4gICAgICAgIHZhciBfdGV4dCA9IF9ub2RlLnRleHQuc2xpY2UoX29mZnNldCwgZW5kLm9mZnNldCk7XG5cbiAgICAgICAgaWYgKF90ZXh0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBlZGl0b3IuYXBwbHkoe1xuICAgICAgICAgICAgdHlwZTogJ3JlbW92ZV90ZXh0JyxcbiAgICAgICAgICAgIHBhdGg6IF9wYXRoLFxuICAgICAgICAgICAgb2Zmc2V0OiBfb2Zmc2V0LFxuICAgICAgICAgICAgdGV4dDogX3RleHRcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZW1vdmVkVGV4dCA9IF90ZXh0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghaXNTaW5nbGVUZXh0ICYmIGlzQWNyb3NzQmxvY2tzICYmIGVuZFJlZi5jdXJyZW50ICYmIHN0YXJ0UmVmLmN1cnJlbnQpIHtcbiAgICAgICAgVHJhbnNmb3Jtcy5tZXJnZU5vZGVzKGVkaXRvciwge1xuICAgICAgICAgIGF0OiBlbmRSZWYuY3VycmVudCxcbiAgICAgICAgICBoYW5naW5nOiB0cnVlLFxuICAgICAgICAgIHZvaWRzOiB2b2lkc1xuICAgICAgICB9KTtcbiAgICAgIH0gLy8gRm9yIFRoYWkgc2NyaXB0LCBkZWxldGluZyBOIGNoYXJhY3RlcihzKSBiYWNrd2FyZCBzaG91bGQgZGVsZXRlXG4gICAgICAvLyBOIGNvZGUgcG9pbnQocykgaW5zdGVhZCBvZiBhbiBlbnRpcmUgZ3JhcGhlbWUgY2x1c3Rlci5cbiAgICAgIC8vIFRoZXJlZm9yZSwgdGhlIHJlbWFpbmluZyBjb2RlIHBvaW50cyBzaG91bGQgYmUgaW5zZXJ0ZWQgYmFjay5cblxuXG4gICAgICBpZiAoaXNDb2xsYXBzZWQgJiYgcmV2ZXJzZSAmJiB1bml0ID09PSAnY2hhcmFjdGVyJyAmJiByZW1vdmVkVGV4dC5sZW5ndGggPiAxICYmIHJlbW92ZWRUZXh0Lm1hdGNoKC9bXFx1MEUwMC1cXHUwRTdGXSsvKSkge1xuICAgICAgICBUcmFuc2Zvcm1zLmluc2VydFRleHQoZWRpdG9yLCByZW1vdmVkVGV4dC5zbGljZSgwLCByZW1vdmVkVGV4dC5sZW5ndGggLSBkaXN0YW5jZSkpO1xuICAgICAgfVxuXG4gICAgICB2YXIgc3RhcnRVbnJlZiA9IHN0YXJ0UmVmLnVucmVmKCk7XG4gICAgICB2YXIgZW5kVW5yZWYgPSBlbmRSZWYudW5yZWYoKTtcbiAgICAgIHZhciBwb2ludCA9IHJldmVyc2UgPyBzdGFydFVucmVmIHx8IGVuZFVucmVmIDogZW5kVW5yZWYgfHwgc3RhcnRVbnJlZjtcblxuICAgICAgaWYgKG9wdGlvbnMuYXQgPT0gbnVsbCAmJiBwb2ludCkge1xuICAgICAgICBUcmFuc2Zvcm1zLnNlbGVjdChlZGl0b3IsIHBvaW50KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcblxuICAvKipcclxuICAgKiBJbnNlcnQgYSBmcmFnbWVudCBhdCBhIHNwZWNpZmljIGxvY2F0aW9uIGluIHRoZSBlZGl0b3IuXHJcbiAgICovXG4gIGluc2VydEZyYWdtZW50OiBmdW5jdGlvbiBpbnNlcnRGcmFnbWVudChlZGl0b3IsIGZyYWdtZW50KSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIEVkaXRvci53aXRob3V0Tm9ybWFsaXppbmcoZWRpdG9yLCBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX29wdGlvbnMkaGFuZ2luZzIgPSBvcHRpb25zLmhhbmdpbmcsXG4gICAgICAgICAgaGFuZ2luZyA9IF9vcHRpb25zJGhhbmdpbmcyID09PSB2b2lkIDAgPyBmYWxzZSA6IF9vcHRpb25zJGhhbmdpbmcyLFxuICAgICAgICAgIF9vcHRpb25zJHZvaWRzMiA9IG9wdGlvbnMudm9pZHMsXG4gICAgICAgICAgdm9pZHMgPSBfb3B0aW9ucyR2b2lkczIgPT09IHZvaWQgMCA/IGZhbHNlIDogX29wdGlvbnMkdm9pZHMyO1xuICAgICAgdmFyIF9vcHRpb25zJGF0MiA9IG9wdGlvbnMuYXQsXG4gICAgICAgICAgYXQgPSBfb3B0aW9ucyRhdDIgPT09IHZvaWQgMCA/IGVkaXRvci5zZWxlY3Rpb24gOiBfb3B0aW9ucyRhdDI7XG5cbiAgICAgIGlmICghZnJhZ21lbnQubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKCFhdCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2UgaWYgKFJhbmdlLmlzUmFuZ2UoYXQpKSB7XG4gICAgICAgIGlmICghaGFuZ2luZykge1xuICAgICAgICAgIGF0ID0gRWRpdG9yLnVuaGFuZ1JhbmdlKGVkaXRvciwgYXQsIHtcbiAgICAgICAgICAgIHZvaWRzOiB2b2lkc1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKFJhbmdlLmlzQ29sbGFwc2VkKGF0KSkge1xuICAgICAgICAgIGF0ID0gYXQuYW5jaG9yO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBfUmFuZ2UkZWRnZXM1ID0gUmFuZ2UuZWRnZXMoYXQpLFxuICAgICAgICAgICAgICBfUmFuZ2UkZWRnZXM2ID0gX3NsaWNlZFRvQXJyYXkoX1JhbmdlJGVkZ2VzNSwgMiksXG4gICAgICAgICAgICAgIGVuZCA9IF9SYW5nZSRlZGdlczZbMV07XG5cbiAgICAgICAgICBpZiAoIXZvaWRzICYmIEVkaXRvcltcInZvaWRcIl0oZWRpdG9yLCB7XG4gICAgICAgICAgICBhdDogZW5kXG4gICAgICAgICAgfSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgcG9pbnRSZWYgPSBFZGl0b3IucG9pbnRSZWYoZWRpdG9yLCBlbmQpO1xuICAgICAgICAgIFRyYW5zZm9ybXNbXCJkZWxldGVcIl0oZWRpdG9yLCB7XG4gICAgICAgICAgICBhdDogYXRcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBhdCA9IHBvaW50UmVmLnVucmVmKCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoUGF0aC5pc1BhdGgoYXQpKSB7XG4gICAgICAgIGF0ID0gRWRpdG9yLnN0YXJ0KGVkaXRvciwgYXQpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXZvaWRzICYmIEVkaXRvcltcInZvaWRcIl0oZWRpdG9yLCB7XG4gICAgICAgIGF0OiBhdFxuICAgICAgfSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyBJZiB0aGUgaW5zZXJ0IHBvaW50IGlzIGF0IHRoZSBlZGdlIG9mIGFuIGlubGluZSBub2RlLCBtb3ZlIGl0IG91dHNpZGVcbiAgICAgIC8vIGluc3RlYWQgc2luY2UgaXQgd2lsbCBuZWVkIHRvIGJlIHNwbGl0IG90aGVyd2lzZS5cblxuXG4gICAgICB2YXIgaW5saW5lRWxlbWVudE1hdGNoID0gRWRpdG9yLmFib3ZlKGVkaXRvciwge1xuICAgICAgICBhdDogYXQsXG4gICAgICAgIG1hdGNoOiBmdW5jdGlvbiBtYXRjaChuKSB7XG4gICAgICAgICAgcmV0dXJuIEVsZW1lbnQuaXNFbGVtZW50KG4pICYmIEVkaXRvci5pc0lubGluZShlZGl0b3IsIG4pO1xuICAgICAgICB9LFxuICAgICAgICBtb2RlOiAnaGlnaGVzdCcsXG4gICAgICAgIHZvaWRzOiB2b2lkc1xuICAgICAgfSk7XG5cbiAgICAgIGlmIChpbmxpbmVFbGVtZW50TWF0Y2gpIHtcbiAgICAgICAgdmFyIF9pbmxpbmVFbGVtZW50TWF0Y2ggPSBfc2xpY2VkVG9BcnJheShpbmxpbmVFbGVtZW50TWF0Y2gsIDIpLFxuICAgICAgICAgICAgX2lubGluZVBhdGggPSBfaW5saW5lRWxlbWVudE1hdGNoWzFdO1xuXG4gICAgICAgIGlmIChFZGl0b3IuaXNFbmQoZWRpdG9yLCBhdCwgX2lubGluZVBhdGgpKSB7XG4gICAgICAgICAgdmFyIGFmdGVyID0gRWRpdG9yLmFmdGVyKGVkaXRvciwgX2lubGluZVBhdGgpO1xuICAgICAgICAgIGF0ID0gYWZ0ZXI7XG4gICAgICAgIH0gZWxzZSBpZiAoRWRpdG9yLmlzU3RhcnQoZWRpdG9yLCBhdCwgX2lubGluZVBhdGgpKSB7XG4gICAgICAgICAgdmFyIGJlZm9yZSA9IEVkaXRvci5iZWZvcmUoZWRpdG9yLCBfaW5saW5lUGF0aCk7XG4gICAgICAgICAgYXQgPSBiZWZvcmU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGJsb2NrTWF0Y2ggPSBFZGl0b3IuYWJvdmUoZWRpdG9yLCB7XG4gICAgICAgIG1hdGNoOiBmdW5jdGlvbiBtYXRjaChuKSB7XG4gICAgICAgICAgcmV0dXJuIEVsZW1lbnQuaXNFbGVtZW50KG4pICYmIEVkaXRvci5pc0Jsb2NrKGVkaXRvciwgbik7XG4gICAgICAgIH0sXG4gICAgICAgIGF0OiBhdCxcbiAgICAgICAgdm9pZHM6IHZvaWRzXG4gICAgICB9KTtcblxuICAgICAgdmFyIF9ibG9ja01hdGNoID0gX3NsaWNlZFRvQXJyYXkoYmxvY2tNYXRjaCwgMiksXG4gICAgICAgICAgYmxvY2tQYXRoID0gX2Jsb2NrTWF0Y2hbMV07XG5cbiAgICAgIHZhciBpc0Jsb2NrU3RhcnQgPSBFZGl0b3IuaXNTdGFydChlZGl0b3IsIGF0LCBibG9ja1BhdGgpO1xuICAgICAgdmFyIGlzQmxvY2tFbmQgPSBFZGl0b3IuaXNFbmQoZWRpdG9yLCBhdCwgYmxvY2tQYXRoKTtcbiAgICAgIHZhciBpc0Jsb2NrRW1wdHkgPSBpc0Jsb2NrU3RhcnQgJiYgaXNCbG9ja0VuZDtcbiAgICAgIHZhciBtZXJnZVN0YXJ0ID0gIWlzQmxvY2tTdGFydCB8fCBpc0Jsb2NrU3RhcnQgJiYgaXNCbG9ja0VuZDtcbiAgICAgIHZhciBtZXJnZUVuZCA9ICFpc0Jsb2NrRW5kO1xuXG4gICAgICB2YXIgX05vZGUkZmlyc3QgPSBOb2RlLmZpcnN0KHtcbiAgICAgICAgY2hpbGRyZW46IGZyYWdtZW50XG4gICAgICB9LCBbXSksXG4gICAgICAgICAgX05vZGUkZmlyc3QyID0gX3NsaWNlZFRvQXJyYXkoX05vZGUkZmlyc3QsIDIpLFxuICAgICAgICAgIGZpcnN0UGF0aCA9IF9Ob2RlJGZpcnN0MlsxXTtcblxuICAgICAgdmFyIF9Ob2RlJGxhc3QgPSBOb2RlLmxhc3Qoe1xuICAgICAgICBjaGlsZHJlbjogZnJhZ21lbnRcbiAgICAgIH0sIFtdKSxcbiAgICAgICAgICBfTm9kZSRsYXN0MiA9IF9zbGljZWRUb0FycmF5KF9Ob2RlJGxhc3QsIDIpLFxuICAgICAgICAgIGxhc3RQYXRoID0gX05vZGUkbGFzdDJbMV07XG5cbiAgICAgIHZhciBtYXRjaGVzID0gW107XG5cbiAgICAgIHZhciBtYXRjaGVyID0gZnVuY3Rpb24gbWF0Y2hlcihfcmVmMykge1xuICAgICAgICB2YXIgX3JlZjQgPSBfc2xpY2VkVG9BcnJheShfcmVmMywgMiksXG4gICAgICAgICAgICBuID0gX3JlZjRbMF0sXG4gICAgICAgICAgICBwID0gX3JlZjRbMV07XG5cbiAgICAgICAgdmFyIGlzUm9vdCA9IHAubGVuZ3RoID09PSAwO1xuXG4gICAgICAgIGlmIChpc1Jvb3QpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNCbG9ja0VtcHR5KSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWVyZ2VTdGFydCAmJiBQYXRoLmlzQW5jZXN0b3IocCwgZmlyc3RQYXRoKSAmJiBFbGVtZW50LmlzRWxlbWVudChuKSAmJiAhZWRpdG9yLmlzVm9pZChuKSAmJiAhZWRpdG9yLmlzSW5saW5lKG4pKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1lcmdlRW5kICYmIFBhdGguaXNBbmNlc3RvcihwLCBsYXN0UGF0aCkgJiYgRWxlbWVudC5pc0VsZW1lbnQobikgJiYgIWVkaXRvci5pc1ZvaWQobikgJiYgIWVkaXRvci5pc0lubGluZShuKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfTtcblxuICAgICAgdmFyIF9pdGVyYXRvcjIgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihOb2RlLm5vZGVzKHtcbiAgICAgICAgY2hpbGRyZW46IGZyYWdtZW50XG4gICAgICB9LCB7XG4gICAgICAgIHBhc3M6IG1hdGNoZXJcbiAgICAgIH0pKSxcbiAgICAgICAgICBfc3RlcDI7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoX2l0ZXJhdG9yMi5zKCk7ICEoX3N0ZXAyID0gX2l0ZXJhdG9yMi5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgdmFyIGVudHJ5ID0gX3N0ZXAyLnZhbHVlO1xuXG4gICAgICAgICAgaWYgKG1hdGNoZXIoZW50cnkpKSB7XG4gICAgICAgICAgICBtYXRjaGVzLnB1c2goZW50cnkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9pdGVyYXRvcjIuZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yMi5mKCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBzdGFydHMgPSBbXTtcbiAgICAgIHZhciBtaWRkbGVzID0gW107XG4gICAgICB2YXIgZW5kcyA9IFtdO1xuICAgICAgdmFyIHN0YXJ0aW5nID0gdHJ1ZTtcbiAgICAgIHZhciBoYXNCbG9ja3MgPSBmYWxzZTtcblxuICAgICAgZm9yICh2YXIgX2kgPSAwLCBfbWF0Y2hlcyA9IG1hdGNoZXM7IF9pIDwgX21hdGNoZXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciBfbWF0Y2hlcyRfaSA9IF9zbGljZWRUb0FycmF5KF9tYXRjaGVzW19pXSwgMSksXG4gICAgICAgICAgICBub2RlID0gX21hdGNoZXMkX2lbMF07XG5cbiAgICAgICAgaWYgKEVsZW1lbnQuaXNFbGVtZW50KG5vZGUpICYmICFlZGl0b3IuaXNJbmxpbmUobm9kZSkpIHtcbiAgICAgICAgICBzdGFydGluZyA9IGZhbHNlO1xuICAgICAgICAgIGhhc0Jsb2NrcyA9IHRydWU7XG4gICAgICAgICAgbWlkZGxlcy5wdXNoKG5vZGUpO1xuICAgICAgICB9IGVsc2UgaWYgKHN0YXJ0aW5nKSB7XG4gICAgICAgICAgc3RhcnRzLnB1c2gobm9kZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZW5kcy5wdXNoKG5vZGUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBfRWRpdG9yJG5vZGVzID0gRWRpdG9yLm5vZGVzKGVkaXRvciwge1xuICAgICAgICBhdDogYXQsXG4gICAgICAgIG1hdGNoOiBmdW5jdGlvbiBtYXRjaChuKSB7XG4gICAgICAgICAgcmV0dXJuIFRleHQuaXNUZXh0KG4pIHx8IEVkaXRvci5pc0lubGluZShlZGl0b3IsIG4pO1xuICAgICAgICB9LFxuICAgICAgICBtb2RlOiAnaGlnaGVzdCcsXG4gICAgICAgIHZvaWRzOiB2b2lkc1xuICAgICAgfSksXG4gICAgICAgICAgX0VkaXRvciRub2RlczIgPSBfc2xpY2VkVG9BcnJheShfRWRpdG9yJG5vZGVzLCAxKSxcbiAgICAgICAgICBpbmxpbmVNYXRjaCA9IF9FZGl0b3Ikbm9kZXMyWzBdO1xuXG4gICAgICB2YXIgX2lubGluZU1hdGNoID0gX3NsaWNlZFRvQXJyYXkoaW5saW5lTWF0Y2gsIDIpLFxuICAgICAgICAgIGlubGluZVBhdGggPSBfaW5saW5lTWF0Y2hbMV07XG5cbiAgICAgIHZhciBpc0lubGluZVN0YXJ0ID0gRWRpdG9yLmlzU3RhcnQoZWRpdG9yLCBhdCwgaW5saW5lUGF0aCk7XG4gICAgICB2YXIgaXNJbmxpbmVFbmQgPSBFZGl0b3IuaXNFbmQoZWRpdG9yLCBhdCwgaW5saW5lUGF0aCk7XG4gICAgICB2YXIgbWlkZGxlUmVmID0gRWRpdG9yLnBhdGhSZWYoZWRpdG9yLCBpc0Jsb2NrRW5kICYmICFlbmRzLmxlbmd0aCA/IFBhdGgubmV4dChibG9ja1BhdGgpIDogYmxvY2tQYXRoKTtcbiAgICAgIHZhciBlbmRSZWYgPSBFZGl0b3IucGF0aFJlZihlZGl0b3IsIGlzSW5saW5lRW5kID8gUGF0aC5uZXh0KGlubGluZVBhdGgpIDogaW5saW5lUGF0aCk7XG4gICAgICBUcmFuc2Zvcm1zLnNwbGl0Tm9kZXMoZWRpdG9yLCB7XG4gICAgICAgIGF0OiBhdCxcbiAgICAgICAgbWF0Y2g6IGZ1bmN0aW9uIG1hdGNoKG4pIHtcbiAgICAgICAgICByZXR1cm4gaGFzQmxvY2tzID8gRWxlbWVudC5pc0VsZW1lbnQobikgJiYgRWRpdG9yLmlzQmxvY2soZWRpdG9yLCBuKSA6IFRleHQuaXNUZXh0KG4pIHx8IEVkaXRvci5pc0lubGluZShlZGl0b3IsIG4pO1xuICAgICAgICB9LFxuICAgICAgICBtb2RlOiBoYXNCbG9ja3MgPyAnbG93ZXN0JyA6ICdoaWdoZXN0JyxcbiAgICAgICAgYWx3YXlzOiBoYXNCbG9ja3MgJiYgKCFpc0Jsb2NrU3RhcnQgfHwgc3RhcnRzLmxlbmd0aCA+IDApICYmICghaXNCbG9ja0VuZCB8fCBlbmRzLmxlbmd0aCA+IDApLFxuICAgICAgICB2b2lkczogdm9pZHNcbiAgICAgIH0pO1xuICAgICAgdmFyIHN0YXJ0UmVmID0gRWRpdG9yLnBhdGhSZWYoZWRpdG9yLCAhaXNJbmxpbmVTdGFydCB8fCBpc0lubGluZVN0YXJ0ICYmIGlzSW5saW5lRW5kID8gUGF0aC5uZXh0KGlubGluZVBhdGgpIDogaW5saW5lUGF0aCk7XG4gICAgICBUcmFuc2Zvcm1zLmluc2VydE5vZGVzKGVkaXRvciwgc3RhcnRzLCB7XG4gICAgICAgIGF0OiBzdGFydFJlZi5jdXJyZW50LFxuICAgICAgICBtYXRjaDogZnVuY3Rpb24gbWF0Y2gobikge1xuICAgICAgICAgIHJldHVybiBUZXh0LmlzVGV4dChuKSB8fCBFZGl0b3IuaXNJbmxpbmUoZWRpdG9yLCBuKTtcbiAgICAgICAgfSxcbiAgICAgICAgbW9kZTogJ2hpZ2hlc3QnLFxuICAgICAgICB2b2lkczogdm9pZHNcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoaXNCbG9ja0VtcHR5ICYmICFzdGFydHMubGVuZ3RoICYmIG1pZGRsZXMubGVuZ3RoICYmICFlbmRzLmxlbmd0aCkge1xuICAgICAgICBUcmFuc2Zvcm1zW1wiZGVsZXRlXCJdKGVkaXRvciwge1xuICAgICAgICAgIGF0OiBibG9ja1BhdGgsXG4gICAgICAgICAgdm9pZHM6IHZvaWRzXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBUcmFuc2Zvcm1zLmluc2VydE5vZGVzKGVkaXRvciwgbWlkZGxlcywge1xuICAgICAgICBhdDogbWlkZGxlUmVmLmN1cnJlbnQsXG4gICAgICAgIG1hdGNoOiBmdW5jdGlvbiBtYXRjaChuKSB7XG4gICAgICAgICAgcmV0dXJuIEVsZW1lbnQuaXNFbGVtZW50KG4pICYmIEVkaXRvci5pc0Jsb2NrKGVkaXRvciwgbik7XG4gICAgICAgIH0sXG4gICAgICAgIG1vZGU6ICdsb3dlc3QnLFxuICAgICAgICB2b2lkczogdm9pZHNcbiAgICAgIH0pO1xuICAgICAgVHJhbnNmb3Jtcy5pbnNlcnROb2RlcyhlZGl0b3IsIGVuZHMsIHtcbiAgICAgICAgYXQ6IGVuZFJlZi5jdXJyZW50LFxuICAgICAgICBtYXRjaDogZnVuY3Rpb24gbWF0Y2gobikge1xuICAgICAgICAgIHJldHVybiBUZXh0LmlzVGV4dChuKSB8fCBFZGl0b3IuaXNJbmxpbmUoZWRpdG9yLCBuKTtcbiAgICAgICAgfSxcbiAgICAgICAgbW9kZTogJ2hpZ2hlc3QnLFxuICAgICAgICB2b2lkczogdm9pZHNcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoIW9wdGlvbnMuYXQpIHtcbiAgICAgICAgdmFyIHBhdGg7XG5cbiAgICAgICAgaWYgKGVuZHMubGVuZ3RoID4gMCAmJiBlbmRSZWYuY3VycmVudCkge1xuICAgICAgICAgIHBhdGggPSBQYXRoLnByZXZpb3VzKGVuZFJlZi5jdXJyZW50KTtcbiAgICAgICAgfSBlbHNlIGlmIChtaWRkbGVzLmxlbmd0aCA+IDAgJiYgbWlkZGxlUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICBwYXRoID0gUGF0aC5wcmV2aW91cyhtaWRkbGVSZWYuY3VycmVudCk7XG4gICAgICAgIH0gZWxzZSBpZiAoc3RhcnRSZWYuY3VycmVudCkge1xuICAgICAgICAgIHBhdGggPSBQYXRoLnByZXZpb3VzKHN0YXJ0UmVmLmN1cnJlbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBhdGgpIHtcbiAgICAgICAgICB2YXIgX2VuZDIgPSBFZGl0b3IuZW5kKGVkaXRvciwgcGF0aCk7XG5cbiAgICAgICAgICBUcmFuc2Zvcm1zLnNlbGVjdChlZGl0b3IsIF9lbmQyKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBzdGFydFJlZi51bnJlZigpO1xuICAgICAgbWlkZGxlUmVmLnVucmVmKCk7XG4gICAgICBlbmRSZWYudW5yZWYoKTtcbiAgICB9KTtcbiAgfSxcblxuICAvKipcclxuICAgKiBJbnNlcnQgYSBzdHJpbmcgb2YgdGV4dCBpbiB0aGUgRWRpdG9yLlxyXG4gICAqL1xuICBpbnNlcnRUZXh0OiBmdW5jdGlvbiBpbnNlcnRUZXh0KGVkaXRvciwgdGV4dCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICBFZGl0b3Iud2l0aG91dE5vcm1hbGl6aW5nKGVkaXRvciwgZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9vcHRpb25zJHZvaWRzMyA9IG9wdGlvbnMudm9pZHMsXG4gICAgICAgICAgdm9pZHMgPSBfb3B0aW9ucyR2b2lkczMgPT09IHZvaWQgMCA/IGZhbHNlIDogX29wdGlvbnMkdm9pZHMzO1xuICAgICAgdmFyIF9vcHRpb25zJGF0MyA9IG9wdGlvbnMuYXQsXG4gICAgICAgICAgYXQgPSBfb3B0aW9ucyRhdDMgPT09IHZvaWQgMCA/IGVkaXRvci5zZWxlY3Rpb24gOiBfb3B0aW9ucyRhdDM7XG5cbiAgICAgIGlmICghYXQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoUGF0aC5pc1BhdGgoYXQpKSB7XG4gICAgICAgIGF0ID0gRWRpdG9yLnJhbmdlKGVkaXRvciwgYXQpO1xuICAgICAgfVxuXG4gICAgICBpZiAoUmFuZ2UuaXNSYW5nZShhdCkpIHtcbiAgICAgICAgaWYgKFJhbmdlLmlzQ29sbGFwc2VkKGF0KSkge1xuICAgICAgICAgIGF0ID0gYXQuYW5jaG9yO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBlbmQgPSBSYW5nZS5lbmQoYXQpO1xuXG4gICAgICAgICAgaWYgKCF2b2lkcyAmJiBFZGl0b3JbXCJ2b2lkXCJdKGVkaXRvciwge1xuICAgICAgICAgICAgYXQ6IGVuZFxuICAgICAgICAgIH0pKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHN0YXJ0ID0gUmFuZ2Uuc3RhcnQoYXQpO1xuICAgICAgICAgIHZhciBzdGFydFJlZiA9IEVkaXRvci5wb2ludFJlZihlZGl0b3IsIHN0YXJ0KTtcbiAgICAgICAgICB2YXIgZW5kUmVmID0gRWRpdG9yLnBvaW50UmVmKGVkaXRvciwgZW5kKTtcbiAgICAgICAgICBUcmFuc2Zvcm1zW1wiZGVsZXRlXCJdKGVkaXRvciwge1xuICAgICAgICAgICAgYXQ6IGF0LFxuICAgICAgICAgICAgdm9pZHM6IHZvaWRzXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdmFyIHN0YXJ0UG9pbnQgPSBzdGFydFJlZi51bnJlZigpO1xuICAgICAgICAgIHZhciBlbmRQb2ludCA9IGVuZFJlZi51bnJlZigpO1xuICAgICAgICAgIGF0ID0gc3RhcnRQb2ludCB8fCBlbmRQb2ludDtcbiAgICAgICAgICBUcmFuc2Zvcm1zLnNldFNlbGVjdGlvbihlZGl0b3IsIHtcbiAgICAgICAgICAgIGFuY2hvcjogYXQsXG4gICAgICAgICAgICBmb2N1czogYXRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIXZvaWRzICYmIEVkaXRvcltcInZvaWRcIl0oZWRpdG9yLCB7XG4gICAgICAgIGF0OiBhdFxuICAgICAgfSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgX2F0ID0gYXQsXG4gICAgICAgICAgcGF0aCA9IF9hdC5wYXRoLFxuICAgICAgICAgIG9mZnNldCA9IF9hdC5vZmZzZXQ7XG4gICAgICBpZiAodGV4dC5sZW5ndGggPiAwKSBlZGl0b3IuYXBwbHkoe1xuICAgICAgICB0eXBlOiAnaW5zZXJ0X3RleHQnLFxuICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICBvZmZzZXQ6IG9mZnNldCxcbiAgICAgICAgdGV4dDogdGV4dFxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBpZiAoZW51bWVyYWJsZU9ubHkpIHsgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyB9IGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgaWYgKGkgJSAyKSB7IG93bktleXMoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHsgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTsgfSBlbHNlIHsgb3duS2V5cyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cbnZhciBUcmFuc2Zvcm1zID0gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgR2VuZXJhbFRyYW5zZm9ybXMpLCBOb2RlVHJhbnNmb3JtcyksIFNlbGVjdGlvblRyYW5zZm9ybXMpLCBUZXh0VHJhbnNmb3Jtcyk7XG5cbmV4cG9ydHMuRWRpdG9yID0gRWRpdG9yO1xuZXhwb3J0cy5FbGVtZW50ID0gRWxlbWVudDtcbmV4cG9ydHMuTG9jYXRpb24gPSBMb2NhdGlvbjtcbmV4cG9ydHMuTm9kZSA9IE5vZGU7XG5leHBvcnRzLk9wZXJhdGlvbiA9IE9wZXJhdGlvbjtcbmV4cG9ydHMuUGF0aCA9IFBhdGg7XG5leHBvcnRzLlBhdGhSZWYgPSBQYXRoUmVmO1xuZXhwb3J0cy5Qb2ludCA9IFBvaW50O1xuZXhwb3J0cy5Qb2ludFJlZiA9IFBvaW50UmVmO1xuZXhwb3J0cy5SYW5nZSA9IFJhbmdlO1xuZXhwb3J0cy5SYW5nZVJlZiA9IFJhbmdlUmVmO1xuZXhwb3J0cy5TY3J1YmJlciA9IFNjcnViYmVyO1xuZXhwb3J0cy5TcGFuID0gU3BhbjtcbmV4cG9ydHMuVGV4dCA9IFRleHQ7XG5leHBvcnRzLlRyYW5zZm9ybXMgPSBUcmFuc2Zvcm1zO1xuZXhwb3J0cy5jcmVhdGVFZGl0b3IgPSBjcmVhdGVFZGl0b3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/slate/dist/index.js\n");

/***/ })

};
;